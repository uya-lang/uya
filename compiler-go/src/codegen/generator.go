package codegen

import (
	"bufio"
	"fmt"
	"os"

	"github.com/uya/compiler-go/src/ir"
)

// ErrorNameMap represents a mapping from error name to error code
type ErrorNameMap struct {
	ErrorName string
	ErrorCode uint32
}

// Generator represents a code generator that converts IR to C code
type Generator struct {
	outputFile     *os.File
	outputWriter   *bufio.Writer
	outputFilename string
	labelCounter   int    // Label counter for generating unique labels
	tempCounter    int    // Temporary variable counter for generating temp variable names
	errorCounter   int    // Error handling counter
	currentFunc    *ir.FuncDefInst // Current function context
	irGen          *ir.Generator   // IR generator for looking up function signatures
	errorMap       []ErrorNameMap  // Error name to error code mapping
}

// NewGenerator creates a new code generator
func NewGenerator() *Generator {
	return &Generator{
		labelCounter: 0,
		tempCounter:  0,
		errorCounter: 0,
		errorMap:     make([]ErrorNameMap, 0, 16),
	}
}

// Free closes and cleans up the generator
func (g *Generator) Free() {
	if g.outputWriter != nil {
		g.outputWriter.Flush()
	}
	if g.outputFile != nil {
		g.outputFile.Close()
	}
	g.outputFile = nil
	g.outputWriter = nil
	g.outputFilename = ""
}

// SetOutputFile sets the output file for code generation
func (g *Generator) SetOutputFile(filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}

	g.outputFile = file
	g.outputWriter = bufio.NewWriter(file)
	g.outputFilename = filename
	return nil
}

// Write writes a string to the output file
func (g *Generator) Write(s string) error {
	if g.outputWriter == nil {
		return nil
	}
	_, err := g.outputWriter.WriteString(s)
	return err
}

// Writef writes a formatted string to the output file
func (g *Generator) Writef(format string, args ...interface{}) error {
	if g.outputWriter == nil {
		return nil
	}
	s := fmt.Sprintf(format, args...)
	_, err := g.outputWriter.WriteString(s)
	return err
}

// NextLabel generates the next unique label name
func (g *Generator) NextLabel() string {
	label := g.labelCounter
	g.labelCounter++
	return fmt.Sprintf("label_%d", label)
}

// NextTemp generates the next unique temporary variable name
func (g *Generator) NextTemp() string {
	temp := g.tempCounter
	g.tempCounter++
	return fmt.Sprintf("temp_%d", temp)
}

// Generate generates C code from IR
func (g *Generator) Generate(irGen *ir.Generator, outputFile string) error {
	if irGen == nil {
		return nil
	}

	g.irGen = irGen

	// Set output file
	if err := g.SetOutputFile(outputFile); err != nil {
		return err
	}
	defer g.Free()

	// Write C99 header
	if err := g.writeHeader(); err != nil {
		return err
	}

	// Generate code for all IR instructions
	instructions := irGen.Instructions()
	for _, inst := range instructions {
		if err := g.GenerateInst(inst); err != nil {
			return err
		}
	}

	// Flush output
	if g.outputWriter != nil {
		return g.outputWriter.Flush()
	}

	return nil
}

// writeHeader writes the C99 header includes and basic definitions
func (g *Generator) writeHeader() error {
	header := `// Generated by Uya to C99 Compiler
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Error type definition (error codes are uint32_t)
typedef uint32_t error;

`
	return g.Write(header)
}

// GenerateInst generates C code for an IR instruction
// Implementation is in inst.go

