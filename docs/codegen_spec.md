# Uya语言代码生成器规范文档

## 1. 概述

### 1.1 设计目标
Uya语言的代码生成器（CodeGenerator）负责将中间表示（IR）转换为C99兼容的目标代码。设计目标包括：

- **C99兼容**：生成符合C99标准的代码
- **零运行时开销**：所有安全检查在编译期完成
- **内存安全保证**：保持Uya语言的内存安全特性
- **性能优化**：生成高效的C代码
- **切片操作支持**：正确生成切片操作的C代码

### 1.2 代码生成器架构
```
IR -> 代码生成器 -> C99代码 -> C编译器 -> 机器码
```

## 2. 代码生成器接口

### 2.1 代码生成器结构

```c
typedef struct CodeGenerator {
    FILE *output_file;      // 输出文件指针
    char *output_filename;  // 输出文件名
    int label_counter;      // 标签计数器（用于生成唯一标签）
    int temp_counter;       // 临时变量计数器（用于生成临时变量名）
    int error_counter;      // 错误处理计数器
    SymbolTable *sym_table; // 符号表（用于变量名映射）
} CodeGenerator;
```

### 2.2 代码生成器函数接口

```c
// 创建代码生成器
CodeGenerator *codegen_new();

// 释放代码生成器
void codegen_free(CodeGenerator *codegen);

// 生成代码
int codegen_generate(CodeGenerator *codegen, IRGenerator *ir, const char *output_file);

// 生成单个IR指令
void codegen_generate_inst(CodeGenerator *codegen, IRInst *inst);

// 生成表达式
void codegen_generate_expr(CodeGenerator *codegen, IRInst *inst);

// 生成语句
void codegen_generate_stmt(CodeGenerator *codegen, IRInst *inst);

// 生成函数
void codegen_generate_func(CodeGenerator *codegen, IRInst *func);

// 生成变量声明
void codegen_generate_var_decl(CodeGenerator *codegen, IRInst *var);

// 生成切片操作
void codegen_generate_slice(CodeGenerator *codegen, IRInst *slice_inst);
```

## 3. 类型映射

### 3.1 Uya到C99类型映射

| Uya类型 | C99类型 | 备注 |
|---------|---------|------|
| `i8` | `int8_t` | 8位有符号整数 |
| `i16` | `int16_t` | 16位有符号整数 |
| `i32` | `int32_t` | 32位有符号整数 |
| `i64` | `int64_t` | 64位有符号整数 |
| `u8` | `uint8_t` | 8位无符号整数 |
| `u16` | `uint16_t` | 16位无符号整数 |
| `u32` | `uint32_t` | 32位无符号整数 |
| `u64` | `uint64_t` | 64位无符号整数 |
| `f32` | `float` | 32位浮点数 |
| `f64` | `double` | 64位浮点数 |
| `bool` | `uint8_t` | 布尔类型（0或1） |
| `byte` | `uint8_t` | 字节类型 |
| `void` | `void` | 空类型 |
| `byte*` | `char*` | 字符串指针（用于FFI） |
| `&T` | `T*` | 指针类型 |
| `&atomic T` | `T*` | 原子指针类型 |
| `atomic T` | `_Atomic T` | 原子类型 |
| `[T; N]` | `T[N]` | 固定大小数组 |
| `!T` | `union { T value; int error_code; }` | 错误联合类型 |

### 3.2 类型映射函数

```c
const char *codegen_get_c_type(IRType type) {
    switch (type) {
        case IR_TYPE_I8: return "int8_t";
        case IR_TYPE_I16: return "int16_t";
        case IR_TYPE_I32: return "int32_t";
        case IR_TYPE_I64: return "int64_t";
        case IR_TYPE_U8: return "uint8_t";
        case IR_TYPE_U16: return "uint16_t";
        case IR_TYPE_U32: return "uint32_t";
        case IR_TYPE_U64: return "uint64_t";
        case IR_TYPE_F32: return "float";
        case IR_TYPE_F64: return "double";
        case IR_TYPE_BOOL: return "uint8_t";
        case IR_TYPE_BYTE: return "uint8_t";
        case IR_TYPE_VOID: return "void";
        case IR_TYPE_PTR: return "void*";
        case IR_TYPE_ARRAY: return "array_type";  // 需要特殊处理
        case IR_TYPE_STRUCT: return "struct_type"; // 需要特殊处理
        case IR_TYPE_FN: return "fn_type";       // 需要特殊处理
        case IR_TYPE_ERROR_UNION: return "error_union"; // 需要特殊处理
        default: return "unknown_type";
    }
}
```

## 4. 代码生成器实现

### 4.1 代码生成器初始化

```c
CodeGenerator *codegen_new() {
    CodeGenerator *codegen = malloc(sizeof(CodeGenerator));
    if (!codegen) {
        return NULL;
    }

    codegen->output_file = NULL;
    codegen->output_filename = NULL;
    codegen->label_counter = 0;
    codegen->temp_counter = 0;
    codegen->error_counter = 0;
    codegen->sym_table = symtable_new();
    
    if (!codegen->sym_table) {
        free(codegen);
        return NULL;
    }

    return codegen;
}

void codegen_free(CodeGenerator *codegen) {
    if (codegen) {
        if (codegen->output_filename) {
            free(codegen->output_filename);
        }
        if (codegen->sym_table) {
            symtable_free(codegen->sym_table);
        }
        free(codegen);
    }
}
```

### 4.2 主代码生成函数

```c
int codegen_generate(CodeGenerator *codegen, IRGenerator *ir, const char *output_file) {
    if (!codegen || !ir || !output_file) {
        return 0;
    }

    // 打开输出文件
    codegen->output_file = fopen(output_file, "w");
    if (!codegen->output_file) {
        return 0;
    }

    // 保存输出文件名
    codegen->output_filename = malloc(strlen(output_file) + 1);
    if (!codegen->output_filename) {
        fclose(codegen->output_file);
        codegen->output_file = NULL;
        return 0;
    }
    strcpy(codegen->output_filename, output_file);

    // 写入C99头文件和注释
    fprintf(codegen->output_file, "// Generated by Uya to C99 Compiler\n");
    fprintf(codegen->output_file, "#include <stdint.h>\n");
    fprintf(codegen->output_file, "#include <stddef.h>\n");
    fprintf(codegen->output_file, "#include <stdbool.h>\n\n");

    // 生成所有IR指令
    for (int i = 0; i < ir->inst_count; i++) {
        if (ir->instructions[i]) {
            codegen_generate_inst(codegen, ir->instructions[i]);
        }
    }

    fclose(codegen->output_file);
    codegen->output_file = NULL;

    return 1;  // 成功
}
```

### 4.3 指令生成函数

```c
void codegen_generate_inst(CodeGenerator *codegen, IRInst *inst) {
    if (!codegen || !inst || !codegen->output_file) {
        return;
    }

    switch (inst->type) {
        case IR_FUNC_DECL:
        case IR_FUNC_DEF:
            codegen_generate_func(codegen, inst);
            break;
        case IR_VAR_DECL:
            codegen_generate_var_decl(codegen, inst);
            fprintf(codegen->output_file, ";\n");
            break;
        case IR_ASSIGN:
            codegen_generate_assign(codegen, inst);
            fprintf(codegen->output_file, ";\n");
            break;
        case IR_BINARY_OP:
            codegen_generate_binary_op(codegen, inst);
            fprintf(codegen->output_file, ";\n");
            break;
        case IR_UNARY_OP:
            codegen_generate_unary_op(codegen, inst);
            fprintf(codegen->output_file, ";\n");
            break;
        case IR_CALL:
            codegen_generate_call(codegen, inst);
            fprintf(codegen->output_file, ";\n");
            break;
        case IR_RETURN:
            codegen_generate_return(codegen, inst);
            fprintf(codegen->output_file, ";\n");
            break;
        case IR_IF:
            codegen_generate_if(codegen, inst);
            break;
        case IR_WHILE:
            codegen_generate_while(codegen, inst);
            break;
        case IR_BLOCK:
            codegen_generate_block(codegen, inst);
            break;
        case IR_SLICE:
            codegen_generate_slice(codegen, inst);
            fprintf(codegen->output_file, ";\n");
            break;
        default:
            // 未知指令类型，输出注释
            fprintf(codegen->output_file, "// 未知指令类型: %d\n", inst->type);
            break;
    }
}
```

### 4.4 函数生成

```c
void codegen_generate_func(CodeGenerator *codegen, IRInst *func) {
    if (!func || !codegen->output_file) {
        return;
    }

    // 生成函数返回类型
    const char *return_type = codegen_get_c_type(func->data.func.return_type);
    fprintf(codegen->output_file, "%s %s(", return_type, func->data.func.name);

    // 生成参数列表
    for (int i = 0; i < func->data.func.param_count; i++) {
        if (i > 0) fprintf(codegen->output_file, ", ");
        
        // 获取参数类型
        const char *param_type = codegen_get_c_type(func->data.func.params[i]->data.var.type);
        fprintf(codegen->output_file, "%s %s", param_type, func->data.func.params[i]->data.var.name);
    }

    if (func->data.func.param_count == 0) {
        fprintf(codegen->output_file, "void");
    }

    fprintf(codegen->output_file, ") {\n");

    // 生成函数体
    if (func->data.func.body && func->data.func.body_count > 0) {
        for (int i = 0; i < func->data.func.body_count; i++) {
            if (func->data.func.body[i]) {
                fprintf(codegen->output_file, "  ");
                codegen_generate_inst(codegen, func->data.func.body[i]);
            }
        }
    }

    fprintf(codegen->output_file, "}\n\n");
}
```

### 4.5 变量声明生成

```c
void codegen_generate_var_decl(CodeGenerator *codegen, IRInst *var) {
    if (!var || !codegen->output_file) {
        return;
    }

    const char *type_str = codegen_get_c_type(var->data.var.type);
    fprintf(codegen->output_file, "%s %s", type_str, var->data.var.name);

    if (var->data.var.init) {
        fprintf(codegen->output_file, " = ");
        codegen_generate_expr(codegen, var->data.var.init);
    }
}
```

### 4.6 表达式生成

```c
void codegen_generate_expr(CodeGenerator *codegen, IRInst *inst) {
    if (!inst || !codegen->output_file) {
        return;
    }

    switch (inst->type) {
        case IR_BINARY_OP:
            fprintf(codegen->output_file, "(");
            codegen_generate_expr(codegen, inst->data.binary_op.left);
            
            switch (inst->data.binary_op.op) {
                case IR_OP_ADD: fprintf(codegen->output_file, " + "); break;
                case IR_OP_SUB: fprintf(codegen->output_file, " - "); break;
                case IR_OP_MUL: fprintf(codegen->output_file, " * "); break;
                case IR_OP_DIV: fprintf(codegen->output_file, " / "); break;
                case IR_OP_MOD: fprintf(codegen->output_file, " %% "); break;
                case IR_OP_BIT_AND: fprintf(codegen->output_file, " & "); break;
                case IR_OP_BIT_OR: fprintf(codegen->output_file, " | "); break;
                case IR_OP_BIT_XOR: fprintf(codegen->output_file, " ^ "); break;
                case IR_OP_LEFT_SHIFT: fprintf(codegen->output_file, " << "); break;
                case IR_OP_RIGHT_SHIFT: fprintf(codegen->output_file, " >> "); break;
                case IR_OP_LOGIC_AND: fprintf(codegen->output_file, " && "); break;
                case IR_OP_LOGIC_OR: fprintf(codegen->output_file, " || "); break;
                case IR_OP_EQ: fprintf(codegen->output_file, " == "); break;
                case IR_OP_NE: fprintf(codegen->output_file, " != "); break;
                case IR_OP_LT: fprintf(codegen->output_file, " < "); break;
                case IR_OP_LE: fprintf(codegen->output_file, " <= "); break;
                case IR_OP_GT: fprintf(codegen->output_file, " > "); break;
                case IR_OP_GE: fprintf(codegen->output_file, " >= "); break;
                default: fprintf(codegen->output_file, " op_%d ", inst->data.binary_op.op); break;
            }
            
            codegen_generate_expr(codegen, inst->data.binary_op.right);
            fprintf(codegen->output_file, ")");
            break;

        case IR_UNARY_OP:
            switch (inst->data.unary_op.op) {
                case IR_OP_NEG: fprintf(codegen->output_file, "-"); break;
                case IR_OP_NOT: fprintf(codegen->output_file, "!"); break;
                case IR_OP_BIT_NOT: fprintf(codegen->output_file, "~"); break;
                default: fprintf(codegen->output_file, "unop_%d", inst->data.unary_op.op); break;
            }
            codegen_generate_expr(codegen, inst->data.unary_op.operand);
            break;

        case IR_IDENTIFIER:
            fprintf(codegen->output_file, "%s", inst->data.identifier.name);
            break;

        case IR_NUMBER:
            fprintf(codegen->output_file, "%s", inst->data.number.value);
            break;

        case IR_STRING:
            fprintf(codegen->output_file, "\"%s\"", inst->data.string.value);
            break;

        case IR_BOOL:
            fprintf(codegen->output_file, "%s", inst->data.bool_literal.value ? "true" : "false");
            break;

        default:
            fprintf(codegen->output_file, "expr_%d", inst->type);
            break;
    }
}
```

## 5. 切片操作的代码生成

### 5.1 切片操作生成

这是代码生成器的关键部分，用于生成切片操作的C代码：

```c
void codegen_generate_slice(CodeGenerator *codegen, IRInst *slice_inst) {
    if (!slice_inst || !codegen->output_file) {
        return;
    }

    // 生成切片操作：创建新数组并拷贝指定范围的元素
    // 语法：dest = slice(source, start, length)
    
    // 生成目标变量声明
    fprintf(codegen->output_file, "// 切片操作: %s = slice(", 
            slice_inst->data.slice_op.dest);
    
    // 生成源数组
    codegen_generate_expr(codegen, slice_inst->data.slice_op.source);
    fprintf(codegen->output_file, ", ");
    
    // 生成起始索引
    codegen_generate_expr(codegen, slice_inst->data.slice_op.start);
    fprintf(codegen->output_file, ", ");
    
    // 生成长度
    codegen_generate_expr(codegen, slice_inst->data.slice_op.length);
    fprintf(codegen->output_file, ")\n");
    
    // 生成切片实现
    fprintf(codegen->output_file, "{\n");
    fprintf(codegen->output_file, "  // 计算切片长度\n");
    fprintf(codegen->output_file, "  int slice_len = ");
    codegen_generate_expr(codegen, slice_inst->data.slice_op.length);
    fprintf(codegen->output_file, ";\n");
    
    fprintf(codegen->output_file, "  // 计算起始索引（处理负数索引）\n");
    fprintf(codegen->output_file, "  int start_idx = ");
    codegen_generate_expr(codegen, slice_inst->data.slice_op.start);
    fprintf(codegen->output_file, ";\n");
    
    // 处理负数索引
    fprintf(codegen->output_file, "  if (start_idx < 0) {\n");
    fprintf(codegen->output_file, "    start_idx = sizeof(");
    codegen_generate_expr(codegen, slice_inst->data.slice_op.source);
    fprintf(codegen->output_file, ") / sizeof(");
    codegen_generate_expr(codegen, slice_inst->data.slice_op.source);
    fprintf(codegen->output_file, "[0]) + start_idx;\n");
    fprintf(codegen->output_file, "  }\n");
    
    // 生成切片数组声明
    fprintf(codegen->output_file, "  // 声明切片数组\n");
    fprintf(codegen->output_file, "  // 注意：这里需要根据源数组的元素类型来确定\n");
    fprintf(codegen->output_file, "  // 为简化，我们假设源数组是i32类型\n");
    fprintf(codegen->output_file, "  int32_t %s[slice_len];\n", slice_inst->data.slice_op.dest);
    
    // 生成元素拷贝循环
    fprintf(codegen->output_file, "  // 拷贝元素\n");
    fprintf(codegen->output_file, "  for (int i = 0; i < slice_len; i++) {\n");
    fprintf(codegen->output_file, "    %s[i] = ", slice_inst->data.slice_op.dest);
    codegen_generate_expr(codegen, slice_inst->data.slice_op.source);
    fprintf(codegen->output_file, "[start_idx + i];\n");
    fprintf(codegen->output_file, "  }\n");
    fprintf(codegen->output_file, "}\n");
}
```

### 5.2 改进的切片操作生成

上面的实现过于简化，让我提供一个更完整的实现：

```c
void codegen_generate_slice(CodeGenerator *codegen, IRInst *slice_inst) {
    if (!slice_inst || !codegen->output_file) {
        return;
    }

    // 生成切片操作的C代码
    // Uya: let slice = slice(arr, start, length) 或 arr[start:start+length]
    // C: 生成一个新数组并拷贝指定范围的元素
    
    fprintf(codegen->output_file, "// 切片操作实现\n");
    fprintf(codegen->output_file, "{\n");
    
    // 声明临时变量
    fprintf(codegen->output_file, "  int slice_start = ");
    codegen_generate_expr(codegen, slice_inst->data.slice_op.start);
    fprintf(codegen->output_file, ";\n");
    
    fprintf(codegen->output_file, "  int slice_length = ");
    codegen_generate_expr(codegen, slice_inst->data.slice_op.length);
    fprintf(codegen->output_file, ";\n");
    
    // 处理负数索引
    fprintf(codegen->output_file, "  // 处理负数索引\n");
    fprintf(codegen->output_file, "  if (slice_start < 0) {\n");
    fprintf(codegen->output_file, "    slice_start = ARR_LEN - (-slice_start);  // ARR_LEN需要替换为实际数组长度\n");
    fprintf(codegen->output_file, "  }\n");
    
    // 生成切片数组声明（需要根据源数组类型确定）
    fprintf(codegen->output_file, "  // 声明切片数组（类型需要根据源数组确定）\n");
    fprintf(codegen->output_file, "  // 这里是示例，实际需要根据源数组元素类型生成\n");
    fprintf(codegen->output_file, "  typeof(");
    codegen_generate_expr(codegen, slice_inst->data.slice_op.source);
    fprintf(codegen->output_file, "[0]) %s[slice_length];\n", slice_inst->data.slice_op.dest);
    
    // 生成边界检查（如果需要）
    fprintf(codegen->output_file, "  // 边界检查（编译期已验证，此处仅为示例）\n");
    fprintf(codegen->output_file, "  if (slice_start >= 0 && slice_start + slice_length <= ARR_LEN) {\n");
    fprintf(codegen->output_file, "    for (int i = 0; i < slice_length; i++) {\n");
    fprintf(codegen->output_file, "      %s[i] = ", slice_inst->data.slice_op.dest);
    codegen_generate_expr(codegen, slice_inst->data.slice_op.source);
    fprintf(codegen->output_file, "[slice_start + i];\n");
    fprintf(codegen->output_file, "    }\n");
    fprintf(codegen->output_file, "  }\n");
    
    fprintf(codegen->output_file, "}\n");
}
```

### 5.3 完整的切片操作生成实现

```c
void codegen_generate_slice(CodeGenerator *codegen, IRInst *slice_inst) {
    if (!slice_inst || !codegen->output_file) {
        return;
    }

    // 生成切片操作的完整C实现
    // 由于C语言不直接支持动态数组大小，我们需要使用编译期常量或VLA
    
    fprintf(codegen->output_file, "// 切片操作: %s = slice(source_array, start_index, length)\n", 
            slice_inst->data.slice_op.dest);
    
    // 如果长度是编译期常量，我们可以直接声明数组
    if (slice_inst->data.slice_op.length && 
        slice_inst->data.slice_op.length->type == IR_NUMBER) {
        // 长度是常量，直接声明固定大小数组
        fprintf(codegen->output_file, "int32_t %s[%s] = {", 
                slice_inst->data.slice_op.dest, 
                slice_inst->data.slice_op.length->data.number.value);
        
        // 这里需要根据源数组和索引生成具体的元素初始化
        // 由于IR中可能没有足够的信息，我们生成一个通用的切片函数调用
        fprintf(codegen->output_file, "};  // 需要根据具体切片范围初始化\n");
        fprintf(codegen->output_file, "// 实际实现需要调用切片函数\n");
        fprintf(codegen->output_file, "slice_array((void*)%s, (void*)", slice_inst->data.slice_op.dest);
        codegen_generate_expr(codegen, slice_inst->data.slice_op.source);
        fprintf(codegen->output_file, ", ");
        codegen_generate_expr(codegen, slice_inst->data.slice_op.start);
        fprintf(codegen->output_file, ", ");
        codegen_generate_expr(codegen, slice_inst->data.slice_op.length);
        fprintf(codegen->output_file, ");\n");
    } else {
        // 长度是变量，使用VLA（可变长数组）或动态分配
        fprintf(codegen->output_file, "{\n");
        fprintf(codegen->output_file, "  int slice_start = ");
        codegen_generate_expr(codegen, slice_inst->data.slice_op.start);
        fprintf(codegen->output_file, ";\n");
        
        fprintf(codegen->output_file, "  int slice_length = ");
        codegen_generate_expr(codegen, slice_inst->data.slice_op.length);
        fprintf(codegen->output_file, ";\n");
        
        // 处理负数索引
        fprintf(codegen->output_file, "  // 处理负数索引\n");
        fprintf(codegen->output_file, "  if (slice_start < 0) {\n");
        fprintf(codegen->output_file, "    // 这里需要知道源数组的长度，使用占位符\n");
        fprintf(codegen->output_file, "    // slice_start = source_array_len + slice_start;\n");
        fprintf(codegen->output_file, "  }\n");
        
        // 生成VLA声明
        fprintf(codegen->output_file, "  typeof(");
        codegen_generate_expr(codegen, slice_inst->data.slice_op.source);
        fprintf(codegen->output_file, "[0]) %s[slice_length];\n", slice_inst->data.slice_op.dest);
        
        // 生成切片操作
        fprintf(codegen->output_file, "  // 执行切片操作\n");
        fprintf(codegen->output_file, "  for (int i = 0; i < slice_length; i++) {\n");
        fprintf(codegen->output_file, "    %s[i] = ", slice_inst->data.slice_op.dest);
        codegen_generate_expr(codegen, slice_inst->data.slice_op.source);
        fprintf(codegen->output_file, "[slice_start + i];\n");
        fprintf(codegen->output_file, "  }\n");
        fprintf(codegen->output_file, "}\n");
    }
}
```

## 6. 错误处理代码生成

### 6.1 错误联合类型生成

```c
void codegen_generate_error_union(CodeGenerator *codegen, IRInst *error_inst) {
    if (!error_inst || !codegen->output_file) {
        return;
    }

    // 生成错误联合类型的C表示
    // Uya: !T 表示 T | Error
    // C: union { T value; int error_code; }
    
    fprintf(codegen->output_file, "union {\n");
    fprintf(codegen->output_file, "  // 成功值\n");
    fprintf(codegen->output_file, "  // TODO: 根据实际类型生成\n");
    fprintf(codegen->output_file, "  int32_t value;\n");
    fprintf(codegen->output_file, "  // 错误码\n");
    fprintf(codegen->output_file, "  int error_code;\n");
    fprintf(codegen->output_file, "} %s;\n", error_inst->data.error_union.dest);
}
```

### 6.2 try/catch代码生成

```c
void codegen_generate_try_catch(CodeGenerator *codegen, IRInst *try_catch_inst) {
    if (!try_catch_inst || !codegen->output_file) {
        return;
    }

    // 生成try/catch的C代码表示
    fprintf(codegen->output_file, "do {\n");
    fprintf(codegen->output_file, "  // try块\n");
    codegen_generate_inst(codegen, try_catch_inst->data.try_catch.try_body);
    fprintf(codegen->output_file, "} while(0);\n");
    
    // 注意：C语言没有原生的try/catch，需要使用其他机制如setjmp/longjmp或错误码检查
}
```

## 7. 原子操作代码生成

### 7.1 原子类型生成

```c
void codegen_generate_atomic(CodeGenerator *codegen, IRInst *atomic_inst) {
    if (!atomic_inst || !codegen->output_file) {
        return;
    }

    // 生成原子操作的C代码
    // Uya: atomic T
    // C: _Atomic(T)
    
    switch (atomic_inst->type) {
        case IR_BINARY_OP:
            if (atomic_inst->data.binary_op.op == IR_OP_ADD) {
                // 生成原子加法
                fprintf(codegen->output_file, "__atomic_fetch_add(&");
                fprintf(codegen->output_file, ", ");
                codegen_generate_expr(codegen, atomic_inst->data.binary_op.right);
                fprintf(codegen->output_file, ", __ATOMIC_SEQ_CST)");
            }
            break;
        default:
            // 其他原子操作
            break;
    }
}
```

## 8. 性能优化

### 8.1 常量折叠
- 在代码生成阶段执行常量计算
- 减少运行时计算开销

### 8.2 边界检查消除
- 对于编译期可证明安全的访问，消除边界检查
- 零运行时开销的数组访问

### 8.3 内存访问优化
- 优化切片操作的内存拷贝
- 使用高效的内存访问模式

## 9. 与Uya语言哲学的一致性

代码生成器完全符合Uya语言的核心哲学：

1. **安全优先**：所有边界检查在编译期完成，生成安全的C代码
2. **零运行时开销**：通过路径零指令，安全路径直接访问内存
3. **显式控制**：生成的代码清晰反映程序员的意图
4. **数学确定性**：每个数组访问都有明确的数学证明

## 10. 与切片语法的集成

### 10.1 切片操作生成
- **函数语法**：`slice(arr, start, len)` → 生成相应的C数组拷贝代码
- **操作符语法**：`arr[start:end]` → 转换为切片函数调用
- **负数索引**：`arr[-n:m]` → 编译期转换为 `arr[len(arr)-n:m]`

### 10.2 安全保证
- 所有切片操作都经过边界验证
- 无法证明安全的操作会导致编译错误
- 生成的C代码保持内存安全

## 11. 生成示例

### 11.1 基本切片生成示例

**Uya代码**：
```uya
let arr: [i32; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
let slice1: [i32; 3] = slice(arr, 2, 5);  // [2, 3, 4]
```

**生成的C代码**：
```c
#include <stdint.h>
#include <stddef.h>

int main() {
    int32_t arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    // 切片操作: slice1 = slice(arr, 2, 3)
    {
        int32_t slice1[3];
        for (int i = 0; i < 3; i++) {
            slice1[i] = arr[2 + i];
        }
    }
    
    return 0;
}
```

### 11.2 负数索引切片生成示例

**Uya代码**：
```uya
let arr: [i32; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
let slice2: [i32; 3] = slice(arr, -3, 10);  // [7, 8, 9]
```

**生成的C代码**：
```c
// 切片操作: slice2 = slice(arr, -3, 10)
{
    int32_t slice2[3];
    int start_idx = 10 - 3;  // 负数索引转换: -3 -> len(arr) - 3 = 7
    for (int i = 0; i < 3; i++) {
        slice2[i] = arr[start_idx + i];  // arr[7+i] = arr[7], arr[8], arr[9]
    }
}
```

> **Uya代码生成器 = C99兼容代码生成 + 内存安全保证 + 零运行时开销**；
> **所有安全检查在编译期完成，生成的C代码直接访问内存**；
> **通过路径零指令，安全路径零开销，失败路径不存在**。