// main.uya - 编译器主程序
// 从 compiler-c/src/main.c 覆盖式翻译
// 注意：入口为 uya_main()，由 bridge.c 调用；命令行参数通过 get_argc/get_argv 获取

// ===== 外部函数（bridge 与 C 标准库在 extern_decls.uya 中声明）=====
// 本文件依赖 extern_decls.uya 中的 get_argc, get_argv, get_stderr, fopen, fread, fclose, fgetc, fprintf, strcmp, strrchr, snprintf

// 后端类型
enum BackendType {
    BACKEND_LLVM,
    BACKEND_C99
}

// 文件读取缓冲区大小（与 Lexer 一致）
const FILE_BUFFER_SIZE: i32 = 1024 * 1024;

// Arena 缓冲区大小（增加以支持自举编译 + 泛型结构体方法单态化）
const ARENA_BUFFER_SIZE: i32 = 160 * 1024 * 1024;  // 160MB

// 最大输入文件数
const MAX_INPUT_FILES: i32 = 64;

// 全局缓冲区（替代 C 的 static 数组，零初始化）
var arena_buffer: [byte: ARENA_BUFFER_SIZE] = [];
var file_buffer: [byte: FILE_BUFFER_SIZE] = [];
// 临时 Arena 缓冲区（用于依赖收集，全局变量避免栈溢出）
// 需要足够大以支持递归解析多个文件的 AST
var temp_arena_buffer: [byte: 32 * 1024 * 1024] = [];
// 大数组移到全局变量避免栈溢出（main_file_paths 是 64 * 4096 = 262KB）
var main_file_paths_global: [[byte: PATH_MAX]: MAX_INPUT_FILES] = [];
// 将 resolved_files 也移到全局变量，避免栈溢出
var resolved_files_global: [&byte: MAX_INPUT_FILES] = [];

// 读取文件内容到缓冲区
// 成功返回读取字节数，失败返回 -1
// 注意：filename 用 &byte，调用 fopen 时转为 *byte
fn read_file_content(filename: &byte, buffer: &byte, buffer_size: usize) i32 {
    const file: *void = fopen(filename as *byte, "rb" as *byte);
    if file == null {
        return -1;
    }
    const bytes_read: usize = fread(buffer as *byte, 1, buffer_size - 1, file);
    const c: i32 = fgetc(file);
    if bytes_read >= buffer_size - 1 {
        fclose(file);
        if c != -1 {
            return -1;
        }
    } else {
        fclose(file);
    }
    buffer[bytes_read] = 0 as byte;
    return bytes_read as i32;
}

// 常量定义
const PATH_MAX: usize = 4096;

// 比较两个路径是否指向同一个文件（考虑路径格式差异）
// 参数：path1 - 第一个路径
//       path2 - 第二个路径
// 返回：相同返回1，不同返回0
fn paths_equal(path1: &byte, path2: &byte) i32 {
    if path1 == null || path2 == null {
        return 0;
    }
    
    // 首先尝试直接比较（最常见的情况）
    if strcmp(path1 as *byte, path2 as *byte) == 0 {
        return 1;
    }
    
    // 如果直接比较失败，提取文件名进行比较
    // 如果文件名相同，使用 stat 检查是否是同一个文件（相同的 inode）
    var name1: &byte = strrchr(path1 as *byte, 47);  // '/'
    var name2: &byte = strrchr(path2 as *byte, 47);  // '/'
    if name1 == null {
        name1 = path1;
    } else {
        name1 = name1 + 1;
    }
    if name2 == null {
        name2 = path2;
    } else {
        name2 = name2 + 1;
    }
    
    // 如果文件名不同，肯定不是同一个文件
    if strcmp(name1 as *byte, name2 as *byte) != 0 {
        return 0;
    }
    
    // 文件名相同，使用 stat 检查是否是同一个文件
    // 在 Linux x86_64 上，struct stat 的布局：
    // st_dev 在偏移 0 处（dev_t，8 字节）
    // st_ino 在偏移 8 处（ino_t，8 字节）
    var st1: Stat = Stat { _data: [0: 144] };
    var st2: Stat = Stat { _data: [0: 144] };
    if stat(path1 as *byte, &st1) == 0 && stat(path2 as *byte, &st2) == 0 {
        // 检查是否是同一个文件（相同的设备和 inode）
        const dev1_ptr: &u64 = &st1._data[0] as &u64;
        const dev2_ptr: &u64 = &st2._data[0] as &u64;
        const ino1_ptr: &u64 = &st1._data[8] as &u64;
        const ino2_ptr: &u64 = &st2._data[8] as &u64;
        const dev1: u64 = dev1_ptr[0];
        const dev2: u64 = dev2_ptr[0];
        const ino1: u64 = ino1_ptr[0];
        const ino2: u64 = ino2_ptr[0];
        if dev1 == dev2 && ino1 == ino2 {
            return 1;
        }
    }
    
    // stat 失败或不是同一个文件，返回0
    return 0;
}

// 注意：arena_strdup 函数在 parser.uya 中定义，这里不再重复定义

// 检查路径是否为目录
fn is_directory(path: &byte) i32 {
    if path == null {
        return 0;
    }
    var st: Stat = Stat { _data: [0: 144] };
    if stat(path as *byte, &st) == 0 {
        // st_mode 在偏移 24 字节处，使用指针访问
        const mode_ptr: &u32 = &st._data[24] as &u32;
        const mode: u32 = mode_ptr[0];
        if (mode & S_IFMT) == S_IFDIR {
            return 1;
        }
    }
    return 0;
}

// 检查路径是否为文件
fn is_file(path: &byte) i32 {
    if path == null {
        return 0;
    }
    var st: Stat = Stat { _data: [0: 144] };
    if stat(path as *byte, &st) == 0 {
        // st_mode 在偏移 24 字节处，使用指针访问
        const mode_ptr: &u32 = &st._data[24] as &u32;
        const mode: u32 = mode_ptr[0];
        if (mode & S_IFMT) == S_IFREG {
            return 1;
        }
    }
    return 0;
}

// 获取编译器程序所在目录
fn get_compiler_dir(argv0: &byte, buffer: &byte, buffer_size: usize) i32 {
    if argv0 == null || buffer == null || buffer_size == 0 {
        return -1;
    }
    
    // 如果是绝对路径，直接提取目录
    if argv0[0] == 47 {
        const last_slash: *byte = strrchr(argv0 as *byte, 47);
        if last_slash != null {
            const dir_len: usize = ptr_diff(last_slash as &byte, argv0);
            if dir_len + 1 < buffer_size {
                memcpy(buffer as *byte, argv0 as *byte, dir_len);
                buffer[dir_len] = 47 as byte;
                buffer[dir_len + 1] = 0 as byte;
                return 0;
            }
        }
    }
    
    // 尝试使用 readlink 获取真实路径（Linux）
    var resolved_path: [byte: PATH_MAX] = [];
    const len: i32 = readlink("/proc/self/exe" as *byte, &resolved_path[0], PATH_MAX - 1);
    if len != -1 {
        resolved_path[len as usize] = 0 as byte;
        const last_slash: *byte = strrchr(&resolved_path[0], 47);
        if last_slash != null {
            const dir_len: usize = ptr_diff(last_slash as &byte, &resolved_path[0]);
            if dir_len + 1 < buffer_size {
                memcpy(buffer as *byte, &resolved_path[0], dir_len);
                buffer[dir_len] = 47 as byte;
                buffer[dir_len + 1] = 0 as byte;
                return 0;
            }
        }
    }
    
    // 回退：使用当前目录
    if buffer_size > 1 {
        buffer[0] = 46 as byte;  // '.'
        buffer[1] = 47 as byte;   // '/'
        buffer[2] = 0 as byte;
        return 0;
    }
    
    return -1;
}

// 获取 UYA_ROOT 环境变量或默认目录
fn get_uya_root(argv0: &byte, buffer: &byte, buffer_size: usize) i32 {
    if buffer == null || buffer_size == 0 {
        return -1;
    }
    
    // 首先尝试从环境变量获取
    const env_root: *byte = getenv("UYA_ROOT" as *byte);
    if env_root != null && env_root[0] != 0 {
        const len: usize = strlen(env_root);
        if len < buffer_size {
            strcpy(buffer as *byte, env_root);
            // 确保以 '/' 结尾
            if len > 0 && buffer[len - 1] != 47 {
                if len + 1 < buffer_size {
                    buffer[len] = 47 as byte;
                    buffer[len + 1] = 0 as byte;
                }
            }
            return 0;
        }
    }
    
    // 如果环境变量未设置，使用编译器程序所在目录
    const result: i32 = get_compiler_dir(argv0, buffer, buffer_size);
    return result;
}

// 打印使用说明（program_name 用 &byte，传给 fprintf 时转为 *byte）
fn print_usage(program_name: &byte) void {
    const stderr: *void = get_stderr();
    fprintf(stderr, "用法: %s [输入文件...] -o <输出文件> [选项]\n" as *byte, program_name as *byte);
    fprintf(stderr, "示例: %s program.uya -o program\n" as *byte, program_name as *byte);
    fprintf(stderr, "示例: %s program.uya -o program.c --c99  # 生成 C99 代码\n" as *byte, program_name as *byte);
    fprintf(stderr, "\n选项:\n" as *byte);
    fprintf(stderr, "  --c99                使用 C99 后端生成 C 代码\n" as *byte);
    fprintf(stderr, "  --line-directives    启用 #line 指令生成（C99 后端）\n" as *byte);
    fprintf(stderr, "  --no-line-directives 禁用 #line 指令生成\n" as *byte);
    fprintf(stderr, "\n说明:\n" as *byte);
    fprintf(stderr, "  - 可以指定单个文件或目录，编译器会自动解析模块依赖\n" as *byte);
    fprintf(stderr, "  - 如果指定目录，目录中必须只有一个文件包含 main 函数\n" as *byte);
    fprintf(stderr, "  - 使用 UYA_ROOT 环境变量指定标准库位置（默认在编译器所在目录）\n" as *byte);
}

// 检测文件是否包含 main 函数
fn detect_main_function(filename: &byte) i32 {
    if filename == null {
        return 0;
    }
    const file_size: i32 = read_file_content(filename, &file_buffer[0], FILE_BUFFER_SIZE as usize);
    if file_size < 0 {
        return 0;
    }
    // 简单的字符串搜索（查找 "fn main("）
    var i: usize = 0;
    while i < file_size as usize {
        if i + 8 <= file_size as usize {
            if strncmp(&file_buffer[i], "fn main(" as *byte, 8) == 0 {
                return 1;
            }
        }
        i = i + 1;
    }
    return 0;
}

// Linux x86_64 struct dirent 布局:
// d_ino: i64 (offset 0, 8 bytes)
// d_off: i64 (offset 8, 8 bytes)
// d_reclen: u16 (offset 16, 2 bytes)
// d_type: u8 (offset 18, 1 byte)
// d_name: char[256] (offset 19)
// Uya 的 Dirent struct 布局不匹配，使用手动偏移量访问

fn dirent_get_type(entry_ptr: &byte) byte {
    return entry_ptr[18];
}

fn dirent_get_name(entry_ptr: &byte) &byte {
    var p: &byte = entry_ptr;
    p = p + 19;
    return p;
}

// 在目录中查找包含 main 函数的文件
fn find_main_files_in_dir(
    dir_path: &byte,
    main_files: &(&byte),
    file_paths_buffer: &([byte: PATH_MAX]),
    max_files: i32,
    file_count: &i32
) i32 {
    if dir_path == null || main_files == null || file_count == null {
        return -1;
    }
    file_count[0] = 0;
    const dir: *DIR = opendir(dir_path as *byte);
    if dir == null {
        return -1;
    }
    var entry: *Dirent = readdir(dir);
    while entry != null && file_count[0] < max_files {
        if dirent_get_type(entry as &byte) == 8 as byte {
            const name: *byte = dirent_get_name(entry as &byte) as *byte;
            const name_len: usize = strlen(name);
            if name_len > 4 {
                const ext: *byte = name + (name_len - 4);
                if strcmp(ext, ".uya" as *byte) == 0 {
                    const len: i32 = snprintf(&file_paths_buffer[file_count[0]][0], PATH_MAX, "%s/%s" as *byte, dir_path as *byte, name);
                    if len > 0 && len < PATH_MAX as i32 {
                        if detect_main_function(&file_paths_buffer[file_count[0]][0] as &byte) != 0 {
                            main_files[file_count[0]] = &file_paths_buffer[file_count[0]][0] as &byte;
                            file_count[0] = file_count[0] + 1;
                        }
                    }
                }
            }
        }
        entry = readdir(dir);
    }
    closedir(dir);
    return 0;
}

// 根据模块路径查找文件
fn find_module_file(
    module_path: &byte,
    project_root: &byte,
    uya_root: &byte,
    buffer: &byte,
    buffer_size: usize
) i32 {
    if module_path == null || buffer == null || buffer_size == 0 {
        return -1;
    }
    
    // 将模块路径转换为文件路径（std.io -> std/io/）
    var file_path: [byte: PATH_MAX] = [];
    const path_len: usize = strlen(module_path as *byte);
    if path_len >= PATH_MAX {
        return -1;
    }
    strcpy(&file_path[0], module_path as *byte);
    // 将 '.' 替换为 '/'
    var i: usize = 0;
    while i < path_len {
        if file_path[i] == 46 {
            file_path[i] = 47;
        }
        i = i + 1;
    }
    
    // 在给定根目录下查找模块文件
    // 策略1：path/ 目录中的 .uya 文件（如 std/c/syscall/ → syscall.uya）
    // 策略2：path.uya 直接文件（如 std/c/string.uya）
    var ri: i32 = 0;
    while ri < 2 {
        var root: &byte = null;
        if ri == 0 { root = project_root; }
        if ri == 1 { root = uya_root; }
        ri = ri + 1;
        if root == null || root[0] == 0 { continue; }
        
        var full_path: [byte: PATH_MAX] = [];
        const len: i32 = snprintf(&full_path[0], PATH_MAX, "%s%s" as *byte, root as *byte, &file_path[0]);
        if len <= 0 || len >= PATH_MAX as i32 { continue; }
        
        // 策略1：目录中查找 .uya 文件
        if is_directory(&full_path[0] as &byte) != 0 {
            const dir: *DIR = opendir(&full_path[0]);
            if dir != null {
                var entry: *Dirent = readdir(dir);
                while entry != null {
                    if dirent_get_type(entry as &byte) == 8 as byte {
                        const name: *byte = dirent_get_name(entry as &byte) as *byte;
                        const name_len: usize = strlen(name);
                        if name_len > 4 {
                            const ext: *byte = name + (name_len - 4);
                            if strcmp(ext, ".uya" as *byte) == 0 {
                                closedir(dir);
                                const result_len: i32 = snprintf(buffer as *byte, buffer_size, "%s%s/%s" as *byte, root as *byte, &file_path[0], name);
                                if result_len > 0 && result_len < buffer_size as i32 {
                                    return 0;
                                }
                            }
                        }
                    }
                    entry = readdir(dir);
                }
                closedir(dir);
            }
        }
        
        // 策略2：直接文件 path.uya
        var uya_path: [byte: PATH_MAX] = [];
        const ulen: i32 = snprintf(&uya_path[0], PATH_MAX, "%s%s.uya" as *byte, root as *byte, &file_path[0]);
        if ulen > 0 && ulen < PATH_MAX as i32 {
            const f: *FILE = fopen(&uya_path[0], "r" as *byte);
            if f != null {
                fclose(f);
                const ulen_sz: usize = ulen as usize;
                if ulen_sz < buffer_size {
                    strcpy(buffer as *byte, &uya_path[0]);
                    return 0;
                }
            }
        }
    }
    
    return -1;
}

// 从 AST 中提取 use 语句的模块路径
// 辅助函数：将 segments[0..count) 连接为 "a.b.c" 形式
fn join_segments_alloc(segs: &(&byte), count: i32, arena: &Arena) &byte {
    var total_len: usize = 0;
    var j: i32 = 0;
    while j < count {
        if segs[j] != null {
            total_len = total_len + strlen(segs[j] as *byte);
            if j > 0 { total_len = total_len + 1; }
        }
        j = j + 1;
    }
    if total_len == 0 { return null; }
    const buf: &byte = arena_alloc(arena, total_len + 1) as &byte;
    if buf == null { return null; }
    var dst: &byte = buf;
    j = 0;
    while j < count {
        if segs[j] != null {
            if j > 0 { dst[0] = 46 as byte; dst = dst + 1; }
            const sl: usize = strlen(segs[j] as *byte);
            memcpy(dst as *byte, segs[j] as *byte, sl);
            dst = dst + sl;
        }
        j = j + 1;
    }
    dst[0] = 0 as byte;
    return buf;
}

fn extract_use_modules(
    ast: &ASTNode,
    modules: &(&byte),
    max_modules: i32,
    module_count: &i32,
    project_root: &byte,
    uya_root: &byte,
    arena: &Arena
) i32 {
    if ast == null || ast.type != ASTNodeType.AST_PROGRAM || modules == null || module_count == null || arena == null {
        return -1;
    }
    module_count[0] = 0;
    var i: i32 = 0;
    while i < ast.program_decl_count && module_count[0] < max_modules {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_USE_STMT {
            const seg_count: i32 = decl.use_stmt_path_segment_count;
            if seg_count > 0 {
                var module_name: &byte = null;
                
                if decl.use_stmt_item_name != null {
                    // item_name 已设置，所有 segments 都是模块路径
                    module_name = join_segments_alloc(decl.use_stmt_path_segments, seg_count, arena);
                } else if seg_count > 1 {
                    // 先尝试全路径作为模块名
                    const full_path: &byte = join_segments_alloc(decl.use_stmt_path_segments, seg_count, arena);
                    if full_path != null {
                        var module_file: [byte: PATH_MAX] = [];
                        if find_module_file(full_path, project_root, uya_root, &module_file[0] as &byte, PATH_MAX) == 0 {
                            module_name = full_path;
                        } else {
                            module_name = join_segments_alloc(decl.use_stmt_path_segments, seg_count - 1, arena);
                        }
                    }
                } else {
                    module_name = join_segments_alloc(decl.use_stmt_path_segments, seg_count, arena);
                }
                
                if module_name != null {
                    // 去重
                    var duplicate: i32 = 0;
                    var k: i32 = 0;
                    while k < module_count[0] {
                        if modules[k] != null && strcmp(modules[k] as *byte, module_name as *byte) == 0 {
                            duplicate = 1;
                            break;
                        }
                        k = k + 1;
                    }
                    if duplicate == 0 {
                        modules[module_count[0]] = module_name;
                        module_count[0] = module_count[0] + 1;
                    }
                }
            }
        }
        i = i + 1;
    }
    return 0;
}

// 递归收集模块依赖
// 返回：成功返回新的文件列表大小，失败返回-1
fn collect_module_dependencies(
    filename: &byte,
    file_list: &(&byte),
    file_list_size: i32,
    max_files: i32,
    processed_files: &(&byte),
    processed_count: &i32,
    max_processed: i32,
    project_root: &byte,
    uya_root: &byte,
    arena: &Arena
) i32 {
    if filename == null || file_list == null || processed_files == null || processed_count == null || arena == null {
        return -1;
    }
    
    // 使用局部变量存储可修改的 file_list_size（函数参数在 Uya 中不可修改）
    var current_size: i32 = file_list_size;
    
    // 检查是否已处理过（避免循环依赖）
    // 使用路径比较函数，考虑路径格式差异
    var i: i32 = 0;
    while i < processed_count[0] {
        if processed_files[i] != null && paths_equal(processed_files[i], filename) != 0 {
            return current_size;  // 已处理，直接返回
        }
        i = i + 1;
    }
    
    // 标记为已处理
    if processed_count[0] >= max_processed {
        return -1;
    }
    processed_files[processed_count[0]] = filename;
    processed_count[0] = processed_count[0] + 1;
    
    // 读取文件并解析 AST
    const file_size: i32 = read_file_content(filename, &file_buffer[0], FILE_BUFFER_SIZE as usize);
    if file_size < 0 {
        return -1;
    }
    
    var lexer: Lexer = Lexer { buffer: [], buffer_size: 0 as usize, position: 0 as usize, line: 1, column: 1, filename: null, string_mode: 0, interp_depth: 0, pending_interp_open: 0, reading_spec: 0, string_text_len: 0 };
    if lexer_init(&lexer, &file_buffer[0], file_size as usize, filename, arena) != 0 {
        return -1;
    }
    
    var parser: Parser = Parser { lexer: null, current_token: null, arena: null, context: ParserContext.PARSER_CONTEXT_NORMAL };
    if parser_init(&parser, &lexer, arena) != 0 {
        return -1;
    }
    
    const ast: &ASTNode = parser_parse(&parser);
    if ast == null || ast.type != ASTNodeType.AST_PROGRAM {
        return -1;
    }
    
    // 提取 use 语句中的模块路径
    var modules: [&byte: MAX_INPUT_FILES] = [];
    var module_count: i32 = 0;
    if extract_use_modules(ast, &modules[0], MAX_INPUT_FILES, &module_count, project_root, uya_root, arena) != 0 {
        return -1;
    }
    
    // 对于每个模块，查找文件并递归处理
    i = 0;
    while i < module_count {
        if modules[i] == null {
            i = i + 1;
            continue;
        }
        
        // 特殊处理：main 模块
        if strcmp(modules[i] as *byte, "main" as *byte) == 0 {
            // main 模块在项目根目录
            // 注意：main 模块通常已经在文件列表中（作为入口文件），
            // 所以这里不需要再次添加。如果确实需要添加，应该检查是否已在列表中。
            // 为了避免重复添加，这里直接跳过 main 模块的处理。
            // 如果 main.uya 不在列表中，它应该已经作为入口文件被添加了。
            i = i + 1;
            continue;
        }
        
        // 查找模块文件
        var module_file: [byte: PATH_MAX] = [];
        if find_module_file(modules[i], project_root, uya_root, &module_file[0] as &byte, PATH_MAX) == 0 {
            // 检查是否已在列表中（使用路径比较函数）
            var already_added: i32 = 0;
            var j: i32 = 0;
            while j < current_size {
                if file_list[j] != null && paths_equal(file_list[j], &module_file[0] as &byte) != 0 {
                    already_added = 1;
                    break;
                }
                j = j + 1;
            }
            if already_added == 0 && current_size < max_files {
                // 使用 Arena 分配文件路径
                const path_len: usize = strlen(&module_file[0]);
                const path_copy: &byte = arena_alloc(arena, path_len + 1) as &byte;
                if path_copy != null {
                    strcpy(path_copy as *byte, &module_file[0]);
                    file_list[current_size] = path_copy;
                    current_size = current_size + 1;
                    // 递归处理
                    current_size = collect_module_dependencies(
                        path_copy,
                        file_list,
                        current_size,
                        max_files,
                        processed_files,
                        processed_count,
                        max_processed,
                        project_root,
                        uya_root,
                        arena
                    );
                    if current_size < 0 {
                        return -1;
                    }
                }
            }
        }
        i = i + 1;
    }
    
    return current_size;
}

// 解析命令行参数
// input_file_indices: 填充前 *input_file_count 个为输入文件在 argv 中的下标
// 返回：0 成功，-1 失败
fn parse_args(
    input_file_indices: &i32,
    input_file_count: &i32,
    output_file_index: &i32,
    backend_type: &BackendType,
    emit_line_directives: &i32
) i32 {
    const argc: i32 = get_argc();
    if argc < 4 {
        const program_name: *byte = get_argv(0);
        if program_name != null {
            print_usage(program_name as &byte);
        }
        return -1;
    }
    input_file_count[0] = 0;
    output_file_index[0] = -1;
    backend_type[0] = BackendType.BACKEND_LLVM;
    emit_line_directives[0] = 0;

    var i: i32 = 1;
    while i < argc {
        const arg: *byte = get_argv(i);
        if arg == null {
            fprintf(get_stderr(), "错误: 无法获取命令行参数（索引 %d）\n" as *byte, i);
            return -1;
        }
        if strcmp(arg, "-o" as *byte) == 0 {
            if i + 1 < argc {
                output_file_index[0] = i + 1;
                i = i + 1;
            } else {
                fprintf(get_stderr(), "错误: -o 选项需要指定输出文件名\n" as *byte);
                return -1;
            }
        } else if strcmp(arg, "--c99" as *byte) == 0 {
            backend_type[0] = BackendType.BACKEND_C99;
        } else if strcmp(arg, "--no-line-directives" as *byte) == 0 {
            emit_line_directives[0] = 0;
        } else if strcmp(arg, "--line-directives" as *byte) == 0 {
            emit_line_directives[0] = 1;
        } else {
            const c: byte = arg[0];
            if c != 45 {
                if input_file_count[0] >= MAX_INPUT_FILES {
                    fprintf(get_stderr(), "错误: 输入文件数量超过最大限制 (%d)\n" as *byte, MAX_INPUT_FILES);
                    return -1;
                }
                const idx: i32 = input_file_count[0];
                input_file_indices[idx] = i;
                input_file_count[0] = idx + 1;
            }
        }
        i = i + 1;
    }

    if input_file_count[0] == 0 {
        fprintf(get_stderr(), "错误: 未指定输入文件\n" as *byte);
        const program_name: *byte = get_argv(0);
        if program_name != null {
            print_usage(program_name as &byte);
        }
        return -1;
    }
    if output_file_index[0] < 0 {
        fprintf(get_stderr(), "错误: 未指定输出文件（使用 -o 选项）\n" as *byte);
        const program_name: *byte = get_argv(0);
        if program_name != null {
            print_usage(program_name as &byte);
        }
        return -1;
    }
    const out_idx: i32 = output_file_index[0];
    const out_path: *byte = get_argv(out_idx);
    if out_path == null {
        fprintf(get_stderr(), "错误: 无法获取输出文件路径（索引 %d）\n" as *byte, out_idx);
        return -1;
    }
    if backend_type[0] == BackendType.BACKEND_LLVM {
        const ext: *byte = strrchr(out_path, 46);
        if ext != null && strcmp(ext, ".c" as *byte) == 0 {
            backend_type[0] = BackendType.BACKEND_C99;
        }
    }
    return 0;
}

// 主编译函数：词法 → 语法 → AST 合并 → 类型检查 → 代码生成
// 支持目录输入和自动依赖收集
fn compile_files(
    input_file_indices: &i32,
    input_file_count: i32,
    output_file_index: i32,
    backend: BackendType,
    emit_line_directives: i32
) i32 {
    
    // 初始化临时 Arena（用于依赖收集，使用全局缓冲区避免栈溢出）
    var temp_arena: Arena = Arena { buffer: null, size: 0 as usize, offset: 0 as usize };
    arena_init(&temp_arena, &temp_arena_buffer[0], 32 * 1024 * 1024);
    
    // 获取 UYA_ROOT 和编译器目录
    var uya_root_buffer: [byte: PATH_MAX] = [];
    const argv0: *byte = get_argv(0);
    if argv0 == null {
        fprintf(get_stderr(), "错误: 无法获取程序路径\n" as *byte);
        return 1;
    }
    if get_uya_root(argv0 as &byte, &uya_root_buffer[0] as &byte, PATH_MAX) != 0 {
        fprintf(get_stderr(), "错误: 无法获取 UYA_ROOT 目录\n" as *byte);
        return 1;
    }
    
    // 处理输入：如果是目录，查找包含 main 的文件；如果是文件，检查是否包含 main
    // 使用全局变量避免栈溢出
    var resolved_files: [&byte: MAX_INPUT_FILES] = resolved_files_global;
    var resolved_count: i32 = 0;
    var project_root_buffer: [byte: PATH_MAX] = [];
    var project_root: &byte = null;
    // 使用全局变量避免栈溢出（262KB 太大），直接使用全局数组
    // var main_file_paths: [[byte: PATH_MAX]: MAX_INPUT_FILES] = [];
    
    var i: i32 = 0;
    while i < input_file_count {
        const idx_i: i32 = input_file_indices[i];
        const input_path: *byte = get_argv(idx_i);
        if input_path == null {
            fprintf(get_stderr(), "错误: 无法获取输入文件路径（索引 %d）\n" as *byte, idx_i);
            return 1;
        }
        const input: &byte = input_path as &byte;
        
        const is_dir_result: i32 = is_directory(input);
        if is_dir_result != 0 {
            // 是目录，查找包含 main 的文件
            var main_files: [&byte: MAX_INPUT_FILES] = [];
            var main_count: i32 = 0;
            if find_main_files_in_dir(input, &main_files[0], &main_file_paths_global[0], MAX_INPUT_FILES, &main_count) != 0 {
                fprintf(get_stderr(), "错误: 无法读取目录 '%s'\n" as *byte, input_path);
                return 1;
            }
            if main_count == 0 {
                fprintf(get_stderr(), "错误: 目录 '%s' 中未找到包含 main 函数的文件\n" as *byte, input_path);
                return 1;
            }
            if main_count > 1 {
                fprintf(get_stderr(), "错误: 目录 '%s' 中有多个文件包含 main 函数:\n" as *byte, input_path);
                var j: i32 = 0;
                while j < main_count {
                    fprintf(get_stderr(), "  %s\n" as *byte, main_files[j] as *byte);
                    j = j + 1;
                }
                return 1;
            }
            resolved_files[resolved_count] = main_files[0];
            resolved_count = resolved_count + 1;
            // 设置项目根目录
            if project_root == null {
                const input_len: usize = strlen(input_path);
                if input_len < PATH_MAX - 1 {
                    strcpy(&project_root_buffer[0], input_path);
                    if project_root_buffer[input_len - 1] != 47 {
                        project_root_buffer[input_len] = 47 as byte;
                        project_root_buffer[input_len + 1] = 0 as byte;
                    }
                    project_root = &project_root_buffer[0] as &byte;
                } else {
                    project_root = input;
                }
            }
        } else if is_file(input) != 0 {
            // 检查是否已在 resolved_files 中（避免重复添加）
            var already_resolved: i32 = 0;
            var j: i32 = 0;
            while j < resolved_count {
                if resolved_files[j] != null && paths_equal(resolved_files[j], input) != 0 {
                    already_resolved = 1;
                    break;
                }
                j = j + 1;
            }
            if already_resolved != 0 {
                i = i + 1;
                continue;
            }
            
            // 是文件，检查是否包含 main
            if detect_main_function(input) != 0 {
                resolved_files[resolved_count] = input;
                resolved_count = resolved_count + 1;
                // 设置项目根目录（文件所在目录）
                if project_root == null {
                    const last_slash: *byte = strrchr(input_path, 47);
                    if last_slash != null {
                        const dir_len: usize = ptr_diff(last_slash as &byte, input) + 1;
                        if dir_len < PATH_MAX {
                            memcpy(&project_root_buffer[0], input_path, dir_len);
                            project_root_buffer[dir_len] = 0 as byte;
                            project_root = &project_root_buffer[0] as &byte;
                        } else {
                            strcpy(&project_root_buffer[0], "./" as *byte);
                            project_root = &project_root_buffer[0] as &byte;
                        }
                    } else {
                        strcpy(&project_root_buffer[0], "./" as *byte);
                        project_root = &project_root_buffer[0] as &byte;
                    }
                }
            } else {
                // 多文件模式下，允许某些文件不包含 main（它们是库文件）
                // 但如果这是唯一输入文件，则必须包含 main
                if input_file_count == 1 {
                    fprintf(get_stderr(), "错误: 文件 '%s' 不包含 main 函数\n" as *byte, input_path);
                    return 1;
                }
                // 多文件模式：将不包含 main 的文件也加入列表（作为库文件）
                resolved_files[resolved_count] = input;
                resolved_count = resolved_count + 1;
            }
        } else {
            fprintf(get_stderr(), "错误: '%s' 既不是文件也不是目录\n" as *byte, input_path);
            return 1;
        }
        i = i + 1;
    }
    
    if resolved_count == 0 {
        fprintf(get_stderr(), "错误: 未找到包含 main 函数的文件\n" as *byte);
        return 1;
    }
    
    // 自动收集模块依赖
    // 只对包含 main 的文件进行依赖收集，库文件已经在列表中，不需要进行依赖收集
    var all_files: [&byte: MAX_INPUT_FILES] = [];
    var all_file_count: i32 = resolved_count;
    i = 0;
    while i < resolved_count {
        all_files[i] = resolved_files[i];
        i = i + 1;
    }
    
    // 收集依赖（只对包含 main 的文件进行依赖收集）
    var processed_files: [&byte: MAX_INPUT_FILES] = [];
    var processed_count: i32 = 0;
    
    // 找出包含 main 的文件（入口文件）
    var main_files: [&byte: MAX_INPUT_FILES] = [];
    var main_file_count: i32 = 0;
    i = 0;
    while i < resolved_count {
        if detect_main_function(resolved_files[i]) != 0 {
            main_files[main_file_count] = resolved_files[i];
            main_file_count = main_file_count + 1;
        }
        i = i + 1;
    }
    
    // 只对包含 main 的文件进行依赖收集
    i = 0;
    while i < main_file_count {
        const new_count: i32 = collect_module_dependencies(
            main_files[i],
            &all_files[0],
            all_file_count,
            MAX_INPUT_FILES,
            &processed_files[0],
            &processed_count,
            MAX_INPUT_FILES,
            project_root,
            &uya_root_buffer[0] as &byte,
            &temp_arena
        );
        if new_count < 0 {
            fprintf(get_stderr(), "错误: 收集模块依赖失败: %s\n" as *byte, main_files[i] as *byte);
            return 1;
        }
        all_file_count = new_count;
        i = i + 1;
    }
    
    const stderr: *void = get_stderr();
    fprintf(get_stderr(), "=== 开始编译 ===\n" as *byte);
    fprintf(get_stderr(), "输入文件数量: %d (包含依赖)\n" as *byte, all_file_count);
    i = 0;
    while i < all_file_count {
        fprintf(get_stderr(), "  %d: %s\n" as *byte, i, all_files[i] as *byte);
        i = i + 1;
    }
    const output_file: *byte = get_argv(output_file_index);
    fprintf(get_stderr(), "输出文件: %s\n" as *byte, output_file);
    if project_root != null {
        fprintf(get_stderr(), "项目根目录: %s\n" as *byte, project_root as *byte);
    }
    fprintf(get_stderr(), "UYA_ROOT: %s\n" as *byte, &uya_root_buffer[0]);
    fprintf(get_stderr(), "=== 词法/语法分析 ===\n" as *byte);
    var backend_str: *byte = "LLVM" as *byte;
    if backend == BackendType.BACKEND_C99 {
        backend_str = "C99" as *byte;
    }
    fprintf(stderr, "后端类型: %s\n" as *byte, backend_str);

    var arena: Arena = Arena { buffer: null, size: 0 as usize, offset: 0 as usize };
    arena_init(&arena, &arena_buffer[0], ARENA_BUFFER_SIZE as usize);

    var programs: [&ASTNode: MAX_INPUT_FILES] = [];

    i = 0;
    while i < all_file_count {
        const input_path: *byte = all_files[i] as *byte;
        const file_size: i32 = read_file_content(input_path as &byte, &file_buffer[0], FILE_BUFFER_SIZE as usize);
        if file_size < 0 {
            fprintf(stderr, "错误: 无法读取文件 '%s' (可能文件太大或不存在)\n" as *byte, input_path);
            return 1;
        }
        var lexer: Lexer = Lexer { buffer: [], buffer_size: 0 as usize, position: 0 as usize, line: 0, column: 0, filename: null, has_error: 0 };
        const input_path_ref: &byte = input_path as &byte;
        if lexer_init(&lexer, &file_buffer[0], file_size as usize, input_path_ref, &arena) != 0 {
            fprintf(stderr, "错误: Lexer 初始化失败: %s\n" as *byte, input_path);
            return 1;
        }
        var parser: Parser = Parser { lexer: null, current_token: null, arena: null, context: ParserContext.PARSER_CONTEXT_NORMAL };
        if parser_init(&parser, &lexer, &arena) != 0 {
            fprintf(stderr, "错误: Parser 初始化失败: %s\n" as *byte, input_path);
            return 1;
        }
        const ast: &ASTNode = parser_parse(&parser);
        if ast == null {
            fprintf(stderr, "错误: 语法分析失败: %s\n" as *byte, input_path);
            return 1;
        }
        if ast.type != ASTNodeType.AST_PROGRAM {
            fprintf(stderr, "错误: 解析结果不是程序节点: %s\n" as *byte, input_path);
            return 1;
        }
        // 检查词法分析错误（如未闭合块注释）
        if lexer.has_error != 0 {
            fprintf(stderr, "错误: 语法分析失败: %s\n" as *byte, input_path);
            return 1;
        }
        programs[i] = ast;
        fprintf(stderr, "  解析完成: %s\n" as *byte, input_path);
        i = i + 1;
    }
    fprintf(stderr, "=== 词法/语法分析完成，共 %d 个文件 ===\n" as *byte, all_file_count);

    fprintf(stderr, "=== AST 合并阶段 ===\n" as *byte);
    const merged_ast: &ASTNode = ast_merge_programs(programs, all_file_count, &arena);
    if merged_ast == null {
        fprintf(stderr, "错误: AST 合并失败\n" as *byte);
        return 1;
    }
    fprintf(stderr, "AST 合并完成，共 %d 个声明\n" as *byte, merged_ast.program_decl_count);

    fprintf(stderr, "=== 类型检查阶段 ===\n" as *byte);
    const void_type: Type = Type { kind: TypeKind.TYPE_VOID, enum_name: null, struct_name: null, pointer_to: null, is_ffi_pointer: 0, element_type: null, array_size: 0 };
    var checker: TypeChecker = TypeChecker { arena: null, symbol_table: SymbolTable { slots: [], count: 0 }, function_table: FunctionTable { slots: [], count: 0 }, scope_level: 0, loop_depth: 0, program_node: null, error_count: 0, default_filename: null, current_return_type: void_type, in_function: 0, in_defer_or_errdefer: 0 };
    var default_filename: *byte = "(unknown)" as *byte;
    if all_file_count > 0 {
        default_filename = all_files[0] as *byte;
    }
    if checker_init(&checker, &arena, default_filename as &byte) != 0 {
        fprintf(stderr, "错误: TypeChecker 初始化失败\n" as *byte);
        return 1;
    }
    // 设置 UYA_ROOT 目录，供 checker 识别标准库模块
    checker.uya_root_dir = &uya_root_buffer[0] as &byte;
    
    if checker_check(&checker, merged_ast) != 0 {
        fprintf(stderr, "错误: 类型检查失败（错误数量: %d）\n" as *byte, checker_get_error_count(&checker));
        const err_msg: &byte = get_last_checker_error();
        if err_msg != null {
            fprintf(stderr, "最后错误: %s\n" as *byte, err_msg as *byte);
        }
        return 1;
    }
    if checker_get_error_count(&checker) > 0 {
        fprintf(stderr, "错误: 类型检查失败（错误数量: %d）\n" as *byte, checker_get_error_count(&checker));
        const err_msg: &byte = get_last_checker_error();
        if err_msg != null {
            fprintf(stderr, "最后错误: %s\n" as *byte, err_msg as *byte);
        }
        return 1;
    }
    fprintf(stderr, "类型检查通过\n" as *byte);

    fprintf(stderr, "=== 代码生成阶段 ===\n" as *byte);
    var module_name: *byte = "(unknown)" as *byte;
    if all_file_count > 0 {
        module_name = all_files[0] as *byte;
    }
    fprintf(stderr, "模块名: %s\n" as *byte, module_name);

    // C99 后端：生成 C 源代码（与 C 版本保持一致，直接使用 C99 后端）
    const out_file: *void = fopen(output_file, "w" as *byte);
    if out_file == null {
        fprintf(stderr, "错误: 无法打开输出文件 '%s'\n" as *byte, output_file);
        return 1;
    }
    var c99_codegen: C99CodeGenerator = C99CodeGenerator { };
    if c99_codegen_new(&c99_codegen, &arena, out_file, module_name as &byte, emit_line_directives) != 0 {
        fprintf(stderr, "错误: C99CodeGenerator 初始化失败\n" as *byte);
        fclose(out_file);
        return 1;
    }
    // 设置单态化实例（从 TypeChecker 传入）
    c99_codegen_set_mono_instances(&c99_codegen, &checker);
    if c99_codegen_generate(&c99_codegen, merged_ast, output_file as &byte) != 0 {
        fprintf(stderr, "错误: C99 代码生成失败\n" as *byte);
        c99_codegen_free(&c99_codegen);
        fclose(out_file);
        return 1;
    }
    c99_codegen_free(&c99_codegen);
    fclose(out_file);
    fprintf(stderr, "代码生成完成: %s\n" as *byte, output_file);

    return 0;
}

// 程序入口（由 bridge.c 调用，重命名为 uya_main）
fn uya_main() i32 {
    
    var input_file_indices: [i32: 64] = [];
    var input_file_count: i32 = 0;
    var output_file_index: i32 = -1;
    var backend: BackendType = BackendType.BACKEND_LLVM;
    var emit_line_directives: i32 = 0;

    if parse_args(&input_file_indices[0], &input_file_count, &output_file_index, &backend, &emit_line_directives) != 0 {
        return 1;
    }
    const result: i32 = compile_files(&input_file_indices[0], input_file_count, output_file_index, backend, emit_line_directives);
    if result != 0 {
        return result;
    }
    return 0;
}

