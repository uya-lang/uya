// main.uya - C99 代码生成器 main 模块
// 生成 C99 源代码
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义
// 注意：gen_function_prototype 和 gen_function 在 function.uya 中定义，
//       由于 function.uya 在 main.uya 之前编译，函数已经可见

// 递归收集 AST 中使用的切片类型，以便输出对应 struct
fn collect_slice_types_from_node(codegen: &C99CodeGenerator, node: &ASTNode) void {
    if codegen == null || node == null {
        return;
    }
    if node.type == ASTNodeType.AST_VAR_DECL && node.var_decl_type != null {
        if node.var_decl_type.type == ASTNodeType.AST_TYPE_SLICE {
            c99_type_to_c(codegen, node.var_decl_type);
        }
        collect_slice_types_from_node(codegen, node.var_decl_type);
        if node.var_decl_init != null {
            collect_slice_types_from_node(codegen, node.var_decl_init);
        }
        return;
    }
    if node.type == ASTNodeType.AST_FN_DECL {
        if node.fn_decl_return_type != null {
            if node.fn_decl_return_type.type == ASTNodeType.AST_TYPE_SLICE {
                c99_type_to_c(codegen, node.fn_decl_return_type);
            }
            collect_slice_types_from_node(codegen, node.fn_decl_return_type);
        }
        var j: i32 = 0;
        while j < node.fn_decl_param_count && node.fn_decl_params != null {
            const p: &ASTNode = node.fn_decl_params[j];
            if p != null {
                collect_slice_types_from_node(codegen, p);
            }
            j = j + 1;
        }
        if node.fn_decl_body != null {
            collect_slice_types_from_node(codegen, node.fn_decl_body);
        }
        return;
    }
    if node.type == ASTNodeType.AST_BLOCK && node.block_stmts != null {
        var i: i32 = 0;
        while i < node.block_stmt_count {
            collect_slice_types_from_node(codegen, node.block_stmts[i]);
            i = i + 1;
        }
        return;
    }
    if node.type == ASTNodeType.AST_IF_STMT {
        collect_slice_types_from_node(codegen, node.if_stmt_condition);
        collect_slice_types_from_node(codegen, node.if_stmt_then_branch);
        if node.if_stmt_else_branch != null {
            collect_slice_types_from_node(codegen, node.if_stmt_else_branch);
        }
        return;
    }
    if node.type == ASTNodeType.AST_WHILE_STMT {
        collect_slice_types_from_node(codegen, node.while_stmt_condition);
        collect_slice_types_from_node(codegen, node.while_stmt_body);
        return;
    }
    if node.type == ASTNodeType.AST_FOR_STMT {
        if node.for_stmt_is_range != 0 {
            collect_slice_types_from_node(codegen, node.for_stmt_range_start);
            if node.for_stmt_range_end != null {
                collect_slice_types_from_node(codegen, node.for_stmt_range_end);
            }
        } else {
            collect_slice_types_from_node(codegen, node.for_stmt_array);
        }
        collect_slice_types_from_node(codegen, node.for_stmt_body);
        return;
    }
    if node.type == ASTNodeType.AST_RETURN_STMT && node.return_stmt_expr != null {
        collect_slice_types_from_node(codegen, node.return_stmt_expr);
        return;
    }
    if node.type == ASTNodeType.AST_ASSIGN {
        collect_slice_types_from_node(codegen, node.assign_dest);
        collect_slice_types_from_node(codegen, node.assign_src);
        return;
    }
    if node.type == ASTNodeType.AST_SLICE_EXPR {
        collect_slice_types_from_node(codegen, node.slice_expr_base);
        collect_slice_types_from_node(codegen, node.slice_expr_start_expr);
        collect_slice_types_from_node(codegen, node.slice_expr_len_expr);
        return;
    }
    if node.type == ASTNodeType.AST_STRUCT_DECL && node.struct_decl_fields != null {
        var i: i32 = 0;
        while i < node.struct_decl_field_count {
            const field: &ASTNode = node.struct_decl_fields[i];
            if field != null && field.type == ASTNodeType.AST_VAR_DECL && field.var_decl_type != null {
                if field.var_decl_type.type == ASTNodeType.AST_TYPE_SLICE {
                    c99_type_to_c(codegen, field.var_decl_type);
                }
                collect_slice_types_from_node(codegen, field.var_decl_type);
            }
            i = i + 1;
        }
        return;
    }
    if node.type == ASTNodeType.AST_BINARY_EXPR {
        collect_slice_types_from_node(codegen, node.binary_expr_left);
        collect_slice_types_from_node(codegen, node.binary_expr_right);
    } else if node.type == ASTNodeType.AST_UNARY_EXPR {
        collect_slice_types_from_node(codegen, node.unary_expr_operand);
    } else if node.type == ASTNodeType.AST_TRY_EXPR {
        collect_slice_types_from_node(codegen, node.try_expr_operand);
    } else if node.type == ASTNodeType.AST_MATCH_EXPR {
        collect_slice_types_from_node(codegen, node.match_expr_expr);
        var i: i32 = 0;
        while i < node.match_expr_arm_count {
            collect_slice_types_from_node(codegen, node.match_expr_arms[i].result_expr);
            i = i + 1;
        }
    } else if node.type == ASTNodeType.AST_MEMBER_ACCESS {
        collect_slice_types_from_node(codegen, node.member_access_object);
    } else if node.type == ASTNodeType.AST_ARRAY_ACCESS {
        collect_slice_types_from_node(codegen, node.array_access_array);
        collect_slice_types_from_node(codegen, node.array_access_index);
    } else if node.type == ASTNodeType.AST_CALL_EXPR {
        collect_slice_types_from_node(codegen, node.call_expr_callee);
        var i: i32 = 0;
        while i < node.call_expr_arg_count && node.call_expr_args != null {
            collect_slice_types_from_node(codegen, node.call_expr_args[i]);
            i = i + 1;
        }
    } else if node.type == ASTNodeType.AST_CAST_EXPR {
        collect_slice_types_from_node(codegen, node.cast_expr_expr);
        if node.cast_expr_target_type != null {
            collect_slice_types_from_node(codegen, node.cast_expr_target_type);
            if node.cast_expr_is_force_cast != 0 {
                const tmp: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_ERROR_UNION, 0, 0, codegen.arena, null);
                if tmp != null {
                    tmp.type_error_union_payload_type = node.cast_expr_target_type;
                    c99_type_to_c(codegen, tmp);
                }
            }
        }
    } else if node.type == ASTNodeType.AST_LEN {
        collect_slice_types_from_node(codegen, node.len_expr_array);
    } else if node.type == ASTNodeType.AST_SIZEOF && node.sizeof_expr_target != null {
        if node.sizeof_expr_is_type != 0 && node.sizeof_expr_target.type == ASTNodeType.AST_TYPE_SLICE {
            c99_type_to_c(codegen, node.sizeof_expr_target);
        }
        collect_slice_types_from_node(codegen, node.sizeof_expr_target);
    }
}

// 递归收集所有测试语句（使用固定大小数组，最多 1000 个测试）
const MAX_TESTS: i32 = 1000;
fn collect_tests_from_node(codegen: &C99CodeGenerator, node: &ASTNode, tests: & & ASTNode, test_count: &i32) i32 {
    if codegen == null || node == null || tests == null || test_count == null {
        return 0;
    }
    var count: i32 = 0;
    // 通过数组访问获取值（test_count 是指向 i32 的指针，可以视为单元素数组）
    // 注意：Uya 中指针可以像数组一样访问
    count = (&test_count[0])[0];
    if count >= MAX_TESTS {
        return 0;  // 防止溢出
    }
    
    if node.type == ASTNodeType.AST_TEST_STMT {
        // 添加到测试列表
        tests[count] = node;
        count = count + 1;
        // 通过数组访问设置值
        (&test_count[0])[0] = count;
    }
    
    // 递归处理子节点
    if node.type == ASTNodeType.AST_BLOCK && node.block_stmts != null {
        var i: i32 = 0;
        while i < node.block_stmt_count {
            collect_tests_from_node(codegen, node.block_stmts[i], tests, test_count);
            i = i + 1;
        }
    } else if node.type == ASTNodeType.AST_IF_STMT {
        collect_tests_from_node(codegen, node.if_stmt_then_branch, tests, test_count);
        if node.if_stmt_else_branch != null {
            collect_tests_from_node(codegen, node.if_stmt_else_branch, tests, test_count);
        }
    } else if node.type == ASTNodeType.AST_WHILE_STMT {
        collect_tests_from_node(codegen, node.while_stmt_body, tests, test_count);
    } else if node.type == ASTNodeType.AST_FOR_STMT {
        collect_tests_from_node(codegen, node.for_stmt_body, tests, test_count);
    } else if node.type == ASTNodeType.AST_FN_DECL && node.fn_decl_body != null {
        collect_tests_from_node(codegen, node.fn_decl_body, tests, test_count);
    }
    return 0;
}

// 从测试描述字符串生成安全的函数名（使用哈希避免中文问题）
fn get_test_function_name(codegen: &C99CodeGenerator, description: &byte) &byte {
    if description == null {
        return null;
    }
    
    // 使用简单的哈希函数生成唯一标识符
    var hash: u32 = 0;
    const len: i32 = strlen(description as *byte);
    var i: i32 = 0;
    while i < len {
        hash = hash * 31 + (description[i] as u32);
        i = i + 1;
    }
    
    // 生成函数名：uya_test_<hash>
    const buf: &byte = arena_alloc(codegen.arena, 64) as &byte;
    if buf == null {
        return null;
    }
    // 使用 snprintf 生成函数名
    snprintf(buf as *byte, 64, "uya_test_%u" as *byte, hash);
    
    return get_safe_c_identifier(codegen, buf);
}

// 生成测试函数
fn gen_test_function(codegen: &C99CodeGenerator, test_stmt: &ASTNode) void {
    if test_stmt == null || test_stmt.type != ASTNodeType.AST_TEST_STMT {
        return;
    }
    
    const description: &byte = test_stmt.test_stmt_description;
    const func_name: &byte = get_test_function_name(codegen, description);
    const body: &ASTNode = test_stmt.test_stmt_body;
    
    if func_name == null || body == null {
        return;
    }
    
    // 创建 void 类型节点（用于设置 current_function_return_type）
    const void_type: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_NAMED, test_stmt.line, test_stmt.column, codegen.arena, test_stmt.filename);
    if void_type != null {
        void_type.type_named_name = "void" as *byte;
    }
    
    // 保存之前的返回类型
    const saved_return_type: &ASTNode = codegen.current_function_return_type;
    
    // 设置当前函数的返回类型为 void
    codegen.current_function_return_type = void_type;
    
    // 生成函数定义
    emit_line_directive(codegen, test_stmt.line, test_stmt.filename);
    fprintf(codegen.output as *void, "static void %s(void) {\n" as *byte, func_name as *byte);
    
    // 生成函数体
    gen_stmt(codegen, body);
    
    // 恢复之前的返回类型
    codegen.current_function_return_type = saved_return_type;
    
    fputs("}\n" as *byte, codegen.output as *void);
}

// 生成测试运行器函数
fn gen_test_runner(codegen: &C99CodeGenerator, tests: & & ASTNode, test_count: i32) void {
    if tests == null || test_count <= 0 {
        return;
    }
    
    fputs("static void uya_run_tests(void) {\n" as *byte, codegen.output as *void);
    
    var i: i32 = 0;
    while i < test_count {
        const test_node: &ASTNode = tests[i];
        if test_node != null && test_node.type == ASTNodeType.AST_TEST_STMT {
            const func_name: &byte = get_test_function_name(codegen, test_node.test_stmt_description);
            if func_name != null {
                fprintf(codegen.output as *void, "    %s();\n" as *byte, func_name as *byte);
            }
        }
        i = i + 1;
    }
    
    fputs("}\n" as *byte, codegen.output as *void);
}

// 生成 C99 代码
fn c99_codegen_generate(codegen: &C99CodeGenerator, ast: &ASTNode, output_file: &byte) i32 {
    if codegen == null || ast == null || output_file == null {
        return -1;
    }
    
    // 检查是否是程序节点
    if ast.type != ASTNodeType.AST_PROGRAM {
        return -1;
    }
    
    // 保存程序节点引用
    codegen.program_node = ast;
    
    // 检测是否在生成标准库（用于 --outlibc）
    // 通过检查输出文件名是否包含 "libuya" 来判断
    var is_std_lib: i32 = 0;
    if output_file != null {
        // 简单检查：查找文件名中是否包含 "libuya"（检查前 100 个字符）
        var i: i32 = 0;
        while i < 100 && output_file[i] != 0 as byte {
            // 检查 "libuya"（6个字符：l-i-b-u-y-a）
            if i + 5 < 100 &&
               output_file[i] == 108 as byte &&      // 'l'
               output_file[i + 1] == 105 as byte &&  // 'i'
               output_file[i + 2] == 98 as byte &&    // 'b'
               output_file[i + 3] == 117 as byte &&   // 'u'
               output_file[i + 4] == 121 as byte &&   // 'y'
               output_file[i + 5] == 97 as byte {     // 'a'
                is_std_lib = 1;
                break;
            }
            i = i + 1;
        }
    }
    
    // 输出文件头
    fputs("// C99 代码由 Uya Mini 编译器生成\n" as *byte, codegen.output as *void);
    fputs("// 使用 -std=c99 编译\n" as *byte, codegen.output as *void);
    fputs("//\n" as *byte, codegen.output as *void);
    
    if is_std_lib != 0 {
        // 标准库模式：零依赖，自己定义所有类型
        fputs("// 零依赖标准库：自己定义所有类型（用于 --nostdlib 编译）\n" as *byte, codegen.output as *void);
        fputs("\n" as *byte, codegen.output as *void);
        // 定义基本类型
        fputs("// 基本整数类型\n" as *byte, codegen.output as *void);
        fputs("typedef signed char int8_t;\n" as *byte, codegen.output as *void);
        fputs("typedef unsigned char uint8_t;\n" as *byte, codegen.output as *void);
        fputs("typedef short int16_t;\n" as *byte, codegen.output as *void);
        fputs("typedef unsigned short uint16_t;\n" as *byte, codegen.output as *void);
        fputs("typedef int int32_t;\n" as *byte, codegen.output as *void);
        fputs("typedef unsigned int uint32_t;\n" as *byte, codegen.output as *void);
        fputs("typedef long long int64_t;\n" as *byte, codegen.output as *void);
        fputs("typedef unsigned long long uint64_t;\n" as *byte, codegen.output as *void);
        fputs("\n" as *byte, codegen.output as *void);
        // size_t 和 ptrdiff_t
        fputs("// size_t 和 ptrdiff_t\n" as *byte, codegen.output as *void);
        fputs("typedef unsigned long size_t;\n" as *byte, codegen.output as *void);
        fputs("typedef long ptrdiff_t;\n" as *byte, codegen.output as *void);
        fputs("\n" as *byte, codegen.output as *void);
        // bool 类型
        fputs("// bool 类型\n" as *byte, codegen.output as *void);
        fputs("typedef uint8_t bool;\n" as *byte, codegen.output as *void);
        fputs("#define true ((bool)1)\n" as *byte, codegen.output as *void);
        fputs("#define false ((bool)0)\n" as *byte, codegen.output as *void);
        fputs("\n" as *byte, codegen.output as *void);
        // NULL 定义
        fputs("// NULL 定义\n" as *byte, codegen.output as *void);
        fputs("#define NULL ((void*)0)\n" as *byte, codegen.output as *void);
        fputs("\n" as *byte, codegen.output as *void);
        // offsetof 宏（用于 alignof）
        fputs("// offsetof 宏（C99 兼容）\n" as *byte, codegen.output as *void);
        fputs("#define offsetof(type, member) ((size_t) &((type *)0)->member)\n" as *byte, codegen.output as *void);
        fputs("\n" as *byte, codegen.output as *void);
        // C99 兼容的 alignof 宏（使用 offsetof 技巧）
        fputs("// C99 兼容的 alignof 实现\n" as *byte, codegen.output as *void);
        fputs("#define uya_alignof(type) offsetof(struct { char c; type t; }, t)\n" as *byte, codegen.output as *void);
        fputs("\n" as *byte, codegen.output as *void);
        // va_list 相关（简化定义，仅用于函数签名）
        fputs("// va_list 简化定义（仅用于函数签名）\n" as *byte, codegen.output as *void);
        fputs("typedef char* va_list;\n" as *byte, codegen.output as *void);
        fputs("\n" as *byte, codegen.output as *void);
        // 注意：标准库模式不使用 __uya_memcpy/__uya_memcmp，因为标准库自己实现了 memcpy/memcmp
    } else {
        // 普通模式：使用标准库头文件
        // 先检查是否定义了与标准库冲突的函数
        var check_i: i32 = 0;
        const check_decl_count: i32 = ast.program_decl_count;
        while check_i < check_decl_count {
            const check_decl: &ASTNode = ast.program_decls[check_i];
            if check_decl != null && check_decl.type == ASTNodeType.AST_FN_DECL {
                const fn_name: &byte = check_decl.fn_decl_name;
                if fn_name != null && (
                    strcmp(fn_name as *byte, ("fopen" as *byte) as &byte) == 0 ||
                    strcmp(fn_name as *byte, ("fclose" as *byte) as &byte) == 0 ||
                    strcmp(fn_name as *byte, ("fread" as *byte) as &byte) == 0 ||
                    strcmp(fn_name as *byte, ("fgetc" as *byte) as &byte) == 0 ||
                    strcmp(fn_name as *byte, ("fprintf" as *byte) as &byte) == 0) {
                    codegen.has_stdio_conflicts = 1;
                    break;
                }
            }
            check_i = check_i + 1;
        }
        
        fputs("#include <stdint.h>\n" as *byte, codegen.output as *void);
        fputs("#include <stdbool.h>\n" as *byte, codegen.output as *void);
        fputs("#include <stddef.h>\n" as *byte, codegen.output as *void);
        fputs("#include <stdarg.h>\n" as *byte, codegen.output as *void);  // for va_list (variadic forward)
        // 只有在没有定义冲突函数时才包含 <stdio.h>
        if codegen.has_stdio_conflicts == 0 {
            fputs("#include <stdio.h>\n" as *byte, codegen.output as *void);  // for standard I/O functions (printf, puts, etc.)
        }
        // 如果使用了 memcpy 或 memset，添加 <string.h>
        if codegen.needs_string_h != 0 {
            fputs("#include <string.h>\n" as *byte, codegen.output as *void);
        }
        fputs("\n" as *byte, codegen.output as *void);
        // C99 兼容的 alignof 宏（使用 offsetof 技巧）
        fputs("// C99 兼容的 alignof 实现\n" as *byte, codegen.output as *void);
        fputs("#define uya_alignof(type) offsetof(struct { char c; type t; }, t)\n" as *byte, codegen.output as *void);
        fputs("\n" as *byte, codegen.output as *void);
        // 内置 memcpy/memcmp 实现（避免与用户定义的 memcpy/memcmp 冲突）
        fputs("static inline void *__uya_memcpy(void *dest, const void *src, size_t n) {\n" as *byte, codegen.output as *void);
        fputs("    char *d = (char *)dest; const char *s = (const char *)src;\n" as *byte, codegen.output as *void);
        fputs("    for (size_t i = 0; i < n; i++) d[i] = s[i]; return dest;\n" as *byte, codegen.output as *void);
        fputs("}\n" as *byte, codegen.output as *void);
        fputs("static inline int __uya_memcmp(const void *s1, const void *s2, size_t n) {\n" as *byte, codegen.output as *void);
        fputs("    const unsigned char *a = (const unsigned char *)s1, *b = (const unsigned char *)s2;\n" as *byte, codegen.output as *void);
        fputs("    for (size_t i = 0; i < n; i++) { if (a[i] != b[i]) return a[i] - b[i]; } return 0;\n" as *byte, codegen.output as *void);
        fputs("}\n\n" as *byte, codegen.output as *void);
    }
    
    // 生成错误联合类型结构体（用于 @syscall 和其他错误联合类型）
    fputs("// 错误联合类型（用于 !i64 等）\n" as *byte, codegen.output as *void);
    fputs("struct err_union_int64_t { uint32_t error_id; int64_t value; };\n" as *byte, codegen.output as *void);
    mark_struct_defined(codegen, ("err_union_int64_t" as *byte) as &byte);
    fputs("\n" as *byte, codegen.output as *void);
    
    // 第一步：收集所有字符串常量（从全局变量初始化和函数体）
    const decl_count: i32 = ast.program_decl_count;
    
    var i: i32 = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null {
            // 跳过 use 语句（模块导入，不需要生成代码）
            if decl.type == ASTNodeType.AST_USE_STMT {
                i = i + 1;
                continue;
            }
            // 跳过宏声明（宏在 checker 阶段已展开，不需要生成代码）
            if decl.type == ASTNodeType.AST_MACRO_DECL {
                i = i + 1;
                continue;
            }
            collect_string_constants_from_decl(codegen, decl);
        }
        i = i + 1;
    }
    
    // 第二步：输出字符串常量定义（在所有其他代码之前）
    emit_string_constants(codegen);
    fputs("\n" as *byte, codegen.output as *void);
    
    // 第三步：注册所有错误声明（用于 return error.X 等）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_ERROR_DECL {
            if decl.error_decl_name != null {
                c99_get_or_add_error_id(codegen, decl.error_decl_name);
            }
        }
        i = i + 1;
    }
    
    // 第四步：收集所有结构体和枚举定义（添加到表中但不生成代码）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null {
            if decl.type == ASTNodeType.AST_STRUCT_DECL {
                // 泛型结构体：注册原始名（但也为单态化实例预注册）
                if is_generic_struct_c99(decl) != 0 {
                    // 为单态化实例注册名称
                    var j: i32 = 0;
                    while j < codegen.mono_instance_count {
                        if codegen.mono_instances[j].generic_name != null &&
                            strcmp(codegen.mono_instances[j].generic_name as *byte, decl.struct_decl_name as *byte) == 0 &&
                            codegen.mono_instances[j].is_function == 0 {
                            // 跳过包含未解析类型参数的实例
                            if has_unresolved_mono_type_args(decl,
                                codegen.mono_instances[j].type_args,
                                codegen.mono_instances[j].type_arg_count) == 0 {
                                const mono_name: &byte = get_mono_struct_name(codegen, decl.struct_decl_name,
                                    codegen.mono_instances[j].type_args,
                                    codegen.mono_instances[j].type_arg_count);
                                if is_struct_in_table(codegen, mono_name) == 0 {
                                    add_struct_definition(codegen, mono_name);
                                }
                            }
                        }
                        j = j + 1;
                    }
                } else {
                    const struct_name: &byte = get_safe_c_identifier(codegen, decl.struct_decl_name);
                    if is_struct_in_table(codegen, struct_name) == 0 {
                        add_struct_definition(codegen, struct_name);
                    }
                }
            } else if decl.type == ASTNodeType.AST_ENUM_DECL {
                const enum_name: &byte = get_safe_c_identifier(codegen, decl.enum_decl_name);
                if is_enum_in_table(codegen, enum_name) == 0 {
                    add_enum_definition(codegen, enum_name);
                }
            }
        }
        i = i + 1;
    }
    
    // 第五步：生成所有结构体的前向声明（解决相互依赖）
    // 首先添加内置 TypeInfo 的前向声明（用于 @mc_type）
    fputs("struct TypeInfo;\n" as *byte, codegen.output as *void);
    i = 0;
    while i < codegen.struct_definition_count {
        if is_struct_defined(codegen, codegen.struct_definitions[i].name) == 0 {
            fprintf(codegen.output as *void, "struct %s;\n" as *byte, codegen.struct_definitions[i].name as *byte);
        }
        i = i + 1;
    }
    if codegen.struct_definition_count > 0 {
        fputs("\n" as *byte, codegen.output as *void);
    }
    
    // 第五步：生成所有枚举定义（在结构体之前，因为结构体可能使用枚举类型）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null {
            // 跳过 use 语句（模块导入，不需要生成代码）
            if decl.type == ASTNodeType.AST_USE_STMT {
                i = i + 1;
                continue;
            }
            // 跳过宏声明（宏在 checker 阶段已展开，不需要生成代码）
            if decl.type == ASTNodeType.AST_MACRO_DECL {
                i = i + 1;
                continue;
            }
            if decl.type == ASTNodeType.AST_ENUM_DECL {
                gen_enum_definition(codegen, decl);
                fputs("\n" as *byte, codegen.output as *void);
            }
        }
        i = i + 1;
    }
    
    // 第五步 b：生成类型别名（typedef）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_TYPE_ALIAS && 
            decl.type_alias_name != null && decl.type_alias_target_type != null {
            const alias_name: &byte = get_safe_c_identifier(codegen, decl.type_alias_name);
            const target_type: &ASTNode = decl.type_alias_target_type;
            
            // 数组类型需要特殊处理：typedef int32_t IntArray[4]; 而不是 typedef int32_t[4] IntArray;
            if target_type.type == ASTNodeType.AST_TYPE_ARRAY {
                // 收集所有数组维度
                var dims: [i32: 16] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                var dim_count: i32 = 0;
                var current: &ASTNode = target_type;
                while current != null && current.type == ASTNodeType.AST_TYPE_ARRAY && dim_count < 16 {
                    var size: i32 = 1;
                    if current.type_array_size_expr != null {
                        size = eval_const_expr(codegen, current.type_array_size_expr);
                        if size <= 0 {
                            size = 1;
                        }
                    }
                    dims[dim_count] = size;
                    dim_count = dim_count + 1;
                    current = current.type_array_element_type;
                }
                // current 现在是基础元素类型
                const base_type_c: &byte = c99_type_to_c(codegen, current);
                fprintf(codegen.output as *void, "typedef %s %s" as *byte, base_type_c as *byte, alias_name as *byte);
                var d: i32 = 0;
                while d < dim_count {
                    fprintf(codegen.output as *void, "[%d]" as *byte, dims[d]);
                    d = d + 1;
                }
                fputs(";\n" as *byte, codegen.output as *void);
            } else {
                const target_type_c: &byte = c99_type_to_c(codegen, target_type);
                fprintf(codegen.output as *void, "typedef %s %s;\n" as *byte, target_type_c as *byte, alias_name as *byte);
            }
        }
        i = i + 1;
    }
    fputs("\n" as *byte, codegen.output as *void);
    
    // 第六步 a：收集所有使用的切片类型（含结构体字段中的 &[T]）
    i = 0;
    while i < decl_count {
        collect_slice_types_from_node(codegen, ast.program_decls[i]);
        i = i + 1;
    }
    // 第六步 b：生成切片结构体（&[T] -> struct uya_slice_X），必须在用户结构体之前
    emit_pending_slice_structs(codegen);
    if codegen.slice_struct_count > 0 {
        fputs("\n" as *byte, codegen.output as *void);
    }
    // 第六步 b2：生成接口结构体与 vtable 结构体（vtable 常量在方法前向声明之后生成）
    emit_interface_structs_and_vtables(codegen);
    fputs("\n" as *byte, codegen.output as *void);
    // 第六步 c：生成联合体定义（在结构体之前，因结构体可能含联合体）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_UNION_DECL {
            gen_union_definition(codegen, decl);
            fputs("\n" as *byte, codegen.output as *void);
        }
        i = i + 1;
    }
    // 第六步 d1：自动生成内置 TypeInfo 结构体（如果用户没有定义且代码中使用了 @mc_type）
    {
        var user_defined_typeinfo: i32 = 0;
        i = 0;
        while i < decl_count {
            const d: &ASTNode = ast.program_decls[i];
            if d != null && d.type == ASTNodeType.AST_STRUCT_DECL && d.struct_decl_name != null &&
                strcmp(d.struct_decl_name as *byte, "TypeInfo" as *byte) == 0 {
                user_defined_typeinfo = 1;
            }
            i = i + 1;
        }
        if user_defined_typeinfo == 0 && is_struct_defined(codegen, ("TypeInfo" as *byte) as &byte) == 0 {
            // 生成内置 TypeInfo 结构体
            fputs("// 内置 TypeInfo 结构体（由 @mc_type 使用）\n" as *byte, codegen.output as *void);
            fputs("struct TypeInfo {\n" as *byte, codegen.output as *void);
            fputs("    int8_t * name;\n" as *byte, codegen.output as *void);
            fputs("    int32_t size;\n" as *byte, codegen.output as *void);
            fputs("    int32_t align;\n" as *byte, codegen.output as *void);
            fputs("    int32_t kind;\n" as *byte, codegen.output as *void);
            fputs("    bool is_integer;\n" as *byte, codegen.output as *void);
            fputs("    bool is_float;\n" as *byte, codegen.output as *void);
            fputs("    bool is_bool;\n" as *byte, codegen.output as *void);
            fputs("    bool is_pointer;\n" as *byte, codegen.output as *void);
            fputs("    bool is_array;\n" as *byte, codegen.output as *void);
            fputs("    bool is_void;\n" as *byte, codegen.output as *void);
            fputs("};\n\n" as *byte, codegen.output as *void);
            mark_struct_defined(codegen, ("TypeInfo" as *byte) as &byte);
        }
    }
    // 第六步 d2：生成所有结构体定义（在切片结构体之后，因为结构体可能含切片字段）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_STRUCT_DECL {
            // 跳过泛型结构体模板，为单态化实例生成定义
            if is_generic_struct_c99(decl) != 0 {
                const sname: &byte = decl.struct_decl_name;
                var j: i32 = 0;
                while j < codegen.mono_instance_count {
                    if codegen.mono_instances[j].generic_name != null &&
                        strcmp(codegen.mono_instances[j].generic_name as *byte, sname as *byte) == 0 &&
                        codegen.mono_instances[j].is_function == 0 {
                        // 跳过包含未解析类型参数的实例（如 Box<T>）
                        if has_unresolved_mono_type_args(decl,
                            codegen.mono_instances[j].type_args,
                            codegen.mono_instances[j].type_arg_count) == 0 {
                            gen_mono_struct_definition(codegen, decl,
                                codegen.mono_instances[j].type_args,
                                codegen.mono_instances[j].type_arg_count);
                            fputs("\n" as *byte, codegen.output as *void);
                        }
                    }
                    j = j + 1;
                }
            } else {
                gen_struct_definition(codegen, decl);
                fputs("\n" as *byte, codegen.output as *void);
            }
        }
        i = i + 1;
    }
    
    // 第七步 c：收集所有测试语句
    // 使用 Arena 分配数组（固定大小数组不能作为可变参数传递）
    const tests_array: & & ASTNode = arena_alloc(codegen.arena, @size_of(&ASTNode) * MAX_TESTS) as & & ASTNode;
    if tests_array == null {
        return -1;
    }
    var test_count: i32 = 0;
    
    // 从程序顶层声明中收集测试语句
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl == null {
            i = i + 1;
            continue;
        }
        if decl.type == ASTNodeType.AST_USE_STMT {
            i = i + 1;
            continue;
        }
        // 跳过宏声明（宏在 checker 阶段已展开，不需要生成代码）
        if decl.type == ASTNodeType.AST_MACRO_DECL {
            i = i + 1;
            continue;
        }
        
        // 顶层测试语句
        if decl.type == ASTNodeType.AST_TEST_STMT {
            if test_count < MAX_TESTS {
                tests_array[test_count] = decl;
                test_count = test_count + 1;
            }
        }
        
        // 从函数体内收集测试（包括嵌套块中的测试）
        if decl.type == ASTNodeType.AST_FN_DECL && decl.fn_decl_body != null {
            collect_tests_from_node(codegen, decl.fn_decl_body, tests_array, &test_count);
        }
        i = i + 1;
    }
    
    // 将测试计数保存到 codegen 中，以便 gen_function 可以判断是否需要调用 uya_run_tests()
    codegen.test_count = test_count;
    
    // 第七步 d：生成系统调用辅助函数（@syscall 内置函数支持）
    fputs("// 系统调用辅助函数（Linux x86-64）\n" as *byte, codegen.output as *void);
    fputs("#ifdef __x86_64__\n" as *byte, codegen.output as *void);
    
    // uya_syscall0 - 无参数
    fputs("static inline long uya_syscall0(long nr) {\n" as *byte, codegen.output as *void);
    fputs("    register long rax __asm__(\"rax\") = nr;\n" as *byte, codegen.output as *void);
    fputs("    __asm__ volatile(\"syscall\" : \"=r\"(rax) : \"r\"(rax) : \"rcx\", \"r11\", \"memory\");\n" as *byte, codegen.output as *void);
    fputs("    return rax;\n" as *byte, codegen.output as *void);
    fputs("}\n\n" as *byte, codegen.output as *void);
    
    // uya_syscall1 - 1 个参数
    fputs("static inline long uya_syscall1(long nr, long a1) {\n" as *byte, codegen.output as *void);
    fputs("    register long rax __asm__(\"rax\") = nr;\n" as *byte, codegen.output as *void);
    fputs("    register long rdi __asm__(\"rdi\") = a1;\n" as *byte, codegen.output as *void);
    fputs("    __asm__ volatile(\"syscall\" : \"=r\"(rax) : \"r\"(rax), \"r\"(rdi) : \"rcx\", \"r11\", \"memory\");\n" as *byte, codegen.output as *void);
    fputs("    return rax;\n" as *byte, codegen.output as *void);
    fputs("}\n\n" as *byte, codegen.output as *void);
    
    // uya_syscall2 - 2 个参数
    fputs("static inline long uya_syscall2(long nr, long a1, long a2) {\n" as *byte, codegen.output as *void);
    fputs("    register long rax __asm__(\"rax\") = nr;\n" as *byte, codegen.output as *void);
    fputs("    register long rdi __asm__(\"rdi\") = a1;\n" as *byte, codegen.output as *void);
    fputs("    register long rsi __asm__(\"rsi\") = a2;\n" as *byte, codegen.output as *void);
    fputs("    __asm__ volatile(\"syscall\" : \"=r\"(rax) : \"r\"(rax), \"r\"(rdi), \"r\"(rsi) : \"rcx\", \"r11\", \"memory\");\n" as *byte, codegen.output as *void);
    fputs("    return rax;\n" as *byte, codegen.output as *void);
    fputs("}\n\n" as *byte, codegen.output as *void);
    
    // uya_syscall3 - 3 个参数
    fputs("static inline long uya_syscall3(long nr, long a1, long a2, long a3) {\n" as *byte, codegen.output as *void);
    fputs("    register long rax __asm__(\"rax\") = nr;\n" as *byte, codegen.output as *void);
    fputs("    register long rdi __asm__(\"rdi\") = a1;\n" as *byte, codegen.output as *void);
    fputs("    register long rsi __asm__(\"rsi\") = a2;\n" as *byte, codegen.output as *void);
    fputs("    register long rdx __asm__(\"rdx\") = a3;\n" as *byte, codegen.output as *void);
    fputs("    __asm__ volatile(\"syscall\" : \"=r\"(rax) : \"r\"(rax), \"r\"(rdi), \"r\"(rsi), \"r\"(rdx) : \"rcx\", \"r11\", \"memory\");\n" as *byte, codegen.output as *void);
    fputs("    return rax;\n" as *byte, codegen.output as *void);
    fputs("}\n\n" as *byte, codegen.output as *void);
    
    // uya_syscall4 - 4 个参数
    fputs("static inline long uya_syscall4(long nr, long a1, long a2, long a3, long a4) {\n" as *byte, codegen.output as *void);
    fputs("    register long rax __asm__(\"rax\") = nr;\n" as *byte, codegen.output as *void);
    fputs("    register long rdi __asm__(\"rdi\") = a1;\n" as *byte, codegen.output as *void);
    fputs("    register long rsi __asm__(\"rsi\") = a2;\n" as *byte, codegen.output as *void);
    fputs("    register long rdx __asm__(\"rdx\") = a3;\n" as *byte, codegen.output as *void);
    fputs("    register long r10 __asm__(\"r10\") = a4;\n" as *byte, codegen.output as *void);
    fputs("    __asm__ volatile(\"syscall\" : \"=r\"(rax) : \"r\"(rax), \"r\"(rdi), \"r\"(rsi), \"r\"(rdx), \"r\"(r10) : \"rcx\", \"r11\", \"memory\");\n" as *byte, codegen.output as *void);
    fputs("    return rax;\n" as *byte, codegen.output as *void);
    fputs("}\n\n" as *byte, codegen.output as *void);
    
    // uya_syscall5 - 5 个参数
    fputs("static inline long uya_syscall5(long nr, long a1, long a2, long a3, long a4, long a5) {\n" as *byte, codegen.output as *void);
    fputs("    register long rax __asm__(\"rax\") = nr;\n" as *byte, codegen.output as *void);
    fputs("    register long rdi __asm__(\"rdi\") = a1;\n" as *byte, codegen.output as *void);
    fputs("    register long rsi __asm__(\"rsi\") = a2;\n" as *byte, codegen.output as *void);
    fputs("    register long rdx __asm__(\"rdx\") = a3;\n" as *byte, codegen.output as *void);
    fputs("    register long r10 __asm__(\"r10\") = a4;\n" as *byte, codegen.output as *void);
    fputs("    register long r8 __asm__(\"r8\") = a5;\n" as *byte, codegen.output as *void);
    fputs("    __asm__ volatile(\"syscall\" : \"=r\"(rax) : \"r\"(rax), \"r\"(rdi), \"r\"(rsi), \"r\"(rdx), \"r\"(r10), \"r\"(r8) : \"rcx\", \"r11\", \"memory\");\n" as *byte, codegen.output as *void);
    fputs("    return rax;\n" as *byte, codegen.output as *void);
    fputs("}\n\n" as *byte, codegen.output as *void);
    
    // uya_syscall6 - 6 个参数
    fputs("static inline long uya_syscall6(long nr, long a1, long a2, long a3, long a4, long a5, long a6) {\n" as *byte, codegen.output as *void);
    fputs("    register long rax __asm__(\"rax\") = nr;\n" as *byte, codegen.output as *void);
    fputs("    register long rdi __asm__(\"rdi\") = a1;\n" as *byte, codegen.output as *void);
    fputs("    register long rsi __asm__(\"rsi\") = a2;\n" as *byte, codegen.output as *void);
    fputs("    register long rdx __asm__(\"rdx\") = a3;\n" as *byte, codegen.output as *void);
    fputs("    register long r10 __asm__(\"r10\") = a4;\n" as *byte, codegen.output as *void);
    fputs("    register long r8 __asm__(\"r8\") = a5;\n" as *byte, codegen.output as *void);
    fputs("    register long r9 __asm__(\"r9\") = a6;\n" as *byte, codegen.output as *void);
    fputs("    __asm__ volatile(\"syscall\" : \"=r\"(rax) : \"r\"(rax), \"r\"(rdi), \"r\"(rsi), \"r\"(rdx), \"r\"(r10), \"r\"(r8), \"r\"(r9) : \"rcx\", \"r11\", \"memory\");\n" as *byte, codegen.output as *void);
    fputs("    return rax;\n" as *byte, codegen.output as *void);
    fputs("}\n" as *byte, codegen.output as *void);
    
    fputs("#else\n" as *byte, codegen.output as *void);
    fputs("#error \"@syscall currently only supports Linux x86-64\"\n" as *byte, codegen.output as *void);
    fputs("#endif\n\n" as *byte, codegen.output as *void);
    
    // 第八步：生成所有函数的前向声明（解决相互递归调用）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_FN_DECL {
            // 跳过泛型函数模板，为单态化实例生成原型
            if is_generic_function_c99(decl) != 0 {
                const fn_name: &byte = decl.fn_decl_name;
                var j: i32 = 0;
                while j < codegen.mono_instance_count {
                    if codegen.mono_instances[j].generic_name != null &&
                        strcmp(codegen.mono_instances[j].generic_name as *byte, fn_name as *byte) == 0 &&
                        codegen.mono_instances[j].is_function != 0 {
                        gen_mono_function_prototype(codegen, decl,
                            codegen.mono_instances[j].type_args,
                            codegen.mono_instances[j].type_arg_count);
                    }
                    j = j + 1;
                }
            } else {
                gen_function_prototype(codegen, decl);
            }
        } else if decl != null && decl.type == ASTNodeType.AST_METHOD_BLOCK {
            var type_name: &byte = null;
            if decl.method_block_struct_name != null {
                type_name = decl.method_block_struct_name;
            } else {
                type_name = decl.method_block_union_name;
            }
            if type_name != null {
                var j: i32 = 0;
                while j < decl.method_block_method_count {
                    const m: &ASTNode = decl.method_block_methods[j];
                    if m != null && m.type == ASTNodeType.AST_FN_DECL {
                        gen_method_prototype(codegen, m, type_name);
                    }
                    j = j + 1;
                }
            }
        } else if decl != null && decl.type == ASTNodeType.AST_STRUCT_DECL {
            // 生成结构体内部定义的方法的前向声明
            const struct_name: &byte = decl.struct_decl_name;
            // 跳过泛型结构体模板的内部方法，为单态化实例生成方法原型
            if is_generic_struct_c99(decl) != 0 {
                var k: i32 = 0;
                while k < codegen.mono_instance_count {
                    if codegen.mono_instances[k].generic_name != null &&
                        strcmp(codegen.mono_instances[k].generic_name as *byte, struct_name as *byte) == 0 &&
                        codegen.mono_instances[k].is_function == 0 {
                        // 跳过包含未解析类型参数的实例
                        if has_unresolved_mono_type_args(decl,
                            codegen.mono_instances[k].type_args,
                            codegen.mono_instances[k].type_arg_count) == 0 {
                            // 为该单态化实例生成方法原型
                            const mono_name: &byte = get_mono_struct_name(codegen, struct_name,
                                codegen.mono_instances[k].type_args,
                                codegen.mono_instances[k].type_arg_count);
                            // 设置单态化上下文
                            const saved_tp: &TypeParam = codegen.current_type_params;
                            const saved_tpc: i32 = codegen.current_type_param_count;
                            const saved_ta: & & ASTNode = codegen.current_type_args;
                            const saved_tac: i32 = codegen.current_type_arg_count;
                            codegen.current_type_params = decl.struct_decl_type_params;
                            codegen.current_type_param_count = decl.struct_decl_type_param_count;
                            codegen.current_type_args = codegen.mono_instances[k].type_args;
                            codegen.current_type_arg_count = codegen.mono_instances[k].type_arg_count;
                            
                            var j: i32 = 0;
                            while j < decl.struct_decl_method_count {
                                const m: &ASTNode = decl.struct_decl_methods[j];
                                if m != null && m.type == ASTNodeType.AST_FN_DECL {
                                    gen_method_prototype(codegen, m, mono_name);
                                }
                                j = j + 1;
                            }
                            
                            // 恢复上下文
                            codegen.current_type_params = saved_tp;
                            codegen.current_type_param_count = saved_tpc;
                            codegen.current_type_args = saved_ta;
                            codegen.current_type_arg_count = saved_tac;
                        }
                    }
                    k = k + 1;
                }
            } else {
                var j: i32 = 0;
                while j < decl.struct_decl_method_count {
                    const m: &ASTNode = decl.struct_decl_methods[j];
                    if m != null && m.type == ASTNodeType.AST_FN_DECL {
                        gen_method_prototype(codegen, m, struct_name);
                    }
                    j = j + 1;
                }
            }
        } else if decl != null && decl.type == ASTNodeType.AST_UNION_DECL {
            // 生成联合体内部方法的前向声明
            const union_name: &byte = decl.union_decl_name;
            var j: i32 = 0;
            while j < decl.union_decl_method_count {
                const m: &ASTNode = decl.union_decl_methods[j];
                if m != null && m.type == ASTNodeType.AST_FN_DECL {
                    gen_method_prototype(codegen, m, union_name);
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }
    
    // 第八步 b：生成 vtable 常量（依赖方法前向声明）
    emit_vtable_constants(codegen);
    fputs("\n" as *byte, codegen.output as *void);
    
    // 第八步 c：生成测试函数前向声明
    if test_count > 0 {
        i = 0;
        while i < test_count {
            const test_node: &ASTNode = tests_array[i];
            if test_node != null && test_node.type == ASTNodeType.AST_TEST_STMT {
                const func_name: &byte = get_test_function_name(codegen, test_node.test_stmt_description);
                if func_name != null {
                    fprintf(codegen.output as *void, "static void %s(void);\n" as *byte, func_name as *byte);
                }
            }
            i = i + 1;
        }
        fputs("static void uya_run_tests(void);\n" as *byte, codegen.output as *void);
        fputs("\n" as *byte, codegen.output as *void);
    }
    
    // 第九步 a：先生成所有常量（确保在函数之前定义）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null {
            // 跳过 use 语句（模块导入，不需要生成代码）
            if decl.type == ASTNodeType.AST_USE_STMT {
                i = i + 1;
                continue;
            }
            // 跳过宏声明（宏在 checker 阶段已展开，不需要生成代码）
            if decl.type == ASTNodeType.AST_MACRO_DECL {
                i = i + 1;
                continue;
            }
            // 只生成常量（const 变量）
            if decl.type == ASTNodeType.AST_VAR_DECL && decl.var_decl_is_const != 0 {
                gen_global_var(codegen, decl);
                fputs("\n" as *byte, codegen.output as *void);
            }
        }
        i = i + 1;
    }
    
    // 第九步 b：生成所有声明（非常量全局变量、函数定义）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null {
            // 跳过 use 语句（模块导入，不需要生成代码）
            if decl.type == ASTNodeType.AST_USE_STMT {
                i = i + 1;
                continue;
            }
            // 跳过宏声明（宏在 checker 阶段已展开，不需要生成代码）
            if decl.type == ASTNodeType.AST_MACRO_DECL {
                i = i + 1;
                continue;
            }
            if decl.type == ASTNodeType.AST_STRUCT_DECL {
                // 生成结构体内部定义的方法
                const struct_name: &byte = decl.struct_decl_name;
                // 跳过泛型结构体模板的内部方法，为单态化实例生成方法定义
                if is_generic_struct_c99(decl) != 0 {
                    var k: i32 = 0;
                    while k < codegen.mono_instance_count {
                        if codegen.mono_instances[k].generic_name != null &&
                            strcmp(codegen.mono_instances[k].generic_name as *byte, struct_name as *byte) == 0 &&
                            codegen.mono_instances[k].is_function == 0 {
                            // 跳过包含未解析类型参数的实例
                            if has_unresolved_mono_type_args(decl,
                                codegen.mono_instances[k].type_args,
                                codegen.mono_instances[k].type_arg_count) == 0 {
                                // 为该单态化实例生成方法定义
                                const mono_name: &byte = get_mono_struct_name(codegen, struct_name,
                                    codegen.mono_instances[k].type_args,
                                    codegen.mono_instances[k].type_arg_count);
                                // 设置单态化上下文
                                const saved_tp: &TypeParam = codegen.current_type_params;
                                const saved_tpc: i32 = codegen.current_type_param_count;
                                const saved_ta: & & ASTNode = codegen.current_type_args;
                                const saved_tac: i32 = codegen.current_type_arg_count;
                                codegen.current_type_params = decl.struct_decl_type_params;
                                codegen.current_type_param_count = decl.struct_decl_type_param_count;
                                codegen.current_type_args = codegen.mono_instances[k].type_args;
                                codegen.current_type_arg_count = codegen.mono_instances[k].type_arg_count;
                                
                                var j: i32 = 0;
                                while j < decl.struct_decl_method_count {
                                    const m: &ASTNode = decl.struct_decl_methods[j];
                                    if m != null && m.type == ASTNodeType.AST_FN_DECL && m.fn_decl_body != null {
                                        gen_method_function(codegen, m, mono_name);
                                        fputs("\n" as *byte, codegen.output as *void);
                                    }
                                    j = j + 1;
                                }
                                
                                // 恢复上下文
                                codegen.current_type_params = saved_tp;
                                codegen.current_type_param_count = saved_tpc;
                                codegen.current_type_args = saved_ta;
                                codegen.current_type_arg_count = saved_tac;
                            }
                        }
                        k = k + 1;
                    }
                } else {
                    var j: i32 = 0;
                    while j < decl.struct_decl_method_count {
                        const m: &ASTNode = decl.struct_decl_methods[j];
                        if m != null && m.type == ASTNodeType.AST_FN_DECL && m.fn_decl_body != null {
                            gen_method_function(codegen, m, struct_name);
                            fputs("\n" as *byte, codegen.output as *void);
                        }
                        j = j + 1;
                    }
                }
            } else if decl.type == ASTNodeType.AST_UNION_DECL {
                // 生成联合体内部方法定义
                const union_name: &byte = decl.union_decl_name;
                var j: i32 = 0;
                while j < decl.union_decl_method_count {
                    const m: &ASTNode = decl.union_decl_methods[j];
                    if m != null && m.type == ASTNodeType.AST_FN_DECL && m.fn_decl_body != null {
                        gen_method_function(codegen, m, union_name);
                        fputs("\n" as *byte, codegen.output as *void);
                    }
                    j = j + 1;
                }
            } else if decl.type == ASTNodeType.AST_ENUM_DECL {
                // 已在前面生成
            } else if decl.type == ASTNodeType.AST_VAR_DECL {
                // 常量已在第九步 a 生成，这里只生成非常量变量
                if decl.var_decl_is_const == 0 {
                    gen_global_var(codegen, decl);
                    fputs("\n" as *byte, codegen.output as *void);
                }
            } else if decl.type == ASTNodeType.AST_FN_DECL {
                // 特殊处理：main 函数在后面生成（需要添加测试运行器调用）
                const func_name: &byte = decl.fn_decl_name;
                var is_main: i32 = 0;
                if func_name != null && strcmp(func_name as *byte, "main" as *byte) == 0 {
                    is_main = 1;
                }
                if is_main == 0 {
                    // 跳过泛型函数模板，为单态化实例生成定义
                    if is_generic_function_c99(decl) != 0 {
                        var j: i32 = 0;
                        while j < codegen.mono_instance_count {
                            if codegen.mono_instances[j].generic_name != null &&
                                strcmp(codegen.mono_instances[j].generic_name as *byte, func_name as *byte) == 0 &&
                                codegen.mono_instances[j].is_function != 0 {
                                gen_mono_function(codegen, decl,
                                    codegen.mono_instances[j].type_args,
                                    codegen.mono_instances[j].type_arg_count);
                                fputs("\n" as *byte, codegen.output as *void);
                            }
                            j = j + 1;
                        }
                    } else {
                        // 只生成有函数体的定义（外部函数由前向声明处理）
                        gen_function(codegen, decl);
                        fputs("\n" as *byte, codegen.output as *void);
                    }
                }
            } else if decl.type == ASTNodeType.AST_METHOD_BLOCK {
                var type_name: &byte = null;
                if decl.method_block_struct_name != null {
                    type_name = decl.method_block_struct_name;
                } else {
                    type_name = decl.method_block_union_name;
                }
                if type_name != null {
                    var j: i32 = 0;
                    while j < decl.method_block_method_count {
                        const m: &ASTNode = decl.method_block_methods[j];
                        if m != null && m.type == ASTNodeType.AST_FN_DECL && m.fn_decl_body != null {
                            gen_method_function(codegen, m, type_name);
                            fputs("\n" as *byte, codegen.output as *void);
                        }
                        j = j + 1;
                    }
                }
            } else {
                // 忽略其他声明类型（暂时）
            }
        }
        i = i + 1;
    }
    
    // 第十步：生成测试函数和运行器
    if test_count > 0 {
        i = 0;
        while i < test_count {
            gen_test_function(codegen, tests_array[i]);
            fputs("\n" as *byte, codegen.output as *void);
            i = i + 1;
        }
        gen_test_runner(codegen, tests_array, test_count);
        fputs("\n" as *byte, codegen.output as *void);
    }
    
    // 第十一步：生成 main 函数（uya_main）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_FN_DECL {
            const func_name: &byte = decl.fn_decl_name;
            if func_name != null && strcmp(func_name as *byte, "main" as *byte) == 0 && decl.fn_decl_body != null {
                // 生成 main 函数（重命名为 uya_main）
                emit_line_directive(codegen, decl.line, decl.filename);
                const return_c: &byte = convert_array_return_type(codegen, decl.fn_decl_return_type);
                fprintf(codegen.output as *void, "%s uya_main(void) {\n" as *byte, return_c as *byte);
                
                // 保存并设置当前函数的返回类型
                const saved_return_type: &ASTNode = codegen.current_function_return_type;
                codegen.current_function_return_type = decl.fn_decl_return_type;
                
                // 如果有测试，在函数体开始处调用测试运行器
                if test_count > 0 {
                    fputs("    uya_run_tests();\n" as *byte, codegen.output as *void);
                }
                
                // 生成原始函数体
                const body: &ASTNode = decl.fn_decl_body;
                if body != null && body.type == ASTNodeType.AST_BLOCK {
                    const stmts: & & ASTNode = body.block_stmts;
                    const stmt_count: i32 = body.block_stmt_count;
                    var j: i32 = 0;
                    while j < stmt_count {
                        gen_stmt(codegen, stmts[j]);
                        j = j + 1;
                    }
                }
                
                // 恢复之前的返回类型
                codegen.current_function_return_type = saved_return_type;
                
                fputs("}\n" as *byte, codegen.output as *void);
                break;
            }
        }
        i = i + 1;
    }
    
    return 0;
}

