// parser.uya - 语法分析器
// 从 compiler-c/src/parser.c 重新覆盖式翻译
//
// 注意：Uya 没有 union，所有 union 字段都转换为结构体的独立字段
// 注意：Uya 不支持指针运算，ptr + i 必须转换为 &ptr[i]
// 注意：Uya 不支持函数前向声明，函数必须在使用前定义

// Lexer 函数前向声明（确保生成的 C 中在 parser_init 之前有声明，避免隐式声明）
extern fn lexer_next_token(lexer: &Lexer, arena: &Arena) &Token;
extern fn lexer_init(lexer: &Lexer, source: &byte, source_len: usize, filename: &byte, arena: &Arena) i32;
// 标准库函数（用于错误报告）
extern fn get_stderr() *void;
extern fn fprintf(stream: *void, format: *byte, ...) i32;

// 解析上下文类型
enum ParserContext {
    PARSER_CONTEXT_NORMAL,          // 普通表达式上下文
    PARSER_CONTEXT_VAR_INIT,        // 变量初始化上下文（var/const 声明中的 = 后面的表达式）
    PARSER_CONTEXT_CONDITION        // 条件表达式上下文（if/while 后面的表达式）
}

// 语法分析器结构体
// 使用 Lexer 读取 Token，构建 AST
struct Parser {
    lexer: &Lexer,           // 词法分析器指针（由调用者提供，不分配）
    current_token: &Token,    // 当前 Token（从 Arena 分配）
    arena: &Arena,            // Arena 分配器（用于分配 Token 和 AST 节点）
    context: ParserContext,  // 当前解析上下文
    pending_greater_token: &Token,  // 待处理的 > token（用于嵌套泛型 >> 拆分）
}

// 初始化 Parser
// 参数：parser - Parser 结构体指针（由调用者提供），lexer - Lexer 指针，arena - Arena 分配器
// 返回：成功返回 0，失败返回 -1
// 注意：Parser 结构体由调用者在栈上或静态分配，此函数只负责初始化
fn parser_init(parser: &Parser, lexer: &Lexer, arena: &Arena) i32 {
    if parser == null || lexer == null || arena == null {
        return -1;
    }
    
    parser.lexer = lexer;
    parser.arena = arena;
    parser.context = ParserContext.PARSER_CONTEXT_NORMAL;  // 默认上下文
    parser.pending_greater_token = null;  // 初始化待处理的 > token
    
    // 获取第一个 Token
    parser.current_token = lexer_next_token(lexer, arena);
    
    return 0;
}

// 辅助函数：检查当前 Token 类型是否匹配
fn parser_match(parser: &Parser, type: TokenType) i32 {
    if parser == null {
        return 0;
    }
    // 如果有待处理的 > token，优先检查它
    if parser.pending_greater_token != null {
        if parser.pending_greater_token.type == type {
            return 1;
        } else {
            return 0;
        }
    }
    if parser.current_token == null {
        return 0;
    }
    if parser.current_token.type == type {
        return 1;
    } else {
        return 0;
    }
}

// 辅助函数：消费当前 Token 并获取下一个
fn parser_consume(parser: &Parser) &Token {
    if parser == null {
        return null;
    }
    
    // 检查是否有待处理的 > token（用于嵌套泛型 >> 拆分）
    if parser.pending_greater_token != null {
        const pending: &Token = parser.pending_greater_token;
        parser.pending_greater_token = null;
        return pending;
    }
    
    if parser.current_token == null {
        return null;
    }
    
    const current: &Token = parser.current_token;
    parser.current_token = lexer_next_token(parser.lexer, parser.arena);
    return current;
}

// 辅助函数：期望特定类型的 Token
fn parser_expect(parser: &Parser, type: TokenType) &Token {
    if parser == null {
        return null;
    }
    
    // 如果有待处理的 > token，优先检查它
    if parser.pending_greater_token != null {
        if parser.pending_greater_token.type != type {
            return null;
        }
        return parser_consume(parser);
    }
    
    if parser.current_token == null {
        return null;
    }
    
    if parser.current_token.type != type {
        // 错误：期望的类型不匹配
        // 注意：Uya 版本简化错误报告，不使用 fprintf（需要 extern 函数）
        return null;
    }
    
    return parser_consume(parser);
}

// 从 Arena 复制字符串
// 注意：需要 extern 函数 strlen 和 memcpy
extern fn strlen(s: *byte) usize;
extern fn memcpy(dest: *byte, src: *byte, n: usize) *byte;

fn arena_strdup(arena: &Arena, src: &byte) &byte {
    if arena == null || src == null {
        return null;
    }
    
    const str_len: usize = strlen(src as *byte) + 1;
    const result: &byte = arena_alloc(arena, str_len) as &byte;
    if result == null {
        return null;
    }
    
    memcpy(result as *byte, src as *byte, str_len);
    return result;
}

// 辅助函数：检查当前 token（'{'）后面是否是结构体字段初始化列表的开始
// 结构体字段初始化列表格式：identifier: expr 或 }
// 注意：调用此函数时，parser.current_token 应该是 '{'
fn parser_peek_is_struct_init(parser: &Parser) i32 {
    if parser == null || parser.lexer == null || parser.current_token == null {
        return 0;
    }
    const lexer: &Lexer = parser.lexer;
    if lexer.string_mode != 0 || lexer.interp_depth > 0 {
        return 0;
    }
    if parser.current_token.type != TokenType.TOKEN_LEFT_BRACE {
        return 0;
    }
    
    // 保存 lexer 状态（当前 lexer 的 position 已经在 '{' 之后）
    var saved_position: usize = lexer.position;
    var saved_line: i32 = lexer.line;
    var saved_column: i32 = lexer.column;
    
    // 获取 '{' 后面的 token（lexer_next_token 会跳过空白字符和注释）
    const after_brace: &Token = lexer_next_token(lexer, parser.arena);
    
    if after_brace == null {
        // 恢复状态
        lexer.position = saved_position;
        lexer.line = saved_line;
        lexer.column = saved_column;
        return 0;
    }
    
    const token_type: TokenType = after_brace.type;
    var is_struct_init: i32 = 0;
    
    // 检查 identifier: 模式或空的 {}
    if token_type == TokenType.TOKEN_RIGHT_BRACE {
        // 空的 {}：在表达式上下文中，可能是结构体字面量，也可能是代码块
        // 采用保守策略：空的 `{}` 在表达式上下文中，优先认为是结构体字面量
        is_struct_init = 1;
    } else if token_type == TokenType.TOKEN_IDENTIFIER || token_type == TokenType.TOKEN_TYPE {
        // 检查标识符后面是否有 ':'
        // 允许 'type' 关键字作为字段名（常见字段名）
        var saved_position2: usize = lexer.position;
        var saved_line2: i32 = lexer.line;
        var saved_column2: i32 = lexer.column;
        
        const after_identifier: &Token = lexer_next_token(lexer, parser.arena);
        if after_identifier != null && after_identifier.type == TokenType.TOKEN_COLON {
            is_struct_init = 1;
        }
        
        // 恢复状态到标识符之前（after_brace 之后）
        lexer.position = saved_position2;
        lexer.line = saved_line2;
        lexer.column = saved_column2;
    }
    
    // 恢复 lexer 状态到 '{' 之后（原始位置）
    lexer.position = saved_position;
    lexer.line = saved_line;
    lexer.column = saved_column;
    
    return is_struct_init;
}

// 前向声明（Uya 不支持，需要重新组织函数顺序）
// 注意：这些函数会在后面定义，但需要先声明以便递归调用
// 由于 Uya 不支持前向声明，我们需要重新组织函数顺序
// 这里先定义基础表达式解析函数，然后定义更复杂的表达式解析函数

// 辅助函数：获取文件名（用于 ast_new_node）
fn parser_get_filename(parser: &Parser) &byte {
    if parser != null && parser.lexer != null {
        return parser.lexer.filename;
    }
    return null;
}

// 解析类型（支持命名类型、指针类型和数组类型）
// type = named_type | pointer_type | array_type
// named_type = ID
// pointer_type = '&' type | '*' type
// array_type = '[' type ':' expr ']'
// 注意：此函数会递归调用 parser_parse_expression，所以需要先定义基础表达式解析函数
fn parser_parse_type(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 错误联合类型 !T
    if parser.current_token.type == TokenType.TOKEN_EXCLAMATION {
        parser_consume(parser);
        const payload: &ASTNode = parser_parse_type(parser);
        if payload == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_ERROR_UNION, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.type_error_union_payload_type = payload;
        return node;
    }
    
    // 原子类型 atomic T
    if parser.current_token.type == TokenType.TOKEN_ATOMIC {
        parser_consume(parser);  // 消费 'atomic'
        const inner_type: &ASTNode = parser_parse_type(parser);
        if inner_type == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_ATOMIC, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.type_atomic_inner_type = inner_type;
        return node;
    }
    
    // 检查是否是元组类型（(T1, T2, ...)）
    if parser.current_token.type == TokenType.TOKEN_LEFT_PAREN {
        parser_consume(parser);  // 消费 '('
        
        const first: &ASTNode = parser_parse_type(parser);
        if first == null {
            return null;
        }
        
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COMMA {
            // 元组类型：(T1, T2, ...)
            var elements: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * 16) as & & ASTNode;
            if elements == null {
                return null;
            }
            var cap: i32 = 16;
            var count: i32 = 0;
            elements[count] = first;
            count = count + 1;
            
            while parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COMMA {
                parser_consume(parser);  // 消费 ','
                const elem: &ASTNode = parser_parse_type(parser);
                if elem == null {
                    return null;
                }
                if count >= cap {
                    const new_cap: i32 = cap * 2;
                    const new_elements: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
                    if new_elements == null {
                        return null;
                    }
                    var i: i32 = 0;
                    while i < count {
                        new_elements[i] = elements[i];
                        i = i + 1;
                    }
                    elements = new_elements;
                    cap = new_cap;
                }
                elements[count] = elem;
                count = count + 1;
            }
            
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            
            const tuple_type: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_TUPLE, line, column, parser.arena, parser_get_filename(parser));
            if tuple_type == null {
                return null;
            }
            tuple_type.type_tuple_element_types = elements;
            tuple_type.type_tuple_element_count = count;
            return tuple_type;
        }
        
        // 单类型括号 (T) => 等价于 T
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        return first;
    }
    
    // 检查是否是指针类型（&Type 或 *Type）或切片类型（&[T] / &[T: N]）
    if parser.current_token.type == TokenType.TOKEN_AMPERSAND {
        parser_consume(parser);  // 消费 '&'
        
        // 切片类型 &[T] 或 &[T: N]：& 后紧跟 [
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
            parser_consume(parser);  // 消费 '['
            const element_type: &ASTNode = parser_parse_type(parser);
            if element_type == null {
                return null;
            }
            var size_expr: &ASTNode = null;
            if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                parser_consume(parser);  // 消费 ':'
                size_expr = parser_parse_expression(parser);
                if size_expr == null {
                    return null;
                }
            }
            if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                return null;
            }
            const slice_type: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_SLICE, line, column, parser.arena, parser_get_filename(parser));
            if slice_type == null {
                return null;
            }
            slice_type.type_slice_element_type = element_type;
            slice_type.type_slice_size_expr = size_expr;
            return slice_type;
        }
        
        // 普通指针类型 &Type
        const pointed_type: &ASTNode = parser_parse_type(parser);
        if pointed_type == null {
            return null;
        }
        
        // 创建指针类型节点
        const filename: &byte = parser_get_filename(parser);
        const pointer_type: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_POINTER, line, column, parser.arena, filename);
        if pointer_type == null {
            return null;
        }
        
        pointer_type.type_pointer_pointed_type = pointed_type;
        pointer_type.type_pointer_is_ffi_pointer = 0;  // 普通指针
        
        return pointer_type;
    } else if parser.current_token.type == TokenType.TOKEN_ASTERISK {
        // FFI 指针类型 *Type（仅用于 extern 函数）
        parser_consume(parser);  // 消费 '*'
        
        // 递归解析指向的类型
        const pointed_type: &ASTNode = parser_parse_type(parser);
        if pointed_type == null {
            return null;
        }
        
        // 创建 FFI 指针类型节点
        const pointer_type: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_POINTER, line, column, parser.arena, parser_get_filename(parser));
        if pointer_type == null {
            return null;
        }
        
        pointer_type.type_pointer_pointed_type = pointed_type;
        pointer_type.type_pointer_is_ffi_pointer = 1;  // FFI 指针
        
        return pointer_type;
    } else if parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
        // 数组类型 [Type: Size]
        parser_consume(parser);  // 消费 '['
        
        // 解析元素类型
        const element_type: &ASTNode = parser_parse_type(parser);
        if element_type == null {
            return null;
        }
        
        // 期望 ':'
        if parser_expect(parser, TokenType.TOKEN_COLON) == null {
            return null;
        }
        
        // 解析数组大小表达式（必须是编译期常量，但解析阶段先解析为表达式）
        // 注意：这里解析为表达式节点，类型检查阶段会验证是否为编译期常量
        // 注意：这里需要调用 parser_parse_expression，该函数会在后面定义
        const size_expr: &ASTNode = parser_parse_expression(parser);
        if size_expr == null {
            return null;
        }
        
        // 期望 ']'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
            return null;
        }
        
        // 创建数组类型节点
        const array_type: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_ARRAY, line, column, parser.arena, parser_get_filename(parser));
        if array_type == null {
            return null;
        }
        
        array_type.type_array_element_type = element_type;
        array_type.type_array_size_expr = size_expr;
        
        return array_type;
    } else if parser.current_token.type == TokenType.TOKEN_UNION {
        // union TypeName（用于 extern union 类型，如参数/返回值）
        parser_consume(parser);
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        const union_type_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if union_type_name == null {
            return null;
        }
        parser_consume(parser);
        const type_node: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_NAMED, line, column, parser.arena, parser_get_filename(parser));
        if type_node == null {
            return null;
        }
        type_node.type_named_name = union_type_name;
        return type_node;
    } else if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
        // 命名类型（i32, bool, void, 或结构体名称）或类型宏调用 macro_name()
        
        // 复制类型名称到 Arena
        const type_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if type_name == null {
            return null;
        }
        
        // 消费类型标识符
        parser_consume(parser);
        
        // 检查是否是泛型类型 Vec<i32> 或类型宏调用 macro_name()
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LESS {
            // 泛型类型：解析类型参数列表
            parser_consume(parser);  // 消费 '<'
            
            var type_args: & & ASTNode = null;
            var type_arg_count: i32 = 0;
            var type_arg_cap: i32 = 0;
            
            while parser.current_token != null &&
                  parser_match(parser, TokenType.TOKEN_GREATER) == 0 &&
                  parser_match(parser, TokenType.TOKEN_RSHIFT) == 0 &&  // >> 也可能是结束符（嵌套泛型）
                  parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                
                const type_arg: &ASTNode = parser_parse_type(parser);
                if type_arg == null {
                    return null;
                }
                
                if type_arg_count >= type_arg_cap {
                    var new_cap: i32 = 4;
                    if type_arg_cap != 0 {
                        new_cap = type_arg_cap * 2;
                    }
                    const new_type_args: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
                    if new_type_args == null {
                        return null;
                    }
                    var i: i32 = 0;
                    while i < type_arg_count {
                        new_type_args[i] = type_args[i];
                        i = i + 1;
                    }
                    type_args = new_type_args;
                    type_arg_cap = new_cap;
                }
                type_args[type_arg_count] = type_arg;
                type_arg_count = type_arg_count + 1;
                
                if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                    parser_consume(parser);
                } else {
                    break;
                }
            }
            
            // 处理 >> 的情况（嵌套泛型如 Box<Pair<i32, i32>>）
            if parser_match(parser, TokenType.TOKEN_RSHIFT) != 0 {
                // 将 >> 拆分为两个 >：消费一个 >，保留另一个 > 供外层使用
                const rshift_token: &Token = parser.current_token;
                parser_consume(parser);  // 消费 >>
                
                // 创建一个新的 > token 并放回 token 流
                const fake_greater: &Token = arena_alloc(parser.arena, @size_of(Token)) as &Token;
                if fake_greater != null {
                    fake_greater.type = TokenType.TOKEN_GREATER;
                    fake_greater.value = ">" as *byte;
                    fake_greater.line = rshift_token.line;
                    fake_greater.column = rshift_token.column + 1;
                    parser.pending_greater_token = fake_greater;
                }
            } else {
                const expect_gt: &Token = parser_expect(parser, TokenType.TOKEN_GREATER);
                if expect_gt == null {
                    return null;
                }
            }
            
            const type_node: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_NAMED, line, column, parser.arena, parser_get_filename(parser));
            if type_node == null {
                return null;
            }
            type_node.type_named_name = type_name;
            type_node.type_named_type_args = type_args;
            type_node.type_named_type_arg_count = type_arg_count;
            return type_node;
        }
        
        // 检查是否是类型宏调用 macro_name()
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LEFT_PAREN {
            parser_consume(parser);  // 消费 '('
            
            // 创建宏调用节点
            const callee: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
            if callee == null {
                return null;
            }
            callee.identifier_name = type_name;
            
            const call: &ASTNode = ast_new_node(ASTNodeType.AST_CALL_EXPR, line, column, parser.arena, parser_get_filename(parser));
            if call == null {
                return null;
            }
            call.call_expr_callee = callee;
            call.call_expr_has_ellipsis_forward = 0;
            
            // 解析参数列表（可能为空）
            var args: & & ASTNode = null;
            var arg_count: i32 = 0;
            var arg_cap: i32 = 0;
            while parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
                const arg: &ASTNode = parser_parse_expression(parser);
                if arg == null {
                    return null;
                }
                if arg_count >= arg_cap {
                    var new_cap: i32 = 4;
                    if arg_cap != 0 {
                        new_cap = arg_cap * 2;
                    }
                    const new_args: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
                    if new_args == null {
                        return null;
                    }
                    var i: i32 = 0;
                    while i < arg_count {
                        new_args[i] = args[i];
                        i = i + 1;
                    }
                    args = new_args;
                    arg_cap = new_cap;
                }
                args[arg_count] = arg;
                arg_count = arg_count + 1;
                if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                    parser_consume(parser);
                }
            }
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            
            call.call_expr_args = args;
            call.call_expr_arg_count = arg_count;
            return call;  // 返回宏调用节点，checker 会展开它
        }
        
        // 普通命名类型
        const type_node: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_NAMED, line, column, parser.arena, parser_get_filename(parser));
        if type_node == null {
            return null;
        }
        
        type_node.type_named_name = type_name;
        type_node.type_named_type_args = null;
        type_node.type_named_type_arg_count = 0;
        
        return type_node;
    }
    
    // 无法识别的类型语法
    return null;
}

// 字符串转整数/浮点辅助函数
extern fn atoi(s: *byte) i32;
extern fn strtod(nptr: *byte, endptr: * *byte) f64;
extern fn strtol(nptr: *byte, endptr: * *byte, base: i32) i64;
extern fn malloc(size: usize) *void;
extern fn free(ptr: *void) void;

// 辅助函数：移除字符串中的下划线
fn remove_underscores(str: &byte, arena: &Arena) &byte {
    if str == null {
        return null;
    }
    var len: usize = 0;
    var i: usize = 0;
    while true {
        const c: byte = str[i];
        if c == 0 {
            break;
        }
        if c != 95 {
            len = len + 1;
        }
        i = i + 1;
    }
    const result: &byte = arena_alloc(arena, len + 1) as &byte;
    if result == null {
        return null;
    }
    var j: usize = 0;
    i = 0;
    while true {
        const c: byte = str[i];
        if c == 0 {
            break;
        }
        if c != 95 {
            result[j] = c;
            j = j + 1;
        }
        i = i + 1;
    }
    result[j] = 0;
    return result;
}

// 辅助函数：解析整数字面量（支持多进制和下划线）
fn parse_integer_literal(str: &byte, arena: &Arena) i32 {
    const cleaned: &byte = remove_underscores(str, arena);
    if cleaned == null {
        return 0;
    }
    var base: i32 = 10;
    var start_pos: i32 = 0;
    if cleaned[0] == 48 {
        if cleaned[1] == 120 || cleaned[1] == 88 {
            base = 16;
            start_pos = 2;
        } else {
            if cleaned[1] == 111 || cleaned[1] == 79 {
                base = 8;
                start_pos = 2;
            } else {
                if cleaned[1] == 98 || cleaned[1] == 66 {
                    base = 2;
                    start_pos = 2;
                }
            }
        }
    }
    const ptr: *byte = &cleaned[start_pos as usize] as *byte;
    const result: i64 = strtol(ptr, null as * *byte, base);
    return result as i32;
}

// 辅助函数：解析浮点字面量（支持下划线）
fn parse_float_literal(str: &byte, arena: &Arena) f64 {
    const cleaned: &byte = remove_underscores(str, arena);
    if cleaned == null {
        return 0.0;
    }
    return strtod(cleaned as *byte, null as * *byte);
}

// 解析基础表达式
// 支持：数字、标识符、布尔字面量、括号表达式、函数调用、结构体字面量、字段访问、块表达式
fn parser_parse_primary_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 解析块表达式 { stmts }（用于宏 stmt 参数传递，也可作为普通块表达式）
    // 需要与结构体初始化区分：如果 '{' 后面是 'identifier:' 模式或 '}'，则是结构体初始化
    if parser.current_token.type == TokenType.TOKEN_LEFT_BRACE {
        if parser_peek_is_struct_init(parser) == 0 {
            return parser_parse_block(parser);
        }
        // 否则，由标识符处理（结构体初始化：StructName{ field: value }）
    }
    
    // 解析整数字面量
    if parser.current_token.type == TokenType.TOKEN_NUMBER {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_NUMBER, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        const value: i32 = parse_integer_literal(parser.current_token.value, parser.arena);
        node.number_value = value;
        parser_consume(parser);
        return node;
    }
    
    // 解析浮点字面量
    if parser.current_token.type == TokenType.TOKEN_FLOAT {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_FLOAT, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        const value: f64 = parse_float_literal(parser.current_token.value, parser.arena);
        node.float_literal_value = value;
        parser_consume(parser);
        return node;
    }
    
    // 解析布尔字面量
    if parser.current_token.type == TokenType.TOKEN_TRUE {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BOOL, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.bool_literal_value = 1;  // true
        
        parser_consume(parser);
        return node;
    }
    
    if parser.current_token.type == TokenType.TOKEN_FALSE {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BOOL, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.bool_literal_value = 0;  // false
        
        parser_consume(parser);
        return node;
    }
    
    // 解析宏插值 ${expr}（用于 @mc_ast 内部引用参数/变量）
    // 与字符串插值区分：字符串插值以 TOKEN_INTERP_TEXT 开始，而宏插值直接以 TOKEN_INTERP_OPEN 开始
    if parser.current_token.type == TokenType.TOKEN_INTERP_OPEN {
        parser_consume(parser);  // 消费 ${
        
        // 解析插值内的表达式（通常是标识符，但也可以是复杂表达式）
        const operand: &ASTNode = parser_parse_expression(parser);
        if operand == null {
            const stderr: *void = get_stderr();
            fprintf(stderr, "错误: 宏插值内缺少表达式\n" as *byte);
            return null;
        }
        
        // 期望 } 结束插值
        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
            const stderr: *void = get_stderr();
            fprintf(stderr, "错误: 宏插值缺少闭合\n" as *byte);
            return null;
        }
        
        // 创建宏插值节点
        const interp_node: &ASTNode = ast_new_node(ASTNodeType.AST_MC_INTERP, line, column, parser.arena, parser_get_filename(parser));
        if interp_node == null {
            return null;
        }
        interp_node.mc_interp_operand = operand;
        return interp_node;
    }
    
    // 解析字符串插值（"text${expr}text" 或 "text${expr:spec}text"），以 TOKEN_INTERP_TEXT 开始
    if parser.current_token.type == TokenType.TOKEN_INTERP_TEXT {
        const MAX_INTERP_SEGMENTS: i32 = 64;
        var seg_is_text: [i32: 64] = [];
        var seg_text: [&byte: 64] = [];
        var seg_expr: [&ASTNode: 64] = [];
        var seg_format_spec: [&byte: 64] = [];
        var seg_count: i32 = 0;
        var saw_end: i32 = 0;
        while seg_count < MAX_INTERP_SEGMENTS && parser.current_token != null {
            if parser.current_token.type == TokenType.TOKEN_INTERP_TEXT {
                seg_is_text[seg_count] = 1;
                seg_text[seg_count] = parser.current_token.value;
                seg_expr[seg_count] = null;
                seg_format_spec[seg_count] = null;
                seg_count = seg_count + 1;
                parser_consume(parser);
            } else if parser.current_token.type == TokenType.TOKEN_INTERP_OPEN {
                parser_consume(parser);
                const expr: &ASTNode = parser_parse_expression(parser);
                if expr == null {
                    return null;
                }
                var spec: &byte = null;
                if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_INTERP_SPEC {
                    spec = parser.current_token.value;
                    parser_consume(parser);
                } else {
                    if parser.current_token == null || parser.current_token.type != TokenType.TOKEN_INTERP_CLOSE {
                        return null;
                    }
                    parser_consume(parser);
                }
                seg_is_text[seg_count] = 0;
                seg_text[seg_count] = null;
                seg_expr[seg_count] = expr;
                seg_format_spec[seg_count] = spec;
                seg_count = seg_count + 1;
            } else if parser.current_token.type == TokenType.TOKEN_INTERP_END {
                parser_consume(parser);
                saw_end = 1;
                break;
            } else if parser.current_token.type == TokenType.TOKEN_INTERP_SPEC && seg_count > 0 &&
                seg_is_text[seg_count - 1] == 0 && seg_expr[seg_count - 1] != null && seg_format_spec[seg_count - 1] == null {
                seg_format_spec[seg_count - 1] = parser.current_token.value;
                parser_consume(parser);
            } else {
                return null;
            }
        }
        if saw_end == 0 || seg_count == 0 || seg_count >= MAX_INTERP_SEGMENTS {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_STRING_INTERP, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        const segs: &ASTStringInterpSegment = arena_alloc(parser.arena, (seg_count as usize) * @size_of(ASTStringInterpSegment)) as &ASTStringInterpSegment;
        if segs == null {
            return null;
        }
        var i: i32 = 0;
        while i < seg_count {
            segs[i].is_text = seg_is_text[i];
            segs[i].text = seg_text[i];
            segs[i].expr = seg_expr[i];
            segs[i].format_spec = seg_format_spec[i];
            i = i + 1;
        }
        node.string_interp_segments = segs;
        node.string_interp_segment_count = seg_count;
        return node;
    }
    
    // 解析字符串字面量
    if parser.current_token.type == TokenType.TOKEN_STRING || parser.current_token.type == TokenType.TOKEN_RAW_STRING {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_STRING, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        // 复制字符串内容到 Arena（token 的 value 已经在 Arena 中）
        const str_value: &byte = parser.current_token.value;
        if str_value == null {
            return null;
        }
        
        // 字符串内容已经在 token 中，直接使用（token 的 value 存储在 Arena 中）
        node.string_literal_value = str_value;
        
        parser_consume(parser);
        return node;
    }
    
    // 解析 error.Name（错误值，用于 return error.X）
    if parser.current_token.type == TokenType.TOKEN_ERROR {
        parser_consume(parser);
        if parser_match(parser, TokenType.TOKEN_DOT) == 0 {
            return null;
        }
        parser_consume(parser);
        if parser.current_token == null || parser.current_token.type != TokenType.TOKEN_IDENTIFIER {
            return null;
        }
        const err_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if err_name == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_ERROR_VALUE, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.error_value_name = err_name;
        parser_consume(parser);
        return node;
    }
    
    // 解析 match 表达式：match expr { pat => expr, ... [else => expr] }
    if parser.current_token.type == TokenType.TOKEN_MATCH {
        parser_consume(parser);
        const expr_val: &ASTNode = parser_parse_expression(parser);
        if expr_val == null {
            return null;
        }
        if parser_expect(parser, TokenType.TOKEN_LEFT_BRACE) == null {
            return null;
        }
        const arms_buf: &ASTMatchArm = arena_alloc(parser.arena, 64 * @size_of(ASTMatchArm)) as &ASTMatchArm;
        if arms_buf == null {
            return null;
        }
        var arm_count: i32 = 0;
        while arm_count < 64 && parser.current_token != null && parser.current_token.type != TokenType.TOKEN_RIGHT_BRACE {
            var kind: MatchPatternKind = MatchPatternKind.MATCH_PAT_ELSE;
            var lit_expr: &ASTNode = null;
            var literal_int_value: i32 = 0;
            var literal_is_bool: i32 = 0;
            var enum_name: &byte = null;
            var variant_name: &byte = null;
            var err_name: &byte = null;
            var bind_name: &byte = null;
            if parser.current_token.type == TokenType.TOKEN_ELSE {
                kind = MatchPatternKind.MATCH_PAT_ELSE;
                parser_consume(parser);
            } else if parser.current_token.type == TokenType.TOKEN_NUMBER {
                kind = MatchPatternKind.MATCH_PAT_LITERAL;
                literal_int_value = atoi(parser.current_token.value as *byte);
                literal_is_bool = 0;
                const lit_line: i32 = parser.current_token.line;
                const lit_col: i32 = parser.current_token.column;
                lit_expr = ast_new_node(ASTNodeType.AST_NUMBER, lit_line, lit_col, parser.arena, parser_get_filename(parser));
                if lit_expr != null {
                    lit_expr.number_value = literal_int_value;
                }
                parser_consume(parser);
            } else if parser.current_token.type == TokenType.TOKEN_TRUE {
                kind = MatchPatternKind.MATCH_PAT_LITERAL;
                literal_int_value = 1;
                literal_is_bool = 1;
                const lit_line: i32 = parser.current_token.line;
                const lit_col: i32 = parser.current_token.column;
                lit_expr = ast_new_node(ASTNodeType.AST_BOOL, lit_line, lit_col, parser.arena, parser_get_filename(parser));
                if lit_expr != null {
                    lit_expr.bool_literal_value = 1;
                }
                parser_consume(parser);
            } else if parser.current_token.type == TokenType.TOKEN_FALSE {
                kind = MatchPatternKind.MATCH_PAT_LITERAL;
                literal_int_value = 0;
                literal_is_bool = 1;
                const lit_line: i32 = parser.current_token.line;
                const lit_col: i32 = parser.current_token.column;
                lit_expr = ast_new_node(ASTNodeType.AST_BOOL, lit_line, lit_col, parser.arena, parser_get_filename(parser));
                if lit_expr != null {
                    lit_expr.bool_literal_value = 0;
                }
                parser_consume(parser);
            } else if parser.current_token.type == TokenType.TOKEN_ERROR {
                kind = MatchPatternKind.MATCH_PAT_ERROR;
                parser_consume(parser);
                if parser_match(parser, TokenType.TOKEN_DOT) == 0 || parser.current_token == null {
                    return null;
                }
                parser_consume(parser);
                if parser.current_token == null || parser.current_token.type != TokenType.TOKEN_IDENTIFIER {
                    return null;
                }
                err_name = arena_strdup(parser.arena, parser.current_token.value);
                if err_name == null {
                    return null;
                }
                parser_consume(parser);
            } else if parser.current_token.type == TokenType.TOKEN_DOT {
                kind = MatchPatternKind.MATCH_PAT_UNION;
                parser_consume(parser);
                if parser.current_token == null || parser.current_token.type != TokenType.TOKEN_IDENTIFIER {
                    return null;
                }
                variant_name = arena_strdup(parser.arena, parser.current_token.value);
                if variant_name == null {
                    return null;
                }
                parser_consume(parser);
                if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
                    return null;
                }
                if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
                    if strcmp(parser.current_token.value as *byte, "_" as *byte) == 0 {
                        bind_name = arena_strdup(parser.arena, "_" as *byte);
                    } else {
                        bind_name = arena_strdup(parser.arena, parser.current_token.value);
                    }
                    if bind_name != null {
                        parser_consume(parser);
                    }
                }
                if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                    return null;
                }
            } else if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
                const first: &byte = parser.current_token.value;
                parser_consume(parser);
                if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                    kind = MatchPatternKind.MATCH_PAT_ENUM;
                    enum_name = first;
                    parser_consume(parser);
                    if parser.current_token == null || parser.current_token.type != TokenType.TOKEN_IDENTIFIER {
                        return null;
                    }
                    variant_name = arena_strdup(parser.arena, parser.current_token.value);
                    if variant_name == null {
                        return null;
                    }
                    parser_consume(parser);
                } else {
                    kind = MatchPatternKind.MATCH_PAT_BIND;
                    bind_name = arena_strdup(parser.arena, first);
                }
            } else {
                return null;
            }
            if parser_expect(parser, TokenType.TOKEN_FAT_ARROW) == null {
                return null;
            }
            var result_expr: &ASTNode = null;
            var result_is_block: i32 = 0;
            if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
                result_expr = parser_parse_block(parser);
                result_is_block = 1;
            } else {
                result_expr = parser_parse_expression(parser);
            }
            if result_expr == null {
                return null;
            }
            arms_buf[arm_count].kind = kind;
            arms_buf[arm_count].result_is_block = result_is_block;
            arms_buf[arm_count].result_expr = result_expr;
            arms_buf[arm_count].literal_expr = null;
            arms_buf[arm_count].literal_int_value = 0;
            arms_buf[arm_count].literal_is_bool = 0;
            arms_buf[arm_count].enum_name = null;
            arms_buf[arm_count].variant_name = null;
            arms_buf[arm_count].error_name = null;
            arms_buf[arm_count].var_name = null;
            if kind == MatchPatternKind.MATCH_PAT_LITERAL {
                arms_buf[arm_count].literal_expr = lit_expr;
                arms_buf[arm_count].literal_int_value = literal_int_value;
                arms_buf[arm_count].literal_is_bool = literal_is_bool;
            } else if kind == MatchPatternKind.MATCH_PAT_ENUM {
                arms_buf[arm_count].enum_name = enum_name;
                arms_buf[arm_count].variant_name = variant_name;
            } else if kind == MatchPatternKind.MATCH_PAT_ERROR {
                arms_buf[arm_count].error_name = err_name;
            } else if kind == MatchPatternKind.MATCH_PAT_UNION {
                arms_buf[arm_count].variant_name = variant_name;
                arms_buf[arm_count].var_name = bind_name;
            } else if kind == MatchPatternKind.MATCH_PAT_BIND {
                arms_buf[arm_count].var_name = bind_name;
            }
            arm_count = arm_count + 1;
            if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COMMA {
                parser_consume(parser);
            }
        }
        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
            return null;
        }
        const match_expr_node: &ASTNode = ast_new_node(ASTNodeType.AST_MATCH_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if match_expr_node == null {
            return null;
        }
        match_expr_node.match_expr_expr = expr_val;
        const arms_final: &ASTMatchArm = arena_alloc(parser.arena, arm_count * @size_of(ASTMatchArm)) as &ASTMatchArm;
        if arms_final == null {
            return null;
        }
        var i: i32 = 0;
        while i < arm_count {
            arms_final[i] = arms_buf[i];
            i = i + 1;
        }
        match_expr_node.match_expr_arms = arms_final;
        match_expr_node.match_expr_arm_count = arm_count;
        return match_expr_node;
    }
    
    // 解析 null 字面量（null 被解析为标识符节点，在代码生成阶段通过字符串比较识别）
    if parser.current_token.type == TokenType.TOKEN_NULL {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        // 复制 "null" 字符串到 Arena（代码生成器会通过字符串比较识别）
        const null_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if null_name == null {
            return null;
        }
        node.identifier_name = null_name;
        
        parser_consume(parser);
        return node;
    }
    
    // 解析 @params（函数体内参数元组），支持 @params.0、@params.1 等后缀
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "params" as &byte) != 0 {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_PARAMS, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        parser_consume(parser);
        var result: &ASTNode = node;
        while parser.current_token != null && parser_match(parser, TokenType.TOKEN_DOT) != 0 {
            parser_consume(parser);
            // 允许 'type' 关键字作为字段名
            if parser.current_token == null || 
               (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && 
                parser.current_token.type != TokenType.TOKEN_NUMBER &&
                parser.current_token.type != TokenType.TOKEN_TYPE) {
                return null;
            }
            var field_name: &byte = null;
            if parser.current_token.type == TokenType.TOKEN_TYPE {
                field_name = arena_strdup(parser.arena, "type" as &byte);
            } else {
                field_name = arena_strdup(parser.arena, parser.current_token.value);
            }
            if field_name == null {
                return null;
            }
            const field_line: i32 = parser.current_token.line;
            const field_column: i32 = parser.current_token.column;
            parser_consume(parser);
            const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
            if member_access == null {
                return null;
            }
            member_access.member_access_object = result;
            member_access.member_access_field_name = field_name;
            result = member_access;
        }
        return result;
    }
    
    // 解析 @max/@min 整数极值字面量（类型由 Checker 从上下文推断）
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "max" as &byte) != 0 {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_INT_LIMIT, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.int_limit_is_max = 1;
        node.int_limit_resolved_kind = 0;
        parser_consume(parser);
        return node;
    }
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "min" as &byte) != 0 {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_INT_LIMIT, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.int_limit_is_max = 0;
        node.int_limit_resolved_kind = 0;
        parser_consume(parser);
        return node;
    }
    
    // 解析 @src_name 表达式
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "src_name" as &byte) != 0 {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_SRC_NAME, line, column, parser.arena, parser_get_filename(parser));
        parser_consume(parser);
        return node;
    }
    
    // 解析 @src_path 表达式
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "src_path" as &byte) != 0 {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_SRC_PATH, line, column, parser.arena, parser_get_filename(parser));
        parser_consume(parser);
        return node;
    }
    
    // 解析 @src_line 表达式
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "src_line" as &byte) != 0 {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_SRC_LINE, line, column, parser.arena, parser_get_filename(parser));
        parser_consume(parser);
        return node;
    }
    
    // 解析 @src_col 表达式
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "src_col" as &byte) != 0 {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_SRC_COL, line, column, parser.arena, parser_get_filename(parser));
        parser_consume(parser);
        return node;
    }
    
    // 解析 @func_name 表达式
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "func_name" as &byte) != 0 {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_FUNC_NAME, line, column, parser.arena, parser_get_filename(parser));
        parser_consume(parser);
        return node;
    }
    
    // 解析 @syscall 表达式：@syscall(nr, arg1, ..., arg6)
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "syscall" as &byte) != 0 {
        parser_consume(parser);  // 消费 'syscall'
        
        // 期望 '('
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const syscall_node: &ASTNode = ast_new_node(ASTNodeType.AST_SYSCALL, line, column, parser.arena, parser_get_filename(parser));
        if syscall_node == null {
            return null;
        }
        
        // 解析系统调用号（第一个参数，必须）
        const syscall_number: &ASTNode = parser_parse_or_expr(parser);
        if syscall_number == null {
            const stderr: *void = get_stderr();
            fprintf(stderr, "错误: @syscall 需要系统调用号作为第一个参数\n" as *byte);
            return null;
        }
        syscall_node.syscall_number = syscall_number;
        
        // 解析可选的参数（最多 6 个）
        const args: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * 6) as & & ASTNode;
        var arg_count: i32 = 0;
        
        while parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COMMA {
            parser_consume(parser);  // 消费逗号
            
            if arg_count >= 6 {
                const stderr: *void = get_stderr();
                fprintf(stderr, "错误: @syscall 最多支持 6 个参数\n" as *byte);
                return null;
            }
            
            const arg: &ASTNode = parser_parse_or_expr(parser);
            if arg == null {
                const stderr: *void = get_stderr();
                fprintf(stderr, "错误: @syscall 参数解析失败\n" as *byte);
                return null;
            }
            args[arg_count] = arg;
            arg_count = arg_count + 1;
        }
        
        syscall_node.syscall_args = args;
        syscall_node.syscall_arg_count = arg_count;
        
        // 期望 ')'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return syscall_node;
    }
    
    // 解析 @size_of 表达式：@size_of(Type) 或 @size_of(expr)
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "size_of" as &byte) != 0 {
        parser_consume(parser);  // 消费 'size_of'
        
        // 期望 '('
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const sizeof_node: &ASTNode = ast_new_node(ASTNodeType.AST_SIZEOF, line, column, parser.arena, parser_get_filename(parser));
        if sizeof_node == null {
            return null;
        }
        
        // 尝试解析类型，如果失败则解析表达式
        // 先检查是否是类型语法（基础类型或 struct 关键字）
        var is_type: i32 = 0;
        var target: &ASTNode = null;
        
        if parser.current_token != null {
            if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
                const type_name: &byte = parser.current_token.value;
                // 检查是否是基础类型或 struct 关键字
                if str_equals(type_name, "i32" as *byte) != 0 || 
                    str_equals(type_name, "usize" as *byte) != 0 ||
                    str_equals(type_name, "bool" as *byte) != 0 || 
                    str_equals(type_name, "byte" as *byte) != 0 ||
                    str_equals(type_name, "f32" as *byte) != 0 ||
                    str_equals(type_name, "f64" as *byte) != 0 ||
                    str_equals(type_name, "void" as *byte) != 0 ||
                    str_equals(type_name, "struct" as *byte) != 0 {
                    target = parser_parse_type(parser);
                    if target != null {
                        is_type = 1;
                    }
                }
            } else if parser.current_token.type == TokenType.TOKEN_AMPERSAND || 
                      parser.current_token.type == TokenType.TOKEN_ASTERISK ||
                      parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
                target = parser_parse_type(parser);
                if target != null {
                    is_type = 1;
                }
            }
        }
        if target == null {
            target = parser_parse_expression(parser);
            if target == null {
                return null;
            }
            is_type = 0;
        }
        sizeof_node.sizeof_expr_target = target;
        sizeof_node.sizeof_expr_is_type = is_type;
        
        // 期望 ')'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return sizeof_node;
    }
    
    // 解析 @align_of 表达式：@align_of(Type) 或 @align_of(expr)
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "align_of" as &byte) != 0 {
        parser_consume(parser);  // 消费 'align_of'
        
        // 期望 '('
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const alignof_node: &ASTNode = ast_new_node(ASTNodeType.AST_ALIGNOF, line, column, parser.arena, parser_get_filename(parser));
        if alignof_node == null {
            return null;
        }
        
        // 尝试解析类型，如果失败则解析表达式
        // 先检查是否是类型语法（基础类型或 struct 关键字）
        var is_type: i32 = 0;
        var target: &ASTNode = null;
        
        if parser.current_token != null {
            if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
                const type_name: &byte = parser.current_token.value;
                // 检查是否是基础类型或 struct 关键字
                if str_equals(type_name, "i32" as *byte) != 0 || 
                    str_equals(type_name, "usize" as *byte) != 0 ||
                    str_equals(type_name, "bool" as *byte) != 0 || 
                    str_equals(type_name, "byte" as *byte) != 0 ||
                    str_equals(type_name, "f32" as *byte) != 0 ||
                    str_equals(type_name, "f64" as *byte) != 0 ||
                    str_equals(type_name, "void" as *byte) != 0 ||
                    str_equals(type_name, "struct" as *byte) != 0 {
                    target = parser_parse_type(parser);
                    if target != null {
                        is_type = 1;
                    }
                }
            } else if parser.current_token.type == TokenType.TOKEN_AMPERSAND || 
                      parser.current_token.type == TokenType.TOKEN_ASTERISK ||
                      parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
                target = parser_parse_type(parser);
                if target != null {
                    is_type = 1;
                }
            }
        }
        if target == null {
            target = parser_parse_expression(parser);
            if target == null {
                return null;
            }
            is_type = 0;
        }
        alignof_node.alignof_expr_target = target;
        alignof_node.alignof_expr_is_type = is_type;
        
        // 期望 ')'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return alignof_node;
    }
    
    // 解析 @len 表达式：@len(array)
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "len" as &byte) != 0 {
        parser_consume(parser);  // 消费 'len'
        
        // 期望 '('
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const len_node: &ASTNode = ast_new_node(ASTNodeType.AST_LEN, line, column, parser.arena, parser_get_filename(parser));
        if len_node == null {
            return null;
        }
        
        // 解析数组表达式
        const array_expr: &ASTNode = parser_parse_expression(parser);
        if array_expr == null {
            return null;
        }
        
        len_node.len_expr_array = array_expr;
        
        // 期望 ')'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return len_node;
    }
    
    // 解析 @mc_code 表达式
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "mc_code" as &byte) != 0 {
        parser_consume(parser);
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        const mc_code_node: &ASTNode = ast_new_node(ASTNodeType.AST_MC_CODE, line, column, parser.arena, parser_get_filename(parser));
        if mc_code_node == null {
            return null;
        }
        const operand: &ASTNode = parser_parse_expression(parser);
        if operand == null {
            return null;
        }
        mc_code_node.mc_code_operand = operand;
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        return mc_code_node;
    }
    
    // 解析 @mc_ast 表达式：@mc_ast(expr|stmt|block) - 宏内获取 AST
    // 支持表达式、语句（if/for/while 等）、块语句、函数定义
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "mc_ast" as &byte) != 0 {
        parser_consume(parser);
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        const mc_ast_node: &ASTNode = ast_new_node(ASTNodeType.AST_MC_AST, line, column, parser.arena, parser_get_filename(parser));
        if mc_ast_node == null {
            return null;
        }
        
        // 根据下一个 token 决定解析方式
        var operand: &ASTNode = null;
        const next_type: TokenType = parser.current_token.type;
        
        if next_type == TokenType.TOKEN_LEFT_BRACE {
            // 块语句 { ... }
            operand = parser_parse_block(parser);
        } else if next_type == TokenType.TOKEN_FN {
            // 函数定义（用于 struct 返回类型的宏生成方法）
            operand = parser_parse_function(parser);
        } else if next_type == TokenType.TOKEN_IF || next_type == TokenType.TOKEN_FOR || 
                  next_type == TokenType.TOKEN_WHILE || next_type == TokenType.TOKEN_RETURN ||
                  next_type == TokenType.TOKEN_CONST || next_type == TokenType.TOKEN_VAR ||
                  next_type == TokenType.TOKEN_DEFER || next_type == TokenType.TOKEN_ERRDEFER {
            // 语句：if/for/while/return/const/var/defer/errdefer
            operand = parser_parse_statement(parser);
        } else {
            // 默认解析为表达式
            operand = parser_parse_expression(parser);
        }
        
        if operand == null {
            return null;
        }
        mc_ast_node.mc_ast_operand = operand;
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        return mc_ast_node;
    }
    
    // 解析 @mc_eval 表达式：@mc_eval(expr) - 宏内编译时求值
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "mc_eval" as &byte) != 0 {
        parser_consume(parser);
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        const mc_eval_node: &ASTNode = ast_new_node(ASTNodeType.AST_MC_EVAL, line, column, parser.arena, parser_get_filename(parser));
        if mc_eval_node == null {
            return null;
        }
        const operand: &ASTNode = parser_parse_expression(parser);
        if operand == null {
            return null;
        }
        mc_eval_node.mc_eval_operand = operand;
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        return mc_eval_node;
    }
    
    // 解析 @mc_error 表达式：@mc_error(msg) - 宏内编译时错误
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "mc_error" as &byte) != 0 {
        parser_consume(parser);
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        const mc_error_node: &ASTNode = ast_new_node(ASTNodeType.AST_MC_ERROR, line, column, parser.arena, parser_get_filename(parser));
        if mc_error_node == null {
            return null;
        }
        const operand: &ASTNode = parser_parse_expression(parser);
        if operand == null {
            return null;
        }
        mc_error_node.mc_error_operand = operand;
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        return mc_error_node;
    }
    
    // 解析 @mc_type 表达式：@mc_type(Type) - 宏内编译时类型反射
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "mc_type" as &byte) != 0 {
        parser_consume(parser);
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        const mc_type_node: &ASTNode = ast_new_node(ASTNodeType.AST_MC_TYPE, line, column, parser.arena, parser_get_filename(parser));
        if mc_type_node == null {
            return null;
        }
        // 解析类型参数
        const target: &ASTNode = parser_parse_type(parser);
        if target == null {
            return null;
        }
        mc_type_node.mc_type_operand = target;
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        return mc_type_node;
    }
    
    // 解析 @mc_get_env 表达式：@mc_get_env(name) - 宏内获取环境变量
    // 注意：这里生成 AST_CALL_EXPR 节点，与 C 版本保持一致
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "mc_get_env" as &byte) != 0 {
        parser_consume(parser);
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        // 创建 callee 标识符
        const callee: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
        if callee == null {
            return null;
        }
        callee.identifier_name = arena_strdup(parser.arena, "mc_get_env" as &byte);
        
        // 创建调用节点
        const call_node: &ASTNode = ast_new_node(ASTNodeType.AST_CALL_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if call_node == null {
            return null;
        }
        call_node.call_expr_callee = callee;
        
        // 解析参数
        const arg: &ASTNode = parser_parse_expression(parser);
        if arg == null {
            return null;
        }
        
        call_node.call_expr_args = arena_alloc(parser.arena, @size_of(&ASTNode)) as & & ASTNode;
        if call_node.call_expr_args == null {
            return null;
        }
        call_node.call_expr_args[0] = arg;
        call_node.call_expr_arg_count = 1;
        
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        return call_node;
    }
    
    // 解析 @await 表达式：try @await expr - 异步挂起点
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "await" as &byte) != 0 {
        parser_consume(parser);  // 消费 @await
        
        const await_node: &ASTNode = ast_new_node(ASTNodeType.AST_AWAIT_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if await_node == null {
            return null;
        }
        
        // 解析被 await 的表达式
        const operand: &ASTNode = parser_parse_unary_expr(parser);
        if operand == null {
            const stderr: *void = get_stderr();
            fprintf(stderr, "错误: @await 后缺少表达式\n" as *byte);
            return null;
        }
        
        await_node.await_expr_operand = operand;
        return await_node;
    }

    // 忽略占位 _：仅允许在赋值左侧、解构中使用，生成 AST_UNDERSCORE
    if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
        if parser.current_token.value != null && str_equals_lexer(parser.current_token.value, "_" as &byte) != 0 {
            const node: &ASTNode = ast_new_node(ASTNodeType.AST_UNDERSCORE, line, column, parser.arena, parser_get_filename(parser));
            if node == null {
                return null;
            }
            parser_consume(parser);
            return node;
        }
    }
    
    // 解析标识符（可能是普通标识符、函数调用、或结构体字面量的开始）
    // 允许 'type' 关键字作为标识符（常见变量名）
    if parser.current_token.type == TokenType.TOKEN_IDENTIFIER || parser.current_token.type == TokenType.TOKEN_TYPE {
        var name: &byte = null;
        if parser.current_token.type == TokenType.TOKEN_TYPE {
            name = arena_strdup(parser.arena, "type" as &byte);
        } else {
            name = arena_strdup(parser.arena, parser.current_token.value);
        }
        if name == null {
            return null;
        }
        
        parser_consume(parser);  // 消费标识符或 'type' 关键字
        
        // 检查是否是泛型函数调用：ID '<' type_list '>' '(' ... 或 ID '(' ...
        var call_type_args: & & ASTNode = null;
        var call_type_arg_count: i32 = 0;
        
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LESS {
            // 需要区分泛型参数 ID<Type> 和比较运算符 ID < expr
            // 策略：peek '<' 后面的 token，判断是类型还是表达式
            const lexer: &Lexer = parser.lexer;
            const saved_position: usize = lexer.position;
            const saved_line: i32 = lexer.line;
            const saved_column: i32 = lexer.column;
            
            // Peek '<' 后面的 token
            const after_less: &Token = lexer_next_token(lexer, parser.arena);
            
            // 如果 '<' 后面是表达式的开始（数字、浮点、字符串、负号等），则 '<' 是比较运算符
            var is_comparison: i32 = 0;
            if after_less != null {
                const t: TokenType = after_less.type;
                if t == TokenType.TOKEN_NUMBER || t == TokenType.TOKEN_FLOAT || t == TokenType.TOKEN_STRING ||
                   t == TokenType.TOKEN_MINUS || t == TokenType.TOKEN_EXCLAMATION || t == TokenType.TOKEN_TILDE ||
                   t == TokenType.TOKEN_TRUE || t == TokenType.TOKEN_FALSE || t == TokenType.TOKEN_NULL ||
                   t == TokenType.TOKEN_LEFT_PAREN || t == TokenType.TOKEN_AT_IDENTIFIER ||
                   t == TokenType.TOKEN_INTERP_OPEN {
                    is_comparison = 1;
                } else if t == TokenType.TOKEN_IDENTIFIER {
                    // 如果是标识符，需要进一步判断
                    // - 如果标识符后面是 '>'、','、'*'、'['、'<'（嵌套泛型），则可能是泛型参数（类型）
                    // - 如果标识符后面是运算符、'{'、'.'、'['（成员访问/索引），则是比较运算符（变量）
                    const after_id: &Token = lexer_next_token(lexer, parser.arena);
                    if after_id != null {
                        const t2: TokenType = after_id.type;
                        // 如果标识符后面是这些 token，则 '<' 是比较运算符
                        // 注意：TOKEN_LESS 可能是嵌套泛型（如 Box<Pair<i32, i32>>），不应该被视为比较运算符
                        if t2 == TokenType.TOKEN_PLUS || t2 == TokenType.TOKEN_MINUS || t2 == TokenType.TOKEN_ASTERISK ||
                           t2 == TokenType.TOKEN_SLASH || t2 == TokenType.TOKEN_PERCENT ||
                           // t2 == TokenType.TOKEN_LESS ||  // 移除：TOKEN_LESS 可能是嵌套泛型
                           t2 == TokenType.TOKEN_LESS_EQUAL || t2 == TokenType.TOKEN_GREATER_EQUAL ||
                           t2 == TokenType.TOKEN_EQUAL || t2 == TokenType.TOKEN_NOT_EQUAL ||
                           t2 == TokenType.TOKEN_LOGICAL_AND || t2 == TokenType.TOKEN_LOGICAL_OR ||
                           t2 == TokenType.TOKEN_LEFT_BRACE || t2 == TokenType.TOKEN_SEMICOLON ||
                           t2 == TokenType.TOKEN_AMPERSAND || t2 == TokenType.TOKEN_PIPE || t2 == TokenType.TOKEN_CARET ||
                           t2 == TokenType.TOKEN_RIGHT_PAREN ||
                           t2 == TokenType.TOKEN_DOT || t2 == TokenType.TOKEN_LEFT_BRACKET || t2 == TokenType.TOKEN_LEFT_PAREN ||
                           t2 == TokenType.TOKEN_AS || t2 == TokenType.TOKEN_AS_BANG {
                            is_comparison = 1;
                        }
                    }
                }
            }
            
            // 恢复 lexer 状态
            lexer.position = saved_position;
            lexer.line = saved_line;
            lexer.column = saved_column;
            
            if is_comparison == 0 {
                // 泛型函数调用：解析类型参数列表
                parser_consume(parser);  // 消费 '<'
                
                var call_type_arg_capacity: i32 = 0;
                
                if parser_match(parser, TokenType.TOKEN_GREATER) == 0 && parser_match(parser, TokenType.TOKEN_RSHIFT) == 0 {
                    // 有类型参数
                    while parser.current_token != null &&
                          parser_match(parser, TokenType.TOKEN_GREATER) == 0 &&
                          parser_match(parser, TokenType.TOKEN_RSHIFT) == 0 &&  // >> 也可能是结束符（嵌套泛型）
                          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                        
                        // 解析类型参数
                        const type_arg: &ASTNode = parser_parse_type(parser);
                        if type_arg == null {
                            return null;
                        }
                        
                        // 扩展类型参数数组
                        if call_type_arg_count >= call_type_arg_capacity {
                            var new_capacity: i32 = 4;
                            if call_type_arg_capacity != 0 {
                                new_capacity = call_type_arg_capacity * 2;
                            }
                            const new_type_args: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_capacity) as & & ASTNode;
                            if new_type_args == null {
                                return null;
                            }
                            
                            // 复制旧类型参数
                            if call_type_args != null {
                                var i: i32 = 0;
                                while i < call_type_arg_count {
                                    new_type_args[i] = call_type_args[i];
                                    i = i + 1;
                                }
                            }
                            
                            call_type_args = new_type_args;
                            call_type_arg_capacity = new_capacity;
                        }
                        
                        call_type_args[call_type_arg_count] = type_arg;
                        call_type_arg_count = call_type_arg_count + 1;
                        
                        // 检查是否有逗号
                        if parser_match(parser, TokenType.TOKEN_COMMA) == 0 {
                            break;
                        }
                        parser_consume(parser);  // 消费 ','
                    }
                }
                
                // 处理 >> 的情况（嵌套泛型如 Box<Pair<i32, i32>>）
                if parser_match(parser, TokenType.TOKEN_RSHIFT) != 0 {
                    // 将 >> 拆分为两个 >：消费一个 >，保留另一个 > 供外层使用
                    const rshift_token: &Token = parser.current_token;
                    parser_consume(parser);  // 消费 >>
                    
                    // 创建一个新的 > token 并放回 token 流
                    const fake_greater: &Token = arena_alloc(parser.arena, @size_of(Token)) as &Token;
                    if fake_greater != null {
                        fake_greater.type = TokenType.TOKEN_GREATER;
                        fake_greater.value = ">" as *byte;
                        fake_greater.line = rshift_token.line;
                        fake_greater.column = rshift_token.column + 1;
                        parser.pending_greater_token = fake_greater;
                    }
                } else {
                    // 期望 '>'
                    const expect_gt: &Token = parser_expect(parser, TokenType.TOKEN_GREATER);
                    if expect_gt == null {
                        return null;
                    }
                }
            }
        }
        
        // 检查下一个 token 类型
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LEFT_PAREN {
            // 函数调用：ID ['<' type_list '>'] '(' [ arg_list ] ')'
            const call: &ASTNode = ast_new_node(ASTNodeType.AST_CALL_EXPR, line, column, parser.arena, parser_get_filename(parser));
            if call == null {
                return null;
            }
            
            // 创建标识符节点作为被调用的函数
            const callee: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
            if callee == null {
                return null;
            }
            callee.identifier_name = name;
            call.call_expr_callee = callee;
            call.call_expr_has_ellipsis_forward = 0;
            call.call_expr_type_args = call_type_args;
            call.call_expr_type_arg_count = call_type_arg_count;
            
            // 消费 '('（与 C 版 parser.c 第 1636-1637 行一致）
            parser_consume(parser);
            
            // 解析参数列表（可选），末尾允许 ... 表示转发可变参数
            var args: & & ASTNode = null;
            var arg_count: i32 = 0;
            var arg_capacity: i32 = 0;
            
            if parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
                // 有参数
                while parser.current_token != null && 
                      parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 && 
                      parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                    
                    // 检查是否为末尾的 ...（转发可变参数）
                    if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                        parser_consume(parser);
                        call.call_expr_has_ellipsis_forward = 1;
                        break;
                    }
                    
                    // 解析参数表达式
                    const arg: &ASTNode = parser_parse_expression(parser);
                    if arg == null {
                        return null;
                    }
                    
                    // 扩展参数数组
                    if arg_count >= arg_capacity {
                        var new_capacity: i32 = 0;
                        if arg_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = arg_capacity * 2;
                        }
                        const new_args: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_capacity) as & & ASTNode;
                        if new_args == null {
                            return null;
                        }
                        
                        // 复制旧参数
                        if args != null {
                            var i: i32 = 0;
                            while i < arg_count {
                                new_args[i] = args[i];
                                i = i + 1;
                            }
                        }
                        
                        args = new_args;
                        arg_capacity = new_capacity;
                    }
                    
                    args[arg_count] = arg;
                    arg_count = arg_count + 1;
                    
                    // 检查是否有逗号或逗号后 ...
                    if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    }
                }
            }
            
            // 期望 ')'
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            
            call.call_expr_args = args;
            call.call_expr_arg_count = arg_count;
            
            // 字段访问和数组访问可能跟在函数调用后面（例如：f().field、f().0 或 f()[0]）
            var result: &ASTNode = call;
            
            // 处理字段访问和数组访问链（.field 或元组 .0/.1）
            while parser.current_token != null {
                if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                    parser_consume(parser);  // 消费 '.'
                    // 允许 'type' 关键字作为字段名
                    if parser.current_token == null || 
                       (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && 
                        parser.current_token.type != TokenType.TOKEN_NUMBER &&
                        parser.current_token.type != TokenType.TOKEN_TYPE) {
                        return null;
                    }
                    var field_name: &byte = null;
                    if parser.current_token.type == TokenType.TOKEN_TYPE {
                        field_name = arena_strdup(parser.arena, "type" as &byte);
                    } else {
                        field_name = arena_strdup(parser.arena, parser.current_token.value);
                    }
                    if field_name == null {
                        return null;
                    }
                    
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费字段名称
                    
                    // 创建字段访问节点
                    const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                    if member_access == null {
                        return null;
                    }
                    
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    
                    result = member_access;
                } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                    const bracket_line: i32 = parser.current_token.line;
                    const bracket_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费 '['
                    const first_expr: &ASTNode = parser_parse_expression(parser);
                    if first_expr == null {
                        return null;
                    }
                    if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                        parser_consume(parser);
                        const len_expr: &ASTNode = parser_parse_expression(parser);
                        if len_expr == null {
                            return null;
                        }
                        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                            return null;
                        }
                        const slice_expr: &ASTNode = ast_new_node(ASTNodeType.AST_SLICE_EXPR, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                        if slice_expr == null {
                            return null;
                        }
                        slice_expr.slice_expr_base = result;
                        slice_expr.slice_expr_start_expr = first_expr;
                        slice_expr.slice_expr_len_expr = len_expr;
                        result = slice_expr;
                    } else {
                        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                            return null;
                        }
                        const array_access: &ASTNode = ast_new_node(ASTNodeType.AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                        if array_access == null {
                            return null;
                        }
                        array_access.array_access_array = result;
                        array_access.array_access_index = first_expr;
                        result = array_access;
                    }
                } else if parser_match(parser, TokenType.TOKEN_LEFT_PAREN) != 0 {
                    // 方法调用：obj.method(args) 例如 f().x(args)
                    parser_consume(parser);
                    const call2: &ASTNode = ast_new_node(ASTNodeType.AST_CALL_EXPR, line, column, parser.arena, parser_get_filename(parser));
                    if call2 == null {
                        return null;
                    }
                    call2.call_expr_callee = result;
                    call2.call_expr_has_ellipsis_forward = 0;
                    var args2: & & ASTNode = null;
                    var arg_count2: i32 = 0;
                    var arg_cap2: i32 = 0;
                    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 &&
                          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                        if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                            parser_consume(parser);
                            call2.call_expr_has_ellipsis_forward = 1;
                            break;
                        }
                        const arg2: &ASTNode = parser_parse_expression(parser);
                        if arg2 == null {
                            return null;
                        }
                        if arg_count2 >= arg_cap2 {
                            var new_cap: i32 = 0;
                            if arg_cap2 == 0 {
                                new_cap = 4;
                            } else {
                                new_cap = arg_cap2 * 2;
                            }
                            const new_a: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
                            if new_a == null {
                                return null;
                            }
                            var i: i32 = 0;
                            while i < arg_count2 {
                                new_a[i] = args2[i];
                                i = i + 1;
                            }
                            args2 = new_a;
                            arg_cap2 = new_cap;
                        }
                        args2[arg_count2] = arg2;
                        arg_count2 = arg_count2 + 1;
                        if parser_match(parser, TokenType.TOKEN_COMMA) == 0 {
                            break;
                        }
                        parser_consume(parser);
                    }
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                        return null;
                    }
                    call2.call_expr_args = args2;
                    call2.call_expr_arg_count = arg_count2;
                    result = call2;
                } else {
                    break;
                }
            }
            
            return result;
        } else if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LEFT_BRACE {
            // 使用 peek 机制检测是否是结构体字面量
            var is_struct_init: i32 = parser_peek_is_struct_init(parser);
            
            // 特殊情况：如果 '{' 后面是 '}'（空块），且这是在条件表达式上下文中，
            // 我们需要检查这是否是在比较表达式之后（如 `p1 == p2 {`）
            if is_struct_init != 0 {
                const lexer: &Lexer = parser.lexer;
                var saved_position: usize = lexer.position;
                var saved_line: i32 = lexer.line;
                var saved_column: i32 = lexer.column;
                
                // Peek '{' 后面的 token
                const after_brace: &Token = lexer_next_token(lexer, parser.arena);
                if after_brace != null && after_brace.type == TokenType.TOKEN_RIGHT_BRACE {
                    // '{' 后面是 '}'（空块）
                    // 恢复 lexer 状态
                    lexer.position = saved_position;
                    lexer.line = saved_line;
                    lexer.column = saved_column;
                    
                    // 根据上下文判断
                    if parser.context == ParserContext.PARSER_CONTEXT_CONDITION {
                        // 在条件表达式上下文中，`{}` 应该是代码块的开始
                        // 返回标识符，让调用者处理 '{' 作为代码块
                        const node: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
                        if node == null {
                            return null;
                        }
                        
                        node.identifier_name = name;
                        return node;
                    }
                    // 在变量初始化上下文或普通上下文中，`{}` 应该是结构体字面量
                    // 继续解析结构体字面量
                } else {
                    // 恢复 lexer 状态
                    lexer.position = saved_position;
                    lexer.line = saved_line;
                    lexer.column = saved_column;
                }
            }
            
            if is_struct_init == 0 {
                // 不是结构体字面量，创建普通标识符（后面的'{'是代码块的开始，不是表达式的一部分）
                const node: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
                if node == null {
                    return null;
                }
                
                node.identifier_name = name;
                
                // 字段访问可能跟在标识符后面（例如：obj.field）
                var result: &ASTNode = node;
                
                // 处理字段访问链（左结合：a.b.c 或元组 .0/.1）
                while parser.current_token != null && parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                    parser_consume(parser);  // 消费 '.'
                    if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER && parser.current_token.type != TokenType.TOKEN_TYPE) {
                        return null;
                    }
                    var field_name: &byte = null;
                    if parser.current_token.type == TokenType.TOKEN_TYPE {
                        field_name = arena_strdup(parser.arena, "type" as &byte);
                    } else {
                        field_name = arena_strdup(parser.arena, parser.current_token.value);
                    }
                    if field_name == null {
                        return null;
                    }
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);
                    const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                    if member_access == null {
                        return null;
                    }
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    result = member_access;
                }
                
                return result;
            }
            
            // 结构体字面量：ID ['<' type_list '>'] '{' field_init_list '}'
            const struct_init: &ASTNode = ast_new_node(ASTNodeType.AST_STRUCT_INIT, line, column, parser.arena, parser_get_filename(parser));
            if struct_init == null {
                return null;
            }
            
            struct_init.struct_init_struct_name = name;
            struct_init.struct_init_type_args = call_type_args;
            struct_init.struct_init_type_arg_count = call_type_arg_count;
            
            // 消费 '{'
            parser_consume(parser);
            
            // 解析字段初始化列表
            var field_names: & & byte = null;
            var field_values: & & ASTNode = null;
            var field_count: i32 = 0;
            var field_capacity: i32 = 0;
            
            if parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 {
                // 有字段初始化
                while parser.current_token != null && 
                      parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
                      parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                    
                    // 解析字段名称，允许 'type' 关键字作为字段名
                    var field_name: &byte = null;
                    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
                        field_name = arena_strdup(parser.arena, parser.current_token.value);
                    } else if parser_match(parser, TokenType.TOKEN_TYPE) != 0 {
                        field_name = arena_strdup(parser.arena, "type" as &byte);
                    } else {
                        return null;
                    }
                    if field_name == null {
                        return null;
                    }
                    
                    parser_consume(parser);  // 消费字段名称
                    
                    // 期望 ':'
                    if parser_expect(parser, TokenType.TOKEN_COLON) == null {
                        return null;
                    }
                    
                    // 解析字段值表达式
                    const field_value: &ASTNode = parser_parse_expression(parser);
                    if field_value == null {
                        return null;
                    }
                    
                    // 扩展字段数组
                    if field_count >= field_capacity {
                        var new_capacity: i32 = 0;
                        if field_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = field_capacity * 2;
                        }
                        const new_field_names: & & byte = arena_alloc(parser.arena, @size_of(&byte) * new_capacity) as & & byte;
                        const new_field_values: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_capacity) as & & ASTNode;
                        if new_field_names == null || new_field_values == null {
                            return null;
                        }
                        
                        // 复制旧字段
                        if field_names != null && field_values != null {
                            var i: i32 = 0;
                            while i < field_count {
                                new_field_names[i] = field_names[i];
                                new_field_values[i] = field_values[i];
                                i = i + 1;
                            }
                        }
                        
                        field_names = new_field_names;
                        field_values = new_field_values;
                        field_capacity = new_capacity;
                    }
                    
                    field_names[field_count] = field_name;
                    field_values[field_count] = field_value;
                    field_count = field_count + 1;
                    
                    // 检查是否有逗号
                    if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    }
                }
            }
            
            // 期望 '}'
            if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
                return null;
            }
            
            struct_init.struct_init_field_names = field_names;
            struct_init.struct_init_field_values = field_values;
            struct_init.struct_init_field_count = field_count;
            
            // 字段访问可能跟在结构体字面量后面（例如：Point{x:1,y:2}.x）
            var result: &ASTNode = struct_init;
            
            // 处理字段访问链（.field 或元组 .0/.1）
            while parser.current_token != null && parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                parser_consume(parser);  // 消费 '.'
                if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER && parser.current_token.type != TokenType.TOKEN_TYPE) {
                    return null;
                }
                var field_name: &byte = null;
                if parser.current_token.type == TokenType.TOKEN_TYPE {
                    field_name = arena_strdup(parser.arena, "type" as &byte);
                } else {
                    field_name = arena_strdup(parser.arena, parser.current_token.value);
                }
                if field_name == null {
                    return null;
                }
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);
                const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                if member_access == null {
                    return null;
                }
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                result = member_access;
            }
            
            return result;
        } else {
            // 普通标识符
            const node: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
            if node == null {
                return null;
            }
            
            node.identifier_name = name;
            
            // 字段访问和数组访问可能跟在标识符后面（例如：obj.field 或 arr[0]）
            var result: &ASTNode = node;
            
            // 处理字段访问和数组访问链（.field 或元组 .0/.1、[index]）
            while parser.current_token != null {
                if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                    parser_consume(parser);  // 消费 '.'
                    if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER && parser.current_token.type != TokenType.TOKEN_TYPE) {
                        return null;
                    }
                    var field_name: &byte = null;
                    if parser.current_token.type == TokenType.TOKEN_TYPE {
                        field_name = arena_strdup(parser.arena, "type" as &byte);
                    } else {
                        field_name = arena_strdup(parser.arena, parser.current_token.value);
                    }
                    if field_name == null {
                        return null;
                    }
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);
                    const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                    if member_access == null {
                        return null;
                    }
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    result = member_access;
                } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                    const bracket_line: i32 = parser.current_token.line;
                    const bracket_column: i32 = parser.current_token.column;
                    parser_consume(parser);
                    const first_expr: &ASTNode = parser_parse_expression(parser);
                    if first_expr == null {
                        return null;
                    }
                    if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                        parser_consume(parser);
                        const len_expr: &ASTNode = parser_parse_expression(parser);
                        if len_expr == null {
                            return null;
                        }
                        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                            return null;
                        }
                        const slice_expr: &ASTNode = ast_new_node(ASTNodeType.AST_SLICE_EXPR, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                        if slice_expr == null {
                            return null;
                        }
                        slice_expr.slice_expr_base = result;
                        slice_expr.slice_expr_start_expr = first_expr;
                        slice_expr.slice_expr_len_expr = len_expr;
                        result = slice_expr;
                    } else {
                        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                            return null;
                        }
                        const array_access: &ASTNode = ast_new_node(ASTNodeType.AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                        if array_access == null {
                            return null;
                        }
                        array_access.array_access_array = result;
                        array_access.array_access_index = first_expr;
                        result = array_access;
                    }
                } else if parser_match(parser, TokenType.TOKEN_LEFT_PAREN) != 0 {
                    // 方法调用：obj.method(args) 或 f()(args)
                    parser_consume(parser);
                    const call: &ASTNode = ast_new_node(ASTNodeType.AST_CALL_EXPR, line, column, parser.arena, parser_get_filename(parser));
                    if call == null {
                        return null;
                    }
                    call.call_expr_callee = result;
                    call.call_expr_has_ellipsis_forward = 0;
                    var args: & & ASTNode = null;
                    var arg_count: i32 = 0;
                    var arg_cap: i32 = 0;
                    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 &&
                          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                        if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                            parser_consume(parser);
                            call.call_expr_has_ellipsis_forward = 1;
                            break;
                        }
                        const arg: &ASTNode = parser_parse_expression(parser);
                        if arg == null {
                            return null;
                        }
                        if arg_count >= arg_cap {
                            var new_cap: i32 = 0;
                            if arg_cap == 0 {
                                new_cap = 4;
                            } else {
                                new_cap = arg_cap * 2;
                            }
                            const new_a: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
                            if new_a == null {
                                return null;
                            }
                            var i: i32 = 0;
                            while i < arg_count {
                                new_a[i] = args[i];
                                i = i + 1;
                            }
                            args = new_a;
                            arg_cap = new_cap;
                        }
                        args[arg_count] = arg;
                        arg_count = arg_count + 1;
                        if parser_match(parser, TokenType.TOKEN_COMMA) == 0 {
                            break;
                        }
                        parser_consume(parser);
                    }
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                        return null;
                    }
                    call.call_expr_args = args;
                    call.call_expr_arg_count = arg_count;
                    result = call;
                } else {
                    break;
                }
            }
            
            return result;
        }
    }
    
    // 解析数组字面量：[expr1, expr2, ..., exprN]、[value: N] 或 []
    if parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
        const array_line: i32 = parser.current_token.line;
        const array_column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 '['
        
        const array_literal: &ASTNode = ast_new_node(ASTNodeType.AST_ARRAY_LITERAL, array_line, array_column, parser.arena, parser_get_filename(parser));
        if array_literal == null {
            return null;
        }
        
        if parser_match(parser, TokenType.TOKEN_RIGHT_BRACKET) != 0 {
            parser_consume(parser);
            array_literal.array_literal_elements = null;
            array_literal.array_literal_element_count = 0;
            array_literal.array_literal_repeat_count_expr = null;
        } else {
            const first: &ASTNode = parser_parse_expression(parser);
            if first == null {
                return null;
            }
            if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                parser_consume(parser);
                const count_expr: &ASTNode = parser_parse_expression(parser);
                if count_expr == null {
                    return null;
                }
                if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                    return null;
                }
                const elements: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode)) as & & ASTNode;
                if elements == null {
                    return null;
                }
                elements[0] = first;
                array_literal.array_literal_elements = elements;
                array_literal.array_literal_element_count = 1;
                array_literal.array_literal_repeat_count_expr = count_expr;
            } else {
                var elements: & & ASTNode = null;
                var element_count: i32 = 0;
                var element_capacity: i32 = 0;
                if element_count >= element_capacity {
                    var new_capacity: i32 = 0;
                    if element_capacity == 0 {
                        new_capacity = 4;
                    } else {
                        new_capacity = element_capacity * 2;
                    }
                    const new_elements: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_capacity) as & & ASTNode;
                    if new_elements == null {
                        return null;
                    }
                    if elements != null {
                        var i: i32 = 0;
                        while i < element_count {
                            new_elements[i] = elements[i];
                            i = i + 1;
                        }
                    }
                    elements = new_elements;
                    element_capacity = new_capacity;
                }
                elements[element_count] = first;
                element_count = element_count + 1;
                while parser.current_token != null &&
                      parser_match(parser, TokenType.TOKEN_RIGHT_BRACKET) == 0 &&
                      parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                    if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    }
                    if parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_BRACKET) != 0 {
                        break;
                    }
                    const element: &ASTNode = parser_parse_expression(parser);
                    if element == null {
                        return null;
                    }
                    if element_count >= element_capacity {
                        var new_capacity: i32 = 0;
                        if element_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = element_capacity * 2;
                        }
                        const new_elements: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_capacity) as & & ASTNode;
                        if new_elements == null {
                            return null;
                        }
                        var i: i32 = 0;
                        while i < element_count {
                            new_elements[i] = elements[i];
                            i = i + 1;
                        }
                        elements = new_elements;
                        element_capacity = new_capacity;
                    }
                    elements[element_count] = element;
                    element_count = element_count + 1;
                }
                if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                    return null;
                }
                array_literal.array_literal_elements = elements;
                array_literal.array_literal_element_count = element_count;
                array_literal.array_literal_repeat_count_expr = null;
            }
        }
        
        // 字段访问和数组访问可能跟在数组字面量后面（例如：[1,2,3][0]）
        var result: &ASTNode = array_literal;
        
        // 处理字段访问和数组访问链（.field 或元组 .0/.1、[index]）
        while parser.current_token != null {
            if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                parser_consume(parser);  // 消费 '.'
                if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER && parser.current_token.type != TokenType.TOKEN_TYPE) {
                    return null;
                }
                var field_name: &byte = null;
                if parser.current_token.type == TokenType.TOKEN_TYPE {
                    field_name = arena_strdup(parser.arena, "type" as &byte);
                } else {
                    field_name = arena_strdup(parser.arena, parser.current_token.value);
                }
                if field_name == null {
                    return null;
                }
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);
                const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                if member_access == null {
                    return null;
                }
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                result = member_access;
            } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                const bracket_line: i32 = parser.current_token.line;
                const bracket_column: i32 = parser.current_token.column;
                parser_consume(parser);
                const first_expr: &ASTNode = parser_parse_expression(parser);
                if first_expr == null {
                    return null;
                }
                if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                    parser_consume(parser);
                    const len_expr: &ASTNode = parser_parse_expression(parser);
                    if len_expr == null {
                        return null;
                    }
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    const slice_expr: &ASTNode = ast_new_node(ASTNodeType.AST_SLICE_EXPR, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                    if slice_expr == null {
                        return null;
                    }
                    slice_expr.slice_expr_base = result;
                    slice_expr.slice_expr_start_expr = first_expr;
                    slice_expr.slice_expr_len_expr = len_expr;
                    result = slice_expr;
                } else {
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    const array_access: &ASTNode = ast_new_node(ASTNodeType.AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                    if array_access == null {
                        return null;
                    }
                    array_access.array_access_array = result;
                    array_access.array_access_index = first_expr;
                    result = array_access;
                }
            } else {
                break;
            }
        }
        
        return result;
    }
    
    // 解析括号表达式或元组字面量
    if parser.current_token.type == TokenType.TOKEN_LEFT_PAREN {
        const paren_line: i32 = parser.current_token.line;
        const paren_column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 '('
        
        const first: &ASTNode = parser_parse_expression(parser);
        if first == null {
            return null;
        }
        
        var result: &ASTNode = null;
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COMMA {
            // 元组字面量：(expr1, expr2, ...)
            var elements: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * 16) as & & ASTNode;
            if elements == null {
                return null;
            }
            var cap: i32 = 16;
            var count: i32 = 0;
            elements[count] = first;
            count = count + 1;
            
            while parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COMMA {
                parser_consume(parser);  // 消费 ','
                const elem: &ASTNode = parser_parse_expression(parser);
                if elem == null {
                    return null;
                }
                if count >= cap {
                    const new_cap: i32 = cap * 2;
                    const new_elements: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
                    if new_elements == null {
                        return null;
                    }
                    var i: i32 = 0;
                    while i < count {
                        new_elements[i] = elements[i];
                        i = i + 1;
                    }
                    elements = new_elements;
                    cap = new_cap;
                }
                elements[count] = elem;
                count = count + 1;
            }
            
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            
            const tuple_lit: &ASTNode = ast_new_node(ASTNodeType.AST_TUPLE_LITERAL, paren_line, paren_column, parser.arena, parser_get_filename(parser));
            if tuple_lit == null {
                return null;
            }
            tuple_lit.tuple_literal_elements = elements;
            tuple_lit.tuple_literal_element_count = count;
            result = tuple_lit;
        } else {
            // 单表达式括号 (expr) => expr
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            result = first;
        }
        
        // 处理字段访问和数组访问链（.field 或元组下标 .0/.1、[index]）
        while parser.current_token != null {
            if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                // 字段访问：.field 或元组下标 .0, .1, ...
                parser_consume(parser);  // 消费 '.'
                
                // 期望字段名称或元组下标（.0, .1, ... 为 NUMBER）
                if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER && parser.current_token.type != TokenType.TOKEN_TYPE) {
                    return null;
                }
                
                var field_name: &byte = null;
                if parser.current_token.type == TokenType.TOKEN_TYPE {
                    field_name = arena_strdup(parser.arena, "type" as &byte);
                } else {
                    field_name = arena_strdup(parser.arena, parser.current_token.value);
                }
                if field_name == null {
                    return null;
                }
                
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费字段名称或元组下标
                
                // 创建字段访问节点
                const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                if member_access == null {
                    return null;
                }
                
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                
                result = member_access;
            } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                const bracket_line: i32 = parser.current_token.line;
                const bracket_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费 '['
                const first_expr: &ASTNode = parser_parse_expression(parser);
                if first_expr == null {
                    return null;
                }
                if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                    parser_consume(parser);
                    const len_expr: &ASTNode = parser_parse_expression(parser);
                    if len_expr == null {
                        return null;
                    }
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    const slice_expr: &ASTNode = ast_new_node(ASTNodeType.AST_SLICE_EXPR, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                    if slice_expr == null {
                        return null;
                    }
                    slice_expr.slice_expr_base = result;
                    slice_expr.slice_expr_start_expr = first_expr;
                    slice_expr.slice_expr_len_expr = len_expr;
                    result = slice_expr;
                } else {
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    const array_access: &ASTNode = ast_new_node(ASTNodeType.AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                    if array_access == null {
                        return null;
                    }
                    array_access.array_access_array = result;
                    array_access.array_access_index = first_expr;
                    result = array_access;
                }
            } else {
                break;
            }
        }
        
        return result;
    }
    
    // 无法识别的基础表达式
    return null;
}

// 解析一元表达式（!, -, &, *, try，右结合）
// unary_expr = ('!' | '-' | '&' | '*' | 'try') unary_expr | primary_expr
fn parser_parse_unary_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // try expr（错误传播）
    if parser_match(parser, TokenType.TOKEN_TRY) != 0 {
        parser_consume(parser);
        const operand: &ASTNode = parser_parse_unary_expr(parser);
        if operand == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_TRY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.try_expr_operand = operand;
        return node;
    }
    
    // 检查一元运算符（!, -, ~, &, *）
    if parser_match(parser, TokenType.TOKEN_EXCLAMATION) != 0 || 
       parser_match(parser, TokenType.TOKEN_MINUS) != 0 ||
       parser_match(parser, TokenType.TOKEN_TILDE) != 0 ||
       parser_match(parser, TokenType.TOKEN_AMPERSAND) != 0 ||
       parser_match(parser, TokenType.TOKEN_ASTERISK) != 0 {
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 递归解析一元表达式（右结合）
        const operand: &ASTNode = parser_parse_unary_expr(parser);
        if operand == null {
            return null;
        }
        
        // 创建一元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_UNARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.unary_expr_op = op;
        node.unary_expr_operand = operand;
        
        return node;
    }
    
    // 不是一元运算符，解析基础表达式
    return parser_parse_primary_expr(parser);
}

// 解析类型转换表达式（右结合），支持后缀 catch
// cast_expr = unary_expr [ 'as' type ] { 'catch' [ '|' ID '|' ] '{' statements '}' }
fn parser_parse_cast_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数（一元表达式）
    var expr: &ASTNode = parser_parse_unary_expr(parser);
    if expr == null {
        return null;
    }
    
    // 检查是否有 'as' 或 'as!' 关键字（类型转换）
    if parser.current_token != null && (parser.current_token.type == TokenType.TOKEN_AS || parser.current_token.type == TokenType.TOKEN_AS_BANG) {
        var is_force_cast: i32 = 0;
        if parser.current_token.type == TokenType.TOKEN_AS_BANG { is_force_cast = 1; }
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 'as' 或 'as!'
        
        // 解析目标类型
        const target_type: &ASTNode = parser_parse_type(parser);
        if target_type == null {
            return null;
        }
        
        // 创建类型转换节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_CAST_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.cast_expr_expr = expr;
        node.cast_expr_target_type = target_type;
        node.cast_expr_is_force_cast = is_force_cast;
        
        expr = node;
    }
    
    // 后缀 catch：expr catch [ |err| ] { stmts }（可多个，左结合）
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_CATCH) != 0 {
        const catch_line: i32 = parser.current_token.line;
        const catch_column: i32 = parser.current_token.column;
        parser_consume(parser);
        var err_name: &byte = null;
        if parser.current_token != null && parser_match(parser, TokenType.TOKEN_PIPE) != 0 {
            parser_consume(parser);
            if parser.current_token == null || parser.current_token.type != TokenType.TOKEN_IDENTIFIER {
                return null;
            }
            err_name = arena_strdup(parser.arena, parser.current_token.value);
            if err_name == null {
                return null;
            }
            parser_consume(parser);
            if parser_expect(parser, TokenType.TOKEN_PIPE) == null {
                return null;
            }
        }
        const catch_block: &ASTNode = parser_parse_block(parser);
        if catch_block == null {
            return null;
        }
        const catch_node: &ASTNode = ast_new_node(ASTNodeType.AST_CATCH_EXPR, catch_line, catch_column, parser.arena, parser_get_filename(parser));
        if catch_node == null {
            return null;
        }
        catch_node.catch_expr_operand = expr;
        catch_node.catch_expr_err_name = err_name;
        catch_node.catch_expr_catch_block = catch_block;
        expr = catch_node;
    }
    
    return expr;
}

// 解析乘除模表达式（左结合）
// mul_expr = cast_expr { ('*' | '/' | '%') cast_expr }
fn parser_parse_mul_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数（类型转换表达式）
    var left: &ASTNode = parser_parse_cast_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的乘除模运算符（左结合），含饱和 *|、包装 *%
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_ASTERISK) != 0 ||
        parser_match(parser, TokenType.TOKEN_SLASH) != 0 ||
        parser_match(parser, TokenType.TOKEN_PERCENT) != 0 ||
        parser_match(parser, TokenType.TOKEN_ASTERISK_PIPE) != 0 ||
        parser_match(parser, TokenType.TOKEN_ASTERISK_PERCENT) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数（类型转换表达式）
        const right: &ASTNode = parser_parse_cast_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析加减表达式（左结合）
// add_expr = mul_expr { ('+' | '-') mul_expr }
fn parser_parse_add_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_mul_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的加减运算符（左结合），含饱和 +|/-|、包装 +%/-%
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_PLUS) != 0 ||
        parser_match(parser, TokenType.TOKEN_MINUS) != 0 ||
        parser_match(parser, TokenType.TOKEN_PLUS_PIPE) != 0 ||
        parser_match(parser, TokenType.TOKEN_MINUS_PIPE) != 0 ||
        parser_match(parser, TokenType.TOKEN_PLUS_PERCENT) != 0 ||
        parser_match(parser, TokenType.TOKEN_MINUS_PERCENT) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_mul_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析位移表达式（左结合）
// shift_expr = add_expr { ('<<' | '>>') add_expr }
fn parser_parse_shift_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    var left: &ASTNode = parser_parse_add_expr(parser);
    if left == null {
        return null;
    }
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_LSHIFT) != 0 ||
        parser_match(parser, TokenType.TOKEN_RSHIFT) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);
        const right: &ASTNode = parser_parse_add_expr(parser);
        if right == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        left = node;
    }
    return left;
}

// 解析比较表达式（左结合）
// rel_expr = shift_expr { ('<' | '>' | '<=' | '>=') shift_expr }
fn parser_parse_rel_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_shift_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的比较运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_LESS) != 0 ||
        parser_match(parser, TokenType.TOKEN_GREATER) != 0 ||
        parser_match(parser, TokenType.TOKEN_LESS_EQUAL) != 0 ||
        parser_match(parser, TokenType.TOKEN_GREATER_EQUAL) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_shift_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析按位与表达式（左结合）
// bitand_expr = eq_expr { '&' eq_expr }
fn parser_parse_bitand_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    var left: &ASTNode = parser_parse_eq_expr(parser);
    if left == null {
        return null;
    }
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_AMPERSAND) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);
        const right: &ASTNode = parser_parse_eq_expr(parser);
        if right == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        left = node;
    }
    return left;
}

// 解析相等性表达式（左结合）
// eq_expr = rel_expr { ('==' | '!=') rel_expr }
fn parser_parse_eq_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_rel_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的相等性运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_EQUAL) != 0 ||
        parser_match(parser, TokenType.TOKEN_NOT_EQUAL) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        var right: &ASTNode = parser_parse_rel_expr(parser);
        if right == null {
            return null;
        }
        
        // 特殊情况：如果右操作数是结构体初始化，且当前 token 是 '{'，且 '{' 后面是 '}'（空块），
        // 这可能是代码块的开始（如 `if p1 == p2 {`），而不是结构体字面量的一部分
        // 为了区分，我们检查当前 token 是否是 '{'
        // 如果是，我们 peek 一下 '{' 后面的内容，如果是 '}'（空块），我们假设这是代码块的开始
        // 在这种情况下，我们需要回退：如果 right 是结构体初始化，我们需要将其替换为标识符
        if parser.current_token != null && 
           parser.current_token.type == TokenType.TOKEN_LEFT_BRACE {
            // 保存 lexer 状态
            const lexer: &Lexer = parser.lexer;
            var saved_position: usize = lexer.position;
            var saved_line: i32 = lexer.line;
            var saved_column: i32 = lexer.column;
            
            // Peek '{' 后面的 token
            const after_brace: &Token = lexer_next_token(lexer, parser.arena);
            if after_brace != null && after_brace.type == TokenType.TOKEN_RIGHT_BRACE {
                // '{' 后面是 '}'（空块），这可能是代码块的开始
                // 恢复 lexer 状态
                lexer.position = saved_position;
                lexer.line = saved_line;
                lexer.column = saved_column;
                
                // 如果 right 是结构体初始化，我们需要将其替换为标识符
                // 因为 '{' 应该是代码块的开始，而不是结构体字面量的一部分
                if right.type == ASTNodeType.AST_STRUCT_INIT {
                    // 获取结构体名称
                    const struct_name: &byte = right.struct_init_struct_name;
                    if struct_name != null {
                        // 创建标识符节点
                        const identifier: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, right.line, right.column, parser.arena, parser_get_filename(parser));
                        if identifier != null {
                            identifier.identifier_name = struct_name;
                            right = identifier;
                        }
                    }
                }
                
                // 停止表达式解析，返回完整的比较表达式（不包含 '{'）
                // 调用者（如 if 语句解析）会处理 '{' 作为代码块
                const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
                if node == null {
                    return null;
                }
                
                node.binary_expr_left = left;
                node.binary_expr_op = op;
                node.binary_expr_right = right;
                
                return node;
            }
            
            // 恢复 lexer 状态
            lexer.position = saved_position;
            lexer.line = saved_line;
            lexer.column = saved_column;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析按位异或表达式（左结合）
// xor_expr = and_expr { '^' and_expr }
fn parser_parse_xor_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    var left: &ASTNode = parser_parse_and_expr(parser);
    if left == null {
        return null;
    }
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_CARET) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);
        const right: &ASTNode = parser_parse_and_expr(parser);
        if right == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        left = node;
    }
    return left;
}

// 解析按位或表达式（左结合）
// bitor_expr = xor_expr { '|' xor_expr }
fn parser_parse_bitor_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    var left: &ASTNode = parser_parse_xor_expr(parser);
    if left == null {
        return null;
    }
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_PIPE) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);
        const right: &ASTNode = parser_parse_xor_expr(parser);
        if right == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        left = node;
    }
    return left;
}

// 解析逻辑与表达式（左结合）
// and_expr = bitand_expr { '&&' bitand_expr }
fn parser_parse_and_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_bitand_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的逻辑与运算符（左结合）
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_LOGICAL_AND) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_bitand_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析逻辑或表达式（左结合）
// or_expr = bitor_expr { '||' bitor_expr }
fn parser_parse_or_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_bitor_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的逻辑或运算符（左结合）
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_LOGICAL_OR) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_bitor_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析赋值表达式（右结合）
// assign_expr = or_expr [ ('=' | '+=' | '-=' | '*=' | '/=' | '%=') assign_expr ]
fn parser_parse_assign_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    const left: &ASTNode = parser_parse_or_expr(parser);
    if left == null {
        return null;
    }
    
    // 检查是否有赋值运算符（包括复合赋值）
    if parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_ASSIGN) != 0 ||
        parser_match(parser, TokenType.TOKEN_PLUS_ASSIGN) != 0 ||
        parser_match(parser, TokenType.TOKEN_MINUS_ASSIGN) != 0 ||
        parser_match(parser, TokenType.TOKEN_ASTERISK_ASSIGN) != 0 ||
        parser_match(parser, TokenType.TOKEN_SLASH_ASSIGN) != 0 ||
        parser_match(parser, TokenType.TOKEN_PERCENT_ASSIGN) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费赋值运算符
        
        // 递归解析赋值表达式（右结合）
        var right: &ASTNode = parser_parse_assign_expr(parser);
        if right == null {
            return null;
        }
        
        // 如果是复合赋值，转换为 x = x op y 的形式
        if op != TokenType.TOKEN_ASSIGN {
            // 创建二元表达式节点（x op y）
            var bin_op: TokenType = TokenType.TOKEN_PLUS;
            if op == TokenType.TOKEN_PLUS_ASSIGN {
                bin_op = TokenType.TOKEN_PLUS;
            } else if op == TokenType.TOKEN_MINUS_ASSIGN {
                bin_op = TokenType.TOKEN_MINUS;
            } else if op == TokenType.TOKEN_ASTERISK_ASSIGN {
                bin_op = TokenType.TOKEN_ASTERISK;
            } else if op == TokenType.TOKEN_SLASH_ASSIGN {
                bin_op = TokenType.TOKEN_SLASH;
            } else if op == TokenType.TOKEN_PERCENT_ASSIGN {
                bin_op = TokenType.TOKEN_PERCENT;
            }
            
            const bin_expr: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
            if bin_expr == null {
                return null;
            }
            bin_expr.binary_expr_left = left;
            bin_expr.binary_expr_op = bin_op;
            bin_expr.binary_expr_right = right;
            right = bin_expr;  // 使用二元表达式作为右操作数
        }
        
        // 创建赋值节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_ASSIGN, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.assign_dest = left;
        node.assign_src = right;
        
        return node;
    }
    
    // 没有赋值运算符，返回左操作数
    return left;
}

// 解析表达式（完整版本）
// expression = assign_expr
fn parser_parse_expression(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 表达式就是赋值表达式
    return parser_parse_assign_expr(parser);
}

// 解析代码块（完善版本，解析语句列表）
fn parser_parse_block(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 '{'
    if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 创建代码块节点
    const block: &ASTNode = ast_new_node(ASTNodeType.AST_BLOCK, line, column, parser.arena, parser_get_filename(parser));
    if block == null {
        return null;
    }
    
    // 初始化语句列表
    var stmts: & & ASTNode = null;
    var stmt_count: i32 = 0;
    var stmt_capacity: i32 = 0;
    
    // 消费 '{'
    parser_consume(parser);
    
    // 解析语句列表
    while parser.current_token != null && 
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        
        // 如果当前token是右大括号，说明是空块，直接退出循环
        if parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) != 0 {
            break;
        }
        
        // 解析语句
        const stmt: &ASTNode = parser_parse_statement(parser);
        if stmt == null {
            // 解析失败：检查是否是因为遇到了右大括号（空块的情况）
            if parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) != 0 {
                // 空块，正常退出循环
                break;
            }
            // 检查是否是 EOF（TokenType.TOKEN_EOF = 0）
            if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_EOF {
                // 遇到文件末尾，正常退出循环（可能是函数体不完整，但这是语法错误，会在其他地方报告）
                break;
            }
            // 否则是真正的解析错误
            // 注意：Uya 版本简化错误报告，不使用 fprintf
            return null;
        }
        
        // 扩展语句数组（使用 Arena 分配）
        if stmt_count >= stmt_capacity {
            var new_capacity: i32 = 0;
                        if stmt_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = stmt_capacity * 2;
                        }
            const new_stmts: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_capacity) as & & ASTNode;
            if new_stmts == null {
                // 注意：Uya 版本简化错误报告
                return null;
            }
            
            // 复制旧语句
            if stmts != null {
                var i: i32 = 0;
                while i < stmt_count {
                    new_stmts[i] = stmts[i];
                    i = i + 1;
                }
            }
            
            stmts = new_stmts;
            stmt_capacity = new_capacity;
        }
        
        stmts[stmt_count] = stmt;
        stmt_count = stmt_count + 1;
    }
    
    // 期望 '}'
    // 注意：如果当前 token 是 'else'，说明可能是 if 语句的 else 分支
    // 但 block 必须以 '}' 结束，所以这里仍然期望 '}'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        // 注意：Uya 版本简化错误报告
        return null;
    }
    
    block.block_stmts = stmts;
    block.block_stmt_count = stmt_count;
    
    return block;
}

// 解析语句
fn parser_parse_statement(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 根据第一个 Token 判断语句类型
    if parser.current_token.type == TokenType.TOKEN_RETURN {
        // 解析 return 语句
        parser_consume(parser);  // 消费 'return'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_RETURN_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 解析返回值表达式（可选，void 函数可以没有返回值）
        if parser_match(parser, TokenType.TOKEN_SEMICOLON) != 0 {
            // 没有返回值（void 函数）
            stmt.return_stmt_expr = null;
            parser_consume(parser);  // 消费 ';'
        } else {
            // 有返回值表达式
            const expr: &ASTNode = parser_parse_expression(parser);
            if expr == null {
                return null;
            }
            stmt.return_stmt_expr = expr;
            
            // 期望 ';'
            if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
                return null;
            }
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_DEFER) != 0 {
        parser_consume(parser);
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_DEFER_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
            stmt.defer_stmt_body = parser_parse_block(parser);
        } else {
            stmt.defer_stmt_body = parser_parse_statement(parser);
        }
        if stmt.defer_stmt_body == null {
            return null;
        }
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_ERRDEFER) != 0 {
        parser_consume(parser);
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_ERRDEFER_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
            stmt.errdefer_stmt_body = parser_parse_block(parser);
        } else {
            stmt.errdefer_stmt_body = parser_parse_statement(parser);
        }
        if stmt.errdefer_stmt_body == null {
            return null;
        }
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_TEST) != 0 {
        parser_consume(parser);  // 消费 'test'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_TEST_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 解析测试说明字符串
        if parser_match(parser, TokenType.TOKEN_STRING) == 0 {
            fprintf(get_stderr(), "错误: 期望测试说明字符串，在第 %d 行第 %d 列\n" as *byte, parser.current_token.line, parser.current_token.column);
            return null;
        }
        stmt.test_stmt_description = parser.current_token.value;
        parser_consume(parser);  // 消费字符串
        
        // 解析测试体（必须是块）
        if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) == 0 {
            fprintf(get_stderr(), "错误: 期望 '{'，在第 %d 行第 %d 列\n" as *byte, parser.current_token.line, parser.current_token.column);
            return null;
        }
        stmt.test_stmt_body = parser_parse_block(parser);
        if stmt.test_stmt_body == null {
            return null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_BREAK) != 0 {
        // 解析 break 语句
        parser_consume(parser);  // 消费 'break'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_BREAK_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 期望 ';'
        if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_CONTINUE) != 0 {
        // 解析 continue 语句
        parser_consume(parser);  // 消费 'continue'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_CONTINUE_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 期望 ';'
        if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_IF) != 0 {
        // 解析 if 语句
        parser_consume(parser);  // 消费 'if'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_IF_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 解析条件表达式
        // 设置上下文为条件表达式上下文，以便在解析表达式时正确区分结构体字面量和代码块
        const saved_context: ParserContext = parser.context;
        parser.context = ParserContext.PARSER_CONTEXT_CONDITION;
        const condition: &ASTNode = parser_parse_expression(parser);
        parser.context = saved_context;  // 恢复上下文
        if condition == null {
            return null;
        }
        stmt.if_stmt_condition = condition;
        
        // 解析 then 分支：允许 { block } 或单条语句（如 if (x) return 2;）
        var then_branch: &ASTNode = null;
        if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
            then_branch = parser_parse_block(parser);
        } else {
            const single: &ASTNode = parser_parse_statement(parser);
            if single == null {
                return null;
            }
            const block: &ASTNode = ast_new_node(ASTNodeType.AST_BLOCK, single.line, single.column, parser.arena, parser_get_filename(parser));
            if block == null {
                return null;
            }
            const stmts: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode)) as & & ASTNode;
            if stmts == null {
                return null;
            }
            stmts[0] = single;
            block.block_stmts = stmts;
            block.block_stmt_count = 1;
            then_branch = block;
        }
        if then_branch == null {
            return null;
        }
        stmt.if_stmt_then_branch = then_branch;
        
        // 解析 else 分支（可选）
        // 支持 else if、else { block }、else 单条语句
        if parser_match(parser, TokenType.TOKEN_ELSE) != 0 {
            parser_consume(parser);  // 消费 'else'
            if parser_match(parser, TokenType.TOKEN_IF) != 0 {
                const else_if_stmt: &ASTNode = parser_parse_statement(parser);
                if else_if_stmt == null {
                    return null;
                }
                stmt.if_stmt_else_branch = else_if_stmt;
            } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
                const else_branch: &ASTNode = parser_parse_block(parser);
                if else_branch == null {
                    return null;
                }
                stmt.if_stmt_else_branch = else_branch;
            } else {
                const single: &ASTNode = parser_parse_statement(parser);
                if single == null {
                    return null;
                }
                const block: &ASTNode = ast_new_node(ASTNodeType.AST_BLOCK, single.line, single.column, parser.arena, parser_get_filename(parser));
                if block == null {
                    return null;
                }
                const stmts: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode)) as & & ASTNode;
                if stmts == null {
                    return null;
                }
                stmts[0] = single;
                block.block_stmts = stmts;
                block.block_stmt_count = 1;
                stmt.if_stmt_else_branch = block;
            }
        } else {
            stmt.if_stmt_else_branch = null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_WHILE) != 0 {
        // 解析 while 语句
        parser_consume(parser);  // 消费 'while'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_WHILE_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 解析条件表达式
        // 设置上下文为条件表达式上下文，以便在解析表达式时正确区分结构体字面量和代码块
        const saved_context: ParserContext = parser.context;
        parser.context = ParserContext.PARSER_CONTEXT_CONDITION;
        const condition: &ASTNode = parser_parse_expression(parser);
        parser.context = saved_context;  // 恢复上下文
        if condition == null {
            return null;
        }
        stmt.while_stmt_condition = condition;
        
        // 解析循环体（代码块）
        const body: &ASTNode = parser_parse_block(parser);
        if body == null {
            return null;
        }
        stmt.while_stmt_body = body;
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_FOR) != 0 {
        parser_consume(parser);  // 消费 'for'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_FOR_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        const first_expr: &ASTNode = parser_parse_xor_expr(parser);
        if first_expr == null {
            return null;
        }
        
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_DOT_DOT {
            stmt.for_stmt_is_range = 1;
            stmt.for_stmt_array = null;
            stmt.for_stmt_range_start = first_expr;
            parser_consume(parser);  // 消费 '..'
            if parser.current_token != null && parser.current_token.type != TokenType.TOKEN_PIPE && parser.current_token.type != TokenType.TOKEN_LEFT_BRACE {
                const end_expr: &ASTNode = parser_parse_xor_expr(parser);
                if end_expr == null {
                    return null;
                }
                stmt.for_stmt_range_end = end_expr;
            } else {
                stmt.for_stmt_range_end = null;
            }
            stmt.for_stmt_is_ref = 0;
            if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_PIPE {
                parser_consume(parser);  // 消费 '|'
                if parser_match(parser, TokenType.TOKEN_AMPERSAND) != 0 {
                    parser_consume(parser);
                    stmt.for_stmt_is_ref = 1;
                }
                const for_var_val: &byte = parser.current_token.value;
                if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                    return null;
                }
                stmt.for_stmt_var_name = arena_strdup(parser.arena, for_var_val);
                parser_consume(parser);
                if parser_expect(parser, TokenType.TOKEN_PIPE) == null {
                    return null;
                }
            } else {
                stmt.for_stmt_var_name = null;
            }
        } else {
            stmt.for_stmt_is_range = 0;
            stmt.for_stmt_range_start = null;
            stmt.for_stmt_range_end = null;
            stmt.for_stmt_array = first_expr;
            if parser_expect(parser, TokenType.TOKEN_PIPE) == null {
                return null;
            }
            var is_ref: i32 = 0;
            if parser_match(parser, TokenType.TOKEN_AMPERSAND) != 0 {
                parser_consume(parser);
                is_ref = 1;
            }
            const for_var_val: &byte = parser.current_token.value;
            if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                return null;
            }
            stmt.for_stmt_var_name = arena_strdup(parser.arena, for_var_val);
            parser_consume(parser);
            if parser_expect(parser, TokenType.TOKEN_PIPE) == null {
                return null;
            }
            stmt.for_stmt_is_ref = is_ref;
        }
        
        const body: &ASTNode = parser_parse_block(parser);
        if body == null {
            return null;
        }
        stmt.for_stmt_body = body;
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_CONST) != 0 || parser_match(parser, TokenType.TOKEN_VAR) != 0 {
        // 解析变量声明
        var is_const: i32 = 0;
        if parser_match(parser, TokenType.TOKEN_CONST) != 0 {
            is_const = 1;
        } else {
            is_const = 0;
        }
        parser_consume(parser);  // 消费 'const' 或 'var'
        
        // 解构声明：const (x, y) = expr; 或 var (x, _) = expr;
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LEFT_PAREN {
            parser_consume(parser);  // 消费 '('
            
            var names: & & byte = arena_alloc(parser.arena, @size_of(&byte) * 16) as & & byte;
            if names == null {
                return null;
            }
            var cap: i32 = 16;
            var count: i32 = 0;
            
            while parser.current_token != null && parser.current_token.type != TokenType.TOKEN_RIGHT_PAREN {
                if count > 0 {
                    if parser_expect(parser, TokenType.TOKEN_COMMA) == null {
                        return null;
                    }
                }
                const name_val: &byte = parser.current_token.value;
                if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                    return null;
                }
                const name: &byte = arena_strdup(parser.arena, name_val);
                if name == null {
                    return null;
                }
                parser_consume(parser);  // 消费标识符
                if count >= cap {
                    const new_cap: i32 = cap * 2;
                    const new_names: & & byte = arena_alloc(parser.arena, @size_of(&byte) * new_cap) as & & byte;
                    if new_names == null {
                        return null;
                    }
                    var i: i32 = 0;
                    while i < count {
                        new_names[i] = names[i];
                        i = i + 1;
                    }
                    names = new_names;
                    cap = new_cap;
                }
                names[count] = name;
                count = count + 1;
            }
            
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            if parser_expect(parser, TokenType.TOKEN_ASSIGN) == null {
                return null;
            }
            
            const saved_context: ParserContext = parser.context;
            parser.context = ParserContext.PARSER_CONTEXT_VAR_INIT;
            const init: &ASTNode = parser_parse_expression(parser);
            parser.context = saved_context;
            if init == null {
                return null;
            }
            if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
                return null;
            }
            
            const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_DESTRUCTURE_DECL, line, column, parser.arena, parser_get_filename(parser));
            if stmt == null {
                return null;
            }
            stmt.destructure_decl_names = names;
            stmt.destructure_decl_name_count = count;
            stmt.destructure_decl_is_const = is_const;
            stmt.destructure_decl_init = init;
            return stmt;
        }
        
        // 期望变量名称，允许 'type' 关键字作为变量名
        var var_name: &byte = null;
        if parser_match(parser, TokenType.TOKEN_TYPE) != 0 {
            var_name = arena_strdup(parser.arena, "type" as &byte);
        } else if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
            var_name = arena_strdup(parser.arena, parser.current_token.value);
        } else {
            return null;
        }
        if var_name == null {
            return null;
        }
        
        parser_consume(parser);  // 消费变量名称
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_VAR_DECL, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        stmt.var_decl_name = var_name;
        stmt.var_decl_is_const = is_const;
        
        // 期望 ':'
        if parser_expect(parser, TokenType.TOKEN_COLON) == null {
            return null;
        }
        
        // 解析类型
        const type: &ASTNode = parser_parse_type(parser);
        if type == null {
            return null;
        }
        stmt.var_decl_type = type;
        
        // 期望 '='
        if parser_expect(parser, TokenType.TOKEN_ASSIGN) == null {
            // 变量未初始化：注意：Uya 版本简化错误报告
            return null;
        }
        
        // 解析初始值表达式
        // 设置上下文为变量初始化上下文，以便在解析表达式时正确区分结构体字面量和代码块
        const saved_context: ParserContext = parser.context;
        parser.context = ParserContext.PARSER_CONTEXT_VAR_INIT;
        const init: &ASTNode = parser_parse_expression(parser);
        parser.context = saved_context;  // 恢复上下文
        if init == null {
            return null;
        }
        stmt.var_decl_init = init;
        
        // 期望 ';'
        if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    // 注意：根据规范，enum 和 struct 只能在顶层定义，不能在函数内部或其他局部作用域内定义
    // 因此这里不处理 TokenType.TOKEN_STRUCT 和 TokenType.TOKEN_ENUM
    // 函数内部也不允许定义函数（嵌套函数不支持）
    
    if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
        // 解析代码块语句
        return parser_parse_block(parser);
    }
    
    // 解析表达式语句（表达式后加分号）
    // 注意：ASTNodeType.AST_EXPR_STMT 节点在 union 中没有对应的数据结构
    // 根据 ast.c 的注释，表达式语句的数据存储在表达式的节点中
    // 所以这里直接返回表达式节点（表达式节点本身可以作为语句）
    
    // 如果当前token是右大括号，说明是空块，返回NULL（由调用者处理）
    if parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) != 0 {
        return null;
    }
    
    const expr: &ASTNode = parser_parse_expression(parser);
    if expr == null {
        // 如果当前token是右大括号，说明是空块，返回NULL（由调用者处理）
        if parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) != 0 {
            return null;
        }
        return null;
    }
    
    // 期望 ';'
    if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
        return null;
    }
    
    // 直接返回表达式节点（表达式节点可以作为语句）
    return expr;
}

// 解析接口声明：interface ID { fn method(self: *Self,...) Ret; ... }
fn parser_parse_interface(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    if parser_match(parser, TokenType.TOKEN_INTERFACE) == 0 {
        return null;
    }
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    parser_consume(parser);
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    const iface_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
    if iface_name == null {
        return null;
    }
    parser_consume(parser);
    
    // 解析泛型参数列表（可选）：<T> 或 <T: Ord>
    var iface_type_params: &TypeParam = null;
    var iface_type_param_count: i32 = 0;
    if parser.current_token != null && parser_match(parser, TokenType.TOKEN_LESS) != 0 {
        var type_param_capacity: i32 = 0;
        
        parser_consume(parser);  // 消费 '<'
        
        while parser.current_token != null &&
              parser_match(parser, TokenType.TOKEN_GREATER) == 0 &&
              parser_match(parser, TokenType.TOKEN_EOF) == 0 {
            
            if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                return null;
            }
            
            const param_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
            if param_name == null {
                return null;
            }
            parser_consume(parser);
            
            if iface_type_param_count >= type_param_capacity {
                var new_cap: i32 = 0;
                if type_param_capacity == 0 {
                    new_cap = 4;
                } else {
                    new_cap = type_param_capacity * 2;
                }
                const new_params: &TypeParam = arena_alloc(parser.arena, @size_of(TypeParam) * new_cap) as &TypeParam;
                if new_params == null {
                    return null;
                }
                var k: i32 = 0;
                while k < iface_type_param_count {
                    new_params[k] = iface_type_params[k];
                    k = k + 1;
                }
                iface_type_params = new_params;
                type_param_capacity = new_cap;
            }
            
            iface_type_params[iface_type_param_count].name = param_name;
            iface_type_params[iface_type_param_count].constraints = null;
            iface_type_params[iface_type_param_count].constraint_count = 0;
            
            // 解析约束（可选）
            if parser_match(parser, TokenType.TOKEN_COLON) != 0 {
                parser_consume(parser);
                var constraints: & & byte = null;
                var constraint_count: i32 = 0;
                var constraint_capacity: i32 = 0;
                
                while parser.current_token != null &&
                      parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
                    const constraint_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
                    if constraint_name == null {
                        return null;
                    }
                    parser_consume(parser);
                    
                    if constraint_count >= constraint_capacity {
                        var new_cap2: i32 = 0;
                        if constraint_capacity == 0 {
                            new_cap2 = 4;
                        } else {
                            new_cap2 = constraint_capacity * 2;
                        }
                        const new_constraints: & & byte = arena_alloc(parser.arena, @size_of(&byte) * new_cap2) as & & byte;
                        if new_constraints == null {
                            return null;
                        }
                        var m: i32 = 0;
                        while m < constraint_count {
                            new_constraints[m] = constraints[m];
                            m = m + 1;
                        }
                        constraints = new_constraints;
                        constraint_capacity = new_cap2;
                    }
                    
                    constraints[constraint_count] = constraint_name;
                    constraint_count = constraint_count + 1;
                    
                    if parser_match(parser, TokenType.TOKEN_PLUS) != 0 {
                        parser_consume(parser);
                    } else {
                        break;
                    }
                }
                
                iface_type_params[iface_type_param_count].constraints = constraints;
                iface_type_params[iface_type_param_count].constraint_count = constraint_count;
            }
            
            iface_type_param_count = iface_type_param_count + 1;
            
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            } else {
                break;
            }
        }
        
        if parser_expect(parser, TokenType.TOKEN_GREATER) == null {
            return null;
        }
    }
    
    if parser_expect(parser, TokenType.TOKEN_LEFT_BRACE) == null {
        return null;
    }
    var sigs: & & ASTNode = null;
    var sig_count: i32 = 0;
    var sig_cap: i32 = 0;
    // 组合接口数组
    var composed: & & byte = null;
    var composed_count: i32 = 0;
    var composed_cap: i32 = 0;
    while parser.current_token != null &&
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        // 检查是否为组合接口引用（标识符后跟分号）
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
            // 这是组合接口引用：IReader;
            const composed_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
            if composed_name == null {
                return null;
            }
            parser_consume(parser);  // 消费标识符
            if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
                return null;
            }
            
            if composed_count >= composed_cap {
                var new_cap2: i32 = 0;
                if composed_cap == 0 {
                    new_cap2 = 4;
                } else {
                    new_cap2 = composed_cap * 2;
                }
                const new_composed: & & byte = arena_alloc(parser.arena, @size_of(&byte) * new_cap2) as & & byte;
                if new_composed == null {
                    return null;
                }
                var k: i32 = 0;
                while k < composed_count {
                    new_composed[k] = composed[k];
                    k = k + 1;
                }
                composed = new_composed;
                composed_cap = new_cap2;
            }
            composed[composed_count] = composed_name;
            composed_count = composed_count + 1;
            continue;
        }
        if parser_match(parser, TokenType.TOKEN_FN) == 0 {
            return null;
        }
        const ml: i32 = parser.current_token.line;
        const mcol: i32 = parser.current_token.column;
        parser_consume(parser);
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        const method_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if method_name == null {
            return null;
        }
        parser_consume(parser);
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        var params: & & ASTNode = null;
        var param_count: i32 = 0;
        var param_cap: i32 = 0;
        while parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 &&
              parser_match(parser, TokenType.TOKEN_EOF) == 0 {
            if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                return null;
            }
            const pname: &byte = arena_strdup(parser.arena, parser.current_token.value);
            if pname == null {
                return null;
            }
            parser_consume(parser);
            if parser_expect(parser, TokenType.TOKEN_COLON) == null {
                return null;
            }
            const ptype: &ASTNode = parser_parse_type(parser);
            if ptype == null {
                return null;
            }
            if param_count >= param_cap {
                var new_cap: i32 = 0;
                if param_cap == 0 {
                    new_cap = 4;
                } else {
                    new_cap = param_cap * 2;
                }
                const new_p: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
                if new_p == null {
                    return null;
                }
                var i: i32 = 0;
                while i < param_count {
                    new_p[i] = params[i];
                    i = i + 1;
                }
                params = new_p;
                param_cap = new_cap;
            }
            const pnode: &ASTNode = ast_new_node(ASTNodeType.AST_VAR_DECL, ml, mcol, parser.arena, parser_get_filename(parser));
            if pnode == null {
                return null;
            }
            pnode.var_decl_name = pname;
            pnode.var_decl_type = ptype;
            pnode.var_decl_init = null;
            pnode.var_decl_is_const = 0;
            params[param_count] = pnode;
            param_count = param_count + 1;
            if parser_match(parser, TokenType.TOKEN_COMMA) == 0 {
                break;
            }
            parser_consume(parser);
        }
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        const ret_type: &ASTNode = parser_parse_type(parser);
        if ret_type == null {
            return null;
        }
        if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
            return null;
        }
        const sig: &ASTNode = ast_new_node(ASTNodeType.AST_FN_DECL, ml, mcol, parser.arena, parser_get_filename(parser));
        if sig == null {
            return null;
        }
        sig.fn_decl_name = method_name;
        sig.fn_decl_params = params;
        sig.fn_decl_param_count = param_count;
        sig.fn_decl_return_type = ret_type;
        sig.fn_decl_body = null;
        sig.fn_decl_is_varargs = 0;
        if sig_count >= sig_cap {
            var new_cap: i32 = 0;
            if sig_cap == 0 {
                new_cap = 4;
            } else {
                new_cap = sig_cap * 2;
            }
            const new_sigs: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
            if new_sigs == null {
                return null;
            }
            var i: i32 = 0;
            while i < sig_count {
                new_sigs[i] = sigs[i];
                i = i + 1;
            }
            sigs = new_sigs;
            sig_cap = new_cap;
        }
        sigs[sig_count] = sig;
        sig_count = sig_count + 1;
    }
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    const node: &ASTNode = ast_new_node(ASTNodeType.AST_INTERFACE_DECL, line, column, parser.arena, parser_get_filename(parser));
    if node == null {
        return null;
    }
    node.interface_decl_name = iface_name;
    node.interface_decl_type_params = iface_type_params;
    node.interface_decl_type_param_count = iface_type_param_count;
    node.interface_decl_method_sigs = sigs;
    node.interface_decl_method_sig_count = sig_count;
    node.interface_decl_composed_interfaces = composed;
    node.interface_decl_composed_count = composed_count;
    return node;
}

// 解析方法块：StructName { fn method(...) { ... } ... }（调用时 struct_name 与 '{' 已消费，当前为块内首 token）
// 也支持在方法块中调用 struct 返回类型的宏：macro_name(args);
fn parser_parse_method_block(parser: &Parser, struct_name: &byte) &ASTNode {
    if parser == null || parser.current_token == null || struct_name == null {
        return null;
    }
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    var methods: & & ASTNode = null;
    var method_count: i32 = 0;
    var method_cap: i32 = 0;
    while parser.current_token != null &&
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        var item: &ASTNode = null;
        
        if parser_match(parser, TokenType.TOKEN_FN) != 0 {
            // 解析方法定义
            item = parser_parse_function(parser);
        } else if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
            // 可能是宏调用：macro_name(args);
            const item_line: i32 = parser.current_token.line;
            const item_col: i32 = parser.current_token.column;
            const name: &byte = arena_strdup(parser.arena, parser.current_token.value);
            if name == null {
                return null;
            }
            parser_consume(parser);
            
            if parser_match(parser, TokenType.TOKEN_LEFT_PAREN) != 0 {
                // 宏调用：name(args);
                parser_consume(parser);  // 消费 '('
                
                const callee: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, item_line, item_col, parser.arena, parser_get_filename(parser));
                if callee == null {
                    return null;
                }
                callee.identifier_name = name;
                
                const call: &ASTNode = ast_new_node(ASTNodeType.AST_CALL_EXPR, item_line, item_col, parser.arena, parser_get_filename(parser));
                if call == null {
                    return null;
                }
                call.call_expr_callee = callee;
                call.call_expr_has_ellipsis_forward = 0;
                
                // 解析参数列表
                var args: & & ASTNode = null;
                var arg_count: i32 = 0;
                var arg_cap: i32 = 0;
                while parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
                    const arg: &ASTNode = parser_parse_expression(parser);
                    if arg == null {
                        return null;
                    }
                    if arg_count >= arg_cap {
                        var new_cap: i32 = 4;
                        if arg_cap != 0 {
                            new_cap = arg_cap * 2;
                        }
                        const new_args: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
                        if new_args == null {
                            return null;
                        }
                        var j: i32 = 0;
                        while j < arg_count {
                            new_args[j] = args[j];
                            j = j + 1;
                        }
                        args = new_args;
                        arg_cap = new_cap;
                    }
                    args[arg_count] = arg;
                    arg_count = arg_count + 1;
                    if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    }
                }
                if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                    return null;
                }
                if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
                    return null;
                }
                
                call.call_expr_args = args;
                call.call_expr_arg_count = arg_count;
                item = call;
            } else {
                const stderr: *void = get_stderr();
                fprintf(stderr, "错误: 方法块内期望 'fn' 或宏调用\n" as *byte);
                return null;
            }
        } else {
            // 不是 fn 也不是标识符，跳出循环
            break;
        }
        
        if item == null {
            return null;
        }
        if method_count >= method_cap {
            var new_cap: i32 = 0;
            if method_cap == 0 {
                new_cap = 4;
            } else {
                new_cap = method_cap * 2;
            }
            const new_m: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
            if new_m == null {
                return null;
            }
            var i: i32 = 0;
            while i < method_count {
                new_m[i] = methods[i];
                i = i + 1;
            }
            methods = new_m;
            method_cap = new_cap;
        }
        methods[method_count] = item;
        method_count = method_count + 1;
    }
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    const node: &ASTNode = ast_new_node(ASTNodeType.AST_METHOD_BLOCK, line, column, parser.arena, parser_get_filename(parser));
    if node == null {
        return null;
    }
    node.method_block_struct_name = struct_name;
    node.method_block_methods = methods;
    node.method_block_method_count = method_count;
    return node;
}

// 解析结构体声明：struct ID { field_list }
// field_list = field { ',' field }
// field = ID ':' type
fn parser_parse_struct(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'struct'
    if parser_match(parser, TokenType.TOKEN_STRUCT) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'struct'
    parser_consume(parser);
    
    // 期望结构体名称
    const struct_name_val: &byte = parser.current_token.value;
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    const struct_name: &byte = arena_strdup(parser.arena, struct_name_val);
    if struct_name == null {
        return null;
    }
    
    // 消费结构体名称
    parser_consume(parser);
    
    // 创建结构体声明节点
    const struct_decl: &ASTNode = ast_new_node(ASTNodeType.AST_STRUCT_DECL, line, column, parser.arena, parser_get_filename(parser));
    if struct_decl == null {
        return null;
    }
    
    struct_decl.struct_decl_name = struct_name;
    struct_decl.struct_decl_type_params = null;
    struct_decl.struct_decl_type_param_count = 0;
    struct_decl.struct_decl_interface_names = null;
    struct_decl.struct_decl_interface_count = 0;
    struct_decl.struct_decl_fields = null;
    struct_decl.struct_decl_field_count = 0;
    
    // 解析泛型参数列表（可选）：<T> 或 <T: Ord> 或 <T: Ord + Clone>
    if parser.current_token != null && parser_match(parser, TokenType.TOKEN_LESS) != 0 {
        var type_params: &TypeParam = null;
        var type_param_count: i32 = 0;
        var type_param_capacity: i32 = 0;
        
        parser_consume(parser);  // 消费 '<'
        
        while parser.current_token != null &&
              parser_match(parser, TokenType.TOKEN_GREATER) == 0 &&
              parser_match(parser, TokenType.TOKEN_EOF) == 0 {
            
            // 解析类型参数名称
            if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                return null;  // 错误：期望类型参数名称
            }
            
            const param_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
            if param_name == null {
                return null;
            }
            parser_consume(parser);
            
            // 分配类型参数结构
            if type_param_count >= type_param_capacity {
                var new_cap: i32 = 0;
                if type_param_capacity == 0 {
                    new_cap = 4;
                } else {
                    new_cap = type_param_capacity * 2;
                }
                const new_params: &TypeParam = arena_alloc(parser.arena, @size_of(TypeParam) * new_cap) as &TypeParam;
                if new_params == null {
                    return null;
                }
                var i: i32 = 0;
                while i < type_param_count {
                    new_params[i] = type_params[i];
                    i = i + 1;
                }
                type_params = new_params;
                type_param_capacity = new_cap;
            }
            
            type_params[type_param_count].name = param_name;
            type_params[type_param_count].constraints = null;
            type_params[type_param_count].constraint_count = 0;
            
            // 解析约束（可选）：: Ord 或 : Ord + Clone
            if parser_match(parser, TokenType.TOKEN_COLON) != 0 {
                parser_consume(parser);  // 消费 ':'
                
                var constraints: & & byte = null;
                var constraint_count: i32 = 0;
                var constraint_capacity: i32 = 0;
                
                // 解析约束列表（用 + 连接）
                while parser.current_token != null &&
                      parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
                    
                    const constraint_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
                    if constraint_name == null {
                        return null;
                    }
                    parser_consume(parser);
                    
                    if constraint_count >= constraint_capacity {
                        var new_cap2: i32 = 0;
                        if constraint_capacity == 0 {
                            new_cap2 = 4;
                        } else {
                            new_cap2 = constraint_capacity * 2;
                        }
                        const new_constraints: & & byte = arena_alloc(parser.arena, @size_of(&byte) * new_cap2) as & & byte;
                        if new_constraints == null {
                            return null;
                        }
                        var j: i32 = 0;
                        while j < constraint_count {
                            new_constraints[j] = constraints[j];
                            j = j + 1;
                        }
                        constraints = new_constraints;
                        constraint_capacity = new_cap2;
                    }
                    
                    constraints[constraint_count] = constraint_name;
                    constraint_count = constraint_count + 1;
                    
                    // 检查是否有 '+' 连接更多约束
                    if parser_match(parser, TokenType.TOKEN_PLUS) != 0 {
                        parser_consume(parser);
                    } else {
                        break;
                    }
                }
                
                type_params[type_param_count].constraints = constraints;
                type_params[type_param_count].constraint_count = constraint_count;
            }
            
            type_param_count = type_param_count + 1;
            
            // 检查是否有逗号（多个类型参数）
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            } else {
                break;
            }
        }
        
        if parser_expect(parser, TokenType.TOKEN_GREATER) == null {
            return null;  // 错误：期望 '>'
        }
        
        struct_decl.struct_decl_type_params = type_params;
        struct_decl.struct_decl_type_param_count = type_param_count;
    }
    
    // 可选的 ': InterfaceName { , InterfaceName }'
    // 支持泛型接口：Interface<T1, T2>
    if parser_match(parser, TokenType.TOKEN_COLON) != 0 {
        parser_consume(parser);
        var ifaces: & & byte = null;
        var iface_capacity: i32 = 0;
        var iface_count: i32 = 0;
        while parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
            if iface_count >= iface_capacity {
                var new_cap: i32 = 0;
                if iface_capacity == 0 {
                    new_cap = 4;
                } else {
                    new_cap = iface_capacity * 2;
                }
                const new_ifaces: & & byte = arena_alloc(parser.arena, @size_of(&byte) * new_cap) as & & byte;
                if new_ifaces == null {
                    return null;
                }
                var i: i32 = 0;
                while i < iface_count {
                    new_ifaces[i] = ifaces[i];
                    i = i + 1;
                }
                ifaces = new_ifaces;
                iface_capacity = new_cap;
            }
            
            // 获取接口名称
            const iface_base_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
            if iface_base_name == null {
                return null;
            }
            parser_consume(parser);
            
            // 检查是否有泛型类型参数 <T1, T2, ...>
            if parser_match(parser, TokenType.TOKEN_LESS) != 0 {
                // 构建完整的泛型接口名称（如 Container<i32>）
                var full_name: [byte: 512] = [];
                var pos: i32 = 0;
                pos = pos + snprintf((full_name as *byte) + pos, 512 - pos, "%s<" as *byte, iface_base_name as *byte);
                
                parser_consume(parser);  // 消费 '<'
                
                var first_type_arg: i32 = 1;
                while parser.current_token != null && 
                      parser_match(parser, TokenType.TOKEN_GREATER) == 0 && 
                      parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                    if first_type_arg == 0 {
                        pos = pos + snprintf((full_name as *byte) + pos, 512 - pos, ", " as *byte);
                    }
                    first_type_arg = 0;
                    
                    // 解析类型名称（简单实现：只支持标识符）
                    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
                        pos = pos + snprintf((full_name as *byte) + pos, 512 - pos, "%s" as *byte, parser.current_token.value as *byte);
                        parser_consume(parser);
                    } else {
                        // 不支持的类型，跳过
                        parser_consume(parser);
                    }
                    
                    // 检查逗号
                    if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    } else {
                        break;
                    }
                }
                
                const expect_gt: i32 = parser_expect(parser, TokenType.TOKEN_GREATER);
                if expect_gt == 0 {
                    return null;  // 错误：期望 '>'
                }
                
                pos = pos + snprintf((full_name as *byte) + pos, 512 - pos, ">" as *byte);
                ifaces[iface_count] = arena_strdup(parser.arena, full_name as *byte);
            } else {
                ifaces[iface_count] = iface_base_name;
            }
            
            if ifaces[iface_count] == null {
                return null;
            }
            iface_count = iface_count + 1;
            
            if parser_match(parser, TokenType.TOKEN_COMMA) == 0 {
                break;
            }
            parser_consume(parser);
        }
        struct_decl.struct_decl_interface_names = ifaces;
        struct_decl.struct_decl_interface_count = iface_count;
    }
    
    // 期望 '{'
    if parser_expect(parser, TokenType.TOKEN_LEFT_BRACE) == null {
        return null;
    }
    
    // 解析字段列表和内部方法
    // 字段列表：field { ',' field }
    // field = ID ':' type
    // 内部方法：fn ID '(' params ')' type '{' body '}'
    var fields: & & ASTNode = null;
    var field_count: i32 = 0;
    var field_capacity: i32 = 0;
    
    var methods: & & ASTNode = null;
    var method_count: i32 = 0;
    var method_capacity: i32 = 0;
    
    while parser.current_token != null && 
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        
        // 检查是否为内部方法定义（fn 关键字）
        if parser_match(parser, TokenType.TOKEN_FN) != 0 {
            // 解析内部方法
            const method: &ASTNode = parser_parse_function(parser);
            if method == null {
                return null;
            }
            
            // 扩展方法数组
            if method_count >= method_capacity {
                var new_cap: i32 = 0;
                if method_capacity == 0 {
                    new_cap = 4;
                } else {
                    new_cap = method_capacity * 2;
                }
                const new_methods: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
                if new_methods == null {
                    return null;
                }
                
                if methods != null {
                    var i: i32 = 0;
                    while i < method_count {
                        new_methods[i] = methods[i];
                        i = i + 1;
                    }
                }
                
                methods = new_methods;
                method_capacity = new_cap;
            }
            
            methods[method_count] = method;
            method_count = method_count + 1;
            
            // 方法后可选逗号
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            }
            continue;
        }
        
        // 解析字段名称（允许 'type' 关键字作为字段名）
        var field_name: &byte = null;
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
            field_name = arena_strdup(parser.arena, parser.current_token.value);
        } else if parser_match(parser, TokenType.TOKEN_TYPE) != 0 {
            field_name = arena_strdup(parser.arena, "type" as &byte);
        } else {
            return null;
        }
        if field_name == null {
            return null;
        }
        
        const field_line: i32 = parser.current_token.line;
        const field_column: i32 = parser.current_token.column;
        
        parser_consume(parser);
        
        // 期望 ':'
        if parser_expect(parser, TokenType.TOKEN_COLON) == null {
            return null;
        }
        
        // 解析字段类型
        const field_type: &ASTNode = parser_parse_type(parser);
        if field_type == null {
            return null;
        }
        
        // 检查是否有默认值（= expr）
        var default_value: &ASTNode = null;
        if parser_match(parser, TokenType.TOKEN_ASSIGN) != 0 {
            parser_consume(parser);  // 消费 '='
            default_value = parser_parse_expression(parser);
            if default_value == null {
                return null;
            }
        }
        
        // 创建字段节点（使用 ASTNodeType.AST_VAR_DECL，is_const = 0）
        const field: &ASTNode = ast_new_node(ASTNodeType.AST_VAR_DECL, field_line, field_column, parser.arena, parser_get_filename(parser));
        if field == null {
            return null;
        }
        
        field.var_decl_name = field_name;
        field.var_decl_type = field_type;
        field.var_decl_init = default_value;  // 存储默认值
        field.var_decl_is_const = 0;
        
        // 扩展字段数组（使用 Arena 分配）
        if field_count >= field_capacity {
            var new_capacity: i32 = 0;
                        if field_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = field_capacity * 2;
                        }
            const new_fields: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_capacity) as & & ASTNode;
            if new_fields == null {
                // 注意：Uya 版本简化错误报告
                return null;
            }
            
            // 复制旧字段
            if fields != null {
                var i: i32 = 0;
                while i < field_count {
                    new_fields[i] = fields[i];
                    i = i + 1;
                }
            }
            
            fields = new_fields;
            field_capacity = new_capacity;
        }
        
        fields[field_count] = field;
        field_count = field_count + 1;
        
        // 检查是否有逗号（可选，最后一个字段后不需要逗号）
        if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
            parser_consume(parser);
        }
    }
    
    // 期望 '}'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    
    struct_decl.struct_decl_fields = fields;
    struct_decl.struct_decl_field_count = field_count;
    struct_decl.struct_decl_methods = methods;
    struct_decl.struct_decl_method_count = method_count;
    
    return struct_decl;
}

// 解析联合体声明主体：当前 token 为联合体名称 ID，解析 ID { variant_list }；is_extern!=0 时不解析 fn 方法
fn parser_parse_union_body(parser: &Parser, line: i32, column: i32, is_extern: i32) &ASTNode {
    if parser == null || parser.current_token == null || parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    const union_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
    if union_name == null {
        return null;
    }
    parser_consume(parser);
    const union_decl: &ASTNode = ast_new_node(ASTNodeType.AST_UNION_DECL, line, column, parser.arena, parser_get_filename(parser));
    if union_decl == null {
        return null;
    }
    union_decl.union_decl_name = union_name;
    union_decl.union_decl_is_extern = is_extern;
    if parser_expect(parser, TokenType.TOKEN_LEFT_BRACE) == null {
        return null;
    }
    var variants: & & ASTNode = null;
    var variant_count: i32 = 0;
    var variant_capacity: i32 = 0;
    var methods: & & ASTNode = null;
    var method_count: i32 = 0;
    var method_capacity: i32 = 0;
    while parser.current_token != null &&
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 &&
          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        if is_extern == 0 && parser_match(parser, TokenType.TOKEN_FN) != 0 {
            const method: &ASTNode = parser_parse_function(parser);
            if method == null {
                return null;
            }
            if method_count >= method_capacity {
                var new_cap: i32 = 0;
                if method_capacity == 0 {
                    new_cap = 4;
                } else {
                    new_cap = method_capacity * 2;
                }
                const new_m: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
                if new_m == null {
                    return null;
                }
                var i: i32 = 0;
                while i < method_count {
                    new_m[i] = methods[i];
                    i = i + 1;
                }
                methods = new_m;
                method_capacity = new_cap;
            }
            methods[method_count] = method;
            method_count = method_count + 1;
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            }
            continue;
        }
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        const v_line: i32 = parser.current_token.line;
        const v_column: i32 = parser.current_token.column;
        const variant_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if variant_name == null {
            return null;
        }
        parser_consume(parser);
        if parser_expect(parser, TokenType.TOKEN_COLON) == null {
            return null;
        }
        const variant_type: &ASTNode = parser_parse_type(parser);
        if variant_type == null {
            return null;
        }
        const variant: &ASTNode = ast_new_node(ASTNodeType.AST_VAR_DECL, v_line, v_column, parser.arena, parser_get_filename(parser));
        if variant == null {
            return null;
        }
        variant.var_decl_name = variant_name;
        variant.var_decl_type = variant_type;
        variant.var_decl_init = null;
        variant.var_decl_is_const = 0;
        if variant_count >= variant_capacity {
            var new_cap: i32 = 0;
            if variant_capacity == 0 {
                new_cap = 4;
            } else {
                new_cap = variant_capacity * 2;
            }
            const new_v: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_cap) as & & ASTNode;
            if new_v == null {
                return null;
            }
            var i: i32 = 0;
            while i < variant_count {
                new_v[i] = variants[i];
                i = i + 1;
            }
            variants = new_v;
            variant_capacity = new_cap;
        }
        variants[variant_count] = variant;
        variant_count = variant_count + 1;
        if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
            parser_consume(parser);
        }
    }
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    union_decl.union_decl_variants = variants;
    union_decl.union_decl_variant_count = variant_count;
    union_decl.union_decl_methods = methods;
    union_decl.union_decl_method_count = method_count;
    return union_decl;
}

// 解析联合体声明：union ID { variant_list }

// 解析类型别名：type Name = Type ;
fn parser_parse_type_alias(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    if parser_match(parser, TokenType.TOKEN_TYPE) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    parser_consume(parser);
    
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        const stderr: *void = get_stderr();
        fprintf(stderr, "错误: type 后期望标识符\n" as *byte);
        return null;
    }
    
    const alias_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
    if alias_name == null {
        return null;
    }
    parser_consume(parser);
    
    if parser_expect(parser, TokenType.TOKEN_ASSIGN) == null {
        return null;
    }
    
    const target_type: &ASTNode = parser_parse_type(parser);
    if target_type == null {
        const stderr: *void = get_stderr();
        fprintf(stderr, "错误: type 别名需要目标类型\n" as *byte);
        return null;
    }
    
    if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
        return null;
    }
    
    const type_alias: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_ALIAS, line, column, parser.arena, parser_get_filename(parser));
    if type_alias == null {
        return null;
    }
    
    type_alias.type_alias_name = alias_name;
    type_alias.type_alias_target_type = target_type;
    type_alias.type_alias_is_export = 0;
    
    return type_alias;
}

// 解析宏声明：mc ID(param_list) return_tag { statements }
fn parser_parse_macro(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    if parser_match(parser, TokenType.TOKEN_MC) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    parser_consume(parser);
    
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        const stderr: *void = get_stderr();
        fprintf(stderr, "错误: 'mc' 后期望宏名称\n" as *byte);
        return null;
    }
    
    const macro_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
    if macro_name == null {
        return null;
    }
    
    parser_consume(parser);
    
    const macro_decl: &ASTNode = ast_new_node(ASTNodeType.AST_MACRO_DECL, line, column, parser.arena, parser_get_filename(parser));
    if macro_decl == null {
        return null;
    }
    
    macro_decl.macro_decl_name = macro_name;
    macro_decl.macro_decl_params = null;
    macro_decl.macro_decl_param_count = 0;
    
    // 期望 '('
    if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
        return null;
    }
    
    // 解析参数列表（可选）
    var params: & & ASTNode = null;
    var param_count: i32 = 0;
    var param_capacity: i32 = 0;
    
    if parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
        // 有参数，进入解析循环
        while parser.current_token != null && 
              parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 && 
              parser_match(parser, TokenType.TOKEN_EOF) == 0 {
            
            // 解析参数名称，允许 'type' 关键字作为参数名
            const param_line: i32 = parser.current_token.line;
            const param_column: i32 = parser.current_token.column;
            var param_name: &byte = null;
            if parser_match(parser, TokenType.TOKEN_TYPE) != 0 {
                param_name = arena_strdup(parser.arena, "type" as &byte);
            } else if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
                param_name = arena_strdup(parser.arena, parser.current_token.value);
            } else {
                const stderr: *void = get_stderr();
                fprintf(stderr, "错误: 宏参数列表中期望参数名称\n" as *byte);
                return null;
            }
            if param_name == null {
                return null;
            }
            
            parser_consume(parser);
            
            // 期望 ':'
            if parser_expect(parser, TokenType.TOKEN_COLON) == null {
                return null;
            }
            
            // 解析参数类型（expr, stmt, type, pattern, ident）
            // 注意：'type' 既是关键字又是宏参数类型，需要同时接受 TOKEN_IDENTIFIER 和 TOKEN_TYPE
            var param_type_str: &byte = null;
            if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
                param_type_str = arena_strdup(parser.arena, parser.current_token.value);
            } else if parser_match(parser, TokenType.TOKEN_TYPE) != 0 {
                param_type_str = arena_strdup(parser.arena, "type" as &byte);
            } else {
                const stderr: *void = get_stderr();
                fprintf(stderr, "错误: 宏参数类型必须是 'expr', 'stmt', 'type', 'pattern' 或 'ident'\n" as *byte);
                return null;
            }
            if param_type_str == null {
                return null;
            }
            
            // 验证参数类型
            if strcmp(param_type_str as *byte, "expr" as *byte) != 0 && 
               strcmp(param_type_str as *byte, "stmt" as *byte) != 0 &&
               strcmp(param_type_str as *byte, "type" as *byte) != 0 && 
               strcmp(param_type_str as *byte, "pattern" as *byte) != 0 &&
               strcmp(param_type_str as *byte, "ident" as *byte) != 0 {
                const stderr: *void = get_stderr();
                fprintf(stderr, "错误: 宏参数类型必须是 'expr', 'stmt', 'type', 'pattern' 或 'ident'\n" as *byte);
                return null;
            }
            
            parser_consume(parser);
            
            // 解析默认值（可选）
            var default_value: &ASTNode = null;
            if parser_match(parser, TokenType.TOKEN_ASSIGN) != 0 {
                parser_consume(parser);
                default_value = parser_parse_expression(parser);
                if default_value == null {
                    const stderr: *void = get_stderr();
                    fprintf(stderr, "错误: 宏参数默认值解析失败\n" as *byte);
                    return null;
                }
            }
            
            // 创建参数类型节点（使用 AST_TYPE_NAMED）
            const param_type_node: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_NAMED, param_line, param_column, parser.arena, parser_get_filename(parser));
            if param_type_node == null {
                return null;
            }
            param_type_node.type_named_name = param_type_str;
            
            // 创建参数节点（使用 AST_VAR_DECL）
            const param: &ASTNode = ast_new_node(ASTNodeType.AST_VAR_DECL, param_line, param_column, parser.arena, parser_get_filename(parser));
            if param == null {
                return null;
            }
            
            param.var_decl_name = param_name;
            param.var_decl_type = param_type_node;
            param.var_decl_init = default_value;
            param.var_decl_is_const = 0;
            
            // 扩展参数数组
            if param_count >= param_capacity {
                var new_capacity: i32 = 4;
                if param_capacity != 0 {
                    new_capacity = param_capacity * 2;
                }
                const new_params: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_capacity) as & & ASTNode;
                if new_params == null {
                    const stderr: *void = get_stderr();
                    fprintf(stderr, "错误: Arena 内存不足，无法分配宏参数数组\n" as *byte);
                    return null;
                }
                
                if params != null {
                    var i: i32 = 0;
                    while i < param_count {
                        new_params[i] = params[i];
                        i = i + 1;
                    }
                }
                
                params = new_params;
                param_capacity = new_capacity;
            }
            
            params[param_count] = param;
            param_count = param_count + 1;
            
            // 检查是否有逗号
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            }
        }
    }
    
    // 期望 ')'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
        return null;
    }
    
    macro_decl.macro_decl_params = params;
    macro_decl.macro_decl_param_count = param_count;
    
    // 解析返回标签（expr, stmt, struct, type）
    // 注意：struct 和 type 是关键字，其他是标识符
    var return_tag: &byte = null;
    if parser_match(parser, TokenType.TOKEN_STRUCT) != 0 {
        return_tag = arena_strdup(parser.arena, "struct" as &byte);
        parser_consume(parser);
    } else if parser_match(parser, TokenType.TOKEN_TYPE) != 0 {
        return_tag = arena_strdup(parser.arena, "type" as &byte);
        parser_consume(parser);
    } else if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
        return_tag = arena_strdup(parser.arena, parser.current_token.value);
        parser_consume(parser);
    } else {
        return null;
    }
    
    if return_tag == null {
        return null;
    }
    
    const body: &ASTNode = parser_parse_block(parser);
    if body == null {
        return null;
    }
    
    macro_decl.macro_decl_return_tag = return_tag;
    macro_decl.macro_decl_body = body;
    macro_decl.macro_decl_is_export = 0;
    
    return macro_decl;
}


fn parser_parse_union(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null || parser_match(parser, TokenType.TOKEN_UNION) == 0 {
        return null;
    }
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    parser_consume(parser);
    return parser_parse_union_body(parser, line, column, 0);
}

// 解析枚举声明：enum ID '{' variant_list '}'
// variant_list = variant { ',' variant }
// variant = ID [ '=' NUM ]
fn parser_parse_enum(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'enum'
    if parser_match(parser, TokenType.TOKEN_ENUM) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'enum'
    parser_consume(parser);
    
    // 期望枚举名称
    const enum_name_val: &byte = parser.current_token.value;
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const enum_name: &byte = arena_strdup(parser.arena, enum_name_val);
    if enum_name == null {
        return null;
    }
    
    // 消费枚举名称
    parser_consume(parser);
    
    // 创建枚举声明节点
    const enum_decl: &ASTNode = ast_new_node(ASTNodeType.AST_ENUM_DECL, line, column, parser.arena, parser_get_filename(parser));
    if enum_decl == null {
        return null;
    }
    
    enum_decl.enum_decl_name = enum_name;
    enum_decl.enum_decl_variants = null;
    enum_decl.enum_decl_variant_count = 0;
    
    // 期望 '{'
    if parser_expect(parser, TokenType.TOKEN_LEFT_BRACE) == null {
        return null;
    }
    
    // 解析变体列表
    // 变体列表：variant { ',' variant }
    // variant = ID
    var variants: &EnumVariant = null;
    var variant_count: i32 = 0;
    var variant_capacity: i32 = 0;
    
    while parser.current_token != null && 
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        
        // 解析变体名称
        const variant_name_val: &byte = parser.current_token.value;
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const variant_name: &byte = arena_strdup(parser.arena, variant_name_val);
        if variant_name == null {
            return null;
        }
        
        parser_consume(parser);
        
        // 扩展变体数组（使用 Arena 分配）
        if variant_count >= variant_capacity {
            var new_capacity: i32 = 0;
                        if variant_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = variant_capacity * 2;
                        }
            const new_variants: &EnumVariant = arena_alloc(parser.arena, @size_of(EnumVariant) * new_capacity) as &EnumVariant;
            if new_variants == null {
                return null;
            }
            
            // 复制旧变体
            if variants != null {
                var i: i32 = 0;
                while i < variant_count {
                    new_variants[i] = variants[i];
                    i = i + 1;
                }
            }
            
            variants = new_variants;
            variant_capacity = new_capacity;
        }
        
        // 解析可选的显式值 (= NUM)
        var variant_value: &byte = null;
        if parser_match(parser, TokenType.TOKEN_ASSIGN) != 0 {
            parser_consume(parser);  // 消费 '='
            
            // 期望数字字面量
            if parser_match(parser, TokenType.TOKEN_NUMBER) == 0 {
                return null;
            }
            
            // 复制数字值字符串到 Arena
            variant_value = arena_strdup(parser.arena, parser.current_token.value);
            if variant_value == null {
                return null;
            }
            
            parser_consume(parser);  // 消费数字值
        }
        
        // 添加变体（确保数组索引有效）
        if variant_count < variant_capacity {
            variants[variant_count].name = variant_name;
            variants[variant_count].value = variant_value;  // null 表示没有显式赋值
            variant_count = variant_count + 1;
        } else {
            // 注意：Uya 版本简化错误报告
            return null;
        }
        
        // 检查是否有逗号（可选，最后一个变体后不需要逗号）
        if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
            parser_consume(parser);
        }
    }
    
    // 期望 '}'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    
    enum_decl.enum_decl_variants = variants;
    enum_decl.enum_decl_variant_count = variant_count;
    
    return enum_decl;
}

// 解析预定义错误声明：error ID ';'
fn parser_parse_error_decl(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    if parser_match(parser, TokenType.TOKEN_ERROR) == 0 {
        return null;
    }
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    parser_consume(parser);
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    const name: &byte = arena_strdup(parser.arena, parser.current_token.value);
    if name == null {
        return null;
    }
    parser_consume(parser);
    if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
        return null;
    }
    const node: &ASTNode = ast_new_node(ASTNodeType.AST_ERROR_DECL, line, column, parser.arena, parser_get_filename(parser));
    if node == null {
        return null;
    }
    node.error_decl_name = name;
    return node;
}

// 解析函数声明：fn ID '(' [ param_list ] ')' type '{' statements '}'
// param_list = param { ',' param }
// param = ID ':' type
fn parser_parse_function(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'fn'
    if parser_match(parser, TokenType.TOKEN_FN) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'fn'
    parser_consume(parser);
    
    // 期望函数名称
    const fn_name_val: &byte = parser.current_token.value;
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const fn_name: &byte = arena_strdup(parser.arena, fn_name_val);
    if fn_name == null {
        return null;
    }
    
    // 消费函数名称
    parser_consume(parser);
    
    // 创建函数声明节点
    const fn_decl: &ASTNode = ast_new_node(ASTNodeType.AST_FN_DECL, line, column, parser.arena, parser_get_filename(parser));
    if fn_decl == null {
        return null;
    }
    
    fn_decl.fn_decl_name = fn_name;
    fn_decl.fn_decl_type_params = null;
    fn_decl.fn_decl_type_param_count = 0;
    fn_decl.fn_decl_params = null;
    fn_decl.fn_decl_param_count = 0;
    fn_decl.fn_decl_return_type = null;
    fn_decl.fn_decl_body = null;
    
    // 解析泛型参数列表（可选）：<T> 或 <T: Ord> 或 <T: Ord + Clone>
    if parser.current_token != null && parser_match(parser, TokenType.TOKEN_LESS) != 0 {
        var fn_type_params: &TypeParam = null;
        var fn_type_param_count: i32 = 0;
        var fn_type_param_capacity: i32 = 0;
        
        parser_consume(parser);  // 消费 '<'
        
        while parser.current_token != null &&
              parser_match(parser, TokenType.TOKEN_GREATER) == 0 &&
              parser_match(parser, TokenType.TOKEN_EOF) == 0 {
            
            if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                return null;
            }
            
            const fn_param_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
            if fn_param_name == null {
                return null;
            }
            parser_consume(parser);
            
            if fn_type_param_count >= fn_type_param_capacity {
                var new_cap: i32 = 0;
                if fn_type_param_capacity == 0 {
                    new_cap = 4;
                } else {
                    new_cap = fn_type_param_capacity * 2;
                }
                const new_params: &TypeParam = arena_alloc(parser.arena, @size_of(TypeParam) * new_cap) as &TypeParam;
                if new_params == null {
                    return null;
                }
                var k: i32 = 0;
                while k < fn_type_param_count {
                    new_params[k] = fn_type_params[k];
                    k = k + 1;
                }
                fn_type_params = new_params;
                fn_type_param_capacity = new_cap;
            }
            
            fn_type_params[fn_type_param_count].name = fn_param_name;
            fn_type_params[fn_type_param_count].constraints = null;
            fn_type_params[fn_type_param_count].constraint_count = 0;
            
            // 解析约束（可选）
            if parser_match(parser, TokenType.TOKEN_COLON) != 0 {
                parser_consume(parser);
                var fn_constraints: & & byte = null;
                var fn_constraint_count: i32 = 0;
                var fn_constraint_capacity: i32 = 0;
                
                while parser.current_token != null &&
                      parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
                    const fn_constraint_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
                    if fn_constraint_name == null {
                        return null;
                    }
                    parser_consume(parser);
                    
                    if fn_constraint_count >= fn_constraint_capacity {
                        var new_cap2: i32 = 0;
                        if fn_constraint_capacity == 0 {
                            new_cap2 = 4;
                        } else {
                            new_cap2 = fn_constraint_capacity * 2;
                        }
                        const new_constraints: & & byte = arena_alloc(parser.arena, @size_of(&byte) * new_cap2) as & & byte;
                        if new_constraints == null {
                            return null;
                        }
                        var m: i32 = 0;
                        while m < fn_constraint_count {
                            new_constraints[m] = fn_constraints[m];
                            m = m + 1;
                        }
                        fn_constraints = new_constraints;
                        fn_constraint_capacity = new_cap2;
                    }
                    
                    fn_constraints[fn_constraint_count] = fn_constraint_name;
                    fn_constraint_count = fn_constraint_count + 1;
                    
                    if parser_match(parser, TokenType.TOKEN_PLUS) != 0 {
                        parser_consume(parser);
                    } else {
                        break;
                    }
                }
                
                fn_type_params[fn_type_param_count].constraints = fn_constraints;
                fn_type_params[fn_type_param_count].constraint_count = fn_constraint_count;
            }
            
            fn_type_param_count = fn_type_param_count + 1;
            
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            } else {
                break;
            }
        }
        
        if parser_expect(parser, TokenType.TOKEN_GREATER) == null {
            return null;
        }
        
        fn_decl.fn_decl_type_params = fn_type_params;
        fn_decl.fn_decl_type_param_count = fn_type_param_count;
    }
    
    // 期望 '('
    if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
        return null;
    }
    
    // 解析参数列表（可选，支持可变参数 ...）
    var params: & & ASTNode = null;
    var param_count: i32 = 0;
    var param_capacity: i32 = 0;
    var is_varargs: i32 = 0;
    
    if parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
        // 有参数
        while parser.current_token != null && 
              parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 && 
              parser_match(parser, TokenType.TOKEN_EOF) == 0 {
            
            // 检查是否为可变参数标记（...）
            if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                parser_consume(parser);
                is_varargs = 1;
                break;
            }
            
            // 解析参数名称，允许 'type' 关键字作为参数名
            const param_line: i32 = parser.current_token.line;
            const param_column: i32 = parser.current_token.column;
            var param_name: &byte = null;
            if parser_match(parser, TokenType.TOKEN_TYPE) != 0 {
                param_name = arena_strdup(parser.arena, "type" as &byte);
            } else if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
                param_name = arena_strdup(parser.arena, parser.current_token.value);
            } else {
                return null;
            }
            if param_name == null {
                return null;
            }
            
            parser_consume(parser);
            
            // 期望 ':'
            if parser_expect(parser, TokenType.TOKEN_COLON) == null {
                return null;
            }
            
            // 解析参数类型
            const param_type: &ASTNode = parser_parse_type(parser);
            if param_type == null {
                return null;
            }
            
            // 创建参数节点（使用 ASTNodeType.AST_VAR_DECL，is_const = 0）
            const param: &ASTNode = ast_new_node(ASTNodeType.AST_VAR_DECL, param_line, param_column, parser.arena, parser_get_filename(parser));
            if param == null {
                return null;
            }
            
            param.var_decl_name = param_name;
            param.var_decl_type = param_type;
            param.var_decl_init = null;
            param.var_decl_is_const = 0;
            
            // 扩展参数数组（使用 Arena 分配）
            if param_count >= param_capacity {
                var new_capacity: i32 = 0;
                        if param_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = param_capacity * 2;
                        }
                const new_params: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_capacity) as & & ASTNode;
                if new_params == null {
                    // 注意：Uya 版本简化错误报告
                    return null;
                }
                
                // 复制旧参数
                if params != null {
                    var i: i32 = 0;
                    while i < param_count {
                        new_params[i] = params[i];
                        i = i + 1;
                    }
                }
                
                params = new_params;
                param_capacity = new_capacity;
            }
            
            params[param_count] = param;
            param_count = param_count + 1;
            
            // 检查是否有逗号或逗号后 ...
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            } else if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                // 逗号后紧跟 ...，下次循环处理
            }
        }
    }
    
    // 期望 ')'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
        return null;
    }
    
    // 解析返回类型
    const return_type: &ASTNode = parser_parse_type(parser);
    if return_type == null {
        return null;
    }
    
    // 解析函数体（代码块）
    const body: &ASTNode = parser_parse_block(parser);
    if body == null {
        // 注意：Uya 版本简化错误报告
        return null;
    }
    
    fn_decl.fn_decl_params = params;
    fn_decl.fn_decl_param_count = param_count;
    fn_decl.fn_decl_return_type = return_type;
    fn_decl.fn_decl_body = body;
    fn_decl.fn_decl_is_varargs = is_varargs;
    
    return fn_decl;
}

// 解析 extern 声明：extern 已由调用方消费，当前为 'fn' 或 'union'
fn parser_parse_extern_decl(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    if parser_match(parser, TokenType.TOKEN_UNION) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        parser_consume(parser);
        return parser_parse_union_body(parser, line, column, 1);
    }
    return parser_parse_extern_function_after_extern(parser);
}

// 解析 extern 函数声明（extern 已消费，当前为 'fn'）
fn parser_parse_extern_function_after_extern(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    if parser_expect(parser, TokenType.TOKEN_FN) == null {
        return null;
    }
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    const fn_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
    if fn_name == null {
        return null;
    }
    
    // 消费函数名称
    parser_consume(parser);
    
    // 创建函数声明节点
    const fn_decl: &ASTNode = ast_new_node(ASTNodeType.AST_FN_DECL, line, column, parser.arena, parser_get_filename(parser));
    if fn_decl == null {
        return null;
    }
    
    fn_decl.fn_decl_name = fn_name;
    fn_decl.fn_decl_params = null;
    fn_decl.fn_decl_param_count = 0;
    fn_decl.fn_decl_return_type = null;
    fn_decl.fn_decl_body = null;  // extern 函数没有函数体
    fn_decl.fn_decl_is_varargs = 0;  // 默认不是可变参数函数
    
    // 期望 '('
    if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
        return null;
    }
    
    // 解析参数列表（可选，支持可变参数）
    var params: & & ASTNode = null;
    var param_count: i32 = 0;
    var param_capacity: i32 = 0;
    var is_varargs: i32 = 0;
    
    if parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
        // 有参数
        while parser.current_token != null && 
              parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 && 
              parser_match(parser, TokenType.TOKEN_EOF) == 0 {
            
            // 检查是否为可变参数标记（...）
            if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                // 可变参数标记必须是参数列表的最后一个元素
                parser_consume(parser);  // 消费 '...'
                is_varargs = 1;
                break;  // 遇到 ... 后退出循环
            }
            
            // 解析参数名称，允许 'type' 关键字作为参数名
            const param_line: i32 = parser.current_token.line;
            const param_column: i32 = parser.current_token.column;
            var param_name: &byte = null;
            if parser_match(parser, TokenType.TOKEN_TYPE) != 0 {
                param_name = arena_strdup(parser.arena, "type" as &byte);
            } else if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
                param_name = arena_strdup(parser.arena, parser.current_token.value);
            } else {
                return null;
            }
            if param_name == null {
                return null;
            }
            
            parser_consume(parser);
            
            // 期望 ':'
            if parser_expect(parser, TokenType.TOKEN_COLON) == null {
                return null;
            }
            
            // 解析参数类型
            const param_type: &ASTNode = parser_parse_type(parser);
            if param_type == null {
                return null;
            }
            
            // 创建参数节点（使用 ASTNodeType.AST_VAR_DECL，is_const = 0）
            const param: &ASTNode = ast_new_node(ASTNodeType.AST_VAR_DECL, param_line, param_column, parser.arena, parser_get_filename(parser));
            if param == null {
                return null;
            }
            
            param.var_decl_name = param_name;
            param.var_decl_type = param_type;
            param.var_decl_init = null;
            param.var_decl_is_const = 0;
            
            // 扩展参数数组（使用 Arena 分配）
            if param_count >= param_capacity {
                var new_capacity: i32 = 0;
                        if param_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = param_capacity * 2;
                        }
                const new_params: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_capacity) as & & ASTNode;
                if new_params == null {
                    return null;
                }
                
                // 复制旧参数
                if params != null {
                    var i: i32 = 0;
                    while i < param_count {
                        new_params[i] = params[i];
                        i = i + 1;
                    }
                }
                
                params = new_params;
                param_capacity = new_capacity;
            }
            
            params[param_count] = param;
            param_count = param_count + 1;
            
            // 检查是否有逗号
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            } else if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                // 逗号后紧跟 ...，也是合法的
                // 不消费逗号，让下次循环处理 ...
            }
        }
    }
    
    // 期望 ')'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
        return null;
    }
    
    // 解析返回类型
    const return_type: &ASTNode = parser_parse_type(parser);
    if return_type == null {
        return null;
    }
    
    // extern 函数以分号结尾，没有函数体
    if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
        return null;
    }
    
    fn_decl.fn_decl_params = params;
    fn_decl.fn_decl_param_count = param_count;
    fn_decl.fn_decl_return_type = return_type;
    fn_decl.fn_decl_body = null;  // extern 函数没有函数体
    fn_decl.fn_decl_is_varargs = is_varargs;
    
    return fn_decl;
}

// 解析 extern 函数声明（从 'extern' 开始）
fn parser_parse_extern_function(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null || parser_match(parser, TokenType.TOKEN_EXTERN) == 0 {
        return null;
    }
    parser_consume(parser);
    return parser_parse_extern_function_after_extern(parser);
}

// 解析 use 语句（use path; 或 use path.item; 或 use path as alias;）
fn parser_parse_use_stmt(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'use'
    if parser_match(parser, TokenType.TOKEN_USE) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'use'
    parser_consume(parser);
    
    // 解析模块路径（identifier { '.' identifier }）
    var path_segments: & & byte = null;
    var path_segment_count: i32 = 0;
    var path_segment_capacity: i32 = 0;
    
    // 至少需要一个标识符
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        const stderr: *void = get_stderr();
        var filename: &byte = "(unknown)" as *byte;
        if parser.lexer != null && parser.lexer.filename != null {
            filename = parser.lexer.filename;
        }
        fprintf(stderr, "错误: 语法分析失败 (%s:%d:%d): 'use' 后期望模块路径（标识符）\n" as *byte,
                filename, line, column);
        return null;
    }
    
    // 读取路径段
    while parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
        // 扩展数组
        if path_segment_count >= path_segment_capacity {
            var new_capacity: i32 = path_segment_capacity;
            if new_capacity == 0 {
                new_capacity = 4;
            } else {
                new_capacity = new_capacity * 2;
            }
            const new_segments: & & byte = arena_alloc(parser.arena, (@size_of(&byte) as usize) * (new_capacity as usize)) as & & byte;
            if new_segments == null {
                return null;
            }
            
            // 复制旧段
            if path_segments != null {
                var i: i32 = 0;
                while i < path_segment_count {
                    new_segments[i] = path_segments[i];
                    i = i + 1;
                }
            }
            
            path_segments = new_segments;
            path_segment_capacity = new_capacity;
        }
        
        const segment: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if segment == null {
            return null;
        }
        path_segments[path_segment_count] = segment;
        path_segment_count = path_segment_count + 1;
        parser_consume(parser);
        
        // 检查是否有 '.'
        if parser_match(parser, TokenType.TOKEN_DOT) == 0 {
            break;
        }
        parser_consume(parser);
    }
    
    // 创建 use 语句节点
    const use_stmt: &ASTNode = ast_new_node(ASTNodeType.AST_USE_STMT, line, column, parser.arena, parser_get_filename(parser));
    if use_stmt == null {
        return null;
    }
    
    use_stmt.use_stmt_path_segments = path_segments;
    use_stmt.use_stmt_path_segment_count = path_segment_count;
    use_stmt.use_stmt_item_name = null;
    use_stmt.use_stmt_alias = null;
    
    // 检查是否有特定项名称（use path.item;）
    if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
        parser_consume(parser);
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            const stderr: *void = get_stderr();
            var filename: &byte = "(unknown)" as *byte;
            if parser.lexer != null && parser.lexer.filename != null {
                filename = parser.lexer.filename;
            }
            fprintf(stderr, "错误: 语法分析失败 (%s:%d:%d): '.' 后期望项名称（标识符）\n" as *byte,
                    filename, parser.current_token.line, parser.current_token.column);
            return null;
        }
        use_stmt.use_stmt_item_name = arena_strdup(parser.arena, parser.current_token.value);
        if use_stmt.use_stmt_item_name == null {
            return null;
        }
        parser_consume(parser);
    }
    
    // 检查是否有别名（use path as alias;）
    if parser_match(parser, TokenType.TOKEN_AS) != 0 {
        parser_consume(parser);
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            const stderr: *void = get_stderr();
            var filename: &byte = "(unknown)" as *byte;
            if parser.lexer != null && parser.lexer.filename != null {
                filename = parser.lexer.filename;
            }
            fprintf(stderr, "错误: 语法分析失败 (%s:%d:%d): 'as' 后期望别名（标识符）\n" as *byte,
                    filename, parser.current_token.line, parser.current_token.column);
            return null;
        }
        use_stmt.use_stmt_alias = arena_strdup(parser.arena, parser.current_token.value);
        if use_stmt.use_stmt_alias == null {
            return null;
        }
        parser_consume(parser);
    }
    
    // 期望 ';'
    if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
        const stderr: *void = get_stderr();
        var filename: &byte = "(unknown)" as *byte;
        if parser.lexer != null && parser.lexer.filename != null {
            filename = parser.lexer.filename;
        }
        fprintf(stderr, "错误: 语法分析失败 (%s:%d:%d): 'use' 语句后期望 ';'\n" as *byte,
                filename, parser.current_token.line, parser.current_token.column);
        return null;
    }
    
    return use_stmt;
}

// 解析声明（函数、结构体或变量声明）
fn parser_parse_declaration(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 检查 use 语句
    if parser_match(parser, TokenType.TOKEN_USE) != 0 {
        return parser_parse_use_stmt(parser);
    }
    
    // 检查 test 语句（可以在顶层声明）
    if parser_match(parser, TokenType.TOKEN_TEST) != 0 {
        return parser_parse_statement(parser);
    }
    
    // 检查 export 关键字
    var is_export: i32 = 0;
    if parser_match(parser, TokenType.TOKEN_EXPORT) != 0 {
        is_export = 1;
        parser_consume(parser);
    }
    
    // 检查 @async_fn 函数属性
    var is_async: i32 = 0;
    if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER &&
        parser.current_token.value != null && str_equals_lexer(parser.current_token.value, "async_fn" as &byte) != 0 {
        is_async = 1;
        parser_consume(parser);  // 消费 @async_fn
        // @async_fn 后必须跟着 fn
        if parser_match(parser, TokenType.TOKEN_FN) == 0 {
            const stderr: *void = get_stderr();
            fprintf(stderr, "错误: @async_fn 后必须跟着 fn 关键字\n" as *byte);
            return null;
        }
    }
    
    // 根据第一个 Token 判断声明类型
    if parser_match(parser, TokenType.TOKEN_EXTERN) != 0 {
        if is_async != 0 {
            const stderr: *void = get_stderr();
            fprintf(stderr, "错误: extern 函数不能使用 @async_fn 属性\n" as *byte);
            return null;
        }
        parser_consume(parser);
        const decl: &ASTNode = parser_parse_extern_decl(parser);
        if decl != null && is_export != 0 {
            // 设置 export 标记（extern 函数/结构体）
            if decl.type == ASTNodeType.AST_FN_DECL {
                decl.fn_decl_is_export = 1;
            } else if decl.type == ASTNodeType.AST_STRUCT_DECL {
                decl.struct_decl_is_export = 1;
            } else if decl.type == ASTNodeType.AST_UNION_DECL {
                decl.union_decl_is_export = 1;
            }
        }
        return decl;
    } else if parser_match(parser, TokenType.TOKEN_FN) != 0 {
        const decl: &ASTNode = parser_parse_function(parser);
        if decl != null {
            if is_export != 0 {
                decl.fn_decl_is_export = 1;
            }
            if is_async != 0 {
                decl.fn_decl_is_async = 1;
            }
        }
        return decl;
    } else if parser_match(parser, TokenType.TOKEN_ERROR) != 0 {
        const decl: &ASTNode = parser_parse_error_decl(parser);
        if decl != null && is_export != 0 {
            decl.error_decl_is_export = 1;
        }
        return decl;
    } else if parser_match(parser, TokenType.TOKEN_ENUM) != 0 {
        const decl: &ASTNode = parser_parse_enum(parser);
        if decl != null && is_export != 0 {
            decl.enum_decl_is_export = 1;
        }
        return decl;
    } else if parser_match(parser, TokenType.TOKEN_INTERFACE) != 0 {
        const decl: &ASTNode = parser_parse_interface(parser);
        if decl != null && is_export != 0 {
            decl.interface_decl_is_export = 1;
        }
        return decl;
    } else if parser_match(parser, TokenType.TOKEN_STRUCT) != 0 {
        const decl: &ASTNode = parser_parse_struct(parser);
        if decl != null && is_export != 0 {
            decl.struct_decl_is_export = 1;
        }
        return decl;
    } else if parser_match(parser, TokenType.TOKEN_UNION) != 0 {
        const decl: &ASTNode = parser_parse_union(parser);
        if decl != null && is_export != 0 {
            decl.union_decl_is_export = 1;
        }
                return decl;
    } else if parser_match(parser, TokenType.TOKEN_MC) != 0 {
        const decl: &ASTNode = parser_parse_macro(parser);
        if decl != null && is_export != 0 {
            decl.macro_decl_is_export = 1;
        }
        return decl;
    } else if parser_match(parser, TokenType.TOKEN_TYPE) != 0 {
        const decl: &ASTNode = parser_parse_type_alias(parser);
        if decl != null && is_export != 0 {
            decl.type_alias_is_export = 1;
        }
        return decl;
    } else if parser_match(parser, TokenType.TOKEN_IDENTIFIER) != 0 {
const name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if name == null {
            return null;
        }
        parser_consume(parser);
        if parser.current_token != null && parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
            parser_consume(parser);
            return parser_parse_method_block(parser, name);
        }
        const stderr: *void = get_stderr();
        var filename: &byte = "(unknown)" as *byte;
        if parser.lexer != null && parser.lexer.filename != null {
            filename = parser.lexer.filename;
        }
        fprintf(stderr, "错误: 语法分析失败 (%s:%d:%d): 顶层标识符 '%s' 后期望 '{'（方法块）\n" as *byte,
                filename, parser.current_token.line, parser.current_token.column, name);
        return null;
    } else if parser_match(parser, TokenType.TOKEN_CONST) != 0 || parser_match(parser, TokenType.TOKEN_VAR) != 0 {
        // 变量声明
        const decl: &ASTNode = parser_parse_statement(parser);
        if decl != null && is_export != 0 && decl.type == ASTNodeType.AST_VAR_DECL {
            decl.var_decl_is_export = 1;
        }
        return decl;
    } else {
        // 无法识别的声明类型
        return null;
    }
}

// 解析程序（顶层声明列表）
fn parser_parse(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 创建程序节点
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    const program: &ASTNode = ast_new_node(ASTNodeType.AST_PROGRAM, line, column, parser.arena, parser_get_filename(parser));
    if program == null {
        return null;
    }
    
    // 初始化声明列表
    program.program_decls = null;
    program.program_decl_count = 0;
    
    // 解析顶层声明列表
    var decls: & & ASTNode = null;
    var decl_count: i32 = 0;
    var decl_capacity: i32 = 0;
    const stderr: *void = get_stderr();
    
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        const decl: &ASTNode = parser_parse_declaration(parser);
        if decl == null {
            // 解析失败：检查是否因为到达文件末尾（EOF）还是真正的错误
            // 如果当前 token 不是 EOF，说明遇到了真正的解析错误
            if parser.current_token != null && parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                // 真正的解析错误：输出错误信息并返回 null（与 C 版一致）
                var filename: &byte = "(unknown)" as *byte;
                if parser.lexer != null && parser.lexer.filename != null {
                    filename = parser.lexer.filename;
                }
                fprintf(stderr, "错误: 语法分析失败 (%s:%d:%d): 意外的 token" as *byte, filename, parser.current_token.line, parser.current_token.column);
                if parser.current_token.value != null {
                    fprintf(stderr, " '%s'" as *byte, parser.current_token.value);
                }
                fprintf(stderr, "\n" as *byte);
                return null;
            }
            if parser.current_token == null {
                // current_token 为 null 时也报告，便于排查自举失败
                var filename: &byte = "(unknown)" as *byte;
                if parser.lexer != null && parser.lexer.filename != null {
                    filename = parser.lexer.filename;
                }
                fprintf(stderr, "错误: 语法分析失败 (%s): 当前 token 为 null\n" as *byte, filename);
                return null;
            }
            // 到达文件末尾，正常退出循环
            break;
        }
        
        // 扩展声明数组（使用 Arena 分配）
        if decl_count >= decl_capacity {
            var new_capacity: i32 = 0;
                        if decl_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = decl_capacity * 2;
                        }
            const new_decls: & & ASTNode = arena_alloc(parser.arena, @size_of(&ASTNode) * new_capacity) as & & ASTNode;
            if new_decls == null {
                return null;
            }
            
            // 复制旧声明
            if decls != null {
                var i: i32 = 0;
                while i < decl_count {
                    new_decls[i] = decls[i];
                    i = i + 1;
                }
            }
            
            decls = new_decls;
            decl_capacity = new_capacity;
        }
        
        decls[decl_count] = decl;
        decl_count = decl_count + 1;
    }
    
    program.program_decls = decls;
    program.program_decl_count = decl_count;
    
    return program;
}

// parser_parse_program 是 parser_parse 的别名（为了兼容性）
fn parser_parse_program(parser: &Parser) &ASTNode {
    return parser_parse(parser);
}

