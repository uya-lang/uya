// 作用域规则测试程序
// 根据 UYA_MINI_SPEC.md 5.1 节的作用域规则进行测试
// 测试全局作用域、局部作用域、块作用域和作用域嵌套

// 全局作用域变量
const global_const: i32 = 100;
var global_var: i32 = 200;

// 测试函数：验证作用域嵌套和访问规则
fn test_scope_nesting() i32 {
    // 函数局部作用域变量
    const local_const: i32 = 10;
    var local_var: i32 = 20;
    
    // 验证可以访问全局变量
    if global_const != 100 || global_var != 200 {
        return 1;  // 应该能访问全局变量
    }
    
    // 验证可以访问局部变量
    if local_const != 10 || local_var != 20 {
        return 2;  // 应该能访问局部变量
    }
    
    // 测试块作用域
    {
        // 块作用域变量
        const block_const: i32 = 30;
        var block_var: i32 = 40;
        
        // 验证可以访问外层作用域的变量
        if global_const != 100 || local_const != 10 {
            return 3;  // 应该能访问外层作用域变量
        }
        
        // 验证可以访问块作用域变量
        if block_const != 30 || block_var != 40 {
            return 4;  // 应该能访问块作用域变量
        }
        
        // 修改外层作用域的 var 变量
        local_var = 25;
        global_var = 250;
    }
    
    // 验证块作用域外的变量修改仍然有效
    if local_var != 25 || global_var != 250 {
        return 5;  // 块作用域内的修改应该影响外层变量
    }
    
    // 测试嵌套块作用域
    {
        const inner_block: i32 = 50;
        {
            const inner_inner: i32 = 60;
            
            // 验证可以访问所有外层作用域
            if global_const != 100 || local_const != 10 || inner_block != 50 || inner_inner != 60 {
                return 6;  // 应该能访问所有外层作用域
            }
        }
    }
    
    return 0;
}

// 测试函数参数作用域
fn test_param_scope(x: i32, y: i32) i32 {
    // 函数参数在函数作用域内
    if x != 1 || y != 2 {
        return 1;  // 应该能访问函数参数
    }
    
    // 测试块作用域内访问函数参数
    {
        const block_val: i32 = x + y;
        if block_val != 3 {
            return 2;  // 应该能在块作用域内访问函数参数
        }
    }
    
    return 0;
}

// 测试 if 语句块作用域
fn test_if_block_scope(condition: bool) i32 {
    if condition {
        const if_block_var: i32 = 100;
        if if_block_var != 100 {
            return 1;  // 应该能在 if 块内访问块变量
        }
    } else {
        const else_block_var: i32 = 200;
        if else_block_var != 200 {
            return 2;  // 应该能在 else 块内访问块变量
        }
    }
    
    return 0;
}

// 测试 while 循环块作用域
fn test_while_block_scope() i32 {
    var count: i32 = 0;
    while count < 3 {
        const loop_var: i32 = count * 10;
        count = count + 1;
        
        if loop_var < 0 || loop_var > 20 {
            return 1;  // 应该能在循环块内访问块变量
        }
    }
    
    return 0;
}

// 测试 for 循环块作用域
fn test_for_block_scope() i32 {
    const arr: [i32: 3] = [10, 20, 30];
    var sum: i32 = 0;
    
    for arr |item| {
        const loop_const: i32 = item * 2;
        sum = sum + loop_const;
    }
    
    if sum != 120 {  // (10*2) + (20*2) + (30*2) = 120
        return 1;  // 应该能在 for 循环块内访问块变量
    }
    
    return 0;
}

// 测试函数调用中的作用域
fn test_function_call_scope() i32 {
    const local: i32 = 42;
    
    // 调用函数，验证参数作用域
    const result: i32 = test_param_scope(1, 2);
    if result != 0 {
        return 1;
    }
    
    // 验证局部变量仍然可访问
    if local != 42 {
        return 2;
    }
    
    return 0;
}

// 测试多层嵌套作用域
fn test_deep_nesting() i32 {
    const level1: i32 = 1;
    {
        const level2: i32 = 2;
        {
            const level3: i32 = 3;
            {
                const level4: i32 = 4;
                
                // 验证可以访问所有外层作用域
                if level1 != 1 || level2 != 2 || level3 != 3 || level4 != 4 {
                    return 1;
                }
            }
        }
    }
    
    return 0;
}

fn main() i32 {
    // 测试 1: 作用域嵌套
    const result1: i32 = test_scope_nesting();
    if result1 != 0 {
        return result1;
    }
    
    // 测试 2: 函数参数作用域
    const result2: i32 = test_param_scope(1, 2);
    if result2 != 0 {
        return 10 + result2;
    }
    
    // 测试 3: if 语句块作用域
    const result3: i32 = test_if_block_scope(true);
    if result3 != 0 {
        return 20 + result3;
    }
    
    const result3b: i32 = test_if_block_scope(false);
    if result3b != 0 {
        return 30 + result3b;
    }
    
    // 测试 4: while 循环块作用域
    const result4: i32 = test_while_block_scope();
    if result4 != 0 {
        return 40 + result4;
    }
    
    // 测试 5: for 循环块作用域
    const result5: i32 = test_for_block_scope();
    if result5 != 0 {
        return 50 + result5;
    }
    
    // 测试 6: 函数调用中的作用域
    const result6: i32 = test_function_call_scope();
    if result6 != 0 {
        return 60 + result6;
    }
    
    // 测试 7: 多层嵌套作用域
    const result7: i32 = test_deep_nesting();
    if result7 != 0 {
        return 70 + result7;
    }
    
    // 所有测试通过
    return 0;
}

