// test_std_string.uya
// 测试 lib/std/c/string 标准库模块（通过 use 导入）

use std.c.string.strlen;
use std.c.string.memcpy;
use std.c.string.memset;
use std.c.string.memcmp;
use std.c.string.memchr;
use std.c.string.strcmp;
use std.c.string.strncmp;
use std.c.string.strcpy;

// ============================================================
// 辅助函数：用 ASCII 码设置字节数组
// ============================================================

// 设置 "Hello" 到 buf（含 null 终止符）
fn set_hello(buf: &byte) void {
    buf[0] = 72 as byte;   // H
    buf[1] = 101 as byte;  // e
    buf[2] = 108 as byte;  // l
    buf[3] = 108 as byte;  // l
    buf[4] = 111 as byte;  // o
    buf[5] = 0 as byte;    // \0
}

// 设置 "World" 到 buf（含 null 终止符）
fn set_world(buf: &byte) void {
    buf[0] = 87 as byte;   // W
    buf[1] = 111 as byte;  // o
    buf[2] = 114 as byte;  // r
    buf[3] = 108 as byte;  // l
    buf[4] = 100 as byte;  // d
    buf[5] = 0 as byte;    // \0
}

// 设置 "Hell" 到 buf（含 null 终止符）
fn set_hell(buf: &byte) void {
    buf[0] = 72 as byte;   // H
    buf[1] = 101 as byte;  // e
    buf[2] = 108 as byte;  // l
    buf[3] = 108 as byte;  // l
    buf[4] = 0 as byte;    // \0
}

// ============================================================
// 测试函数
// ============================================================

fn test_strlen() i32 {
    var hello: [byte: 10] = [];
    set_hello(&hello[0] as &byte);
    const len1: usize = strlen(&hello[0] as &byte);
    if len1 != 5 {
        return 1;
    }

    var empty: [byte: 4] = [];
    empty[0] = 0 as byte;
    const len2: usize = strlen(&empty[0] as &byte);
    if len2 != 0 {
        return 2;
    }

    var single: [byte: 4] = [];
    single[0] = 65 as byte;  // 'A'
    single[1] = 0 as byte;
    const len3: usize = strlen(&single[0] as &byte);
    if len3 != 1 {
        return 3;
    }

    return 0;
}

fn test_memcpy() i32 {
    var src: [byte: 10] = [];
    set_hello(&src[0] as &byte);
    var dest: [byte: 10] = [];

    _ = memcpy(&dest[0] as &byte, &src[0] as &byte, 6);
    if dest[0] != 72 as byte {
        return 1;  // 'H'
    }
    if dest[4] != 111 as byte {
        return 2;  // 'o'
    }
    if dest[5] != 0 as byte {
        return 3;  // '\0'
    }

    var partial: [byte: 10] = [];
    _ = memcpy(&partial[0] as &byte, &src[0] as &byte, 3);
    if partial[0] != 72 as byte {
        return 4;  // 'H'
    }
    if partial[2] != 108 as byte {
        return 5;  // 'l'
    }

    return 0;
}

fn test_memset() i32 {
    var buf: [byte: 10] = [];
    _ = memset(&buf[0] as &byte, 65 as byte, 5);
    if buf[0] != 65 as byte {
        return 1;  // 'A'
    }
    if buf[4] != 65 as byte {
        return 2;
    }
    if buf[5] != 0 as byte {
        return 3;
    }

    var buf2: [byte: 10] = [];
    buf2[0] = 100 as byte;
    buf2[1] = 100 as byte;
    _ = memset(&buf2[0] as &byte, 0 as byte, 5);
    if buf2[0] != 0 as byte {
        return 4;
    }
    if buf2[4] != 0 as byte {
        return 5;
    }

    return 0;
}

fn test_memcmp() i32 {
    var a: [byte: 10] = [];
    var b: [byte: 10] = [];
    set_hello(&a[0] as &byte);
    set_hello(&b[0] as &byte);
    const cmp1: i32 = memcmp(&a[0] as &byte, &b[0] as &byte, 5);
    if cmp1 != 0 {
        return 1;
    }

    set_hello(&a[0] as &byte);
    set_world(&b[0] as &byte);
    const cmp2: i32 = memcmp(&a[0] as &byte, &b[0] as &byte, 1);
    if cmp2 >= 0 {
        return 2;  // 'H' (72) < 'W' (87)
    }

    const cmp3: i32 = memcmp(&b[0] as &byte, &a[0] as &byte, 1);
    if cmp3 <= 0 {
        return 3;  // 'W' (87) > 'H' (72)
    }

    return 0;
}

fn test_strcmp() i32 {
    var a: [byte: 10] = [];
    var b: [byte: 10] = [];
    set_hello(&a[0] as &byte);
    set_hello(&b[0] as &byte);
    const cmp1: i32 = strcmp(&a[0] as &byte, &b[0] as &byte);
    if cmp1 != 0 {
        return 1;
    }

    set_hello(&a[0] as &byte);
    set_world(&b[0] as &byte);
    const cmp2: i32 = strcmp(&a[0] as &byte, &b[0] as &byte);
    if cmp2 >= 0 {
        return 2;  // "Hello" < "World"
    }

    set_hello(&a[0] as &byte);
    set_hell(&b[0] as &byte);
    const cmp3: i32 = strcmp(&a[0] as &byte, &b[0] as &byte);
    if cmp3 <= 0 {
        return 3;  // "Hello" > "Hell"
    }

    return 0;
}

fn test_strcpy() i32 {
    var src: [byte: 10] = [];
    set_hello(&src[0] as &byte);
    var dest: [byte: 10] = [];
    _ = strcpy(&dest[0] as &byte, &src[0] as &byte);

    const len: usize = strlen(&dest[0] as &byte);
    if len != 5 {
        return 1;
    }
    if dest[0] != 72 as byte {
        return 2;  // 'H'
    }
    if dest[4] != 111 as byte {
        return 3;  // 'o'
    }
    if dest[5] != 0 as byte {
        return 4;  // '\0'
    }

    return 0;
}

fn test_strncmp() i32 {
    var a: [byte: 10] = [];
    var b: [byte: 10] = [];
    set_hello(&a[0] as &byte);
    set_hell(&b[0] as &byte);
    const cmp1: i32 = strncmp(&a[0] as &byte, &b[0] as &byte, 4);
    if cmp1 != 0 {
        return 1;  // "Hell" == "Hell" (前 4 字节)
    }

    set_hello(&a[0] as &byte);
    set_world(&b[0] as &byte);
    const cmp2: i32 = strncmp(&a[0] as &byte, &b[0] as &byte, 3);
    if cmp2 >= 0 {
        return 2;  // "Hel" < "Wor"
    }

    return 0;
}

fn test_memchr() i32 {
    var buf: [byte: 10] = [];
    set_hello(&buf[0] as &byte);
    const ptr1: *void = memchr(&buf[0] as *void, 108, 5);  // 'l'
    if ptr1 == null {
        return 1;  // 应该找到 'l'
    }
    // 检查是否指向 buf[2]（第一个 'l' 在位置 2）
    if ptr1 != &buf[2] as *void {
        return 2;
    }

    const ptr2: *void = memchr(&buf[0] as *void, 120, 5);  // 'x'
    if ptr2 != null {
        return 3;  // 不应该找到 'x'
    }

    const ptr3: *void = memchr(&buf[0] as *void, 72, 5);  // 'H'
    if ptr3 == null {
        return 4;  // 应该找到 'H'
    }
    // 检查是否指向 buf[0]（'H' 在位置 0）
    if ptr3 != &buf[0] as *void {
        return 5;
    }

    return 0;
}

// ============================================================
// 主测试入口
// ============================================================

fn main() i32 {
    var result: i32 = 0;

    result = test_strlen();
    if result != 0 {
        return result;  // strlen 测试失败
    }

    result = test_memcpy();
    if result != 0 {
        return result + 10;  // memcpy 测试失败
    }

    result = test_memset();
    if result != 0 {
        return result + 20;  // memset 测试失败
    }

    result = test_memcmp();
    if result != 0 {
        return result + 30;  // memcmp 测试失败
    }

    result = test_strcmp();
    if result != 0 {
        return result + 40;  // strcmp 测试失败
    }

    result = test_strcpy();
    if result != 0 {
        return result + 50;  // strcpy 测试失败
    }

    result = test_strncmp();
    if result != 0 {
        return result + 60;  // strncmp 测试失败
    }

    result = test_memchr();
    if result != 0 {
        return result + 70;  // memchr 测试失败
    }

    return 0;
}
