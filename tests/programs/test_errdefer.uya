// 测试 errdefer：仅错误返回时 LIFO 执行
error E;
fn f() !i32 {
    var x: i32 = 0;
    errdefer { x = 2; }
    defer { x = x + 1; }
    return error.E;  // 错误返回：先 errdefer (x=2)，再 defer (x=2+1=3)
}
fn main() i32 {
    const r: i32 = f() catch { 0; };  // 捕获后 r=0
    var y: i32 = 0;
    defer { y = 1; }  // main 返回 i32，不能用 errdefer；仅测 defer
    if (r != 0) { return 1; }
    return (1 - y) - 1;  // 规范 §9：先计算 1-y=1，再 defer(y=1)，返回 0 表示通过
}
