// 混合嵌套测试
// 测试控制流、函数调用和结构体访问的混合嵌套

struct Point {
    x: i32,
    y: i32,
}

fn add(a: i32, b: i32) i32 {
    return a + b;
}

fn multiply(a: i32, b: i32) i32 {
    return a * b;
}

fn get_sum(p: Point) i32 {
    return add(p.x, p.y);
}

fn process_point(p: Point, factor: i32) i32 {
    if factor > 0 {
        if p.x > 0 {
            return multiply(get_sum(p), factor);
        } else {
            return 0;
        }
    } else {
        return get_sum(p);
    }
}

fn main() i32 {
    const p1: Point = Point{ x: 3, y: 4 };
    const p2: Point = Point{ x: 5, y: 6 };
    
    // 测试函数调用嵌套在if中
    var result: i32 = 0;
    if get_sum(p1) > 5 {
        result = multiply(get_sum(p1), 2);
    } else {
        result = get_sum(p1);
    }
    // get_sum(p1) = 7 > 5, result = 7 * 2 = 14
    if result != 14 {
        return 1;
    }
    
    // 测试process_point函数（内部有嵌套if和函数调用）
    const r1: i32 = process_point(p1, 2);
    // p1.x = 3 > 0, factor = 2 > 0
    // return multiply(get_sum(p1), 2) = multiply(7, 2) = 14
    if r1 != 14 {
        return 2;
    }
    
    // 测试while循环中的嵌套函数调用和结构体访问
    var sum: i32 = 0;
    var i: i32 = 0;
    while i < 3 {
        var p: Point = Point{ x: i, y: i + 1 };
        if i > 0 {
            sum = add(sum, get_sum(p));
        }
        i = i + 1;
    }
    // i=0: skip
    // i=1: p = Point{1, 2}, get_sum = 3, sum = 3
    // i=2: p = Point{2, 3}, get_sum = 5, sum = 8
    if sum != 8 {
        return 3;
    }
    
    // 测试深层混合嵌套
    var count: i32 = 0;
    var x: i32 = 0;
    while x < 2 {
        const p: Point = Point{ x: x, y: x * 2 };
        if process_point(p, 1) > 0 {
            var y: i32 = 0;
            while y < 2 {
                count = add(count, multiply(get_sum(p), y + 1));
                y = y + 1;
            }
        }
        x = x + 1;
    }
    // x=0: p = Point{0, 0}, process_point returns 0, skip
    // x=1: p = Point{1, 2}, process_point(1, 1) = 3 > 0
    //   y=0: count += multiply(3, 1) = 3
    //   y=1: count += multiply(3, 2) = 6
    // count = 9
    if count != 9 {
        return 4;
    }
    
    return 0;
}

