# 证明失败错误报告实现计划

## 问题描述

证明失败错误报告需要：

- 在证明超时或无法证明时，报告编译错误（不自动插入运行时检查）
- 错误消息中提供清晰的修复建议，告诉用户如何添加显式检查
- 符合 Uya 语言的"显式控制哲学"：程序员必须显式处理，编译器不自动插入代码
- 错误消息包含具体的代码示例，帮助用户快速修复

## 技术方案

### 证明失败检测

**在 checker 阶段检测证明失败**：

```c
// checker.c
static void checker_report_proof_failure(TypeChecker *checker, 
                                         ASTNode *node,
                                         const char *operation,
                                         const char *suggestion) {
    char error_msg[512];
    snprintf(error_msg, sizeof(error_msg),
        "无法证明 %s 的安全性。\n"
        "建议：在 %s 之前添加显式检查。\n"
        "示例：\n%s",
        operation, operation, suggestion);
    
    checker_report_error(checker, node, error_msg);
}
```



## 数据结构设计

### 错误建议模板

```c
// checker.c
typedef struct ProofFailureSuggestion {
    const char *operation;      // 操作类型（"数组访问", "整数溢出" 等）
    const char *suggestion;      // 修复建议代码示例
} ProofFailureSuggestion;

// 预定义的修复建议
static const ProofFailureSuggestion proof_suggestions[] = {
    {
        .operation = "数组访问",
        .suggestion = "if (i < 0 || i >= len) {\n"
                     "    return error.OutOfBounds;\n"
                     "}\n"
                     "const val = arr[i];"
    },
    {
        .operation = "整数溢出",
        .suggestion = "const result = try a + b;\n"
                     "// 或使用饱和运算符: const result = a +| b;\n"
                     "// 或使用包装运算符: const result = a +% b;"
    },
    {
        .operation = "空指针解引用",
        .suggestion = "if (ptr == null) {\n"
                     "    return error.NullPointer;\n"
                     "}\n"
                     "const val = *ptr;"
    },
    {
        .operation = "除零",
        .suggestion = "if (b == 0) {\n"
                     "    return error.DivideByZero;\n"
                     "}\n"
                     "const result = a / b;"
    },
    {
        .operation = "未初始化使用",
        .suggestion = "var x: i32 = 0;  // 初始化变量\n"
                     "// 或在使用前赋值: x = some_value;"
    }
};
```



## 算法实现

### 1. 数组访问证明失败

**错误报告**：

```c
// checker.c
static int verify_array_access_safe(TypeChecker *checker, ASTNode *node) {
    ASTNode *index_expr = node->data.array_access.index;
    Type array_type = checker_infer_type(checker, node->data.array_access.array);
    
    if (array_type.kind == TYPE_ARRAY) {
        int array_len = array_type.data.array.array_size;
        
        // 常量索引：直接检查
        int const_index = checker_eval_const_expr(checker, index_expr);
        if (const_index >= 0) {
            if (const_index < 0 || const_index >= array_len) {
                checker_report_error(checker, node, "数组索引越界");
                return -1;
            }
            return 0;  // 常量索引安全
        }
        
        // 变量索引：尝试证明
        const char *index_var = extract_var_name(index_expr);
        int proof_result = verify_array_access_with_proof(checker, index_var, array_len);
        
        if (proof_result == -1) {
            // 证明失败：报告错误并提供建议
            char suggestion[256];
            snprintf(suggestion, sizeof(suggestion),
                "if (%s < 0 || %s >= %d) {\n"
                "    return error.OutOfBounds;\n"
                "}\n"
                "const val = arr[%s];",
                index_var, index_var, array_len, index_var);
            
            checker_report_proof_failure(checker, node, "数组访问", suggestion);
            return -1;
        }
        
        return proof_result;  // 证明成功
    }
    
    return 0;
}
```



### 2. 整数溢出证明失败

**错误报告**：

```c
// checker.c
static int verify_overflow_safe(TypeChecker *checker, ASTNode *node) {
    TokenType op = node->data.binary_expr.op;
    if (op != TOKEN_PLUS && op != TOKEN_MINUS && op != TOKEN_ASTERISK) {
        return 0;  // 不是算术运算
    }
    
    Type left_type = checker_infer_type(checker, node->data.binary_expr.left);
    if (!is_integer_type(left_type.kind)) {
        return 0;  // 不是整数类型
    }
    
    // 尝试证明无溢出
    SymbolicValue *left_sv = expr_to_symbolic(checker, node->data.binary_expr.left);
    SymbolicValue *right_sv = expr_to_symbolic(checker, node->data.binary_expr.right);
    
    if (left_sv == NULL || right_sv == NULL) {
        // 无法转换为符号值，报告错误
        const char *op_str = (op == TOKEN_PLUS) ? "+" : 
                            (op == TOKEN_MINUS) ? "-" : "*";
        char suggestion[512];
        snprintf(suggestion, sizeof(suggestion),
            "// 方式 1: 使用 try 关键字\n"
            "const result = try a %s b;\n"
            "\n"
            "// 方式 2: 使用饱和运算符\n"
            "const result = a %s| b;\n"
            "\n"
            "// 方式 3: 使用包装运算符\n"
            "const result = a %s%% b;\n"
            "\n"
            "// 方式 4: 显式溢出检查\n"
            "if (a > 0 && b > 0 && a > @max - b) {\n"
            "    return error.Overflow;\n"
            "}\n"
            "const result = a %s b;",
            op_str, op_str, op_str, op_str);
        
        checker_report_proof_failure(checker, node, "整数溢出", suggestion);
        return -1;
    }
    
    int proof_result = verify_overflow_with_proof(checker, left_sv, right_sv, left_type);
    if (proof_result == -1) {
        // 证明失败：报告错误
        const char *op_str = (op == TOKEN_PLUS) ? "+" : 
                            (op == TOKEN_MINUS) ? "-" : "*";
        char suggestion[512];
        snprintf(suggestion, sizeof(suggestion),
            "const result = try a %s b;  // 或使用 a %s| b (饱和) 或 a %s%% b (包装)",
            op_str, op_str, op_str);
        
        checker_report_proof_failure(checker, node, "整数溢出", suggestion);
        return -1;
    }
    
    return proof_result;
}
```



### 3. 空指针解引用证明失败

**错误报告**：

```c
// checker.c
static int verify_null_pointer_safe(TypeChecker *checker, ASTNode *node) {
    ASTNode *ptr_expr = node->data.unary_expr.operand;
    
    // 尝试证明指针非空
    int proof_result = verify_pointer_not_null(checker, ptr_expr);
    
    if (proof_result == -1) {
        // 证明失败：报告错误
        const char *ptr_var = extract_var_name(ptr_expr);
        char suggestion[256];
        snprintf(suggestion, sizeof(suggestion),
            "if (%s == null) {\n"
            "    return error.NullPointer;\n"
            "}\n"
            "const val = *%s;",
            ptr_var ? ptr_var : "ptr", ptr_var ? ptr_var : "ptr");
        
        checker_report_proof_failure(checker, node, "空指针解引用", suggestion);
        return -1;
    }
    
    return proof_result;
}
```



### 4. 除零证明失败

**错误报告**：

```c
// checker.c
static int verify_div_zero_safe(TypeChecker *checker, ASTNode *node) {
    ASTNode *right_expr = node->data.binary_expr.right;
    
    // 常量除零：直接报错
    int const_divisor = checker_eval_const_expr(checker, right_expr);
    if (const_divisor == 0) {
        checker_report_error(checker, node, "除零错误：除数不能为 0");
        return -1;
    }
    
    // 变量除零：尝试证明
    int proof_result = verify_divisor_not_zero(checker, right_expr);
    
    if (proof_result == -1) {
        // 证明失败：报告错误
        const char *divisor_var = extract_var_name(right_expr);
        char suggestion[256];
        snprintf(suggestion, sizeof(suggestion),
            "if (%s == 0) {\n"
            "    return error.DivideByZero;\n"
            "}\n"
            "const result = a / %s;",
            divisor_var ? divisor_var : "b", divisor_var ? divisor_var : "b");
        
        checker_report_proof_failure(checker, node, "除零", suggestion);
        return -1;
    }
    
    return proof_result;
}
```



### 5. 未初始化使用证明失败

**错误报告**：

```c
// checker.c
static int verify_uninitialized_use(TypeChecker *checker, ASTNode *node) {
    const char *var_name = node->data.identifier.name;
    Symbol *sym = symbol_table_lookup(checker, var_name);
    
    if (sym == NULL) {
        return 0;  // 符号不存在，由其他错误处理
    }
    
    // 检查变量是否已初始化
    if (!sym->is_initialized) {
        // 未初始化：报告错误
        char suggestion[256];
        snprintf(suggestion, sizeof(suggestion),
            "// 方式 1: 声明时初始化\n"
            "var %s: i32 = 0;\n"
            "\n"
            "// 方式 2: 使用前赋值\n"
            "%s = some_value;",
            var_name, var_name);
        
        checker_report_proof_failure(checker, node, "未初始化使用", suggestion);
        return -1;
    }
    
    return 0;  // 已初始化，安全
}
```



## 集成点

### 在 checker_check_node 中集成证明失败检测

```c
// checker.c
static int checker_check_node(TypeChecker *checker, ASTNode *node) {
    switch (node->type) {
        case AST_ARRAY_ACCESS:
            // 数组访问安全性检查
            if (verify_array_access_safe(checker, node) < 0) {
                return -1;  // 证明失败，已报告错误
            }
            break;
            
        case AST_BINARY_EXPR: {
            TokenType op = node->data.binary_expr.op;
            if (op == TOKEN_PLUS || op == TOKEN_MINUS || op == TOKEN_ASTERISK) {
                // 整数溢出检查
                if (verify_overflow_safe(checker, node) < 0) {
                    return -1;  // 证明失败，已报告错误
                }
            } else if (op == TOKEN_SLASH) {
                // 除零检查
                if (verify_div_zero_safe(checker, node) < 0) {
                    return -1;  // 证明失败，已报告错误
                }
            }
            break;
        }
        
        case AST_UNARY_EXPR:
            if (node->data.unary_expr.op == TOKEN_ASTERISK) {
                // 空指针解引用检查
                if (verify_null_pointer_safe(checker, node) < 0) {
                    return -1;  // 证明失败，已报告错误
                }
            }
            break;
            
        case AST_IDENTIFIER:
            // 未初始化使用检查
            if (verify_uninitialized_use(checker, node) < 0) {
                return -1;  // 证明失败，已报告错误
            }
            break;
            
        // ... 其他节点类型 ...
    }
    
    return 0;
}
```



## 错误消息优化

### 1. 上下文信息

**在错误消息中包含代码位置和上下文**：

```c
// checker.c
static void checker_report_proof_failure(TypeChecker *checker,
                                         ASTNode *node,
                                         const char *operation,
                                         const char *suggestion) {
    // 获取代码位置
    const char *filename = node->filename ? node->filename : checker->default_filename;
    int line = node->line;
    int column = node->column;
    
    // 生成详细的错误消息
    fprintf(stderr, "%s:%d:%d: 错误: 无法证明 %s 的安全性\n",
            filename, line, column, operation);
    
    // 显示代码片段（如果可能）
    if (node->source_snippet) {
        fprintf(stderr, "  %s\n", node->source_snippet);
        fprintf(stderr, "  %*s^\n", column - 1, "");
    }
    
    // 显示修复建议
    fprintf(stderr, "\n建议：在 %s 之前添加显式检查。\n", operation);
    fprintf(stderr, "示例代码：\n%s\n", suggestion);
}
```



### 2. 错误消息格式

**统一的错误消息格式**：

```javascript
文件名:行号:列号: 错误: 无法证明 [操作] 的安全性
  代码片段
  ^
  
建议：在 [操作] 之前添加显式检查。
示例代码：
[修复建议代码]
```



## 测试策略

### 测试用例

1. **数组访问证明失败错误**：

- `error_proof_array_access.uya` - 测试数组访问证明失败时的错误报告

2. **整数溢出证明失败错误**：

- `error_proof_overflow.uya` - 测试整数溢出证明失败时的错误报告

3. **空指针解引用证明失败错误**：

- `error_proof_null.uya` - 测试空指针解引用证明失败时的错误报告

4. **除零证明失败错误**：

- `error_proof_divzero.uya` - 测试除零证明失败时的错误报告

5. **未初始化使用证明失败错误**：

- `error_proof_uninit.uya` - 测试未初始化使用证明失败时的错误报告

6. **证明成功测试**：

- `test_proof_success.uya` - 测试证明成功的情况（应编译通过）

## 实现步骤

1. **步骤 1**：实现证明失败错误报告函数（`checker_report_proof_failure`）
2. **步骤 2**：定义修复建议模板（数组访问、溢出、空指针、除零、未初始化）
3. **步骤 3**：实现数组访问证明失败检测和错误报告
4. **步骤 4**：实现整数溢出证明失败检测和错误报告
5. **步骤 5**：实现空指针解引用证明失败检测和错误报告
6. **步骤 6**：实现除零证明失败检测和错误报告
7. **步骤 7**：实现未初始化使用证明失败检测和错误报告
8. **步骤 8**：在 `checker_check_node` 中集成所有证明失败检测
9. **步骤 9**：优化错误消息格式（包含代码位置、上下文、修复建议）
10. **步骤 10**：添加测试用例并验证

## 技术难点

1. **错误消息质量**：需要生成清晰、有用的错误消息，帮助用户快速修复
2. **代码位置追踪**：需要在错误消息中显示准确的代码位置
3. **修复建议准确性**：需要根据实际代码生成准确的修复建议
4. **显式控制哲学**：确保不自动插入任何代码，只报告错误和建议

## 设计原则

### 显式控制哲学

Uya 语言遵循"显式控制哲学"：

- **程序员负责**：程序员必须显式处理所有不安全操作
- **编译器验证**：编译器验证程序员提供的证明
- **不自动插入**：编译器不自动插入任何运行时检查代码
- **失败即错误**：无法证明安全性时，报告编译错误并提供修复建议

### 错误消息设计原则

1. **清晰性**：错误消息应清晰说明问题
2. **可操作性**：提供具体的修复建议和代码示例
3. **上下文**：包含代码位置和上下文信息
4. **教育性**：帮助用户理解如何正确使用语言特性

## 参考资源

- Rust 编译器错误消息：参考错误消息格式和修复建议