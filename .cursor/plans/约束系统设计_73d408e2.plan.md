---
name: 约束系统设计
overview: 设计高效的约束表示和求解算法，用于内存安全证明中的路径敏感分析和符号执行。约束系统需要支持线性约束、逻辑组合、约束合并和简化。
todos:
  - id: constraint_ds
    content: 定义约束和符号值的数据结构（Constraint, ConstraintSet, SymbolicValue）
    status: pending
  - id: constraint_extract
    content: 实现约束提取函数（从表达式提取约束，支持比较运算符和逻辑组合）
    status: pending
    dependencies:
      - constraint_ds
  - id: constraint_simplify
    content: 实现约束简化函数（常量折叠、变量替换、线性约束简化）
    status: pending
    dependencies:
      - constraint_extract
  - id: constraint_verify
    content: 实现约束验证函数（数组访问、溢出、除零验证）
    status: pending
    dependencies:
      - constraint_simplify
  - id: constraint_integrate
    content: 在 checker_check_node 中集成约束系统（if 语句、数组访问等）
    status: pending
    dependencies:
      - constraint_verify
  - id: constraint_test
    content: 添加测试用例并验证约束系统功能
    status: pending
    dependencies:
      - constraint_integrate
---

# 约束系统设计实现计划

## 问题描述

内存安全证明需要高效的约束系统来：

- 表示路径敏感分析中的条件约束（如 `i >= 0 && i < 10`）
- 支持符号执行中的约束求解（如证明 `a + b <= max`）
- 合并和简化约束条件
- 验证约束是否满足（如 `i >= 0 && i < len` 证明数组访问安全）

## 技术方案

### 约束表示

**约束类型**：

1. **比较约束**：`x < c`, `x <= c`, `x > c`, `x >= c`, `x == c`, `x != c`
2. **算术约束**：`x + y < c`, `x - y > c`, `x * y <= c`（线性约束）
3. **逻辑组合**：`C1 && C2`, `C1 || C2`, `!C`

**约束结构**：

```c
typedef enum {
    CONSTRAINT_LT,    // <
    CONSTRAINT_LE,    // <=
    CONSTRAINT_GT,    // >
    CONSTRAINT_GE,    // >=
    CONSTRAINT_EQ,    // ==
    CONSTRAINT_NE     // !=
} ConstraintOp;

typedef struct Constraint {
    ConstraintOp op;           // 比较运算符
    SymbolicValue left;        // 左操作数（符号值）
    SymbolicValue right;       // 右操作数（符号值或常量）
    int is_true;               // 约束是否为真（1=真，0=假，-1=未知）
} Constraint;

typedef struct ConstraintSet {
    Constraint *constraints;   // 约束数组（从 Arena 分配）
    int count;                 // 约束数量
    int capacity;              // 容量
} ConstraintSet;
```



### 符号值表示

**符号值类型**：

```c
typedef enum {
    SYMBOLIC_CONST,    // 常量值
    SYMBOLIC_VAR,     // 符号变量（如 `i`, `a`, `b`）
    SYMBOLIC_EXPR     // 符号表达式（如 `a + b`, `i * 2`）
} SymbolicKind;

typedef struct SymbolicValue {
    SymbolicKind kind;
    union {
        int64_t const_value;           // 常量值
        const char *var_name;          // 变量名
        struct {
            SymbolicValue *left;       // 左操作数
            SymbolicValue *right;      // 右操作数
            int op;                    // 运算符（TOKEN_PLUS, TOKEN_MINUS, TOKEN_ASTERISK）
        } expr;
    } data;
} SymbolicValue;
```



### 约束求解算法

**1. 约束简化**：

- 常量折叠：`5 < 10` → `true`
- 变量替换：已知 `x = 5`，则 `x < 10` → `5 < 10` → `true`
- 线性约束简化：`x + 5 < 10` → `x < 5`

**2. 约束合并**：

- 合并相同变量的约束：`x < 10 && x > 0` → `0 < x < 10`
- 检测矛盾：`x < 5 && x > 10` → 矛盾（不可满足）

**3. 约束验证**：

- 验证数组访问：检查约束集中是否存在 `i >= 0 && i < len`
- 验证整数溢出：检查 `a + b <= max && a + b >= min`
- 验证除零：检查 `y != 0`

## 数据结构设计

### 在 TypeChecker 中添加约束系统

```c
// checker.h
typedef struct PathContext {
    ConstraintSet constraints;    // 当前路径的约束集
    int depth;                    // 路径深度（用于嵌套 if/while）
    struct PathContext *parent;   // 父路径上下文（用于作用域退出）
} PathContext;

typedef struct TypeChecker {
    // ... 现有字段 ...
    PathContext *current_path;    // 当前路径上下文
    PathContext *path_stack[64];  // 路径栈（用于嵌套控制流）
    int path_stack_depth;         // 路径栈深度
} TypeChecker;
```



## 算法实现

### 1. 约束收集

**在 if 语句中收集约束**：

```c
// checker.c
static void checker_collect_constraints_from_if(TypeChecker *checker, ASTNode *if_node) {
    ASTNode *condition = if_node->data.if_stmt.condition;
    ConstraintSet then_constraints = extract_constraints_from_expr(checker, condition, 1);  // 正条件
    ConstraintSet else_constraints = extract_constraints_from_expr(checker, condition, 0);    // 负条件
    
    // 在 then 分支中应用正约束
    push_path_context(checker, then_constraints);
    checker_check_node(checker, if_node->data.if_stmt.then_block);
    pop_path_context(checker);
    
    // 在 else 分支中应用负约束
    if (if_node->data.if_stmt.else_block) {
        push_path_context(checker, else_constraints);
        checker_check_node(checker, if_node->data.if_stmt.else_block);
        pop_path_context(checker);
    }
}
```

**约束提取**：

```c
static ConstraintSet extract_constraints_from_expr(TypeChecker *checker, ASTNode *expr, int is_positive) {
    ConstraintSet result = {0};
    
    if (expr->type == AST_BINARY_EXPR) {
        TokenType op = expr->data.binary_expr.op;
        if (op == TOKEN_AND_AND) {
            // C1 && C2：合并两个约束集
            ConstraintSet left = extract_constraints_from_expr(checker, expr->data.binary_expr.left, is_positive);
            ConstraintSet right = extract_constraints_from_expr(checker, expr->data.binary_expr.right, is_positive);
            return merge_constraint_sets(checker, left, right);
        } else if (op == TOKEN_OR_OR) {
            // C1 || C2：取交集（较复杂，暂不支持）
            return result;
        } else if (is_comparison_op(op)) {
            // 比较运算符：创建约束
            Constraint c = create_constraint_from_comparison(checker, expr, is_positive);
            return add_constraint_to_set(checker, result, c);
        }
    }
    
    return result;
}
```



### 2. 约束求解

**验证数组访问**：

```c
static int verify_array_access_safe(TypeChecker *checker, const char *index_var, int array_len) {
    ConstraintSet *cs = &checker->current_path->constraints;
    
    // 检查是否存在 i >= 0 && i < len
    int has_lower = 0, has_upper = 0;
    for (int i = 0; i < cs->count; i++) {
        Constraint *c = &cs->constraints[i];
        if (c->left.kind == SYMBOLIC_VAR && strcmp(c->left.data.var_name, index_var) == 0) {
            if (c->op == CONSTRAINT_GE && c->right.kind == SYMBOLIC_CONST && c->right.data.const_value == 0) {
                has_lower = 1;
            }
            if (c->op == CONSTRAINT_LT && c->right.kind == SYMBOLIC_CONST && c->right.data.const_value == array_len) {
                has_upper = 1;
            }
        }
    }
    
    return has_lower && has_upper;
}
```



### 3. 约束简化

**常量折叠和变量替换**：

```c
static int simplify_constraint(TypeChecker *checker, Constraint *c) {
    // 如果左右都是常量，直接求值
    if (c->left.kind == SYMBOLIC_CONST && c->right.kind == SYMBOLIC_CONST) {
        int64_t left_val = c->left.data.const_value;
        int64_t right_val = c->right.data.const_value;
        
        switch (c->op) {
            case CONSTRAINT_LT: return left_val < right_val;
            case CONSTRAINT_LE: return left_val <= right_val;
            case CONSTRAINT_GT: return left_val > right_val;
            case CONSTRAINT_GE: return left_val >= right_val;
            case CONSTRAINT_EQ: return left_val == right_val;
            case CONSTRAINT_NE: return left_val != right_val;
        }
    }
    
    // 变量替换：查找符号表中变量的值
    if (c->left.kind == SYMBOLIC_VAR) {
        Symbol *sym = symbol_table_lookup(checker, c->left.data.var_name);
        if (sym && sym->is_const) {
            // 替换为常量值
            c->left.kind = SYMBOLIC_CONST;
            c->left.data.const_value = get_const_value(checker, sym);
            return simplify_constraint(checker, c);  // 递归简化
        }
    }
    
    return -1;  // 无法简化
}
```



## 集成点

### 在 checker_check_node 中集成

```c
// checker.c
static int checker_check_node(TypeChecker *checker, ASTNode *node) {
    switch (node->type) {
        case AST_IF_STMT:
            checker_collect_constraints_from_if(checker, node);
            break;
            
        case AST_ARRAY_ACCESS: {
            // 检查数组访问安全性
            ASTNode *index_expr = node->data.array_access.index;
            Type array_type = checker_infer_type(checker, node->data.array_access.array);
            
            if (array_type.kind == TYPE_ARRAY) {
                int array_len = array_type.data.array.array_size;
                // 如果是常量索引，直接检查
                int const_index = checker_eval_const_expr(checker, index_expr);
                if (const_index >= 0) {
                    if (const_index < 0 || const_index >= array_len) {
                        checker_report_error(checker, node, "数组索引越界");
                        return -1;
                    }
                } else {
                    // 变量索引：使用约束系统验证
                    const char *index_var = extract_var_name(index_expr);
                    if (!verify_array_access_safe(checker, index_var, array_len)) {
                        // 证明超时或无法证明：标记需要运行时检查
                        node->needs_runtime_check = 1;
                    }
                }
            }
            break;
        }
        
        // ... 其他节点类型 ...
    }
}
```



## 测试策略

### 测试用例

1. **约束收集测试**：

- `test_constraint_collect.uya` - 测试 if 语句中的约束收集

2. **约束求解测试**：

- `test_constraint_solve.uya` - 测试约束求解算法

3. **数组访问验证测试**：

- `test_constraint_array_access.uya` - 测试数组访问的约束验证

4. **约束简化测试**：

- `test_constraint_simplify.uya` - 测试约束简化（常量折叠、变量替换）

## 实现步骤

1. **步骤 1**：定义约束和符号值的数据结构（`checker.h`）
2. **步骤 2**：实现约束提取函数（从表达式提取约束）
3. **步骤 3**：实现约束合并和简化函数
4. **步骤 4**：实现约束验证函数（数组访问、溢出、除零）
5. **步骤 5**：在 `checker_check_node` 中集成约束系统
6. **步骤 6**：添加测试用例并验证