---
name: 实现编译期证明机制
overview: 实现完整的编译期证明机制，包括符号表管理、类型检查、常量求值、路径敏感分析和所有安全检查（数组边界、整数溢出、除零、const赋值、未初始化、空指针）。
todos: []
---

# 实现编译期证明机制

## 架构设计

编译期证明机制的核心是类型检查器（TypeChecker），它需要实现：

1. **符号表和作用域管理** - 跟踪变量定义和类型
2. **类型系统** - 类型推断和类型匹配检查
3. **常量表达式求值** - 编译期常量计算
4. **路径敏感分析** - 跟踪控制流路径，建立约束条件
5. **安全检查** - 验证所有UB场景的安全性
```javascript
AST → TypeChecker → 符号表/作用域 → 类型检查 → 安全检查 → IR生成
                      ↓
                   错误报告
```




## 实现步骤

### 阶段1：基础设施（符号表和类型系统）

#### 1.1 扩展 TypeChecker 结构

- 文件：`compiler/src/checker/typechecker.h` 和 `typechecker.c`
- 添加：
- 错误管理（错误列表、错误计数）
- 符号表（变量名 → 符号信息）
- 作用域栈（管理嵌套作用域）
- 类型注册表（跟踪所有类型定义）
- 约束条件集合（用于路径敏感分析）

#### 1.2 实现符号表

- 符号结构：变量名、类型、作用域层级、是否可变、是否已初始化
- 符号表操作：添加符号、查找符号、作用域进入/退出

#### 1.3 实现类型系统

- 类型推断函数：从AST节点推断类型
- 类型匹配检查：验证两个类型是否完全一致
- 类型转换检查：验证 `as` 和 `as!` 转换的合法性

### 阶段2：常量表达式求值

#### 2.1 常量表达式求值器

- 文件：`compiler/src/checker/const_eval.c`（新建）
- 功能：
- 求值字面量（整数、浮点、布尔）
- 求值常量变量引用
- 求值算术运算（+、-、*、/、%）
- 求值位运算（&、|、^、~、<<、>>）
- 求值比较运算（==、!=、<、>、<=、>=）
- 求值逻辑运算（&&、||、!）
- 溢出检测：常量运算溢出时报告编译错误

#### 2.2 集成到类型检查器

- 在类型检查时识别常量表达式
- 对常量表达式进行编译期求值
- 将求值结果用于后续检查（如数组大小）

### 阶段3：路径敏感分析框架

#### 3.1 约束条件系统

- 文件：`compiler/src/checker/constraints.c`（新建）
- 约束类型：
- 范围约束：`x >= 0 && x < 10`
- 非零约束：`x != 0`
- 空指针约束：`ptr != null`
- 初始化约束：`var x is initialized`
- 约束传播：通过if语句建立约束，在then/else分支中应用

#### 3.2 路径敏感分析

- 跟踪控制流路径（if、while、for）
- 在每个分支中维护约束条件集合
- 合并分支后的约束条件

### 阶段4：安全检查实现

#### 4.1 const变量赋值检查

- 在赋值语句检查时：
- 查找目标变量的符号
- 检查 `is_mut` 标志
- 如果 `is_const == 1` 或 `is_mut == 0`，报告编译错误

#### 4.2 数组边界检查

- 常量索引：直接检查是否在 `[0, len)` 范围内
- 变量索引：
- 检查约束条件中是否有 `i >= 0 && i < len`
- 如果没有，报告编译错误
- 多维数组：检查所有维度的边界

#### 4.3 整数溢出检查

- 常量运算：编译期计算，检查是否溢出
- 变量运算：
- 检查是否有显式溢出检查（如 `if a > 0 && b > 0 && a > max - b`）
- 或检查约束条件能否证明无溢出
- 无法证明则报告编译错误

#### 4.4 除零检查

- 常量除零：编译期检查除数是否为0
- 变量除零：
- 检查约束条件中是否有 `y != 0`
- 如果没有，报告编译错误

#### 4.5 未初始化内存检查

- 跟踪变量是否已初始化
- 在变量使用时检查初始化状态
- 未初始化则报告编译错误

#### 4.6 空指针解引用检查

- 跟踪指针变量的空指针检查
- 在解引用前检查约束条件中是否有 `ptr != null`
- 如果没有，报告编译错误

### 阶段5：类型检查主流程

#### 5.1 AST遍历

- 实现递归遍历AST的函数
- 对每个节点类型调用相应的检查函数：
- `typecheck_var_decl` - 变量声明
- `typecheck_assign` - 赋值语句
- `typecheck_binary_expr` - 二元表达式
- `typecheck_subscript` - 数组访问
- `typecheck_call` - 函数调用
- `typecheck_if_stmt` - if语句（建立约束）
- 等等

#### 5.2 错误报告

- 实现错误消息格式化
- 包含文件名、行号、列号
- 提供修复建议

### 阶段6：集成到编译流程

#### 6.1 修改主流程

- 文件：`compiler/src/main.c`
- 在IR生成之前调用类型检查器
- 如果类型检查失败，停止编译并报告错误

#### 6.2 测试

- 为每个安全检查创建测试用例
- 验证正确代码通过检查
- 验证错误代码被正确拒绝

## 关键数据结构

```c
// 符号信息
typedef struct Symbol {
    char *name;
    IRType type;
    int is_mut;
    int is_const;
    int is_initialized;
    int scope_level;
    int line, column;
    char *filename;
} Symbol;

// 约束条件
typedef struct Constraint {
    enum {
        CONSTRAINT_RANGE,      // x >= min && x < max
        CONSTRAINT_NONZERO,     // x != 0
        CONSTRAINT_NOT_NULL,    // ptr != null
        CONSTRAINT_INITIALIZED  // var is initialized
    } type;
    char *var_name;
    // 根据类型存储相应数据
} Constraint;

// 约束集合
typedef struct ConstraintSet {
    Constraint **constraints;
    int count;
    int capacity;
} ConstraintSet;
```



## 实现文件清单

1. `compiler/src/checker/typechecker.h` - 扩展头文件
2. `compiler/src/checker/typechecker.c` - 主实现
3. `compiler/src/checker/const_eval.h` - 常量求值头文件（新建）
4. `compiler/src/checker/const_eval.c` - 常量求值实现（新建）
5. `compiler/src/checker/constraints.h` - 约束系统头文件（新建）
6. `compiler/src/checker/constraints.c` - 约束系统实现（新建）
7. `compiler/src/main.c` - 集成类型检查到主流程

## 注意事项

1. **性能**：符号表使用哈希表实现O(1)查找
2. **内存管理**：所有动态分配的内存需要正确释放
3. **错误处理**：收集所有错误，不要在第一处错误就停止
4. **向后兼容**：保持对现有代码的兼容性
5. **测试覆盖**：为每个安全检查创建正反测试用例

## 测试策略

为每个安全检查创建测试用例：

- `tests/typecheck_const_assign.uya` - const赋值检查
- `tests/typecheck_array_bounds.uya` - 数组边界检查
- `tests/typecheck_overflow.uya` - 整数溢出检查