---
name: 实现文件级并行编译（每个文件生成独立C文件）
overview: 实现文件级并行编译，每个 uya 文件独立编译生成一个 C 文件，然后链接所有 C 文件。使用 POSIX pthread 实现并行编译，支持依赖排序和增量编译。
todos:
  - id: design_compilation_model
    content: 设计新的编译模型：两阶段编译（类型信息收集 + 并行编译），依赖图排序，每个文件独立生成 C 文件
    status: pending
  - id: create_thread_pool
    content: 创建线程池模块（thread_pool.h/c），实现基于 pthread 的线程池，支持任务提交和结果收集
    status: pending
  - id: implement_type_collection
    content: 实现类型信息收集阶段：快速解析所有文件，收集结构体、函数签名等类型信息，构建全局类型表
    status: pending
    dependencies:
      - design_compilation_model
  - id: implement_dependency_sorting
    content: 实现依赖图排序：根据 use 语句构建依赖图，按依赖顺序排序文件列表
    status: pending
    dependencies:
      - design_compilation_model
  - id: implement_per_file_compilation
    content: 实现单文件编译函数：每个文件独立进行词法分析、语法分析、类型检查、代码生成，生成独立的 C 文件
    status: pending
    dependencies:
      - implement_type_collection
      - create_thread_pool
  - id: implement_parallel_compilation
    content: 实现并行编译：使用线程池并行编译所有文件（在依赖顺序允许的情况下），每个文件生成独立的 C 文件
    status: pending
    dependencies:
      - implement_per_file_compilation
      - implement_dependency_sorting
  - id: implement_header_generation
    content: 实现头文件生成：为每个 C 文件生成对应的 .h 头文件，包含函数声明、结构体定义等（或使用 extern 声明）
    status: pending
    dependencies:
      - implement_per_file_compilation
  - id: modify_main_compilation_flow
    content: 修改主编译流程 compile_files：替换单文件输出为多文件输出，添加链接阶段（gcc 链接所有 C 文件）
    status: pending
    dependencies:
      - implement_parallel_compilation
      - implement_header_generation
  - id: update_makefile
    content: 更新 Makefile，添加 pthread 链接选项（-lpthread）
    status: pending
    dependencies:
      - create_thread_pool
  - id: testing
    content: 测试并行编译的正确性和性能，验证多文件编译结果与单文件合并编译结果一致，测试增量编译场景
    status: pending
    dependencies:
      - modify_main_compilation_flow
---

# 实现文件级并行编译（每个文件生成独立C文件）

## 目标

实现文件级并行编译，每个 uya 文件独立编译生成一个 C 文件，然后链接所有 C 文件。这种方式类似于传统编译器（gcc）的做法，支持完全并行化和增量编译。

## 当前架构分析

### 当前编译流程（`compiler-mini/src/main.c`）

1. **依赖收集阶段**（`collect_module_dependencies`）：递归收集所有模块依赖
2. **词法/语法分析阶段**（第 826-860 行）：顺序解析所有文件
3. **AST 合并阶段**（第 864 行）：合并所有文件的 AST 成一个 AST_PROGRAM
4. **类型检查阶段**（第 872-894 行）：对整个合并后的 AST 进行类型检查
5. **代码生成阶段**（第 896-923 行）：生成单个 C99 文件

### 新方案的优势

1. **完全并行化**：每个文件可以独立处理（词法、语法、类型检查、代码生成）
2. **增量编译**：只重新编译修改的文件
3. **内存效率**：不需要合并所有 AST，内存占用更小
4. **符合传统模式**：类似 gcc 的 .c → .o → 链接流程

## 实现方案

### 1. 两阶段编译模型

#### 阶段 1：类型信息收集（串行或轻量并行）

- 快速解析所有文件，只提取类型信息：
- 结构体定义（struct）
- 联合体定义（union）
- 接口定义（interface）
- 枚举定义（enum）
- 函数签名（函数名、参数类型、返回类型）
- 全局变量类型
- 构建全局类型表（TypeChecker 的 ModuleTable）
- 用于后续类型检查阶段

#### 阶段 2：并行编译（完全并行）

- 根据依赖图排序文件
- 并行编译所有文件（在依赖允许的情况下）
- 每个文件：

1. 词法分析
2. 语法分析
3. 类型检查（使用阶段1收集的类型信息）
4. 代码生成（生成独立的 C 文件）

### 2. 依赖图排序

- 根据 `use` 语句构建有向无环图（DAG）
- 使用拓扑排序确定编译顺序
- 无依赖的文件可以并行编译
- 有依赖的文件按依赖顺序编译（被依赖的文件先编译）

### 3. 每个文件独立编译

#### 3.1 单文件编译函数

```c
typedef struct {
    const char *filename;
    const char *output_c_file;  // 输出的 C 文件路径
    Arena *arena;  // 独立的 Arena
    TypeChecker *global_type_checker;  // 全局类型检查器（只读）
    ASTNode *result_ast;  // 解析结果
    int error_code;  // 错误码
} CompileTask;
```



#### 3.2 编译流程（每个文件）

1. 读取文件内容
2. 词法分析（Lexer）
3. 语法分析（Parser）
4. 类型检查（使用全局类型检查器，但每个文件有独立的符号表作用域）
5. 代码生成（生成独立的 C 文件）

### 4. 头文件生成策略

**选项 A：生成独立的 .h 头文件**

- 每个 .uya 文件生成对应的 .h 文件
- 包含函数声明、结构体定义等
- C 文件包含对应的头文件

**选项 B：使用 extern 声明（推荐）**

- 在生成的 C 文件中使用 extern 声明外部函数/变量
- 不需要单独的头文件
- 简化实现

**推荐选项 B**：在代码生成时，对于跨文件的引用，生成 extern 声明。

### 5. 链接阶段

- 编译完成后，使用 gcc 链接所有生成的 C 文件
- 类似于：`gcc file1.c file2.c file3.c -o output`
- 如果指定了 `-exec` 选项，自动执行链接

## 实现步骤

### 步骤 1：设计编译模型

- 定义两阶段编译的数据结构
- 设计全局类型表的接口
- 设计依赖图的数据结构

### 步骤 2：实现类型信息收集

- 创建轻量级解析函数（只提取类型信息）
- 构建全局类型表（ModuleTable）
- 处理 use 语句，构建模块依赖关系

### 步骤 3：实现依赖图排序

- 根据 use 语句构建依赖图
- 实现拓扑排序算法
- 确定文件编译顺序

### 步骤 4：实现单文件编译函数

- 函数：`compile_single_file`
- 功能：完整的单文件编译流程（词法→语法→类型检查→代码生成）
- 使用全局类型检查器进行类型检查

### 步骤 5：实现并行编译

- 使用线程池并行编译文件
- 根据依赖顺序调度任务
- 每个文件生成独立的 C 文件

### 步骤 6：实现头文件/外部声明生成

- 在代码生成时，识别跨文件引用
- 生成 extern 声明或包含头文件

### 步骤 7：修改主编译流程

- 修改 `compile_files` 函数
- 实现两阶段编译
- 添加链接阶段（如果指定 -exec）

### 步骤 8：测试和验证

- 测试多文件编译的正确性
- 验证生成的 C 文件可以正确链接
- 性能测试（编译时间对比）
- 增量编译测试

## 关键文件

- `compiler-mini/src/main.c`：修改 `compile_files` 函数，实现两阶段编译和并行编译
- `compiler-mini/src/thread_pool.h`：线程池头文件（新建）
- `compiler-mini/src/thread_pool.c`：线程池实现（新建）
- `compiler-mini/src/checker.c`：可能需要修改以支持全局类型表（只读访问）
- `compiler-mini/src/codegen/c99/main.c`：可能需要修改以支持 extern 声明生成
- `compiler-mini/Makefile`：添加 pthread 链接选项（`-lpthread`）

## 技术挑战

### 1. 类型检查的跨文件访问

- 当前类型检查器需要访问所有声明（通过 `program_node`）
- 新方案需要访问全局类型表
- 解决方案：TypeChecker 维护全局类型表（ModuleTable），每个文件的类型检查使用全局类型表查找跨文件类型

### 2. 循环依赖检测

- 需要在类型信息收集阶段检测循环依赖
- 使用现有的 `detect_circular_dependencies` 函数

### 3. 代码生成的跨文件引用

- 函数调用：生成函数调用（如果在本文件中定义）或 extern 声明（如果在其他文件中）
- 类型引用：结构体、枚举等类型的引用
- 全局变量：extern 声明

### 4. 模块可见性（export）

- 只有 export 的项才能被其他文件访问
- 需要在类型信息收集阶段记录 export 信息
- 在代码生成时检查可见性

## 注意事项

1. **向后兼容**：保持与现有单文件输出模式的兼容性（可通过编译选项控制）
2. **错误处理**：线程中的错误需要正确传递到主线程
3. **内存管理**：每个文件使用独立的 Arena，确保不泄漏
4. **性能优化**：小文件可能不如串行快，需要根据文件数量动态选择
5. **链接器依赖**：需要系统有 gcc 或 clang 链接器

## 可选优化

1. **增量编译**：记录文件的修改时间，只重新编译修改的文件
2. **编译缓存**：缓存已编译的 C 文件，避免重复编译
3. **并行链接**：如果文件很多，可以考虑并行编译 C 文件为 .o 文件，然后链接