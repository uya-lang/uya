# 证明超时机制实现计划

## 问题描述

证明超时机制需要：

- 设置证明时间限制和步数限制
- 在证明过程中跟踪步数和时间
- 检测证明超时
- 超时时标记需要运行时检查，而不是报编译错误
- 平衡证明能力和编译速度

## 技术方案

### 证明超时配置

**配置结构**：

```c
// checker.h
typedef struct ProofConfig {
    int timeout_ms;           // 证明超时时间（毫秒，默认 100ms）
    int step_limit;           // 证明步数限制（默认 1000 步）
    int max_path_depth;       // 最大路径深度（默认 10）
    int max_loop_iterations;  // 最大循环迭代次数（默认 3）
} ProofConfig;

typedef struct ProofState {
    int current_steps;        // 当前证明步数
    int start_time_ms;        // 证明开始时间（毫秒，可选）
    int is_timeout;           // 是否超时（1=是，0=否）
    ProofConfig config;        // 证明配置
} ProofState;

typedef struct TypeChecker {
    // ... 现有字段 ...
    ProofState proof_state;   // 证明状态
} TypeChecker;
```



### 证明过程跟踪

**步数计数**：

```c
// checker.c
static void proof_increment_step(TypeChecker *checker) {
    checker->proof_state.current_steps++;
    
    // 检查步数限制
    if (checker->proof_state.current_steps > checker->proof_state.config.step_limit) {
        checker->proof_state.is_timeout = 1;
    }
}

static int proof_check_timeout(TypeChecker *checker) {
    // 检查步数限制
    if (checker->proof_state.current_steps > checker->proof_state.config.step_limit) {
        return 1;  // 超时
    }
    
    // 检查时间限制（如果支持）
    #ifdef HAVE_CLOCK_GETTIME
    if (checker->proof_state.start_time_ms > 0) {
        struct timespec now;
        clock_gettime(CLOCK_MONOTONIC, &now);
        int elapsed_ms = (now.tv_sec * 1000 + now.tv_nsec / 1000000) - 
                         checker->proof_state.start_time_ms;
        if (elapsed_ms > checker->proof_state.config.timeout_ms) {
            return 1;  // 超时
        }
    }
    #endif
    
    return 0;  // 未超时
}
```



### 证明超时检测

**在证明函数中检测超时**：

```c
static int verify_with_timeout(TypeChecker *checker, 
                                Constraint *constraint,
                                const char *operation) {
    // 开始证明
    proof_start(checker);
    
    // 执行证明
    int result = satisfy_constraint(checker, constraint);
    
    // 检查超时
    if (proof_check_timeout(checker)) {
        // 证明超时，返回 -1 表示需要运行时检查
        return -1;
    }
    
    return result;
}
```



### 超时标记

**在 AST 节点中标记需要运行时检查**：

```c
// ast.h
typedef struct ASTNode {
    // ... 现有字段 ...
    int needs_runtime_check;  // 需要运行时检查（1=是，0=否）
    int proof_timeout;        // 证明超时（1=是，0=否）
} ASTNode;
```

**标记函数**：

```c
static void mark_runtime_check(TypeChecker *checker, ASTNode *node, const char *reason) {
    node->needs_runtime_check = 1;
    node->proof_timeout = checker->proof_state.is_timeout;
    
    // 可选：记录原因（用于调试）
    #ifdef DEBUG_PROOF
    if (reason) {
        fprintf(stderr, "标记运行时检查: %s (原因: %s)\n", 
                node_to_string(node), reason);
    }
    #endif
}
```



## 数据结构设计

### 证明状态管理

```c
// checker.c
static void proof_start(TypeChecker *checker) {
    checker->proof_state.current_steps = 0;
    checker->proof_state.is_timeout = 0;
    
    #ifdef HAVE_CLOCK_GETTIME
    struct timespec now;
    clock_gettime(CLOCK_MONOTONIC, &now);
    checker->proof_state.start_time_ms = now.tv_sec * 1000 + now.tv_nsec / 1000000;
    #else
    checker->proof_state.start_time_ms = 0;
    #endif
}

static void proof_reset(TypeChecker *checker) {
    proof_start(checker);
}
```



## 算法实现

### 1. 数组访问证明（带超时）

```c
static int verify_array_access_with_timeout(TypeChecker *checker, 
                                             ASTNode *node,
                                             const char *index_var,
                                             int array_len) {
    proof_start(checker);
    
    // 建立约束
    Constraint lower = create_constraint(index_var, CONSTRAINT_GE, 0);
    Constraint upper = create_constraint(index_var, CONSTRAINT_LT, array_len);
    
    // 验证约束
    int lower_ok = verify_with_timeout(checker, &lower, "数组下界检查");
    int upper_ok = verify_with_timeout(checker, &upper, "数组上界检查");
    
    // 检查超时
    if (proof_check_timeout(checker)) {
        mark_runtime_check(checker, node, "证明超时");
        return -1;  // 超时，需要运行时检查
    }
    
    if (lower_ok == 1 && upper_ok == 1) {
        return 1;  // 证明安全
    }
    
    // 无法证明，标记运行时检查
    mark_runtime_check(checker, node, "无法证明安全性");
    return -1;
}
```



### 2. 溢出证明（带超时）

```c
static int verify_overflow_with_timeout(TypeChecker *checker,
                                       ASTNode *node,
                                       SymbolicValue *left,
                                       SymbolicValue *right,
                                       Type type) {
    proof_start(checker);
    
    // 建立约束
    int64_t max_val = get_type_max(type);
    int64_t min_val = get_type_min(type);
    
    SymbolicValue *sum = symbolic_add(checker, left, right);
    Constraint upper = create_constraint_symbolic(sum, CONSTRAINT_LE, max_val);
    Constraint lower = create_constraint_symbolic(sum, CONSTRAINT_GE, min_val);
    
    // 验证约束
    int upper_ok = verify_with_timeout(checker, &upper, "溢出上界检查");
    int lower_ok = verify_with_timeout(checker, &lower, "溢出下界检查");
    
    // 检查超时
    if (proof_check_timeout(checker)) {
        mark_runtime_check(checker, node, "证明超时");
        return -1;
    }
    
    if (upper_ok == 1 && lower_ok == 1) {
        return 1;  // 证明安全
    }
    
    mark_runtime_check(checker, node, "无法证明无溢出");
    return -1;
}
```



### 3. 证明超时恢复

```c
static int checker_check_node_with_timeout(TypeChecker *checker, ASTNode *node) {
    // 保存当前证明状态
    ProofState saved_state = checker->proof_state;
    
    // 执行检查
    int result = checker_check_node(checker, node);
    
    // 如果超时，恢复状态并标记节点
    if (checker->proof_state.is_timeout) {
        checker->proof_state = saved_state;
        mark_runtime_check(checker, node, "证明超时");
    }
    
    return result;
}
```



## 集成点

### 在 checker_check_node 中集成超时检测

```c
static int checker_check_node(TypeChecker *checker, ASTNode *node) {
    // 检查超时
    if (proof_check_timeout(checker)) {
        mark_runtime_check(checker, node, "证明超时");
        return 0;  // 不报错，标记运行时检查
    }
    
    switch (node->type) {
        case AST_ARRAY_ACCESS: {
            // 数组访问检查（带超时）
            ASTNode *index_expr = node->data.array_access.index;
            Type array_type = checker_infer_type(checker, node->data.array_access.array);
            
            if (array_type.kind == TYPE_ARRAY) {
                int array_len = array_type.data.array.array_size;
                int const_index = checker_eval_const_expr(checker, index_expr);
                
                if (const_index >= 0) {
                    // 常量索引：直接检查
                    if (const_index < 0 || const_index >= array_len) {
                        checker_report_error(checker, node, "数组索引越界");
                        return -1;
                    }
                } else {
                    // 变量索引：使用证明（带超时）
                    const char *index_var = extract_var_name(index_expr);
                    verify_array_access_with_timeout(checker, node, index_var, array_len);
                }
            }
            break;
        }
        
        case AST_BINARY_EXPR: {
            // 算术运算溢出检查（带超时）
            TokenType op = node->data.binary_expr.op;
            if (op == TOKEN_PLUS || op == TOKEN_MINUS || op == TOKEN_ASTERISK) {
                Type left_type = checker_infer_type(checker, node->data.binary_expr.left);
                if (is_integer_type(left_type.kind)) {
                    SymbolicValue *left_sv = expr_to_symbolic(checker, node->data.binary_expr.left);
                    SymbolicValue *right_sv = expr_to_symbolic(checker, node->data.binary_expr.right);
                    
                    if (left_sv && right_sv) {
                        verify_overflow_with_timeout(checker, node, left_sv, right_sv, left_type);
                    }
                }
            }
            break;
        }
        
        // ... 其他节点类型 ...
    }
    
    return 0;
}
```



## 配置选项

### 编译器选项

```c
// main.c
typedef struct CompilerOptions {
    // ... 现有选项 ...
    int proof_timeout_ms;      // 证明超时时间（毫秒）
    int proof_step_limit;     // 证明步数限制
} CompilerOptions;

// 命令行选项
// --proof-timeout=100   设置证明超时时间
// --proof-steps=1000    设置证明步数限制
```



## 测试策略

### 测试用例

1. **证明超时检测测试**：

- `test_proof_timeout.uya` - 测试证明超时检测

2. **运行时检查标记测试**：

- `test_runtime_check_mark.uya` - 测试运行时检查标记

3. **证明性能测试**：

- `test_proof_performance.uya` - 测试证明性能（不应过慢）

## 实现步骤

1. **步骤 1**：定义证明超时配置和状态（`checker.h`）
2. **步骤 2**：实现证明过程跟踪（步数计数、时间计时）
3. **步骤 3**：实现证明超时检测函数
4. **步骤 4**：在 AST 节点中添加运行时检查标记
5. **步骤 5**：在证明函数中集成超时检测
6. **步骤 6**：添加测试用例并验证

## 技术难点

1. **时间计时**：需要平台相关的时间函数（clock_gettime 等）
2. **超时恢复**：需要正确恢复证明状态，避免影响后续证明
3. **性能平衡**：需要平衡证明能力和编译速度

## 参考资源

- 静态分析工具（Clang Static Analyzer）：参考超时机制