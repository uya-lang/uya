# 符号执行实现计划

## 问题描述

符号执行需要：

- 表示符号变量和符号表达式（如 `a + b`, `i * 2`）
- 对符号值进行算术运算
- 建立符号约束（如 `a + b <= max`）
- 求解符号约束（验证安全性）

## 技术方案

### 符号值表示

**符号值结构**（已在约束系统设计中定义，这里扩展）：

```c
// checker.h
typedef enum {
    SYMBOLIC_CONST,    // 常量值
    SYMBOLIC_VAR,     // 符号变量（如 `i`, `a`, `b`）
    SYMBOLIC_EXPR     // 符号表达式（如 `a + b`, `i * 2`）
} SymbolicKind;

typedef struct SymbolicValue {
    SymbolicKind kind;
    union {
        int64_t const_value;           // 常量值
        const char *var_name;          // 变量名
        struct {
            struct SymbolicValue *left;       // 左操作数（从 Arena 分配）
            struct SymbolicValue *right;      // 右操作数（从 Arena 分配）
            int op;                    // 运算符（TOKEN_PLUS, TOKEN_MINUS, TOKEN_ASTERISK, TOKEN_SLASH）
        } expr;
    } data;
} SymbolicValue;
```



### 符号算术运算

**符号值运算函数**：

```c
// checker.c
static SymbolicValue *symbolic_add(TypeChecker *checker, 
                                    SymbolicValue *left, 
                                    SymbolicValue *right) {
    // 常量折叠
    if (left->kind == SYMBOLIC_CONST && right->kind == SYMBOLIC_CONST) {
        SymbolicValue *result = (SymbolicValue *)arena_alloc(checker->arena, sizeof(SymbolicValue));
        result->kind = SYMBOLIC_CONST;
        result->data.const_value = left->data.const_value + right->data.const_value;
        return result;
    }
    
    // 符号表达式
    SymbolicValue *result = (SymbolicValue *)arena_alloc(checker->arena, sizeof(SymbolicValue));
    result->kind = SYMBOLIC_EXPR;
    result->data.expr.left = left;
    result->data.expr.right = right;
    result->data.expr.op = TOKEN_PLUS;
    return result;
}

static SymbolicValue *symbolic_sub(TypeChecker *checker, 
                                    SymbolicValue *left, 
                                    SymbolicValue *right) {
    // 类似 symbolic_add，但 op = TOKEN_MINUS
    // ...
}

static SymbolicValue *symbolic_mul(TypeChecker *checker, 
                                    SymbolicValue *left, 
                                    SymbolicValue *right) {
    // 类似 symbolic_add，但 op = TOKEN_ASTERISK
    // ...
}

static SymbolicValue *symbolic_div(TypeChecker *checker, 
                                    SymbolicValue *left, 
                                    SymbolicValue *right) {
    // 类似 symbolic_add，但 op = TOKEN_SLASH
    // 需要检查除零
    // ...
}
```



### 符号约束建立

**从表达式建立符号约束**：

```c
static SymbolicValue *expr_to_symbolic(TypeChecker *checker, ASTNode *expr) {
    if (expr == NULL) return NULL;
    
    switch (expr->type) {
        case AST_NUMBER: {
            SymbolicValue *sv = (SymbolicValue *)arena_alloc(checker->arena, sizeof(SymbolicValue));
            sv->kind = SYMBOLIC_CONST;
            sv->data.const_value = expr->data.number.value;
            return sv;
        }
        
        case AST_IDENTIFIER: {
            SymbolicValue *sv = (SymbolicValue *)arena_alloc(checker->arena, sizeof(SymbolicValue));
            sv->kind = SYMBOLIC_VAR;
            sv->data.var_name = expr->data.identifier.name;
            return sv;
        }
        
        case AST_BINARY_EXPR: {
            SymbolicValue *left = expr_to_symbolic(checker, expr->data.binary_expr.left);
            SymbolicValue *right = expr_to_symbolic(checker, expr->data.binary_expr.right);
            
            TokenType op = expr->data.binary_expr.op;
            switch (op) {
                case TOKEN_PLUS: return symbolic_add(checker, left, right);
                case TOKEN_MINUS: return symbolic_sub(checker, left, right);
                case TOKEN_ASTERISK: return symbolic_mul(checker, left, right);
                case TOKEN_SLASH: return symbolic_div(checker, left, right);
                default: return NULL;
            }
        }
        
        default:
            return NULL;
    }
}
```



### 符号约束求解

**验证整数溢出**：

```c
static int verify_overflow_safe(TypeChecker *checker, 
                                SymbolicValue *left, 
                                SymbolicValue *right,
                                Type type) {
    // 获取类型范围
    int64_t max_val = get_type_max(type);
    int64_t min_val = get_type_min(type);
    
    // 建立约束：left + right <= max && left + right >= min
    SymbolicValue *sum = symbolic_add(checker, left, right);
    
    // 检查上溢：sum <= max
    Constraint upper = {
        .op = CONSTRAINT_LE,
        .left = *sum,
        .right = {.kind = SYMBOLIC_CONST, .data.const_value = max_val}
    };
    
    // 检查下溢：sum >= min
    Constraint lower = {
        .op = CONSTRAINT_GE,
        .left = *sum,
        .right = {.kind = SYMBOLIC_CONST, .data.const_value = min_val}
    };
    
    // 验证约束是否满足
    return satisfy_constraint(checker, &upper) && 
           satisfy_constraint(checker, &lower);
}
```

**验证数组访问**：

```c
static int verify_array_access_symbolic(TypeChecker *checker, 
                                         SymbolicValue *index,
                                         int array_len) {
    // 建立约束：index >= 0 && index < len
    Constraint lower = {
        .op = CONSTRAINT_GE,
        .left = *index,
        .right = {.kind = SYMBOLIC_CONST, .data.const_value = 0}
    };
    
    Constraint upper = {
        .op = CONSTRAINT_LT,
        .left = *index,
        .right = {.kind = SYMBOLIC_CONST, .data.const_value = array_len}
    };
    
    // 检查约束集中是否存在这两个约束
    return has_constraint(checker, &lower) && has_constraint(checker, &upper);
}
```

**验证除零**：

```c
static int verify_div_zero_safe(TypeChecker *checker, SymbolicValue *divisor) {
    // 建立约束：divisor != 0
    Constraint not_zero = {
        .op = CONSTRAINT_NE,
        .left = *divisor,
        .right = {.kind = SYMBOLIC_CONST, .data.const_value = 0}
    };
    
    // 检查约束集中是否存在这个约束
    return has_constraint(checker, &not_zero);
}
```



## 数据结构设计

### 符号值池（可选优化）

```c
// checker.h
typedef struct SymbolicPool {
    SymbolicValue *values[256];  // 符号值池（避免重复分配）
    int count;
} SymbolicPool;

typedef struct TypeChecker {
    // ... 现有字段 ...
    SymbolicPool symbolic_pool;   // 符号值池
} TypeChecker;
```



## 算法实现

### 1. 符号表达式简化

```c
static SymbolicValue *simplify_symbolic_expr(TypeChecker *checker, SymbolicValue *sv) {
    if (sv->kind != SYMBOLIC_EXPR) return sv;
    
    // 常量折叠
    if (sv->data.expr.left->kind == SYMBOLIC_CONST && 
        sv->data.expr.right->kind == SYMBOLIC_CONST) {
        int64_t left_val = sv->data.expr.left->data.const_value;
        int64_t right_val = sv->data.expr.right->data.const_value;
        int64_t result_val = 0;
        
        switch (sv->data.expr.op) {
            case TOKEN_PLUS: result_val = left_val + right_val; break;
            case TOKEN_MINUS: result_val = left_val - right_val; break;
            case TOKEN_ASTERISK: result_val = left_val * right_val; break;
            case TOKEN_SLASH: 
                if (right_val == 0) return NULL;  // 除零
                result_val = left_val / right_val; 
                break;
            default: return sv;
        }
        
        SymbolicValue *result = (SymbolicValue *)arena_alloc(checker->arena, sizeof(SymbolicValue));
        result->kind = SYMBOLIC_CONST;
        result->data.const_value = result_val;
        return result;
    }
    
    // 递归简化左右操作数
    sv->data.expr.left = simplify_symbolic_expr(checker, sv->data.expr.left);
    sv->data.expr.right = simplify_symbolic_expr(checker, sv->data.expr.right);
    
    return sv;
}
```



### 2. 约束满足性检查

```c
static int satisfy_constraint(TypeChecker *checker, Constraint *c) {
    // 简化约束
    simplify_constraint(checker, c);
    
    // 如果约束已确定为真或假
    if (c->is_true == 1) return 1;
    if (c->is_true == 0) return 0;
    
    // 检查约束集中是否存在该约束
    ConstraintSet *cs = &checker->current_path->constraints;
    for (int i = 0; i < cs->count; i++) {
        if (constraint_implies(&cs->constraints[i], c)) {
            return 1;
        }
    }
    
    return -1;  // 未知
}
```



## 集成点

### 在数组访问中集成符号执行

```c
static int checker_check_array_access(TypeChecker *checker, ASTNode *node) {
    ASTNode *index_expr = node->data.array_access.index;
    Type array_type = checker_infer_type(checker, node->data.array_access.array);
    
    if (array_type.kind == TYPE_ARRAY) {
        int array_len = array_type.data.array.array_size;
        
        // 转换为符号值
        SymbolicValue *index_sv = expr_to_symbolic(checker, index_expr);
        if (index_sv == NULL) {
            // 无法转换为符号值，标记需要运行时检查
            node->needs_runtime_check = 1;
            return 0;
        }
        
        // 验证数组访问安全性
        if (!verify_array_access_symbolic(checker, index_sv, array_len)) {
            // 无法证明安全，标记需要运行时检查
            node->needs_runtime_check = 1;
        }
    }
    
    return 0;
}
```



### 在算术运算中集成符号执行

```c
static int checker_check_arithmetic_overflow(TypeChecker *checker, ASTNode *node) {
    if (node->type != AST_BINARY_EXPR) return 0;
    
    TokenType op = node->data.binary_expr.op;
    if (op != TOKEN_PLUS && op != TOKEN_MINUS && op != TOKEN_ASTERISK) {
        return 0;
    }
    
    // 获取操作数类型
    Type left_type = checker_infer_type(checker, node->data.binary_expr.left);
    Type right_type = checker_infer_type(checker, node->data.binary_expr.right);
    
    if (!is_integer_type(left_type.kind) || !is_integer_type(right_type.kind)) {
        return 0;
    }
    
    // 转换为符号值
    SymbolicValue *left_sv = expr_to_symbolic(checker, node->data.binary_expr.left);
    SymbolicValue *right_sv = expr_to_symbolic(checker, node->data.binary_expr.right);
    
    if (left_sv == NULL || right_sv == NULL) {
        node->needs_runtime_check = 1;
        return 0;
    }
    
    // 验证溢出安全性
    if (!verify_overflow_safe(checker, left_sv, right_sv, left_type)) {
        node->needs_runtime_check = 1;
    }
    
    return 0;
}
```



## 测试策略

### 测试用例

1. **符号值表示测试**：

- `test_symbolic_value.uya` - 测试符号值的创建和表示

2. **符号算术运算测试**：

- `test_symbolic_arithmetic.uya` - 测试符号值的算术运算

3. **符号约束求解测试**：

- `test_symbolic_solve.uya` - 测试符号约束的求解

4. **数组访问符号验证测试**：

- `test_symbolic_array_access.uya` - 测试数组访问的符号验证

5. **溢出符号验证测试**：

- `test_symbolic_overflow.uya` - 测试整数溢出的符号验证

## 实现步骤

1. **步骤 1**：实现符号值表示（扩展 SymbolicValue 结构）
2. **步骤 2**：实现符号算术运算函数（add, sub, mul, div）
3. **步骤 3**：实现表达式到符号值的转换
4. **步骤 4**：实现符号约束建立和求解
5. **步骤 5**：在 checker 中集成符号执行（数组访问、算术运算）
6. **步骤 6**：添加测试用例并验证

## 技术难点

1. **符号表达式简化**：需要递归简化复杂的符号表达式
2. **约束求解复杂度**：符号约束求解可能很复杂，需要高效的算法
3. **内存管理**：符号值需要从 Arena 分配，避免内存泄漏

## 参考资源

- 符号执行工具（KLEE, SAGE）：参考符号值表示和约束求解