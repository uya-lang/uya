---
name: 内存安全证明实现
overview: 实现 Uya 语言的内存安全证明系统，通过编译期证明消除未定义行为（UB）。包括常量折叠、路径敏感分析、符号执行引擎、证明超时机制，以及证明失败错误报告。证明范围仅限当前函数内，证明失败时报告编译错误并提供修复建议，符合"显式控制哲学"。
todos:
  - id: const_folding
    content: 阶段 1：常量折叠增强 - 扩展 checker_eval_const_expr 支持溢出/越界/除零检测
    status: pending
  - id: path_sensitive
    content: 阶段 2：路径敏感分析框架 - 实现约束收集和传播系统
    status: pending
    dependencies:
      - const_folding
  - id: symbolic_exec
    content: 阶段 3：符号执行引擎 - 实现符号值和约束求解器
    status: pending
    dependencies:
      - path_sensitive
  - id: timeout_mechanism
    content: 阶段 4：证明超时机制 - 实现证明超时检测和标记
    status: pending
    dependencies:
      - symbolic_exec
  - id: uninit_detection
    content: 阶段 5：未初始化使用检测 - 跟踪变量初始化状态
    status: pending
    dependencies:
      - path_sensitive
  - id: null_detection
    content: 阶段 6：空指针解引用检测 - 跟踪指针空值状态
    status: pending
    dependencies:
      - path_sensitive
  - id: proof_failure_report
    content: 阶段 7：证明失败错误报告 - 在证明失败时报告编译错误并提供修复建议
    status: pending
    dependencies:
      - timeout_mechanism
      - uninit_detection
      - null_detection
  - id: uya_src_sync
    content: 阶段 8：uya-src 同步 - 将所有功能同步到自举编译器
    status: pending
    dependencies:
      - proof_failure_report
---

# 内存安全证明实现计划

## 概述

实现 Uya 语言的内存安全证明系统（规范 uya.md §14），通过编译期证明消除所有未定义行为（UB）。证明范围仅限当前函数内，证明失败时报告编译错误并提供修复建议，符合"显式控制哲学"：程序员必须显式处理，编译器不自动插入代码。

## 当前状态

- ✅ 饱和/包装运算（`+|`, `-|`, `*|`, `+%`, `-%`, `*%`）已实现
- ✅ `as!` 强制类型转换已实现
- ❌ 内存安全证明未实现（当前编译器不进行边界检查、溢出检查等）

## 实现目标

### 内存安全强制表

| UB 场景 | 编译期要求 | 失败处理 |
|---------|-----------|---------|
| 数组越界 | 常量越界 → 编译错误；变量 → 证明 `i >= 0 && i < len` | 证明失败 → 编译错误，提供修复建议 |
| 空指针解引用 | 证明 `ptr != null` 或前序有空检查 | 证明失败 → 编译错误，提供修复建议 |
| 未初始化使用 | 证明首次使用前已赋值 | 证明失败 → 编译错误，提供修复建议 |
| 整数溢出 | 常量溢出 → 编译错误；变量 → 编译器证明或显式检查 | 证明失败 → 编译错误，提供修复建议 |
| 除零 | 常量除零 → 编译错误；变量 → 证明 `y != 0` | 证明失败 → 编译错误，提供修复建议 |

## 实现阶段

### 阶段 1：常量折叠增强（基础）

**目标**：扩展现有的 `checker_eval_const_expr`，增加溢出/越界/除零检测**实现内容**：

- 扩展 `checker_eval_const_expr` 支持所有整数类型（i8, i16, i32, i64, u8, u16, u32, u64）
- 在常量表达式求值时检测溢出（加法、减法、乘法）
- 在常量表达式求值时检测除零
- 在数组访问时检测常量索引越界
- 错误报告：溢出/除零/越界时调用 `checker_report_error`

**涉及文件**：

- `compiler-mini/src/checker.c` - 扩展 `checker_eval_const_expr` 函数
- `compiler-mini/src/checker.h` - 可能需要添加辅助函数声明

**测试用例**：

- `error_const_overflow.uya` - 常量溢出编译错误
- `error_const_div_zero.uya` - 常量除零编译错误
- `error_const_bounds.uya` - 常量数组越界编译错误

### 阶段 2：路径敏感分析框架

**目标**：实现路径敏感分析框架，跟踪代码路径并建立约束条件**实现内容**：

- 在 `TypeChecker` 中添加约束系统数据结构：
- `ConstraintSet`：存储当前路径的约束条件（如 `i >= 0 && i < 10`）
- `PathContext`：路径上下文（用于跟踪 if/while/for 等控制流）
- 实现约束收集：
- 在 `if` 语句中收集条件约束
- 在 `while`/`for` 循环中收集循环条件约束
- 在 `return error` 后标记路径为"错误路径"（后续代码不可达）
- 实现约束传播：
- 在 `then` 分支中，正条件为真（如 `if i < 10` → `i < 10`）
- 在 `else` 分支中，正条件为假（如 `if i < 10` → `i >= 10`）
- 支持逻辑与（`&&`）和逻辑或（`||`）的约束分解

**涉及文件**：

- `compiler-mini/src/checker.h` - 添加 `ConstraintSet`、`PathContext` 数据结构
- `compiler-mini/src/checker.c` - 实现约束收集和传播逻辑

**测试用例**：

- `test_safety_bounds.uya` - 数组越界证明（路径敏感）
- `test_safety_overflow.uya` - 整数溢出证明（路径敏感）

### 阶段 3：符号执行引擎（约束求解）

**目标**：实现符号执行引擎，用于复杂场景的约束求解**实现内容**：

- 实现符号值表示：
- `SymbolicValue`：符号值结构（常量值或符号变量）
- 支持符号变量的算术运算（`+`, `-`, `*`, `/`）
- 实现约束求解器：
- 简单约束求解（如 `x > 0 && x < 10`）
- 线性约束求解（如 `a + b < 100`）
- 约束合并和简化
- 实现证明验证：
- 验证数组访问：`i >= 0 && i < len`
- 验证整数溢出：`a + b <= MAX && a + b >= MIN`
- 验证除零：`y != 0`
- 验证空指针：`ptr != null`

**涉及文件**：

- `compiler-mini/src/checker.h` - 添加 `SymbolicValue`、约束求解相关数据结构
- `compiler-mini/src/checker.c` - 实现符号执行和约束求解逻辑

**测试用例**：

- `test_safety_symbolic.uya` - 符号执行测试（复杂约束）

### 阶段 4：证明超时机制

**目标**：实现证明超时机制，超时则报告编译错误**实现内容**：

- 在 `TypeChecker` 中添加证明超时配置：
- `proof_timeout_ms`：证明超时时间（毫秒，默认 100ms）
- `proof_step_limit`：证明步数限制（默认 1000 步）
- 在证明过程中跟踪：
- 证明步数计数
- 证明时间计时（可选，需要平台支持）
- 证明超时处理：
- 检测证明超时
- 报告编译错误并提供修复建议

**涉及文件**：

- `compiler-mini/src/checker.h` - 添加证明超时配置
- `compiler-mini/src/checker.c` - 实现证明超时检测

**测试用例**：

- `error_proof_timeout.uya` - 证明超时错误报告测试

### 阶段 5：未初始化使用检测

**目标**：检测未初始化变量的使用**实现内容**：

- 在 `Symbol` 中添加初始化状态：
- `is_initialized`：是否已初始化（0=未初始化，1=已初始化）
- 在变量声明时标记初始化状态：
- `const x: i32 = 10;` → `is_initialized = 1`
- `var x: i32;` → `is_initialized = 0`
- 在变量使用前检查初始化状态：
- 未初始化时调用 `checker_report_error` 并提供修复建议

**涉及文件**：

- `compiler-mini/src/checker.h` - 在 `Symbol` 中添加 `is_initialized` 字段
- `compiler-mini/src/checker.c` - 实现未初始化检测逻辑

**测试用例**：

- `test_safety_uninit.uya` - 未初始化检测测试
- `error_uninit_use.uya` - 未初始化使用编译错误

### 阶段 6：空指针解引用检测

**目标**：检测空指针解引用**实现内容**：

- 在路径敏感分析中跟踪指针的空值状态：
- `ptr == null` 检查后，在 `then` 分支中标记 `ptr` 为空
- `ptr != null` 检查后，在 `then` 分支中标记 `ptr` 非空
- 在指针解引用前检查空值状态：
- 未证明非空时调用 `checker_report_error` 并提供修复建议

**涉及文件**：

- `compiler-mini/src/checker.h` - 在约束系统中添加指针空值状态跟踪
- `compiler-mini/src/checker.c` - 实现空指针检测逻辑

**测试用例**：

- `test_safety_null.uya` - 空指针证明测试
- `error_null_deref.uya` - 空指针解引用编译错误

### 阶段 7：证明失败错误报告

**目标**：在证明失败时报告编译错误并提供修复建议**实现内容**：

- 实现证明失败错误报告函数：
- `checker_report_proof_failure`：报告证明失败并提供修复建议
- 定义修复建议模板：
- 数组访问：`if (i < 0 || i >= len) { return error.OutOfBounds; }`
- 整数溢出：`const result = try a + b;` 或使用饱和/包装运算符
- 空指针：`if (ptr == null) { return error.NullPointer; }`
- 除零：`if (b == 0) { return error.DivideByZero; }`
- 未初始化：`var x: i32 = 0;` 或在使用前赋值
- 实现各操作的证明失败检测：
- 数组访问、整数溢出、空指针、除零、未初始化
- 优化错误消息格式：
- 包含代码位置、上下文信息、修复建议代码示例

**涉及文件**：

- `compiler-mini/src/checker.c` - 实现证明失败错误报告
- `compiler-mini/src/checker.h` - 添加错误报告相关函数声明

**测试用例**：

- `error_proof_array_access.uya` - 数组访问证明失败错误
- `error_proof_overflow.uya` - 整数溢出证明失败错误
- `error_proof_null.uya` - 空指针证明失败错误
- `error_proof_divzero.uya` - 除零证明失败错误
- `error_proof_uninit.uya` - 未初始化证明失败错误

### 阶段 8：uya-src 同步

**目标**：将内存安全证明功能同步到自举编译器（uya-src）**实现内容**：

- 同步所有阶段的功能到 `compiler-mini/uya-src/`：
- `checker.uya` - 常量折叠、路径敏感分析、符号执行、证明超时、证明失败错误报告

**验证**：

- 所有测试用例通过 `--c99` 和 `--uya --c99`
- 自举对比 `--c99 -b` 一致

## 实现优先级

1. **阶段 1**（常量折叠增强）- 高优先级，基础功能
2. **阶段 2**（路径敏感分析框架）- 高优先级，核心功能
3. **阶段 3**（符号执行引擎）- 中优先级，复杂场景
4. **阶段 4**（证明超时机制）- 中优先级，用户体验
5. **阶段 5**（未初始化使用检测）- 中优先级
6. **阶段 6**（空指针解引用检测）- 中优先级
7. **阶段 7**（证明失败错误报告）- 高优先级，完整功能
8. **阶段 8**（uya-src 同步）- 必须完成

## 参考文档

- [uya.md](../uya.md) §14 - 内存安全完整规范
- [compiler-mini/todo_mini_to_full.md](compiler-mini/todo_mini_to_full.md) §25 - 内存安全证明待办
- [examples/add_safe.uya](../examples/add_safe.uya) - 溢出检查示例
- [examples/safe_access_2.uya](../examples/safe_access_2.uya) - 数组边界检查示例

## 技术难点

1. **约束系统设计**：需要高效的约束表示和求解算法
2. **路径敏感分析**：需要正确跟踪所有代码路径，处理循环和递归
3. **符号执行**：需要实现符号变量的算术运算和约束求解
4. **证明超时**：需要平衡证明能力和编译速度
5. **证明失败错误报告**：需要生成清晰、有用的错误消息，帮助用户快速修复

**技术难点详细计划**：
- [约束系统设计](约束系统设计_73d408e2.plan.md)
- [路径敏感分析](路径敏感分析_233d5e09.plan.md)
- [符号执行](符号执行_8f3a1b2c.plan.md)
- [证明超时机制](证明超时机制_4c5d6e7f.plan.md)
- [证明失败错误报告](运行时检查生成_9a0b1c2d.plan.md)

## 测试策略

- 每个阶段完成后添加相应的测试用例
- 测试用例必须同时通过 `--c99` 和 `--uya --c99`
- 包含成功路径和预期失败用例（`error_*.uya`）
- 覆盖常量检查、路径敏感分析、符号执行、证明失败错误报告等场景

## 设计原则

### 显式控制哲学

Uya 语言遵循"显式控制哲学"：
- **程序员负责**：程序员必须显式处理所有不安全操作
- **编译器验证**：编译器验证程序员提供的证明
- **不自动插入**：编译器不自动插入任何运行时检查代码
- **失败即错误**：无法证明安全性时，报告编译错误并提供修复建议

这与 Rust 的借用检查器或 Zig 的显式错误处理类似，但更强调编译期证明而非运行时检查。