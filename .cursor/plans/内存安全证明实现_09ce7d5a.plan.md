---
name: 内存安全证明实现
overview: 实现 Uya 语言的内存安全证明系统，通过编译期证明消除未定义行为（UB）。包括常量折叠、路径敏感分析、符号执行引擎、证明超时机制，以及自动插入运行时检查。证明范围仅限当前函数内，证明超时则自动插入运行时检查。
todos:
  - id: const_folding
    content: 阶段 1：常量折叠增强 - 扩展 checker_eval_const_expr 支持溢出/越界/除零检测
    status: pending
  - id: path_sensitive
    content: 阶段 2：路径敏感分析框架 - 实现约束收集和传播系统
    status: pending
    dependencies:
      - const_folding
  - id: symbolic_exec
    content: 阶段 3：符号执行引擎 - 实现符号值和约束求解器
    status: pending
    dependencies:
      - path_sensitive
  - id: timeout_mechanism
    content: 阶段 4：证明超时机制 - 实现证明超时检测和标记
    status: pending
    dependencies:
      - symbolic_exec
  - id: uninit_detection
    content: 阶段 5：未初始化使用检测 - 跟踪变量初始化状态
    status: pending
    dependencies:
      - path_sensitive
  - id: null_detection
    content: 阶段 6：空指针解引用检测 - 跟踪指针空值状态
    status: pending
    dependencies:
      - path_sensitive
  - id: runtime_checks
    content: 阶段 7：自动插入运行时检查 - 在 Codegen 中生成运行时检查代码
    status: pending
    dependencies:
      - timeout_mechanism
      - uninit_detection
      - null_detection
  - id: uya_src_sync
    content: 阶段 8：uya-src 同步 - 将所有功能同步到自举编译器
    status: pending
    dependencies:
      - runtime_checks
---

# 内存安全证明实现计划

## 概述

实现 Uya 语言的内存安全证明系统（规范 uya.md §14），通过编译期证明消除所有未定义行为（UB）。证明范围仅限当前函数内，证明超时则自动插入运行时检查。

## 当前状态

- ✅ 饱和/包装运算（`+|`, `-|`, `*|`, `+%`, `-%`, `*%`）已实现
- ✅ `as!` 强制类型转换已实现
- ❌ 内存安全证明未实现（当前编译器不进行边界检查、溢出检查等）

## 实现目标

### 内存安全强制表

| UB 场景 | 编译期要求 | 失败处理 ||---------|-----------|---------|| 数组越界 | 常量越界 → 编译错误；变量 → 证明 `i >= 0 && i < len` | 证明超时 → 自动插入运行时检查 || 空指针解引用 | 证明 `ptr != null` 或前序有空检查 | 证明超时 → 自动插入运行时检查 || 未初始化使用 | 证明首次使用前已赋值 | 证明超时 → 自动插入运行时检查 || 整数溢出 | 常量溢出 → 编译错误；变量 → 编译器证明或显式检查 | 证明超时 → 自动插入运行时检查 || 除零 | 常量除零 → 编译错误；变量 → 证明 `y != 0` | 证明超时 → 自动插入运行时检查 |

## 实现阶段

### 阶段 1：常量折叠增强（基础）

**目标**：扩展现有的 `checker_eval_const_expr`，增加溢出/越界/除零检测**实现内容**：

- 扩展 `checker_eval_const_expr` 支持所有整数类型（i8, i16, i32, i64, u8, u16, u32, u64）
- 在常量表达式求值时检测溢出（加法、减法、乘法）
- 在常量表达式求值时检测除零
- 在数组访问时检测常量索引越界
- 错误报告：溢出/除零/越界时调用 `checker_report_error`

**涉及文件**：

- `compiler-mini/src/checker.c` - 扩展 `checker_eval_const_expr` 函数
- `compiler-mini/src/checker.h` - 可能需要添加辅助函数声明

**测试用例**：

- `error_const_overflow.uya` - 常量溢出编译错误
- `error_const_div_zero.uya` - 常量除零编译错误
- `error_const_bounds.uya` - 常量数组越界编译错误

### 阶段 2：路径敏感分析框架

**目标**：实现路径敏感分析框架，跟踪代码路径并建立约束条件**实现内容**：

- 在 `TypeChecker` 中添加约束系统数据结构：
- `ConstraintSet`：存储当前路径的约束条件（如 `i >= 0 && i < 10`）
- `PathContext`：路径上下文（用于跟踪 if/while/for 等控制流）
- 实现约束收集：
- 在 `if` 语句中收集条件约束
- 在 `while`/`for` 循环中收集循环条件约束
- 在 `return error` 后标记路径为"错误路径"（后续代码不可达）
- 实现约束传播：
- 在 `then` 分支中，正条件为真（如 `if i < 10` → `i < 10`）
- 在 `else` 分支中，正条件为假（如 `if i < 10` → `i >= 10`）
- 支持逻辑与（`&&`）和逻辑或（`||`）的约束分解

**涉及文件**：

- `compiler-mini/src/checker.h` - 添加 `ConstraintSet`、`PathContext` 数据结构
- `compiler-mini/src/checker.c` - 实现约束收集和传播逻辑

**测试用例**：

- `test_safety_bounds.uya` - 数组越界证明（路径敏感）
- `test_safety_overflow.uya` - 整数溢出证明（路径敏感）

### 阶段 3：符号执行引擎（约束求解）

**目标**：实现符号执行引擎，用于复杂场景的约束求解**实现内容**：

- 实现符号值表示：
- `SymbolicValue`：符号值结构（常量值或符号变量）
- 支持符号变量的算术运算（`+`, `-`, `*`, `/`）
- 实现约束求解器：
- 简单约束求解（如 `x > 0 && x < 10`）
- 线性约束求解（如 `a + b < 100`）
- 约束合并和简化
- 实现证明验证：
- 验证数组访问：`i >= 0 && i < len`
- 验证整数溢出：`a + b <= MAX && a + b >= MIN`
- 验证除零：`y != 0`
- 验证空指针：`ptr != null`

**涉及文件**：

- `compiler-mini/src/checker.h` - 添加 `SymbolicValue`、约束求解相关数据结构
- `compiler-mini/src/checker.c` - 实现符号执行和约束求解逻辑

**测试用例**：

- `test_safety_symbolic.uya` - 符号执行测试（复杂约束）

### 阶段 4：证明超时机制

**目标**：实现证明超时机制，超时则自动插入运行时检查**实现内容**：

- 在 `TypeChecker` 中添加证明超时配置：
- `proof_timeout_ms`：证明超时时间（毫秒，默认 100ms）
- `proof_step_limit`：证明步数限制（默认 1000 步）
- 在证明过程中跟踪：
- 证明步数计数
- 证明时间计时（可选，需要平台支持）
- 证明超时处理：
- 标记需要运行时检查的表达式
- 在 Codegen 阶段插入运行时检查代码

**涉及文件**：

- `compiler-mini/src/checker.h` - 添加证明超时配置
- `compiler-mini/src/checker.c` - 实现证明超时检测
- `compiler-mini/src/ast.h` - 在 AST 节点中添加标记（如 `needs_runtime_check`）

**测试用例**：

- `test_safety_runtime.uya` - 运行时检查自动插入测试

### 阶段 5：未初始化使用检测

**目标**：检测未初始化变量的使用**实现内容**：

- 在 `Symbol` 中添加初始化状态：
- `is_initialized`：是否已初始化（0=未初始化，1=已初始化）
- 在变量声明时标记初始化状态：
- `const x: i32 = 10;` → `is_initialized = 1`
- `var x: i32;` → `is_initialized = 0`
- 在变量使用前检查初始化状态：
- 未初始化时调用 `checker_report_error` 或标记需要运行时检查

**涉及文件**：

- `compiler-mini/src/checker.h` - 在 `Symbol` 中添加 `is_initialized` 字段
- `compiler-mini/src/checker.c` - 实现未初始化检测逻辑

**测试用例**：

- `test_safety_uninit.uya` - 未初始化检测测试
- `error_uninit_use.uya` - 未初始化使用编译错误

### 阶段 6：空指针解引用检测

**目标**：检测空指针解引用**实现内容**：

- 在路径敏感分析中跟踪指针的空值状态：
- `ptr == null` 检查后，在 `then` 分支中标记 `ptr` 为空
- `ptr != null` 检查后，在 `then` 分支中标记 `ptr` 非空
- 在指针解引用前检查空值状态：
- 未证明非空时调用 `checker_report_error` 或标记需要运行时检查

**涉及文件**：

- `compiler-mini/src/checker.h` - 在约束系统中添加指针空值状态跟踪
- `compiler-mini/src/checker.c` - 实现空指针检测逻辑

**测试用例**：

- `test_safety_null.uya` - 空指针证明测试
- `error_null_deref.uya` - 空指针解引用编译错误

### 阶段 7：自动插入运行时检查（Codegen）

**目标**：在 Codegen 阶段自动插入运行时检查代码**实现内容**：

- 在 AST 节点中标记需要运行时检查的表达式：
- 数组访问：`arr[i] `→ 插入 `if (i < 0 || i >= len) { return error.OutOfBounds; }`
- 整数运算：`a + b` → 插入溢出检查（使用 `__builtin_*_overflow`）
- 除零检查：`a / b` → 插入 `if (b == 0) { return error.DivideByZero; }`
- 空指针解引用：`*ptr` → 插入 `if (ptr == null) { return error.NullPointer; }`
- 在 Codegen 中生成运行时检查代码：
- `codegen/c99/expr.c` - 数组访问、算术运算
- `codegen/c99/stmt.c` - 变量声明（未初始化检查）

**涉及文件**：

- `compiler-mini/src/codegen/c99/expr.c` - 插入运行时检查代码
- `compiler-mini/src/codegen/c99/stmt.c` - 插入未初始化检查代码
- `compiler-mini/src/ast.h` - 在 AST 节点中添加 `needs_runtime_check` 标记

**测试用例**：

- `test_safety_runtime.uya` - 运行时检查自动插入测试

### 阶段 8：uya-src 同步

**目标**：将内存安全证明功能同步到自举编译器（uya-src）**实现内容**：

- 同步所有阶段的功能到 `compiler-mini/uya-src/`：
- `checker.uya` - 常量折叠、路径敏感分析、符号执行、证明超时
- `codegen/c99/expr.uya` - 运行时检查代码生成
- `codegen/c99/stmt.uya` - 未初始化检查代码生成

**验证**：

- 所有测试用例通过 `--c99` 和 `--uya --c99`
- 自举对比 `--c99 -b` 一致

## 实现优先级

1. **阶段 1**（常量折叠增强）- 高优先级，基础功能
2. **阶段 2**（路径敏感分析框架）- 高优先级，核心功能
3. **阶段 3**（符号执行引擎）- 中优先级，复杂场景
4. **阶段 4**（证明超时机制）- 中优先级，用户体验
5. **阶段 5**（未初始化使用检测）- 中优先级
6. **阶段 6**（空指针解引用检测）- 中优先级
7. **阶段 7**（自动插入运行时检查）- 高优先级，完整功能
8. **阶段 8**（uya-src 同步）- 必须完成

## 参考文档

- [uya.md](../uya.md) §14 - 内存安全完整规范
- [compiler-mini/todo_mini_to_full.md](compiler-mini/todo_mini_to_full.md) §25 - 内存安全证明待办
- [examples/add_safe.uya](../examples/add_safe.uya) - 溢出检查示例
- [examples/safe_access_2.uya](../examples/safe_access_2.uya) - 数组边界检查示例

## 技术难点

1. **约束系统设计**：需要高效的约束表示和求解算法
2. **路径敏感分析**：需要正确跟踪所有代码路径，处理循环和递归
3. **符号执行**：需要实现符号变量的算术运算和约束求解
4. **证明超时**：需要平衡证明能力和编译速度
5. **运行时检查生成**：需要正确插入检查代码，不影响正常代码路径的性能

## 测试策略

- 每个阶段完成后添加相应的测试用例
- 测试用例必须同时通过 `--c99` 和 `--uya --c99`