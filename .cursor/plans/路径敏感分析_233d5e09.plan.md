---
name: 路径敏感分析
overview: 实现路径敏感分析框架，正确跟踪所有代码路径，处理循环和递归。路径敏感分析需要维护路径上下文、收集条件约束、处理控制流合并。
todos:
  - id: path_context_ds
    content: 定义路径上下文数据结构（PathContext, 路径栈）
    status: pending
  - id: path_stack
    content: 实现路径栈管理函数（push_path_context, pop_path_context）
    status: pending
    dependencies:
      - path_context_ds
  - id: path_if
    content: 实现 if 语句路径分析（then/else 分支约束收集和合并）
    status: pending
    dependencies:
      - path_stack
  - id: path_loop
    content: 实现 while/for 循环路径分析（有限次数展开）
    status: pending
    dependencies:
      - path_if
  - id: path_match
    content: 实现 match 表达式路径分析（多分支约束收集和合并）
    status: pending
    dependencies:
      - path_if
  - id: path_merge
    content: 实现路径合并策略（约束交集/并集）
    status: pending
    dependencies:
      - path_if
      - path_loop
      - path_match
  - id: path_test
    content: 添加测试用例并验证路径敏感分析功能
    status: pending
    dependencies:
      - path_merge
---

# 路径敏感分析实现计划

## 问题描述

路径敏感分析需要：

- 正确跟踪所有代码路径（if/else、while、for、match 等）
- 在每条路径上维护独立的约束集
- 处理控制流合并（多个路径汇合）
- 处理循环和递归（避免无限展开）
- 在路径退出时正确恢复约束状态

## 技术方案

### 路径上下文管理

**路径栈结构**：

```c
// checker.h
typedef struct PathContext {
    ConstraintSet constraints;    // 当前路径的约束集
    int depth;                    // 路径深度（用于嵌套控制流）
    struct PathContext *parent;   // 父路径上下文（用于作用域退出）
    int is_loop;                  // 是否为循环路径（1=是，0=否）
    int loop_iteration;           // 循环迭代次数（用于避免无限展开）
} PathContext;

typedef struct TypeChecker {
    // ... 现有字段 ...
    PathContext *current_path;    // 当前路径上下文
    PathContext *path_stack[64];  // 路径栈（用于嵌套控制流）
    int path_stack_depth;         // 路径栈深度
    int max_path_depth;           // 最大路径深度（防止无限递归）
    int max_loop_iterations;      // 最大循环迭代次数（默认 3）
} TypeChecker;
```



### 控制流处理

**1. if 语句处理**：

- then 分支：应用正条件约束
- else 分支：应用负条件约束
- 分支合并：合并两个分支的约束（取交集或并集）

**2. while/for 循环处理**：

- 循环条件：收集循环条件约束
- 循环展开：有限次数展开（默认 3 次）
- 循环不变式：识别循环不变式约束

**3. match 表达式处理**：

- 每个分支：应用对应模式的约束
- 分支合并：合并所有分支的约束

## 数据结构设计

### 路径上下文栈

```c
// checker.c
static void push_path_context(TypeChecker *checker, ConstraintSet constraints) {
    if (checker->path_stack_depth >= 64) {
        checker_report_error(checker, NULL, "路径栈溢出：嵌套过深");
        return;
    }
    
    PathContext *ctx = (PathContext *)arena_alloc(checker->arena, sizeof(PathContext));
    if (ctx == NULL) return;
    
    ctx->constraints = constraints;
    ctx->depth = checker->path_stack_depth;
    ctx->parent = checker->current_path;
    ctx->is_loop = 0;
    ctx->loop_iteration = 0;
    
    checker->path_stack[checker->path_stack_depth++] = ctx;
    checker->current_path = ctx;
}

static void pop_path_context(TypeChecker *checker) {
    if (checker->path_stack_depth == 0) return;
    
    checker->path_stack_depth--;
    if (checker->path_stack_depth > 0) {
        checker->current_path = checker->path_stack[checker->path_stack_depth - 1];
    } else {
        checker->current_path = NULL;
    }
}
```



## 算法实现

### 1. if 语句路径分析

```c
static void checker_analyze_if_path(TypeChecker *checker, ASTNode *if_node) {
    ASTNode *condition = if_node->data.if_stmt.condition;
    
    // 提取条件约束
    ConstraintSet then_constraints = extract_constraints_from_expr(checker, condition, 1);
    ConstraintSet else_constraints = extract_constraints_from_expr(checker, condition, 0);
    
    // then 分支：应用正约束
    push_path_context(checker, merge_constraint_sets(checker, 
        checker->current_path->constraints, then_constraints));
    checker_check_node(checker, if_node->data.if_stmt.then_block);
    ConstraintSet then_result = checker->current_path->constraints;
    pop_path_context(checker);
    
    // else 分支：应用负约束
    ConstraintSet else_result = {0};
    if (if_node->data.if_stmt.else_block) {
        push_path_context(checker, merge_constraint_sets(checker,
            checker->current_path->constraints, else_constraints));
        checker_check_node(checker, if_node->data.if_stmt.else_block);
        else_result = checker->current_path->constraints;
        pop_path_context(checker);
    }
    
    // 路径合并：取两个分支约束的交集（保守策略）
    // 或者：在 if 语句后，约束集为空（因为不知道走哪个分支）
    // 这里采用保守策略：合并后只保留两个分支都满足的约束
    checker->current_path->constraints = intersect_constraint_sets(checker, then_result, else_result);
}
```



### 2. while 循环路径分析

```c
static void checker_analyze_while_path(TypeChecker *checker, ASTNode *while_node) {
    ASTNode *condition = while_node->data.while_stmt.condition;
    
    // 检查循环深度，避免无限展开
    if (checker->current_path->is_loop && 
        checker->current_path->loop_iteration >= checker->max_loop_iterations) {
        // 循环展开次数过多，停止分析
        checker_report_error(checker, while_node, "循环展开次数过多，无法完成路径分析");
        return;
    }
    
    // 创建循环路径上下文
    PathContext *loop_ctx = (PathContext *)arena_alloc(checker->arena, sizeof(PathContext));
    loop_ctx->constraints = checker->current_path->constraints;
    loop_ctx->depth = checker->current_path->depth + 1;
    loop_ctx->parent = checker->current_path;
    loop_ctx->is_loop = 1;
    loop_ctx->loop_iteration = 0;
    
    // 有限次数展开循环
    for (int i = 0; i < checker->max_loop_iterations; i++) {
        loop_ctx->loop_iteration = i;
        
        // 检查循环条件
        ConstraintSet loop_constraints = extract_constraints_from_expr(checker, condition, 1);
        
        // 如果条件不满足，退出循环
        if (!satisfy_constraints(checker, loop_constraints)) {
            break;
        }
        
        // 应用循环条件约束
        loop_ctx->constraints = merge_constraint_sets(checker, 
            loop_ctx->constraints, loop_constraints);
        
        // 分析循环体
        push_path_context(checker, loop_ctx->constraints);
        checker_check_node(checker, while_node->data.while_stmt.body);
        loop_ctx->constraints = checker->current_path->constraints;
        pop_path_context(checker);
    }
    
    // 循环退出：应用循环条件的负约束
    ConstraintSet exit_constraints = extract_constraints_from_expr(checker, condition, 0);
    checker->current_path->constraints = merge_constraint_sets(checker,
        loop_ctx->constraints, exit_constraints);
}
```



### 3. for 循环路径分析

```c
static void checker_analyze_for_path(TypeChecker *checker, ASTNode *for_node) {
    // for 循环处理类似 while，但需要处理循环变量
    ASTNode *init = for_node->data.for_stmt.init;
    ASTNode *condition = for_node->data.for_stmt.condition;
    ASTNode *update = for_node->data.for_stmt.update;
    ASTNode *body = for_node->data.for_stmt.body;
    
    // 分析初始化
    if (init) {
        checker_check_node(checker, init);
    }
    
    // 有限次数展开循环（类似 while）
    // ... 实现类似 while 循环 ...
}
```



### 4. match 表达式路径分析

```c
static void checker_analyze_match_path(TypeChecker *checker, ASTNode *match_node) {
    ASTNode *expr = match_node->data.match_expr.expr;
    ASTMatchArm *arms = match_node->data.match_expr.arms;
    int arm_count = match_node->data.match_expr.arm_count;
    
    // 为每个分支创建路径上下文
    ConstraintSet merged_constraints = {0};
    
    for (int i = 0; i < arm_count; i++) {
        ASTMatchArm *arm = &arms[i];
        
        // 提取模式约束
        ConstraintSet pattern_constraints = extract_constraints_from_pattern(checker, 
            expr, arm->pattern);
        
        // 分析分支体
        push_path_context(checker, merge_constraint_sets(checker,
            checker->current_path->constraints, pattern_constraints));
        checker_check_node(checker, arm->result);
        ConstraintSet arm_result = checker->current_path->constraints;
        pop_path_context(checker);
        
        // 合并分支约束（取交集）
        if (i == 0) {
            merged_constraints = arm_result;
        } else {
            merged_constraints = intersect_constraint_sets(checker, 
                merged_constraints, arm_result);
        }
    }
    
    // match 表达式后：应用合并后的约束
    checker->current_path->constraints = merged_constraints;
}
```



### 5. 路径合并策略

**约束交集**（保守策略）：

```c
static ConstraintSet intersect_constraint_sets(TypeChecker *checker, 
                                               ConstraintSet cs1, 
                                               ConstraintSet cs2) {
    ConstraintSet result = {0};
    
    // 找出两个约束集中都存在的约束
    for (int i = 0; i < cs1.count; i++) {
        for (int j = 0; j < cs2.count; j++) {
            if (constraint_equals(&cs1.constraints[i], &cs2.constraints[j])) {
                add_constraint_to_set(checker, result, cs1.constraints[i]);
            }
        }
    }
    
    return result;
}
```



## 集成点

### 在 checker_check_node 中集成

```c
static int checker_check_node(TypeChecker *checker, ASTNode *node) {
    switch (node->type) {
        case AST_IF_STMT:
            checker_analyze_if_path(checker, node);
            break;
            
        case AST_WHILE_STMT:
            checker_analyze_while_path(checker, node);
            break;
            
        case AST_FOR_STMT:
            checker_analyze_for_path(checker, node);
            break;
            
        case AST_MATCH_EXPR:
            checker_analyze_match_path(checker, node);
            break;
            
        // ... 其他节点类型 ...
    }
}
```



## 测试策略

### 测试用例

1. **if 语句路径分析**：

- `test_path_if.uya` - 测试 if 语句的路径分析

2. **while 循环路径分析**：

- `test_path_while.uya` - 测试 while 循环的路径分析

3. **for 循环路径分析**：

- `test_path_for.uya` - 测试 for 循环的路径分析

4. **match 表达式路径分析**：

- `test_path_match.uya` - 测试 match 表达式的路径分析

5. **路径合并测试**：

- `test_path_merge.uya` - 测试路径合并策略

## 实现步骤

1. **步骤 1**：定义路径上下文数据结构（`checker.h`）
2. **步骤 2**：实现路径栈管理函数（push/pop）
3. **步骤 3**：实现 if 语句路径分析
4. **步骤 4**：实现 while/for 循环路径分析
5. **步骤 5**：实现 match 表达式路径分析
6. **步骤 6**：实现路径合并策略
7. **步骤 7**：添加测试用例并验证

## 技术难点

1. **循环展开**：需要平衡分析精度和性能，避免无限展开
2. **路径合并**：需要选择合适的合并策略（交集或并集）
3. **递归处理**：需要检测递归调用，避免无限展开
4. **约束传播**：需要在路径间正确传播约束

## 参考资源