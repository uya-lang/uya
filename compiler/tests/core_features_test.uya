// Uya语言核心功能测试（无extern依赖）

// 1. 基本类型和变量
fn test_basic_types() void {
    const x: i32 = 42;
    var y: i32 = 10;
    y = y + 5;
    
    const f: f64 = 3.14159;
    const b: bool = true;
    
    // 模拟输出
    const _ = x + y + f as i32;  // 避免未使用变量警告
}

// 2. 结构体测试
struct Vec3 {
    x: f32,
    y: f32,
    z: f32
}

fn test_structs() void {
    const v: Vec3 = Vec3{ x: 1.0, y: 2.0, z: 3.0 };
    const _ = v.x + v.y + v.z;  // 避免未使用变量警告
}

// 3. 数组和切片测试
fn test_arrays_and_slices() void {
    const arr: [i32: 5] = [1, 2, 3, 4, 5];
    
    // 测试切片
    const slice1: [i32: 3] = slice(arr, 1, 4);  // [2, 3, 4]
    
    // 测试负数索引切片
    const slice2: [i32: 2] = slice(arr, -2, 5);  // [4, 5]
    
    // 计算一些值以避免未使用变量警告
    const sum1: i32 = 0;
    for (iter(&slice1)) |val| {
        const _ = sum1 + val;
    }
    
    const sum2: i32 = 0;
    for (iter(&slice2)) |val| {
        const _ = sum2 + val;
    }
}

// 4. 错误处理测试
error CustomError;
error AnotherError;

fn may_fail(flag: bool) !i32 {
    if flag {
        return 42;
    } else {
        return error.CustomError;
    }
}

fn test_error_handling() void {
    // 成功路径
    const success_val: i32 = try may_fail(true);
    const _ = success_val;
    
    // 错误路径
    const err_val: i32 = may_fail(false) catch |err| {
        if err == error.CustomError {
            return 0;
        }
        return 0;
    };
    const _ = err_val;
}

// 5. 控制流测试
fn test_control_flow() void {
    const x: i32 = 10;
    if x > 5 {
        const _ = x;  // 使用变量避免警告
    } else {
        const _ = x;  // 使用变量避免警告
    }
    
    var i: i32 = 0;
    while i < 3 {
        i = i + 1;
    }
    
    const nums: [i32: 3] = [10, 20, 30];
    for (iter(&nums)) |num| {
        const _ = num;  // 使用变量避免警告
    }
}

// 6. 函数测试
fn add(a: i32, b: i32) i32 {
    return a + b;
}

fn test_functions() void {
    const result: i32 = add(5, 7);
    const _ = result;
}

// 7. 接口测试
interface IWriter {
    fn write(self: *Self, data: byte*) i32;
}

struct ConsoleWriter {
    fd: i32
}

ConsoleWriter : IWriter {
    fn write(self: *Self, data: byte*) i32 {
        const _ = data;  // 使用参数避免警告
        return 0;
    }
}

fn test_interface() void {
    const writer: ConsoleWriter = ConsoleWriter{ fd: 1 };
    const _ = writer;  // 使用变量避免警告
}

// 8. 原子类型测试
struct AtomicCounter {
    value: atomic i32
}

fn test_atomic() void {
    var counter: AtomicCounter = AtomicCounter{ value: 0 };
    
    // 原子操作
    counter.value += 1;  // 自动原子fetch_add
    counter.value += 1;
    
    const val: i32 = counter.value;  // 自动原子load
    const _ = val;
}

// 9. defer/errdefer测试
fn test_defer_errdefer() !void {
    defer {
        const _ = 0;  // 模拟清理操作
    }
    
    errdefer {
        const _ = 0;  // 模拟错误清理操作
    }
    
    return;
}

// 10. 字符串插值测试（如果支持）
fn test_string_interpolation() void {
    const x: i32 = 42;
    const pi: f64 = 3.14159;
    const _ = x + (pi as i32);  // 避免未使用变量警告
}

// 11. 泛型测试（如果支持）
fn id(val: T) T {
    return val;
}

fn test_generic() void {
    const int_val: i32 = id(123);
    const _ = int_val;
}

// 12. 宏测试（如果支持）
mc twice(x: i32) expr { x + x }

fn test_macro() void {
    const x: i32 = 5;
    const result: i32 = twice(x);  // 展开为 x + x
    const _ = result;
}

fn main() i32 {
    test_basic_types();
    test_structs();
    test_arrays_and_slices();
    test_error_handling();
    test_control_flow();
    test_functions();
    test_interface();
    test_atomic();
    test_defer_errdefer() catch |err| {
        const _ = err;
    };
    test_string_interpolation();
    test_generic();
    test_macro();
    
    return 0;
}