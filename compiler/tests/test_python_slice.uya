// Python风格切片语法测试
extern i32 printf(byte* fmt, ...);

fn main() i32 {
    printf("=== Python风格切片语法测试 ===\n");
    
    // 创建测试数组
    const arr: [i32; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    printf("原数组: ");
    for (iter(&arr)) |item| {
        printf("%d ", item);
    }
    printf("\n");
    
    // 基本切片 [start:end]
    const slice1: [i32; 3] = slice(arr, 2, 5);  // [2, 3, 4]
    printf("arr[2:5]: ");
    for (iter(&slice1)) |item| {
        printf("%d ", item);
    }
    printf("\n");
    
    // 从开头到某位置 [:end]
    const slice2: [i32; 3] = slice(arr, 0, 3);  // [0, 1, 2]
    printf("arr[:3]: ");
    for (iter(&slice2)) |item| {
        printf("%d ", item);
    }
    printf("\n");
    
    // 从某位置到末尾 [start:]
    const slice3: [i32; 3] = slice(arr, 7, 10);  // [7, 8, 9]
    printf("arr[7:]: ");
    for (iter(&slice3)) |item| {
        printf("%d ", item);
    }
    printf("\n");
    
    // 整个数组 [:]
    const slice4: [i32; 10] = slice(arr, 0, 10);  // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    printf("arr[:]: ");
    for (iter(&slice4)) |item| {
        printf("%d ", item);
    }
    printf("\n");
    
    // 负数索引切片
    const slice5: [i32; 3] = slice(arr, -3, 10);  // [7, 8, 9] - 从倒数第3个到末尾
    printf("arr[-3:]: ");
    for (iter(&slice5)) |item| {
        printf("%d ", item);
    }
    printf("\n");
    
    // 从开头到倒数第几个 [:negative]
    const slice6: [i32; 7] = slice(arr, 0, -3);  // [0, 1, 2, 3, 4, 5, 6] - 从开头到倒数第3个（不包含）
    printf("arr[:-3]: ");
    for (iter(&slice6)) |item| {
        printf("%d ", item);
    }
    printf("\n");
    
    // 负数到负数 [negative:negative]
    const slice7: [i32; 3] = slice(arr, -5, -2);  // [5, 6, 7] - 从倒数第5个到倒数第2个（不包含）
    printf("arr[-5:-2]: ");
    for (iter(&slice7)) |item| {
        printf("%d ", item);
    }
    printf("\n");
    
    // 单元素切片
    const slice8: [i32; 1] = slice(arr, 5, 6);  // [5]
    printf("arr[5:6]: %d\n", slice8[0]);
    
    // 空切片
    const slice9: [i32; 0] = slice(arr, 3, 3);  // []
    printf("arr[3:3]: (空切片，长度为 %d)\n", len(slice9));
    
    // 字符串切片模拟（使用byte数组）
    const str_arr: [byte; 13] = "Hello, World!";
    const str_slice: [byte; 5] = slice(str_arr, 0, 5);  // "Hello"
    printf("str_arr[0:5]: ");
    for (iter(&str_slice)) |ch| {
        printf("%c", ch);
    }
    printf("\n");
    
    const str_slice2: [byte; 5] = slice(str_arr, -6, 13);  // "World"
    printf("str_arr[-6:13]: ");
    for (iter(&str_slice2)) |ch| {
        printf("%c", ch);
    }
    printf("\n");
    
    // 复杂切片：步长（如果支持）
    // 注意：当前实现可能不支持步长，这里仅作概念演示
    printf("\n=== 切片边界测试 ===\n");
    
    // 边界情况测试
    const small_arr: [i32; 3] = [10, 20, 30];
    
    // 小数组切片
    const small_slice1: [i32; 2] = slice(small_arr, 1, 3);  // [20, 30]
    printf("small_arr[1:3]: ");
    for (iter(&small_slice1)) |item| {
        printf("%d ", item);
    }
    printf("\n");
    
    // 超出边界的尝试（这些应该在编译期被检测到）
    // const invalid_slice: [i32; 1] = slice(small_arr, 5, 6);  // 编译错误
    
    printf("\n=== 切片语法测试完成 ===\n");
    
    return 0;
}