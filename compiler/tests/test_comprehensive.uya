// Uya语言综合测试
extern i32 printf(byte* fmt, ...);
extern f64 sin(f64 x);
extern f64 cos(f64 x);
extern f64 sqrt(f64 x);

// 结构体定义
struct Point {
    x: f32,
    y: f32
}

struct Vec3 {
    x: f32,
    y: f32,
    z: f32
}

// 接口定义
interface IShape {
    fn area(self: *Self) f32;
    fn perimeter(self: *Self) f32;
}

// 圆形结构体实现接口
struct Circle {
    center: Point,
    radius: f32
}

impl Circle : IShape {
    fn area(self: *Self) f32 {
        return 3.14159 * self.radius * self.radius;
    }
    
    fn perimeter(self: *Self) f32 {
        return 2.0 * 3.14159 * self.radius;
    }
}

// 矩形结构体实现接口
struct Rectangle {
    width: f32,
    height: f32
}

impl Rectangle : IShape {
    fn area(self: *Self) f32 {
        return self.width * self.height;
    }
    
    fn perimeter(self: *Self) f32 {
        return 2.0 * (self.width + self.height);
    }
}

// 错误定义
error DivisionByZero;
error NegativeSqrt;

// 原子类型测试
struct Counter {
    value: atomic i32
}

// 泛型函数（如果支持）
fn identity(x: T) T {
    return x;
}

// 宏定义
mc square(x: i32) expr { x * x }

// 测试基本功能
fn test_basics() void {
    printf("=== 基本功能测试 ===\n");
    
    // 变量声明
    const x: i32 = 10;
    var y: i32 = 20;
    y = y + 5;  // 修改可变变量
    
    printf("x = %d, y = %d\n", x, y);
    
    // 基本运算
    const sum: i32 = x + y;
    const product: i32 = x * y;
    printf("sum = %d, product = %d\n", sum, product);
    
    // 条件语句
    if x < y {
        printf("x < y\n");
    } else {
        printf("x >= y\n");
    }
    
    // 循环
    var i: i32 = 0;
    while i < 3 {
        printf("Loop iteration: %d\n", i);
        i = i + 1;
    }
}

// 测试数组和切片
fn test_arrays_and_slices() void {
    printf("\n=== 数组和切片测试 ===\n");
    
    // 数组声明和初始化
    const arr: [i32; 5] = [1, 2, 3, 4, 5];
    printf("Original array: ");
    for (iter(&arr)) |item| {
        printf("%d ", item);
    }
    printf("\n");
    
    // 数组访问（安全）
    if 2 < len(arr) {
        printf("arr[2] = %d\n", arr[2]);
    }
    
    // 切片操作
    const slice1: [i32; 3] = slice(arr, 1, 4);  // [2, 3, 4]
    printf("Slice [1:4]: ");
    for (iter(&slice1)) |item| {
        printf("%d ", item);
    }
    printf("\n");
    
    // 负数索引切片
    const slice2: [i32; 2] = slice(arr, -2, 5);  // [4, 5]
    printf("Slice [-2:5]: ");
    for (iter(&slice2)) |item| {
        printf("%d ", item);
    }
    printf("\n");
}

// 测试错误处理
fn safe_divide(a: i32, b: i32) !i32 {
    if b == 0 {
        return error.DivisionByZero;
    }
    return a / b;
}

fn safe_sqrt(x: f64) !f64 {
    if x < 0.0 {
        return error.NegativeSqrt;
    }
    return sqrt(x);
}

fn test_error_handling() void {
    printf("\n=== 错误处理测试 ===\n");
    
    // 测试成功情况
    const result: i32 = try safe_divide(10, 2);
    printf("10 / 2 = %d\n", result);
    
    // 测试错误情况
    const div_result: i32 = safe_divide(10, 0) catch |err| {
        if err == error.DivisionByZero {
            printf("Caught division by zero error\n");
        }
        return -1;
    };
    
    // 测试另一个错误
    const sqrt_result: f64 = safe_sqrt(-1.0) catch |err| {
        if err == error.NegativeSqrt {
            printf("Caught negative sqrt error\n");
        }
        return -1.0;
    };
}

// 测试结构体和方法
fn test_structs_and_methods() void {
    printf("\n=== 结构体和方法测试 ===\n");
    
    // 创建圆形
    const circle: Circle = Circle{
        center: Point{ x: 0.0, y: 0.0 },
        radius: 5.0
    };
    
    // 创建矩形
    const rectangle: Rectangle = Rectangle{
        width: 4.0,
        height: 6.0
    };
    
    // 使用接口
    const shape1: IShape = circle;  // 自动装箱
    const shape2: IShape = rectangle;  // 自动装箱
    
    printf("Circle area: %f, perimeter: %f\n", 
           shape1.area(), shape1.perimeter());
    printf("Rectangle area: %f, perimeter: %f\n", 
           shape2.area(), shape2.perimeter());
}

// 测试指针和引用
fn test_pointers() void {
    printf("\n=== 指针测试 ===\n");
    
    var x: i32 = 42;
    const ptr: &i32 = &x;
    
    printf("Value of x: %d\n", x);
    printf("Value pointed by ptr: %d\n", *ptr);
    
    // 修改通过指针
    const mut_ref: &mut i32 = &mut x;
    *mut_ref = 100;
    printf("After modifying through pointer, x: %d\n", x);
    
    // 安全指针算术
    const arr: [i32; 3] = [10, 20, 30];
    const base_ptr: &i32 = &arr[0];
    
    // 编译器可以证明 base_ptr + 1 和 base_ptr + 2 都在安全范围内
    const val1: i32 = *(base_ptr + 1);  // arr[1]
    const val2: i32 = *(base_ptr + 2);  // arr[2]
    
    printf("Pointer arithmetic: %d, %d\n", val1, val2);
}

// 测试defer和errdefer
fn test_defer_errdefer() !i32 {
    printf("\n=== defer/errdefer 测试 ===\n");
    
    defer {
        printf("Normal cleanup in defer\n");
    }
    
    errdefer {
        printf("Error cleanup in errdefer\n");
    }
    
    const result: i32 = try safe_divide(20, 4);
    printf("Division result: %d\n", result);
    
    // 模拟错误情况
    if result < 0 {
        return error.NegativeResult;  // 假设的错误
    }
    
    return result;
}

// 测试泛型（如果支持）
fn test_generics() void {
    printf("\n=== 泛型测试 ===\n");
    
    const int_val: i32 = identity(42);
    const float_val: f64 = identity(3.14);
    const str_val: byte* = identity("Hello");
    
    printf("Generic identity i32: %d\n", int_val);
    printf("Generic identity f64: %f\n", float_val);
    // printf("Generic identity string: %s\n", str_val);  // 如果支持字符串
}

// 测试宏
fn test_macros() void {
    printf("\n=== 宏测试 ===\n");
    
    const x: i32 = 5;
    const squared: i32 = square(x);  // 展开为 x * x
    printf("square(5) = %d\n", squared);
}

// 测试原子类型
fn test_atomics() void {
    printf("\n=== 原子类型测试 ===\n");
    
    var counter: Counter = Counter{ value: 0 };
    
    // 原子操作
    counter.value += 1;  // 自动原子 fetch_add
    counter.value += 1;  // 自动原子 fetch_add
    
    const current_val: i32 = counter.value;  // 自动原子 load
    printf("Atomic counter value: %d\n", current_val);
}

// 测试字符串插值（如果支持）
fn test_string_interpolation() void {
    printf("\n=== 字符串插值测试 ===\n");
    
    const x: i32 = 42;
    const pi: f64 = 3.14159;
    
    // 如果支持字符串插值语法
    // const msg: [i8; 64] = "x=${x}, pi=${pi:.2f}\n";
    // printf(&msg[0]);
    
    printf("x=%d, pi=%.2f\n", x, pi);  // 使用C函数
}

fn main() i32 {
    test_basics();
    test_arrays_and_slices();
    test_error_handling();
    test_structs_and_methods();
    test_pointers();
    
    const defer_result: i32 = test_defer_errdefer() catch |err| {
        printf("Error in defer test: %d\n", err as i32);
        return 1;
    };
    printf("Defer test result: %d\n", defer_result);
    
    test_generics();
    test_macros();
    test_atomics();
    test_string_interpolation();
    
    printf("\n=== 所有测试完成 ===\n");
    return 0;
}