// Uya语言特性测试套件

// 结构体定义
struct Vec3 {
    x: f32,
    y: f32,
    z: f32
}

// 错误定义
error FileError;
error ParseError;

// 基本类型和变量测试
fn test_basic_types() i32 {
    const x: i32 = 42;
    var y: i32 = 10;
    y = y + 5;
    
    const f: f64 = 3.14159;
    const b: bool = true;
    
    return x + y + (f as i32);
}

// 结构体测试
fn test_structs() Vec3 {
    const v: Vec3 = Vec3{ x: 1.0, y: 2.0, z: 3.0 };
    return v;
}

// 数组和切片测试
fn test_arrays_and_slices() i32 {
    const arr: [i32: 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    
    // 基本切片
    const slice1: [i32: 3] = slice(arr, 2, 5);  // [2, 3, 4]
    
    // 负数索引切片
    const slice2: [i32: 3] = slice(arr, -3, 10);  // [7, 8, 9]
    
    // 从开头到某位置
    const slice3: [i32: 3] = slice(arr, 0, 3);  // [0, 1, 2]
    
    // 从某位置到末尾
    const slice4: [i32: 3] = slice(arr, 7, 10);  // [7, 8, 9]
    
    // 负数到负数
    const slice5: [i32: 3] = slice(arr, -5, -2);  // [5, 6, 7]
    
    // 计算结果
    var sum: i32 = 0;
    for (iter(&slice1)) |val| {
        sum = sum + val;
    }
    for (iter(&slice2)) |val| {
        sum = sum + val;
    }
    for (iter(&slice3)) |val| {
        sum = sum + val;
    }
    for (iter(&slice4)) |val| {
        sum = sum + val;
    }
    for (iter(&slice5)) |val| {
        sum = sum + val;
    }
    
    return sum;
}

// 错误处理测试
fn may_fail(flag: bool) !i32 {
    if flag {
        return 42;
    } else {
        return error.FileError;
    }
}

fn test_error_handling() i32 {
    // 成功路径
    const success_val: i32 = try may_fail(true);
    
    // 错误路径
    const err_val: i32 = may_fail(false) catch |err| {
        if err == error.FileError {
            return 1;
        }
        return 0;
    };
    
    return success_val + err_val;
}

// 控制流测试
fn test_control_flow() i32 {
    const x: i32 = 10;
    var result: i32 = 0;
    
    if x > 5 {
        result = result + 1;
    } else {
        result = result + 0;
    }
    
    var i: i32 = 0;
    while i < 3 {
        result = result + i;
        i = i + 1;
    }
    
    const nums: [i32: 3] = [10, 20, 30];
    for (iter(&nums)) |num| {
        result = result + num;
    }
    
    return result;
}

// 函数测试
fn add(a: i32, b: i32) i32 {
    return a + b;
}

fn multiply(a: i32, b: i32) i32 {
    return a * b;
}

fn test_functions() i32 {
    const sum: i32 = add(5, 7);
    const product: i32 = multiply(3, 4);
    return sum + product;
}

// 接口测试
interface ICalculator {
    fn calculate(self: *Self, a: i32, b: i32) i32;
}

struct SimpleCalc {
    multiplier: i32
}

SimpleCalc : ICalculator {
    fn calculate(self: *Self, a: i32, b: i32) i32 {
        return (a + b) * self.multiplier;
    }
}

fn test_interface() i32 {
    const calc: SimpleCalc = SimpleCalc{ multiplier: 2 };
    const result: i32 = calc.calculate(3, 4);  // (3 + 4) * 2 = 14
    return result;
}

// 原子类型测试
struct Counter {
    value: atomic i32
}

fn test_atomic() i32 {
    var counter: Counter = Counter{ value: 0 };
    
    // 原子操作
    counter.value += 1;  // 自动原子fetch_add
    counter.value += 1;
    counter.value += 1;
    
    const val: i32 = counter.value;  // 自动原子load
    return val;
}

// 泛型测试（如果支持）
fn identity(val: T) T {
    return val;
}

fn test_generic() i32 {
    const int_val: i32 = identity(123);
    return int_val;
}

// 宏测试
mc double(x: i32) expr { x * 2 }

fn test_macro() i32 {
    const x: i32 = 5;
    const doubled: i32 = double(x);  // 展开为 x * 2
    return doubled;
}

// 综合测试
fn comprehensive_test() i32 {
    var result: i32 = 0;
    
    result = result + test_basic_types();
    result = result + (test_structs().x as i32);
    result = result + test_arrays_and_slices();
    result = result + test_error_handling();
    result = result + test_control_flow();
    result = result + test_functions();
    result = result + test_interface();
    result = result + test_atomic();
    result = result + test_generic();
    result = result + test_macro();
    
    return result;
}

fn main() i32 {
    const result: i32 = comprehensive_test();
    return result;
}