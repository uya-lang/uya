// Uya语言完整特性测试

// 结构体定义
struct Point {
    x: i32,
    y: i32
}

struct Vec3 {
    x: f32,
    y: f32,
    z: f32
}

// 错误定义
error FileError;
error ParseError;

// 基本类型和变量测试
fn test_basics() i32 {
    let x: i32 = 42;
    let mut y: i32 = 10;
    y = y + 5;
    
    let f: f64 = 3.14159;
    let b: bool = true;
    
    return x + y + (f as i32);
}

// 结构体测试
fn test_structs() i32 {
    let p: Point = Point{ x: 10, y: 20 };
    return p.x + p.y;
}

// 数组和切片测试
fn test_slices() i32 {
    let arr: [i32; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    let mut sum: i32 = 0;
    
    // 基本切片
    let slice1: [i32; 3] = arr[2:3];  // [2, 3, 4]
    for slice1 |val| {
        sum = sum + val;
    }
    
    // 负数索引切片
    let slice2: [i32; 3] = arr[-3:3];  // [7, 8, 9]
    for slice2 |val| {
        sum = sum + val;
    }
    
    // 从开头切片
    let slice3: [i32; 5] = arr[0:5];  // [0, 1, 2, 3, 4]
    for slice3 |val| {
        sum = sum + val;
    }
    
    // 到末尾切片
    let slice4: [i32; 3] = arr[7:3];  // [7, 8, 9]
    for slice4 |val| {
        sum = sum + val;
    }
    
    // 负数索引切片
    let slice5: [i32; 3] = arr[-5:3];  // [5, 6, 7]
    for slice5 |val| {
        sum = sum + val;
    }
    
    return sum;
}

// 错误处理测试
fn might_fail(ok: bool) !i32 {
    if ok {
        return 100;
    } else {
        return error.FileError;
    }
}

fn test_errors() i32 {
    // 成功路径
    let success_val: i32 = try might_fail(true);
    
    // 错误路径
    let err_val: i32 = might_fail(false) catch |err| {
        if err == error.FileError {
            return 1;
        }
        return 0;
    };
    
    return success_val + err_val;
}

// 控制流测试
fn test_control_flow() i32 {
    let mut result: i32 = 0;
    let x: i32 = 10;
    
    if x > 5 {
        result = result + 10;
    } else {
        result = result + 0;
    }
    
    let mut i: i32 = 0;
    while i < 3 {
        result = result + i;
        i = i + 1;
    }
    
    let nums: [i32; 3] = [1, 2, 3];
    for nums |num| {
        result = result + num;
    }
    
    return result;
}

// 函数测试
fn add(a: i32, b: i32) i32 {
    return a + b;
}

fn test_functions() i32 {
    return add(15, 25);
}

// 接口测试（简化版）
interface IShape {
    fn area(self: *Self) f32;
}

struct Rectangle {
    width: f32,
    height: f32
}

impl Rectangle : IShape {
    fn area(self: *Self) f32 {
        return self.width * self.height;
    }
}

fn test_interface() i32 {
    let rect: Rectangle = Rectangle{ width: 5.0, height: 3.0 };
    let area: f32 = rect.area();
    return area as i32;
}

// 原子类型测试
struct Counter {
    value: atomic i32
}

fn test_atomic() i32 {
    let mut counter: Counter = Counter{ value: 0 };
    
    counter.value += 1;
    counter.value += 1;
    counter.value += 1;
    
    return counter.value;
}

// 泛型测试（如果支持）
fn identity(val: T) T {
    return val;
}

fn test_generic() i32 {
    let val: i32 = identity(42);
    return val;
}

// 宏测试
mc double_val(x: i32) expr { x * 2 }

fn test_macro() i32 {
    let x: i32 = 10;
    let result: i32 = double_val(x);  // 展开为 x * 2
    return result;
}

// 综合测试函数
fn all_tests() i32 {
    let mut total: i32 = 0;

    total = total + test_basics();
    total = total + test_structs();
    total = total + test_slices();
    total = total + test_errors();
    total = total + test_control_flow();
    total = total + test_functions();
    total = total + test_interface();
    total = total + test_atomic();
    total = total + test_generic();
    total = total + test_macro();

    return total;
}

fn main() i32 {
    let result: i32 = all_tests();
    return result;
}