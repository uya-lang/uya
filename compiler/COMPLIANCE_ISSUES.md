# 编译器实现与语言规范符合性检查报告

## 概述

本报告列出了当前编译器实现与 Uya 语言规范（uya.md）之间的主要差异。

## 严重不符合项（必须实现）

### 1. 类型检查器完全未实现

**规范要求**：
- 所有类型必须完全匹配，无隐式转换
- 函数参数类型必须与签名匹配
- 变量初始化表达式类型必须与声明类型一致

**当前实现**：
- `compiler/src/checker/typechecker.c` 只是一个占位符
- `typechecker_check()` 函数总是返回成功，没有实际检查

**影响**：类型错误不会被捕获，可能导致运行时错误

---

### 2. const 变量赋值检查缺失

**规范要求**（第3章）：
- `const` 声明的变量**不可变**
- 可变变量可重新赋值；不可变变量赋值会编译错误
- 赋值运算符 `=` 仅用于 `var` 变量

**当前实现**：
- 解析器正确标记了 `is_mut` 和 `is_const`
- 但类型检查器没有检查 const 变量是否被赋值
- 代码生成器直接生成赋值代码，没有验证

**示例问题代码**：
```uya
const x: i32 = 10;
x = 20;  // 应该编译错误，但当前编译器会通过
```

---

### 3. 数组边界检查缺失

**规范要求**（第4章、第10章）：
- 常量索引越界 → **编译错误**
- 变量索引 → 必须证明 `i >= 0 && i < len`，证明失败 → **编译错误**
- 零运行时检查，通过路径零指令

**当前实现**：
- 完全没有数组边界检查
- 数组访问直接生成 C 代码，没有任何验证

**示例问题代码**：
```uya
const arr: [i32; 10] = [0; 10];
const x: i32 = arr[20];  // 应该编译错误（常量索引越界）
const i: i32 = get_index();
const y: i32 = arr[i];   // 应该编译错误（无法证明 i >= 0 && i < 10）
```

---

### 4. 整数溢出检查缺失

**规范要求**（第10章）：
- 常量运算溢出 → **编译错误**（编译期直接检查）
- 变量运算 → 必须显式检查溢出条件，或编译器能够证明无溢出
- 无法证明无溢出 → **编译错误**
- 溢出检查模式：
  - 加法上溢：`a > 0 && b > 0 && a > MAX - b`
  - 加法下溢：`a < 0 && b < 0 && a < MIN - b`
  - 乘法上溢：`a > 0 && b > 0 && a > MAX / b`

**当前实现**：
- 完全没有溢出检查
- 整数运算直接生成 C 代码

**示例问题代码**：
```uya
const x: i32 = 2147483647 + 1;  // 应该编译错误（常量溢出）
fn add(a: i32, b: i32) i32 {
    return a + b;  // 应该编译错误（无法证明无溢出）
}
```

---

### 5. 除零错误检查缺失

**规范要求**（第10章）：
- 常量除零 → **编译错误**
- 变量 → 必须证明 `y != 0`，证明失败 → **编译错误**

**当前实现**：
- 完全没有除零检查
- 除法运算直接生成 C 代码

**示例问题代码**：
```uya
const x: i32 = 10 / 0;  // 应该编译错误（常量除零）
fn div(a: i32, b: i32) i32 {
    return a / b;  // 应该编译错误（无法证明 b != 0）
}
```

---

### 6. 未初始化内存使用检查缺失

**规范要求**（第14章）：
- 必须证明「首次使用前已赋值」或「前序有赋值路径」
- 证明失败 → **编译错误**

**当前实现**：
- 完全没有未初始化检查

**示例问题代码**：
```uya
var x: i32;  // 未初始化
const y: i32 = x;  // 应该编译错误（使用未初始化变量）
```

---

### 7. 空指针解引用检查缺失

**规范要求**（第14章）：
- 必须证明 `ptr != null` 或前序有 `if ptr == null { return error; }`
- 证明失败 → **编译错误**

**当前实现**：
- 完全没有空指针检查

---

## 部分实现项（需要完善）

### 8. 变量声明语法

**状态**：✅ 已实现
- 支持 `const` 和 `var` 语法
- 向后兼容 `let` 和 `let mut`

**需要改进**：
- 需要检查 const 变量的赋值（见第2项）

---

### 9. 类型注解要求

**规范要求**（第3章）：
- 0.13 不支持类型推断，所有变量必须显式类型注解

**当前实现**：
- 解析器要求类型注解（`: Type`）
- 但类型检查器没有验证类型注解是否正确

---

## 功能缺失项（规范要求但未实现）

### 10. 编译期常量表达式求值

**规范要求**（第3章）：
- 常量必须在编译期求值
- 支持常量表达式：字面量、常量变量、算术运算等
- `const` 常量可以作为数组大小

**当前实现**：
- 没有编译期常量求值
- 数组大小必须是字面量数字

---

### 11. 变量遮蔽检查

**规范要求**（第3章）：
- 同一作用域内不能有同名变量
- 内层作用域可以声明与外层作用域同名的变量（遮蔽外层变量）

**当前实现**：
- 没有变量遮蔽检查
- 可能允许同一作用域内同名变量

---

### 12. 错误类型和错误联合类型

**规范要求**（第2章）：
- 支持 `!T` 错误联合类型
- 支持 `error.ErrorName` 语法
- 错误处理机制

**当前实现**：
- 可能部分支持，需要验证

---

### 13. 模块系统

**规范要求**（第1.5章）：
- 目录级模块
- 显式导出 `export`
- 路径导入 `use`

**当前实现**：
- 需要检查是否实现

---

## 建议的修复优先级

### 高优先级（核心安全特性）
1. ✅ 实现类型检查器基础功能
2. ✅ 实现 const 变量赋值检查
3. ✅ 实现数组边界检查
4. ✅ 实现整数溢出检查
5. ✅ 实现除零检查

### 中优先级（内存安全）
6. ✅ 实现未初始化内存检查
7. ✅ 实现空指针解引用检查

### 低优先级（功能完善）
8. ✅ 实现编译期常量表达式求值
9. ✅ 实现变量遮蔽检查
10. ✅ 完善错误类型支持

---

## 总结

当前编译器实现主要缺少**所有安全检查机制**，这是 Uya 语言的核心特性。规范要求的所有编译期证明机制都未实现，这导致：

1. 类型错误不会被捕获
2. 内存安全问题（数组越界、未初始化、空指针）不会被检测
3. 整数溢出和除零错误不会被检测
4. const 变量的不可变性没有被强制执行

**建议**：优先实现类型检查器和核心安全检查，这是 Uya 语言区别于其他语言的关键特性。

