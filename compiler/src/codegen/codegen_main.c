#include "codegen.h"
#include "codegen_error.h"
#include "codegen_type.h"
#include "codegen_value.h"
#include "codegen_inst.h"
#include "../ir/ir.h"
#include "../parser/ast.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

CodeGenerator *codegen_new() {
    CodeGenerator *codegen = malloc(sizeof(CodeGenerator));
    if (!codegen) {
        return NULL;
    }

    codegen->output_file = NULL;
    codegen->output_filename = NULL;
    codegen->label_counter = 0;
    codegen->temp_counter = 0;
    codegen->current_function = NULL;
    codegen->ir = NULL;
    codegen->error_map = NULL;
    codegen->error_map_size = 0;
    codegen->error_map_capacity = 0;

    return codegen;
}

void codegen_free(CodeGenerator *codegen) {
    if (codegen) {
        if (codegen->output_filename) {
            free(codegen->output_filename);
        }
        // Free error map
        if (codegen->error_map) {
            for (int i = 0; i < codegen->error_map_size; i++) {
                if (codegen->error_map[i].error_name) {
                    free(codegen->error_map[i].error_name);
                }
            }
            free(codegen->error_map);
        }
        free(codegen);
    }
}

int codegen_generate(CodeGenerator *codegen, IRGenerator *ir, ASTNode *ast, const char *output_file) {
    if (!codegen || !ir || !output_file) {
        return 0;
    }

    // Store IR generator reference for function lookup
    codegen->ir = ir;

    // 第一步：收集所有错误名称并检测冲突（从AST和IR中收集）
    if (collect_error_names(codegen, ir, ast) != 0) {
        // 发现冲突，编译失败
        return 0;
    }

    codegen->output_file = fopen(output_file, "w");
    if (!codegen->output_file) {
        return 0;
    }

    codegen->output_filename = malloc(strlen(output_file) + 1);
    if (!codegen->output_filename) {
        fclose(codegen->output_file);
        return 0;
    }
    strcpy(codegen->output_filename, output_file);

    // 写入C99头文件
    fprintf(codegen->output_file, "// Generated by Uya to C99 Compiler\n");
    fprintf(codegen->output_file, "#include <stdint.h>\n");
    fprintf(codegen->output_file, "#include <stddef.h>\n");
    fprintf(codegen->output_file, "#include <stdbool.h>\n");
    fprintf(codegen->output_file, "#include <stdio.h>\n");
    fprintf(codegen->output_file, "#include <stdlib.h>\n");
    fprintf(codegen->output_file, "#include <string.h>\n");
    fprintf(codegen->output_file, "#include <unistd.h>\n");
    fprintf(codegen->output_file, "#include <fcntl.h>\n\n");
    // Error type definition (error is a type containing error codes, represented as uint32_t)
    fprintf(codegen->output_file, "// Error type definition (error codes are uint32_t)\n");
    fprintf(codegen->output_file, "typedef uint32_t error;\n\n");

    // Generate slice type definition
    // According to uya.md: &[T] is represented as struct slice_T { void* ptr; size_t len; }
    fprintf(codegen->output_file, "// Slice type definition\n");
    fprintf(codegen->output_file, "// Generic slice structure for all slice types\n");
    fprintf(codegen->output_file, "struct slice {\n");
    fprintf(codegen->output_file, "    void* ptr;    // 8 bytes (64位) 或 4 bytes (32位)\n");
    fprintf(codegen->output_file, "    size_t len;   // 8 bytes (64位) 或 4 bytes (32位)\n");
    fprintf(codegen->output_file, "};\n\n");

    // Generate interface type definition
    // According to uya.md: InterfaceName is represented as struct interface { void* vtable; void* data; }
    fprintf(codegen->output_file, "// Interface type definition\n");
    fprintf(codegen->output_file, "// Generic interface structure for all interface types\n");
    fprintf(codegen->output_file, "struct interface {\n");
    fprintf(codegen->output_file, "    void* vtable;  // 8 bytes (64位) 或 4 bytes (32位)\n");
    fprintf(codegen->output_file, "    void* data;    // 8 bytes (64位) 或 4 bytes (32位)\n");
    fprintf(codegen->output_file, "};\n\n");

    // Collect and generate error union type definitions for all functions with !T return types
    fprintf(codegen->output_file, "// Error union type definitions\n");
    if (ir && ir->instructions) {
        // Collect all error union types actually used in the program
        // Use a simple array to track unique base types (excluding struct types for now)
        IRType *used_types = NULL;
        int type_count = 0;
        int type_capacity = 0;

        // First pass: collect all error union return types
        for (int i = 0; i < ir->inst_count; i++) {
            if (ir->instructions[i] && ir->instructions[i]->type == IR_FUNC_DEF) {
                IRInst *func = ir->instructions[i];
                if (func->data.func.return_type_is_error_union) {
                    IRType base_type = func->data.func.return_type;

                    // Skip struct types for now (need struct name which is not stored in IRType)
                    // TODO: Improve IR to store struct name in return type information
                    if (base_type == IR_TYPE_STRUCT) {
                        continue;
                    }

                    // Check if this type is already collected
                    int found = 0;
                    for (int j = 0; j < type_count; j++) {
                        if (used_types[j] == base_type) {
                            found = 1;
                            break;
                        }
                    }

                    if (!found) {
                        // Expand array if needed
                        if (type_count >= type_capacity) {
                            int new_capacity = type_capacity == 0 ? 8 : type_capacity * 2;
                            IRType *new_types = realloc(used_types, new_capacity * sizeof(IRType));
                            if (!new_types) {
                                if (used_types) free(used_types);
                                break;
                            }
                            used_types = new_types;
                            type_capacity = new_capacity;
                        }

                        used_types[type_count++] = base_type;
                    }
                }
            }
        }

        // Generate error union type definitions for collected types
        for (int i = 0; i < type_count; i++) {
            codegen_write_error_union_type_def(codegen, used_types[i]);
        }

        // Also generate common types that might be used (for backward compatibility)
        // Check if i32 and void are already in the list
        int has_i32 = 0, has_void = 0;
        for (int i = 0; i < type_count; i++) {
            if (used_types[i] == IR_TYPE_I32) has_i32 = 1;
            if (used_types[i] == IR_TYPE_VOID) has_void = 1;
        }
        if (!has_i32) codegen_write_error_union_type_def(codegen, IR_TYPE_I32);
        if (!has_void) codegen_write_error_union_type_def(codegen, IR_TYPE_VOID);

        // Cleanup
        if (used_types) free(used_types);
    }
    fprintf(codegen->output_file, "\n");

    // 第一遍：生成结构体声明和枚举声明（必须在函数声明之前）
    if (ir && ir->instructions) {
        for (int i = 0; i < ir->inst_count; i++) {
            if (ir->instructions[i] && ir->instructions[i]->type == IR_STRUCT_DECL) {
                codegen_generate_inst(codegen, ir->instructions[i]);
            }
            if (ir->instructions[i] && ir->instructions[i]->type == IR_ENUM_DECL) {
                codegen_generate_inst(codegen, ir->instructions[i]);
            }
        }
    }

    // 第二遍：生成函数声明（前向声明）
    fprintf(codegen->output_file, "// Forward declarations\n");
    if (ir && ir->instructions) {
        for (int i = 0; i < ir->inst_count; i++) {
            if (ir->instructions[i] && ir->instructions[i]->type == IR_FUNC_DEF) {
                IRInst *func = ir->instructions[i];
                // Skip test functions
                if (func->data.func.name && strncmp(func->data.func.name, "@test$", 6) == 0) {
                    continue;
                }
                // Generate forward declaration
                if (func->data.func.return_type_is_error_union) {
                    codegen_write_error_union_type_name(codegen, func->data.func.return_type);
                } else if (func->data.func.return_type == IR_TYPE_STRUCT) {
                    // For struct return types, use return_type_original_name if available
                    if (func->data.func.return_type_original_name) {
                        fprintf(codegen->output_file, "%s", func->data.func.return_type_original_name);
                    } else {
                        // Fallback: try to find the struct name
                        const char *struct_name = codegen_find_struct_name_from_return_type(codegen, func);
                        if (struct_name) {
                            fprintf(codegen->output_file, "%s", struct_name);
                        } else {
                            codegen_write_type(codegen, func->data.func.return_type);
                        }
                    }
                } else {
                    codegen_write_type(codegen, func->data.func.return_type);
                }

                // For drop functions, use the actual function name (drop_TypeName)
                char *actual_func_name = func->data.func.name;
                char drop_func_name[256] = {0};
                int is_drop_func_forward = 0;
                if (func->data.func.name && strcmp(func->data.func.name, "drop") == 0 &&
                    func->data.func.param_count > 0 && func->data.func.params[0] &&
                    func->data.func.params[0]->data.var.original_type_name) {
                    snprintf(drop_func_name, sizeof(drop_func_name), "drop_%s",
                             func->data.func.params[0]->data.var.original_type_name);
                    actual_func_name = drop_func_name;
                    is_drop_func_forward = 1;
                }

                fprintf(codegen->output_file, " %s(", actual_func_name);
                for (int j = 0; j < func->data.func.param_count; j++) {
                    if (j > 0) fprintf(codegen->output_file, ", ");
                    if (func->data.func.params[j]->data.var.type == IR_TYPE_PTR &&
                        func->data.func.params[j]->data.var.original_type_name) {
                        fprintf(codegen->output_file, "%s* %s",
                                func->data.func.params[j]->data.var.original_type_name,
                                func->data.func.params[j]->data.var.name);
                    } else if (func->data.func.params[j]->data.var.type == IR_TYPE_STRUCT &&
                               func->data.func.params[j]->data.var.original_type_name) {
                        // For drop functions, use pointer parameter to avoid copying large structs
                        if (is_drop_func_forward && j == 0) {
                            fprintf(codegen->output_file, "%s* %s",
                                    func->data.func.params[j]->data.var.original_type_name,
                                    func->data.func.params[j]->data.var.name);
                        } else {
                            fprintf(codegen->output_file, "%s %s",
                                    func->data.func.params[j]->data.var.original_type_name,
                                    func->data.func.params[j]->data.var.name);
                        }
                    } else {
                        codegen_write_type(codegen, func->data.func.params[j]->data.var.type);
                        fprintf(codegen->output_file, " %s", func->data.func.params[j]->data.var.name);
                    }
                }
                fprintf(codegen->output_file, ");\n");
            }
        }
    }
    fprintf(codegen->output_file, "\n");

    // 第三遍：生成函数定义（跳过已生成的结构体声明和枚举声明）
    if (ir && ir->instructions) {
        for (int i = 0; i < ir->inst_count; i++) {
            if (ir->instructions[i]) {
                // Skip struct and enum declarations (already generated in first pass)
                if (ir->instructions[i]->type == IR_STRUCT_DECL || ir->instructions[i]->type == IR_ENUM_DECL) {
                    continue;
                }
                codegen_generate_inst(codegen, ir->instructions[i]);
            }
        }
    }

    fclose(codegen->output_file);
    codegen->output_file = NULL;

    return 1;
}