# 错误码哈希冲突率分析

## 当前实现

**哈希函数**: 多项式哈希（Polynomial Hash）
- 公式: `error_code = error_code * 31 + char`
- 类似 Java 的 `String.hashCode()`
- 乘数: 31（质数，有助于减少冲突）

**哈希空间**: 2^32 - 1 = 4,294,967,295（0 被保留表示成功）

## 冲突率分析

### 实际测试结果
- 测试 54 个不同的错误名称：**0 个冲突**
- 理论冲突概率：0.000034%
- 哈希值分布：覆盖 96.83% 的可用空间

### 不同规模下的理论冲突概率

| 错误名称数量 | 冲突概率 | 适用场景 |
|------------|---------|---------|
| 10         | < 0.0001% | 小型项目 |
| 50         | < 0.0001% | 中型项目 |
| 100        | 0.0001%   | 大型项目 |
| 500        | 0.0029%   | 企业级项目 |
| 1,000      | 0.01%     | 大型系统 |
| 5,000      | 0.29%     | 超大型系统 |
| 10,000     | 1.16%     | 极端情况 |
| 50,000     | 25.25%    | 不推荐 |
| 100,000    | 68.78%    | 不推荐 |

### 生日悖论分析

根据生日悖论，当错误名称数量达到约 **√(2^32) ≈ 65,536** 时，冲突概率约为 50%。

## 结论

### 优点
1. **简单高效**: 实现简单，计算快速
2. **低冲突率**: 对于 < 10,000 个错误名称，冲突概率 < 1%
3. **分布均匀**: 哈希值分布覆盖 96%+ 的可用空间
4. **实际可用**: 大多数项目不会有超过 1,000 个不同的错误名称

### 适用场景
- ✅ **推荐用于**: < 10,000 个错误名称的项目
- ⚠️ **谨慎使用**: 10,000 - 50,000 个错误名称
- ❌ **不推荐**: > 50,000 个错误名称

### 如果冲突率不够低

如果需要更低的冲突率，可以考虑：

1. **FNV-1a 哈希**:
   ```c
   uint32_t hash = 2166136261U;
   for (const char *p = name; *p; p++) {
       hash ^= (unsigned char)*p;
       hash *= 16777619U;
   }
   ```

2. **MurmurHash3**: 更复杂的哈希函数，冲突率更低

3. **编译期冲突检测**: 在编译时检测冲突并报错

4. **使用更大的类型**: 如果允许，可以使用 uint64_t 而不是 uint32_t
