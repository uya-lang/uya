# 编译期枚举错误码方案

## 实现概述

已实现**编译期枚举方案**，替代哈希函数生成错误码。该方案在编译时收集所有错误名称，按字母序排序后分配递增的错误码（1, 2, 3, ...）。

## 方案优势

### ✅ 无冲突
- **保证唯一性**：每个错误名称分配唯一的错误码
- **编译期检测**：如果出现重复，会在编译时发现

### ✅ 稳定性
- **可重现**：相同代码每次编译生成相同的错误码
- **可预测**：按字母序排序，错误码分配顺序固定

### ✅ 简单高效
- **实现简单**：只需收集、排序、分配
- **查找快速**：使用二分查找，O(log n) 时间复杂度

## 实现细节

### 1. 错误名称收集
- 在代码生成阶段，遍历所有 IR 指令
- 递归查找所有 `IR_ERROR_VALUE` 指令
- 收集唯一的错误名称

### 2. 排序和分配
- 使用 `qsort` 按字母序排序错误名称
- 从 1 开始分配递增的错误码（0 保留表示成功）

### 3. 错误码查找
- 使用二分查找在映射表中查找错误码
- O(log n) 时间复杂度

## 测试结果

### 测试1: 多个不同错误
```uya
fn test1() !i32 { return error.DivisionByZero; }
fn test2() !void { return error.FileNotFound; }
fn test3() !i32 { return error.InvalidInput; }
```
**结果**: DivisionByZero=1, FileNotFound=2, InvalidInput=3 ✅

### 测试2: 字母序排序
```uya
fn test() !i32 { return error.Zebra; }
fn test2() !i32 { return error.Apple; }
fn test3() !i32 { return error.Banana; }
```
**结果**: Apple=1, Banana=2, Zebra=3 ✅（按字母序）

### 测试3: 重复使用
```uya
fn test1() !i32 { return error.TestError; }
fn test2() !i32 { return error.TestError; }
```
**结果**: 两个函数都使用错误码 1 ✅（相同错误名称得到相同错误码）

## 与哈希函数方案对比

| 特性 | 哈希函数 | 编译期枚举 |
|------|---------|-----------|
| 冲突率 | 低（<1% for <10K errors） | **0%**（保证无冲突） |
| 稳定性 | 高 | **高**（完全稳定） |
| 可预测性 | 中（需要计算） | **高**（按字母序） |
| 实现复杂度 | 低 | **中**（需要收集和排序） |
| 查找速度 | O(1) | O(log n) |
| 内存占用 | 无 | 小（映射表） |

## 结论

编译期枚举方案是**理想的错误码生成方案**，特别适合：
- ✅ 需要保证无冲突的场景
- ✅ 需要稳定、可预测错误码的场景
- ✅ 错误名称数量适中的项目（< 10,000）

对于大多数项目，编译期枚举方案比哈希函数方案更优。
