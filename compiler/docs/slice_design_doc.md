# Uya语言切片语法设计文档

## 1. 概述

### 1.1 设计目标
Uya语言的切片语法旨在提供类似Python的便捷切片功能，同时保持Uya语言的内存安全和零运行时开销特性。设计目标包括：

- **Python风格语法**：支持类似Python的切片语法，如 `arr[start:end]` 和负数索引
- **内存安全**：所有切片操作必须在编译期或运行时被证明为安全
- **零运行时开销**：通过路径零指令，安全路径无额外开销
- **向后兼容**：与现有Uya语法完全兼容

### 1.2 设计哲学
切片语法的设计遵循Uya语言的核心哲学：
- **安全优先**：所有未定义行为必须被编译期证明为安全，失败即编译错误
- **显式控制**：程序员必须提供边界检查，帮助编译器完成证明
- **零运行时开销**：通过路径零指令，失败路径不存在

## 2. 语法规范

### 2.1 基本切片语法
```
slice_expr = primary '[' start? ':' end? ']'
start      = expr
end        = expr
```

### 2.2 语法形式
- `arr[start:end]` - 从索引start到end-1的元素切片
- `arr[start:]` - 从索引start到数组末尾
- `arr[:end]` - 从数组开头到索引end-1
- `arr[:]` - 整个数组的副本
- `arr[start:end:step]` - （未来版本支持）带步长的切片

### 2.3 负数索引
- `arr[-1]` - 最后一个元素
- `arr[-n]` - 倒数第n个元素
- `arr[-3:5]` - 从倒数第3个元素到索引4
- `arr[2:-1]` - 从索引2到倒数第1个元素（不包含）
- `arr[-5:-2]` - 从倒数第5个到倒数第2个元素（不包含）

## 3. 语义定义

### 3.1 边界检查
所有切片操作必须满足边界条件：
- `start >= 0 && start <= len(arr)`
- `end >= start && end <= len(arr)`
- 对于负数索引：`-n` 转换为 `len(arr) - n`

### 3.2 类型系统
- 切片操作返回类型：`[T; M]`，其中T是原数组元素类型，M是切片元素数量
- `len` 函数可用于获取切片长度：`len(slice)`

### 3.3 安全保证
- **编译期证明**：常量索引和边界在编译期验证
- **运行时检查**：变量索引需要运行时边界检查，但通过路径零指令
- **失败即错误**：无法证明安全的切片操作会导致编译错误

## 4. 实现细节

### 4.1 词法分析
- 新增 `TOKEN_ELLIPSIS` (`...`) 用于可变参数
- 支持负数索引的解析（`-` 号号与数字的组合）

### 4.2 语法分析
- 扩展 `AST_SUBSCRIPT_EXPR` 节点以支持切片语法
- 添加 `AST_SLICE_EXPR` 专门节点处理切片表达式

### 4.3 中间表示 (IR)
- 新增 `IR_SLICE` 指令类型
- 添加 `slice_op` 结构体：
  ```c
  struct {
      char *dest;      // 目标切片变量
      IRInst *source;  // 源数组
      IRInst *start;   // 起始索引
      IRInst *end;     // 结束索引
  } slice_op;
  ```

### 4.4 代码生成
- 生成高效的内存拷贝代码
- 编译期常量边界检查
- 运行时边界验证（当编译期无法证明时）

## 5. 使用示例

### 5.1 基本切片操作
```uya
let arr: [i32; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

// 基本切片 [2:5] -> [2, 3, 4]
let slice1: [i32; 3] = slice(arr, 2, 5);

// 负数索引切片 [-3:10] -> [7, 8, 9]
let slice2: [i32; 3] = slice(arr, -3, 10);

// 从开头到某位置 [:3] -> [0, 1, 2]
let slice3: [i32; 3] = slice(arr, 0, 3);

// 从某位置到末尾 [7:] -> [7, 8, 9]
let slice4: [i32; 3] = slice(arr, 7, 10);

// 从开头到倒数第几个 [:-1] -> [0, 1, 2, 3, 4, 5, 6, 7, 8]
let slice5: [i32; 9] = slice(arr, 0, -1);

// 负数到负数 [-5:-2] -> [5, 6, 7]
let slice6: [i32; 3] = slice(arr, -5, -2);
```

### 5.2 安全边界检查
```uya
fn safe_slice(arr: [i32; 10], start: i32, end: i32) ![i32; 5] {  // 假设返回长度为5的切片
    if start < 0 || start >= 10 || end < start || end > 10 {
        return error.BoundsError;  // 边界检查失败
    }
    return slice(arr, start, end);  // 编译器证明安全
}
```

### 5.3 与现有语法的集成
```uya
// 切片与for循环结合
for (iter(&slice(arr, 2, 5))) |item| {
    printf("Item: %d\n", item);
}

// 切片与错误处理结合
let result: [i32; 3] = safe_slice(arr, 2, 5) catch |err| {
    if err == error.BoundsError {
        return [0; 3];  // 返回默认切片
    }
    return [0; 3];
};
```

## 6. 性能特性

### 6.1 编译期优化
- 常量边界检查在编译期完成
- 生成高效的内存拷贝代码
- 无运行时边界检查（当编译期可证明时）

### 6.2 运行时性能
- 通过路径零指令，安全路径无额外开销
- 内存拷贝使用高效的系统调用
- 零堆分配，切片在栈上分配

## 7. 错误处理

### 7.1 边界错误
- `error.SliceBoundsError` - 切片边界超出范围
- `error.NegativeIndexError` - 负数索引超出范围

### 7.2 错误处理示例
```uya
fn get_slice_safely(arr: [i32; 10], start: i32, end: i32) ![i32; N] {  // N为end-start
    if start < 0 {
        start = len(arr) + start;  // 转换负数索引
    }
    if end < 0 {
        end = len(arr) + end;
    }
    
    if start < 0 || start >= len(arr) || end < start || end > len(arr) {
        return error.SliceBoundsError;
    }
    
    return slice(arr, start, end);
}
```

## 8. 与现有特性的集成

### 8.1 与类型系统的集成
- 切片操作保持类型安全
- 返回类型根据切片长度推断

### 8.2 与内存安全的集成
- 所有切片操作经过内存安全验证
- 与RAII和drop机制兼容

### 8.3 与错误处理的集成
- 切片操作可返回错误联合类型
- 与try/catch机制兼容

## 9. 未来扩展

### 9.1 步长支持
未来版本将支持带步长的切片：`arr[start:end:step]`

### 9.2 多维数组切片
支持多维数组的切片操作：`matrix[row_start:row_end][col_start:col_end]`

### 9.3 切片修改操作
支持对切片元素的修改操作

## 10. 与Python切片的对比

| 特性 | Python | Uya | 说明 |
|------|--------|-----|------|
| 基本切片 | `arr[start:end]` | `slice(arr, start, end)` 或 `arr[start:end]` | 语法相似 |
| 负数索引 | `arr[-1]` | `arr[-1]` | 语义相同 |
| 省略边界 | `arr[start:]` | `arr[start:]` | 语义相同 |
| 内存安全 | 运行时检查 | 编译期证明 | Uya更安全 |
| 性能 | 运行时开销 | 零运行时开销 | Uya更高效 |
| 类型安全 | 动态类型 | 静态类型 | Uya更安全 |

## 11. 实现状态

### 11.1 已实现功能
- ✅ 基本切片语法 `arr[start:end]`
- ✅ 负数索引支持
- ✅ 边界检查机制
- ✅ 与现有类型系统集成
- ✅ 与错误处理系统集成

### 11.2 待实现功能
- ⏳ 步长支持 `arr[start:end:step]`
- ⏳ 多维数组切片
- ⏳ 切片修改操作

## 12. 总结

Uya语言的切片语法成功地将Python风格的便捷切片功能与Uya的安全性哲学相结合。通过编译期证明和边界检查，确保了内存安全，同时保持了零运行时开销的性能特性。该设计既提供了高级语言的便利性，又保持了系统编程语言的安全性和性能。

> **优雅 0.12 切片 = Python 风格语法 + Rust 级内存安全 + C 级性能**；
> **零运行时开销，编译期边界证明，失败即编译错误**；
> **通过路径零指令，安全路径直接访问内存**。