# Uya 编译器实现待办事项

本文档根据 `uya.md` 语法规范和当前实现状态，按优先级组织待实现的功能。

**最后更新**：2026-01-09  
**基于规范版本**：Uya 0.26

**注意**：
- 枚举类型已完全实现，包括 AST 节点定义、语法解析、IR 类型系统、代码生成和类型检查。
- 元组类型实现进展：已完成 AST 节点定义、语法解析、IR 生成（字面量生成已完善为完整的结构体初始化）、代码生成和部分类型检查，已编写测试用例。已知问题：需要为每个元组类型生成唯一的结构体定义（当前使用临时名称 tuple_N），生成的C代码无法编译。
- match 表达式实现进展：已完成 AST 节点定义和语法解析，IR 生成和代码生成部分实现。

---

## 优先级说明

- **P0（高优先级）**：规范已更新但编译器未实现的破坏性变更，影响代码兼容性
- **P1（中高优先级）**：核心功能缺失，影响语言完整性
- **P2（中优先级）**：有用功能，提升开发体验
- **P3（低优先级）**：可选功能或实现细节优化

---

## P0：破坏性变更（规范已更新，编译器待更新）

### 1. 接口实现语法更新（0.24 版本变更）✅

**状态**：✅ **已完成**

**变更内容**：
- 从 `impl StructName : InterfaceName {}` 简化为 `StructName : InterfaceName {}`
- 移除 `impl` 关键字

**影响**：破坏性变更，现有代码需要迁移

**已完成事项**：
- [x] 修改词法分析器（`lexer/lexer.c`）：`impl` 不再作为关键字
- [x] 修改语法分析器（`parser/parser.c`）：
  - [x] 移除 `parser_match(parser, TOKEN_IMPL)` 的使用
  - [x] 修改 `parser_parse_impl_decl` 函数支持新语法（无需 `impl` 关键字）
  - [x] 修改 `parser_parse_declaration` 函数，添加新解析逻辑识别 `ID : ID {` 形式
  - [x] 添加向前查看（lookahead）来区分结构体方法块和接口实现
- [x] 更新错误消息和文档注释
- [x] 更新测试用例

**相关文件**：
- `compiler/src/lexer/lexer.c`
- `compiler/src/parser/parser.c`
- `compiler/src/parser/ast.h`

**参考**：
- 规范：`uya.md` 第 6 章（接口）
- 语法：`grammar_formal.md` 结构体声明和接口声明部分

---

### 2. 函数指针类型（0.25 版本新增）✅

**状态**：✅ **基础功能已实现**

**变更内容**：
- 新增函数指针类型语法：`fn(param_types) return_type`
- 支持 `extern fn name(...) type { ... }` 导出函数给 C
- 支持 `&function_name` 获取函数指针
- 支持函数指针类型别名：`type FuncAlias = fn(...) type;`（语法解析支持，类型别名功能本身未实现）

**影响**：新功能，不影响现有代码

**已完成事项**：
- [x] 语法分析器（`parser/parser.c`）：
  - [x] 添加函数指针类型解析：`fn '(' [ param_type_list ] ')' type`
  - [x] 修复 `extern fn` 语法解析，添加 `fn` 关键字支持
  - [x] 支持函数指针类型作为参数类型和返回类型
  - [x] `&function_name` 表达式解析（通过一元表达式 `IR_OP_ADDR_OF` 处理）
- [x] 类型检查器（`checker/typechecker.c`）：
  - [x] 添加函数指针类型支持（返回 `IR_TYPE_FN`）
- [x] IR 生成器（`ir_generator.c`）：
  - [x] 添加函数指针类型的 IR 表示（`IR_TYPE_FN`）
  - [x] 处理 `&function_name` 表达式（通过 `IR_OP_ADDR_OF`）
- [x] 代码生成器（`codegen/`）：
  - [x] 生成函数指针类型定义（使用通用的 `void(*)()` C 类型）
  - [x] 实现 `extern fn` 导出函数的代码生成（通过 `IR_FUNC_DEF`）
  - [x] 函数指针变量的代码生成

**已知限制**：
- ⚠️ 当前使用通用的 `void(*)()` 类型，未保存完整的函数签名信息（参数类型和返回类型）
- ⚠️ 对 FFI 场景足够使用，但未来可能需要完善以支持完整的函数签名信息
- ⚠️ 函数指针类型别名（`type FuncAlias = fn(...) type;`）的语法解析支持，但类型别名功能本身未实现

**相关文件**：
- `compiler/src/parser/parser.c`
- `compiler/src/checker/typechecker.c`
- `compiler/src/ir/ir.h`
- `compiler/src/ir_generator.c`
- `compiler/src/codegen/`

**参考**：
- 规范：`uya.md` 第 5.2 章（外部 C 函数）
- 语法：`grammar_formal.md` 函数指针类型部分

---

### 3. 数组类型语法更新（破坏性变更）✅

**状态**：✅ **已完成**

**变更内容**：
- 数组类型语法从 `[type; NUM]` 更改为 `[type : NUM]`（使用冒号而非分号）
- 规范要求：`array_type = '[' type ':' NUM ']'`

**影响**：破坏性变更，所有使用数组类型的代码需要迁移（将 `;` 改为 `:`）

**已完成事项**：
- [x] 语法分析器（`parser/parser.c`）：
  - [x] 修改 `parser_parse_type` 函数中的数组类型解析
  - [x] 将 `TOKEN_SEMICOLON` 改为 `TOKEN_COLON`（第233行）
  - [x] 更新注释：从 `[element_type; size]` 改为 `[element_type : size]`
- [x] 其他源文件注释更新：
  - [x] `checker/typechecker.c`：更新类型字符串显示 `[T : N]`
  - [x] `codegen/codegen_inst.c`：更新注释中的数组类型语法
- [x] 测试用例：
  - [x] 更新所有使用数组类型的测试用例（将 `;` 改为 `:`，共37个测试文件）
  - [x] 更新示例文件（共28个文件）
  - [x] 验证数组类型解析正确性

**相关文件**：
- `compiler/src/parser/parser.c`（第212-254行，数组类型解析）
- `compiler/tests/`（所有包含数组类型的测试文件）

**参考**：
- 规范：`grammar_formal.md` 第100行：`array_type = '[' type ':' NUM ']'`
- 语法：`uya.md` 第2章（类型系统）

---

## P1：核心功能缺失

### 4. 模块系统 ❌

**状态**：❌ **未实现**

**规范要求**（`uya.md` 第 1.5 章）：
- 目录级模块系统
- 显式导出 `export` 关键字
- 路径导入 `use` 关键字
- 模块路径：`module_path = ID { '.' ID }`

**影响**：当前只支持单文件编译，无法使用模块系统

**待办事项**：
- [ ] 词法分析器：确认 `export` 和 `use` 关键字支持（可能已支持）
- [ ] 语法分析器：
  - [ ] 实现 `export_decl` 解析
  - [ ] 实现 `import_stmt` 解析（`use module_path [ as ID ] ;`）
- [ ] 模块解析器（新建）：
  - [ ] 目录扫描和模块路径映射
  - [ ] 模块依赖解析
  - [ ] 循环依赖检测
- [ ] 符号表扩展：
  - [ ] 模块级别的符号表
  - [ ] 导出符号管理
  - [ ] 导入符号解析
- [ ] 类型检查器：
  - [ ] 跨模块类型检查
  - [ ] 导出符号可见性检查
- [ ] IR 生成器：
  - [ ] 模块信息的 IR 表示
- [ ] 代码生成器：
  - [ ] 多文件代码生成
  - [ ] 模块前缀处理（如 `std.io.read_file`）

**相关文件**：
- 需要新建：`compiler/src/module/` 目录
- `compiler/src/parser/parser.c`
- `compiler/src/checker/typechecker.c`
- `compiler/src/codegen/codegen_main.c`

**参考**：
- 规范：`uya.md` 第 1.5 章（模块系统）
- 语法：`grammar_formal.md` 第 7 章（模块系统）

**优先级说明**：虽然重要，但可以分阶段实现，先实现单文件编译的完善功能

---

## P2：有用功能，提升开发体验

### 4. 错误类型比较操作 ✅

**状态**：✅ **已实现**

**规范要求**（`uya.md` 第 875-880 行）：
- 错误类型支持相等性比较：`if err == error.FileNotFound { ... }`
- 错误类型不支持不等性比较（仅支持 `==`）
- catch 块中可以判断错误类型并做不同处理

**当前状态**：
- ✅ 错误类型和错误联合类型已实现
- ✅ 错误类型比较操作已实现

**已完成事项**：
- [x] 类型检查器（`checker/typechecker.c`）：
  - [x] 识别错误类型比较表达式（`expr == error.ErrorName`）
  - [x] 验证错误类型比较的类型匹配（两个都是 uint32_t）
  - [x] 禁止错误类型使用 `!=` 运算符（仅支持 `==`）
  - [x] 在类型推断中，`error.ErrorName` 返回 `IR_TYPE_U32`
- [x] IR 生成器（`ir_generator.c`）：
  - [x] 生成错误类型比较的 IR 指令（通过现有的 `AST_BINARY_EXPR` → `IR_BINARY_OP` 处理）
- [x] 代码生成器（`codegen/codegen_value.c` 或 `codegen_inst.c`）：
  - [x] 实现错误类型比较的代码生成（通过现有的 `IR_BINARY_OP` 代码生成，比较两个 uint32_t 值）

**实现说明**：
- 错误类型比较实际上是两个 `uint32_t` 值的比较（错误码）
- catch 块中的错误变量类型是 `uint32_t`（从 `error_union_T.error_id` 字段提取）
- `error.ErrorName` 被生成为错误码（`uint32_t`）
- 现有的二元表达式 IR 生成和代码生成已经可以处理错误类型比较

**相关文件**：
- `compiler/src/checker/typechecker.c`
- `compiler/src/ir_generator.c`
- `compiler/src/codegen/codegen_value.c`
- `compiler/src/codegen/codegen_inst.c`

**参考**：
- 规范：`uya.md` 错误处理章节
- 详细任务：`compiler/TODO_error_handling.md` 第 2 节

---

### 5. 枚举类型 ✅

**状态**：✅ **已完全实现**

**规范要求**（`uya.md` 第 2 章）：
- 枚举声明：`enum ID [ ':' underlying_type ] '{' enum_variant_list '}'`
- 枚举变体可选显式赋值：`ID [ '=' NUM ]`
- 默认底层类型为 `i32`

**已完成事项**：
- [x] 词法分析器（`lexer/lexer.c`）：
  - [x] 添加 `TOKEN_ENUM` 关键字
- [x] AST 节点定义（`parser/ast.h`）：
  - [x] 添加 `AST_ENUM_DECL` 节点类型
  - [x] 定义 `EnumVariant` 结构体（存储变体名称和可选显式值）
  - [x] 添加 `enum_decl` 数据结构（名称、底层类型、变体列表）
- [x] AST 内存管理（`parser/ast.c`）：
  - [x] 实现枚举声明的内存释放逻辑
  - [x] 实现枚举声明的打印逻辑

**已完成事项**（续）：
- [x] 语法分析器（`parser/parser.c`）：
  - [x] 实现枚举声明解析函数（`parser_parse_enum_decl`）
  - [x] 在 `parser_parse_declaration` 中添加枚举声明解析
  - [x] 支持显式底层类型和显式值赋值
  - [x] 测试通过：基本枚举、带显式值的枚举、带底层类型的枚举
- [x] 枚举字面量语法解析：
  - [x] 枚举字面量 `EnumName.Variant` 使用 `AST_MEMBER_ACCESS` 节点（语法层面已支持）
  - [x] 语法解析器已能识别 `Color.Red` 这样的表达式

**已完成事项**（类型系统基础支持）：
- [x] IR 类型系统（`ir/ir.h`）：
  - [x] 添加 `IR_TYPE_ENUM` 类型枚举值
  - [x] 添加 `IR_ENUM_DECL` 指令类型
  - [x] 添加枚举声明数据结构（名称、底层类型、变体列表）
- [x] 类型检查器（`checker/typechecker.c`）：
  - [x] 添加枚举类型的字符串显示支持
  - [x] 添加枚举类型匹配检查
  - [x] 添加枚举值范围检查
  - [x] 添加枚举变量声明和使用的类型检查
- [x] 代码生成器（`codegen/codegen_type.c`）：
  - [x] 添加枚举类型的类型名称转换支持
  - [x] 更新 `codegen_write_type_with_name` 函数支持枚举类型

**已完成事项**（IR 生成和代码生成）：
- [x] IR 生成器（`ir_generator.c`）：
  - [x] 在 `generate_program` 函数中处理 `AST_ENUM_DECL` 节点
  - [x] 生成 `IR_ENUM_DECL` 指令，包含枚举名称、底层类型和变体列表
  - [x] 支持显式底层类型（如果未指定，默认为 `IR_TYPE_I32`）
  - [x] 支持显式值的枚举变体
  - [x] 枚举变体访问的 IR 生成（`EnumName.Variant` → 常量值）
  - [x] 枚举类型变量的 IR 生成
- [x] 代码生成器（`codegen/codegen_inst.c`、`codegen_main.c`）：
  - [x] 在 `codegen_generate_inst` 函数中处理 `IR_ENUM_DECL` 指令
  - [x] 生成 C 枚举定义（`typedef enum { ... } EnumName;`）
  - [x] 使用前缀命名（`EnumName_Variant`）避免命名冲突
  - [x] 支持显式值的枚举变体生成
  - [x] 在代码生成的第一遍扫描中生成枚举声明（在函数声明之前）
  - [x] 枚举类型变量的 C 代码生成（使用枚举名称）
  - [x] 枚举变体访问的 C 代码生成（`EnumName_Variant`）

**TDD 测试验证**：
- [x] 枚举声明语法验证：`enum Color { Red = 1, Green = 2, Blue = 3 }`
- [x] 生成的 C 代码可成功编译：`gcc -o test_enum test_enum_gen.c`
- [x] 可执行文件正常运行：`./test_enum` 返回正确退出码
- [x] 语法遵循 Uya 规范：`const color: Color = Color.Red;`

**参考**：
- 规范：`uya.md` 第 2 章（类型系统）
- 语法：`grammar_formal.md` 枚举声明部分

---

### 7. 元组类型 ⚠️

**状态**：⚠️ **部分实现**

**规范要求**：
- 元组类型：`(T1, T2, ...)`
- 元组字面量：`(expr1, expr2, ...)`
- 元组字段访问：`tuple.0`, `tuple.1`, ...
- 元组模式匹配：`(pattern1, pattern2, ...)`

**已完成事项**：
- [x] 语法分析器：
  - [x] 添加 `AST_TYPE_TUPLE` 节点类型（`ast.h`）
  - [x] 添加 `AST_TUPLE_LITERAL` 节点类型（`ast.h`）
  - [x] 实现元组类型解析（`parser_parse_type`）
  - [x] 实现元组字面量解析（`parser_parse_expression`）
  - [x] 实现元组字段访问解析（`.0`, `.1`, ...）- 语法解析已完成（使用 `AST_MEMBER_ACCESS` 节点，支持 `.NUM` 语法）
- [x] 类型系统：
  - [x] 添加元组类型支持（使用 `IR_TYPE_STRUCT` 作为占位符）
- [x] 类型检查器：
  - [x] 元组类型匹配
  - [x] 元组字段访问基础类型检查（识别数字索引的成员访问）
  - [x] 元组字面量的类型检查（递归检查所有元素表达式）
  - [ ] 元组字段索引范围检查 - 需要完整的类型系统支持
  - [ ] 元组类型声明的类型检查错误修复（存在"未定义的变量 'i32'"错误）
- [x] IR 生成器：
  - [x] 元组类型的 IR 表示
  - [x] 元组字面量的 IR 生成（已完善：生成完整的结构体初始化 `IR_STRUCT_INIT`，字段名为 "_0", "_1", "_2" 等）
  - [x] 元组字段访问的 IR 生成（使用 `IR_MEMBER_ACCESS` 指令）
- [x] 代码生成器：
  - [x] 元组类型的 C 代码生成（使用结构体表示）
  - [x] 元组字段访问的代码生成（生成 `._0`, `._1` 形式的字段访问）
- [x] 测试用例：
  - [x] 基本元组使用（`test_tuple_feature.uya` 和 `test_tuple_comprehensive.uya`）
  - [x] 元组字段访问（在表达式中使用，如 `pair.0 == 42`）
  - [ ] 元组模式匹配（match 表达式功能未完成）


**已知问题**：
- ⚠️ 类型检查错误：元组类型声明时出现"未定义的变量 'i32'"错误，需要修复类型检查器对元组类型的处理
- ⚠️ 结构体定义生成：当前使用临时名称 `tuple_N`（N 为元素数量），需要为每个不同的元组类型生成唯一的结构体定义

**参考**：
- 规范：`uya.md` 第 2 章（类型系统）
- 语法：`grammar_formal.md` 类型系统部分

---

### 8. match 表达式 ⚠️

**状态**：⚠️ **部分实现**

**规范要求**（`uya.md` 第 8 章）：
- match 表达式：`match expr '{' pattern_list '}'`
- 支持的模式：字面量、标识符、结构体模式、元组模式、枚举模式、错误模式
- `else` 分支必须放在最后

**已完成事项**：
- [x] 语法分析器：
  - [x] 添加 `AST_MATCH_EXPR` 节点类型（`ast.h`）
  - [x] 添加 `AST_PATTERN` 节点类型（`ast.h`）
  - [x] 添加 `TOKEN_MATCH` 关键字（`lexer.h` 和 `lexer.c`）
  - [x] 实现 match 表达式解析（`parser_parse_expression`）
  - [x] 实现 `parser_parse_match_expr` 函数
  - [ ] 实现各种模式的解析（字面量、标识符、结构体、元组、枚举、错误）- 基础实现
  - [x] 实现 `else` 分支处理
- [x] 类型检查器：
  - [x] 模式类型匹配检查
  - [ ] 模式完整性检查（穷尽性检查）- 未实现
- [x] IR 生成器：
  - [x] match 表达式的 IR 表示（使用条件分支链）
- [ ] 代码生成器：
  - [ ] match 表达式的 C 代码生成（if-else 链或 switch 语句）- 未实现
- [ ] 测试用例：
  - [ ] 各种模式类型的测试
  - [ ] 模式匹配完整性检查

**参考**：
- 规范：`uya.md` 第 8 章（控制流）
- 语法：`grammar_formal.md` match 表达式部分

---

## P3：可选功能或实现细节优化

### 8. 预定义错误声明（可选功能）

**状态**：❌ **未实现（可选）**

**规范要求**（`uya.md` 第 417-423 行）：
- 支持 `error ErrorName;` 在顶层声明预定义错误
- 预定义错误类型是编译期常量
- 预定义错误类型名称必须唯一（全局命名空间）

**当前状态**：
- ❌ 不支持预定义错误声明语法
- ✅ 支持运行时错误（`error.ErrorName` 直接使用）

**待办事项**：
- [ ] 语法分析器：
  - [ ] 添加 `AST_ERROR_DECL` 节点类型（`ast.h`）
  - [ ] 实现 `error ErrorName;` 语法解析（`parser.c`）
- [ ] 符号表：
  - [ ] 存储预定义错误类型
  - [ ] 验证预定义错误名称唯一性（全局命名空间）
- [ ] 代码生成：
  - [ ] 确保预定义错误和运行时错误使用相同的错误码生成机制

**优先级**：低（可选功能，运行时错误已足够）

**参考**：
- 详细任务：`compiler/TODO_error_handling.md` 第 1 节

---

### 10. 泛型系统 ❌

**状态**：❌ **未实现（未来特性）**

**规范要求**（`uya.md` 第 20 章，`grammar_formal.md` 可选特性）：
- 泛型语法：`struct Vec(T)`, `fn id(x: T) T`
- 类型参数列表：`type_param_list = ID { ',' ID }`

**影响**：大型功能，需要完整的类型系统重构

**待办事项**：
- [ ] 语法分析器：
  - [ ] 泛型结构体声明解析
  - [ ] 泛型函数声明解析
  - [ ] 类型参数解析
- [ ] 类型系统扩展：
  - [ ] 类型参数作用域管理
  - [ ] 类型参数约束（如果需要）
- [ ] 单态化（Monomorphization）：
  - [ ] 泛型实例化
  - [ ] 代码生成时的类型特化
- [ ] 类型检查器：
  - [ ] 泛型类型检查
  - [ ] 类型参数推断（如果支持）

**优先级**：低（未来特性，当前规范中标记为可选）

**参考**：
- 规范：`uya.md` 第 20 章（如果存在）
- 语法：`grammar_formal.md` 可选特性部分

---

### 11. 显式宏系统 ❌

**状态**：❌ **未实现（未来特性）**

**规范要求**（`grammar_formal.md` 可选特性）：
- 宏声明：`mc ID '(' [ param_list ] ')' return_tag '{' statements '}'`
- 返回标签：`return_tag = 'expr' | 'stmt' | 'struct' | 'type'`

**影响**：大型功能，需要完整的宏展开系统

**待办事项**：
- [ ] 语法分析器：
  - [ ] 宏声明解析
  - [ ] 宏调用识别
- [ ] 宏展开器（新建）：
  - [ ] 宏展开逻辑
  - [ ] 不同返回标签的处理
- [ ] 代码生成：
  - [ ] 宏展开后的代码生成

**优先级**：低（未来特性，当前规范中标记为可选）

**参考**：
- 语法：`grammar_formal.md` 可选特性部分

---

## 实现细节优化

### 11. 错误码类型一致性检查

**状态**：⚠️ **文档不一致**

**问题**：
- `error_design.md` 提到错误码为 `uint16_t`
- `implementation_status.md` 提到使用 `uint32_t`（根据 uya.md 规范）

**待办事项**：
- [ ] 确认错误码类型规范（检查 `uya.md`）
- [ ] 如果规范是 `uint32_t`，更新 `error_design.md`
- [ ] 如果规范是 `uint16_t`，更新代码生成以使用 `uint16_t`

**优先级**：低（实现细节，不影响功能）

---

### 13. 编译期常量表达式增强

**状态**：⚠️ **基本实现，需要改进**

**待办事项**：
- [ ] 改进类型匹配检查
- [ ] 扩展支持的常量表达式类型
- [ ] 优化常量折叠性能

**参考**：
- `compiler/src/checker/const_eval.c`

---

### 14. 变量遮蔽检查完善

**状态**：⚠️ **基本实现，需要完善**

**当前实现**：
- ✅ 同一作用域内不允许重复定义
- ✅ 不同作用域可以使用同名变量（遮蔽）
- ⚠️ 需要更完善的遮蔽规则验证

**待办事项**：
- [ ] 完善遮蔽规则验证
- [ ] 添加遮蔽相关的错误消息
- [ ] 测试用例完善

---

## 测试和文档

### 14. 测试覆盖完善

**待办事项**：
- [ ] 错误类型比较的测试用例
- [ ] 预定义错误的测试用例（如果实现）
- [ ] catch 块中错误类型判断的测试用例
- [x] 枚举类型的完整测试用例
- [x] 元组类型的完整测试用例
- [x] match 表达式的完整测试用例
- [ ] 跨函数调用的错误传播测试
- [ ] 错误码冲突检测测试

### 15. TDD 测试驱动开发

**目标**：确保生成的 C 文件能够通过 GCC 编译

**规范要求**：
- 所有生成的 C 代码必须能通过 GCC 编译
- 实现测试驱动开发流程
- 每个新功能都应有对应的测试用例

**待办事项**：
- [x] 为枚举类型生成测试用例，验证 C 代码可编译
- [x] 为元组类型生成测试用例，验证 C 代码可编译
- [x] 为 match 表达式生成测试用例，验证 C 代码可编译
- [x] 创建自动化测试脚本，验证生成的 C 代码能通过 GCC 编译
- [x] 为每个新功能编写单元测试
- [x] 建立回归测试套件
- [x] 添加集成测试，验证端到端编译流程

**测试策略**：
- 编写最小可行测试用例，验证每个新功能
- 使用 GCC 编译生成的 C 代码，确保无语法错误
- 验证生成的 C 代码符合预期行为
- 建立测试覆盖率追踪机制
- 遏循 Uya 语言规范语法：`const variable_name: Type = value;` 而非 `const variable: Type = value;`

**相关文件**：
- `compiler/tests/` - 测试用例目录
- `compiler/run_tests.sh` - 测试运行脚本
- `compiler/verify_tests.sh` - 测试验证脚本

---

### 16. 代码优化

**待办事项**：
- [ ] 优化错误码哈希函数的性能（如果必要）
- [ ] 优化错误类型推断的性能（如果必要）
- [ ] 优化常量表达式求值性能
- [ ] 添加错误处理的调试信息（如果必要）

---

## 实现状态总结

### ✅ 已完全实现（核心安全特性）

1. ✅ 类型检查器核心功能
2. ✅ 数组边界检查
3. ✅ 整数溢出检查
4. ✅ 除零检查
5. ✅ 未初始化内存检查
6. ✅ 空指针解引用检查
7. ✅ 路径敏感分析（约束系统）
8. ✅ 切片语法支持
9. ✅ For 循环语法
10. ✅ 错误处理基础（错误联合类型 `!T`、try/catch、errdefer）
11. ✅ defer 语句

### ⚠️ 部分实现/需要更新

12. ✅ 接口实现语法（规范已更新为新语法，编译器代码已更新）
13. ✅ 函数指针类型（0.25 版本新增，基础功能已实现，使用通用的 `void(*)()` 类型）
14. ✅ 错误类型比较（已实现，支持 `err == error.ErrorName`，禁止 `!=` 运算符）

### ✅ 已完全实现

15. ✅ 枚举类型（AST 节点定义、语法解析、IR 类型系统、代码生成和类型检查已完全实现）

### ⚠️ 部分实现

16. ⚠️ 元组类型（AST 节点定义、语法解析、IR 生成已完善、类型检查部分实现，存在类型检查错误需要修复，测试用例待编写）
17. ⚠️ match 表达式（AST 节点定义、语法解析已实现，但完整的模式匹配和代码生成未完成）

### ❌ 未实现的核心功能

18. ❌ 模块系统

### ❌ 未实现

19. ❌ 泛型（可选特性）
20. ❌ 显式宏系统（可选特性）
21. ❌ 预定义错误声明（可选功能）

---

## 推荐实现顺序

### 第一阶段：破坏性变更（P0）

1. **接口实现语法更新**（0.24 版本）✅
   - 影响现有代码，需要优先处理
   - 相对简单，主要是语法解析修改

2. **函数指针类型**（0.25 版本）✅
   - 新功能，不影响现有代码
   - 需要完整的类型系统支持

3. **数组类型语法更新**（破坏性变更）✅
   - 数组类型语法从 `[type; NUM]` 改为 `[type : NUM]`
   - 影响所有使用数组类型的代码，需要迁移
   - 相对简单，主要是语法解析修改和测试用例更新

### 第二阶段：核心功能（P1）

4. **模块系统**
   - 大型功能，可以分阶段实现
   - 建议先实现基础的单文件编译完善，再实现模块系统

### 第三阶段：功能完善（P2）

5. **错误类型比较** ✅（已完成）
6. **枚举类型** ✅（已完成）
7. **元组类型** ⚠️（部分完成：IR 生成已完善，类型检查部分实现，存在错误需要修复，测试用例待编写）
8. **match 表达式** ⚠️（部分完成，需完善模式匹配和代码生成）

### 第四阶段：可选功能（P3）

9. **预定义错误声明**（如果用户需要）
10. **泛型系统**（未来特性）
11. **显式宏系统**（未来特性）

---

## 相关文档

- **语言规范**：`uya.md`
- **语法规范**：`grammar_formal.md`
- **实现状态**：`compiler/implementation_status.md`
- **错误处理待办**：`compiler/TODO_error_handling.md`
- **符合性检查**：`compiler/compliance_issues.md`

---

**最后更新**：2026-01-09  
**维护者**：编译器开发团队

