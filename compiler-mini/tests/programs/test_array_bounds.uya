// 数组越界测试程序
// 测试数组边界访问和越界访问（运行时行为，未定义）
// 注意：数组越界是运行时行为，编译器不进行边界检查
// 本测试验证编译器允许这些访问，并测试各种边界情况

struct Point {
    x: i32,
    y: i32,
}

fn get_index() i32 {
    return 3;
}

fn process_element(val: i32) i32 {
    return val * 2;
}

fn main() i32 {
    // ========== 测试 1: 基本数组边界访问 ==========
    
    const arr1: [i32: 3] = [10, 20, 30];
    
    // 1.1 访问第一个元素（索引 0，合法）
    if arr1[0] != 10 {
        return 1;
    }
    
    // 1.2 访问最后一个元素（索引 len-1，合法）
    if arr1[2] != 30 {
        return 2;
    }
    
    // 1.3 访问中间元素（合法）
    if arr1[1] != 20 {
        return 3;
    }
    
    // ========== 测试 2: 数组越界访问（运行时未定义行为） ==========
    // 注意：这些访问在编译时不会报错，但运行时行为未定义
    
    // 2.1 访问超出数组大小的索引（越界）
    // arr1[3]  // 数组大小为 3，索引 3 越界（未定义行为）
    // 注意：我们不在测试中实际执行越界访问，因为会导致未定义行为
    // 但我们可以测试编译器允许这种语法
    
    // 2.2 使用变量索引访问（可能越界）
    var index: i32 = 0;
    if arr1[index] != 10 {
        return 4;
    }
    
    index = 2;
    if arr1[index] != 30 {
        return 5;
    }
    
    // index = 3;  // 如果设置为 3，访问 arr1[index] 会越界（未定义行为）
    // 我们不在测试中执行，但编译器应该允许这种语法
    
    // ========== 测试 3: 在循环中的数组访问 ==========
    
    const arr2: [i32: 5] = [1, 2, 3, 4, 5];
    var sum: i32 = 0;
    var i: i32 = 0;
    
    // 3.1 合法范围内的循环访问
    while i < @len(arr2) {
        sum = sum + arr2[i];
        i = i + 1;
    }
    
    if sum != 15 {  // 1+2+3+4+5 = 15
        return 6;
    }
    
    // 3.2 使用 for 循环访问
    var sum2: i32 = 0;
    for arr2 |item| {
        sum2 = sum2 + item;
    }
    
    if sum2 != 15 {
        return 7;
    }
    
    // ========== 测试 4: 多维数组边界访问 ==========
    
    const arr3: [[i32: 2]: 3] = [
        [1, 2],
        [3, 4],
        [5, 6],
    ];
    
    // 4.1 访问第一维的第一个元素（合法）
    if arr3[0][0] != 1 {
        return 8;
    }
    
    // 4.2 访问第一维的最后一个元素（合法）
    if arr3[2][1] != 6 {
        return 9;
    }
    
    // 4.3 访问中间元素（合法）
    if arr3[1][0] != 3 {
        return 10;
    }
    
    // ========== 测试 5: 使用表达式作为索引 ==========
    
    const arr4: [i32: 4] = [100, 200, 300, 400];
    
    // 5.1 使用常量表达式
    if arr4[1 + 1] != 300 {  // arr4[2]
        return 11;
    }
    
    // 5.2 使用变量表达式
    var idx1: i32 = 1;
    var idx2: i32 = 1;
    if arr4[idx1 + idx2] != 300 {  // arr4[2]
        return 12;
    }
    
    // 5.3 使用函数返回值作为索引
    if arr4[get_index()] != 400 {
        return 13;
    }
    
    // ========== 测试 6: 数组赋值中的边界访问 ==========
    
    var arr5: [i32: 3] = [1, 2, 3];
    
    // 6.1 合法索引赋值
    arr5[0] = 10;
    if arr5[0] != 10 {
        return 14;
    }
    
    arr5[2] = 30;
    if arr5[2] != 30 {
        return 15;
    }
    
    // ========== 测试 7: 指针数组访问 ==========
    
    var arr6: [i32: 3] = [1, 2, 3];
    const arr6_ptr: &[i32: 3] = &arr6;
    
    // 7.1 通过指针访问数组（合法）
    if arr6_ptr[0] != 1 {
        return 16;
    }
    
    if arr6_ptr[2] != 3 {
        return 17;
    }
    
    // 7.2 通过指针修改数组元素
    arr6_ptr[1] = 20;
    if arr6[1] != 20 {
        return 18;
    }
    
    // ========== 测试 8: 结构体数组边界访问 ==========
    
    const arr7: [Point: 3] = [
        Point{ x: 1, y: 2 },
        Point{ x: 3, y: 4 },
        Point{ x: 5, y: 6 },
    ];
    
    // 8.1 访问结构体数组的第一个元素（合法）
    if arr7[0].x != 1 || arr7[0].y != 2 {
        return 19;
    }
    
    // 8.2 访问结构体数组的最后一个元素（合法）
    if arr7[2].x != 5 || arr7[2].y != 6 {
        return 20;
    }
    
    // 8.3 修改结构体数组元素
    var arr8: [Point: 2] = [
        Point{ x: 10, y: 20 },
        Point{ x: 30, y: 40 },
    ];
    
    arr8[0].x = 100;
    if arr8[0].x != 100 {
        return 21;
    }
    
    // ========== 测试 9: 边界值测试 ==========
    
    // 9.1 单元素数组
    const arr9: [i32: 1] = [42];
    if arr9[0] != 42 {
        return 22;
    }
    
    // 9.2 大数组的边界访问
    const arr10: [i32: 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    
    if arr10[0] != 0 {
        return 23;
    }
    
    if arr10[9] != 9 {
        return 24;
    }
    
    // ========== 测试 10: 在条件语句中的数组访问 ==========
    
    const arr11: [i32: 3] = [1, 2, 3];
    
    if arr11[0] == 1 && arr11[1] == 2 && arr11[2] == 3 {
        // 合法访问
    } else {
        return 25;
    }
    
    // ========== 测试 11: 数组访问作为函数参数 ==========
    
    const arr12: [i32: 3] = [10, 20, 30];
    const result: i32 = process_element(arr12[1]);
    if result != 40 {  // 20 * 2 = 40
        return 26;
    }
    
    // ========== 测试 12: 嵌套数组访问 ==========
    
    const arr13: [[i32: 2]: 2] = [
        [1, 2],
        [3, 4],
    ];
    
    // 12.1 嵌套访问
    if arr13[0][1] != 2 {
        return 27;
    }
    
    if arr13[1][0] != 3 {
        return 28;
    }
    
    // 12.2 嵌套访问赋值
    var arr14: [[i32: 2]: 2] = [
        [10, 20],
        [30, 40],
    ];
    
    arr14[0][1] = 200;
    if arr14[0][1] != 200 {
        return 29;
    }
    
    // ========== 测试 13: 使用 @len() 函数进行边界检查 ==========
    // 注意：虽然编译器不进行边界检查，但程序可以使用 @len() 进行运行时检查
    
    const arr15: [i32: 5] = [1, 2, 3, 4, 5];
    var safe_index: i32 = 3;
    
    // 使用 @len() 进行运行时边界检查
    if safe_index >= 0 && safe_index < @len(arr15) {
        if arr15[safe_index] != 4 {
            return 30;
        }
    } else {
        return 31;  // 索引越界（但这里不会发生，因为 safe_index = 3 < 5）
    }
    
    // ========== 测试 14: 数组访问在复杂表达式中的使用 ==========
    
    const arr16: [i32: 4] = [1, 2, 3, 4];
    
    // 14.1 数组访问作为算术表达式的一部分
    const sum3: i32 = arr16[0] + arr16[1] + arr16[2] + arr16[3];
    if sum3 != 10 {
        return 32;
    }
    
    // 14.2 数组访问作为比较表达式的一部分
    if arr16[0] < arr16[1] && arr16[1] < arr16[2] && arr16[2] < arr16[3] {
        // 合法访问和比较
    } else {
        return 33;
    }
    
    // ========== 测试 15: 空数组边界情况 ==========
    
    var arr17: [i32: 0] = [];
    // 注意：空数组无法访问任何元素，任何索引访问都会越界
    // 但我们不在这里实际访问，因为会导致未定义行为
    // 编译器应该允许空数组的声明
    
    // 所有测试通过
    return 0;
}

