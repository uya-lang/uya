// 一元运算符完整测试程序
// 测试所有一元运算符：!（逻辑非）、-（负号）、&（取地址）、*（解引用）

struct Point {
    x: i32,
    y: i32,
}

fn main() i32 {
    // ========== 测试1：逻辑非运算符 ! ==========
    
    // 1.1 !true
    var bool_val1: bool = true;
    var result1: bool = !bool_val1;
    if result1 != false {
        return 1;  // !true 应该是 false
    }
    
    // 1.2 !false
    var bool_val2: bool = false;
    var result2: bool = !bool_val2;
    if result2 != true {
        return 2;  // !false 应该是 true
    }
    
    // 1.3 双重否定
    var bool_val3: bool = true;
    var result3: bool = !!bool_val3;
    if result3 != true {
        return 3;  // !!true 应该是 true
    }
    
    // 1.4 逻辑非在条件表达式中使用
    if !true {
        return 4;  // !true 应该是 false，不应该进入 if
    }
    if !false {
        // 应该进入这里
    } else {
        return 5;  // !false 应该是 true，应该进入 if
    }
    
    // ========== 测试2：负号运算符 - ==========
    
    // 2.1 正数取负
    var i32_val1: i32 = 42;
    var result4: i32 = -i32_val1;
    if result4 != -42 {
        return 6;  // -42 应该是 -42
    }
    
    // 2.2 负数取负
    var i32_val2: i32 = -10;
    var result5: i32 = -i32_val2;
    if result5 != 10 {
        return 7;  // -(-10) 应该是 10
    }
    
    // 2.3 零取负
    var i32_val3: i32 = 0;
    var result6: i32 = -i32_val3;
    if result6 != 0 {
        return 8;  // -0 应该是 0
    }
    
    // 2.4 负号在表达式中使用
    var i32_val4: i32 = 5;
    var result7: i32 = -i32_val4 + 10;
    if result7 != 5 {
        return 9;  // -5 + 10 应该是 5
    }
    
    // 2.5 双重负号
    var i32_val5: i32 = 20;
    var result8: i32 = --i32_val5;
    if result8 != 20 {
        return 10;  // --20 应该是 20（不是递减运算符）
    }
    
    // ========== 测试3：取地址运算符 & ==========
    
    // 3.1 取 i32 变量地址
    var x: i32 = 42;
    var ptr1: &i32 = &x;
    if ptr1 == null {
        return 11;  // ptr1 不应该是 null
    }
    
    // 3.2 通过指针修改值
    *ptr1 = 100;
    if x != 100 {
        return 12;  // 通过指针修改后，x 应该是 100
    }
    
    // 3.3 取结构体变量地址
    var p: Point = Point{ x: 10, y: 20 };
    var ptr2: &Point = &p;
    if ptr2 == null {
        return 13;  // ptr2 不应该是 null
    }
    
    // 3.4 通过结构体指针访问字段
    ptr2.x = 30;
    if p.x != 30 {
        return 14;  // 通过指针修改字段后，p.x 应该是 30
    }
    
    // 3.5 取数组元素地址
    var arr: [i32: 3] = [1, 2, 3];
    var ptr3: &i32 = &arr[0];
    if ptr3 == null {
        return 15;  // ptr3 不应该是 null
    }
    if *ptr3 != 1 {
        return 16;  // *ptr3 应该是 1
    }
    
    // ========== 测试4：解引用运算符 * ==========
    
    // 4.1 解引用 i32 指针
    var y: i32 = 50;
    var ptr4: &i32 = &y;
    var value1: i32 = *ptr4;
    if value1 != 50 {
        return 17;  // *ptr4 应该是 50
    }
    
    // 4.2 通过解引用修改值
    *ptr4 = 60;
    if y != 60 {
        return 18;  // 通过解引用修改后，y 应该是 60
    }
    
    // 4.3 解引用结构体指针
    var q: Point = Point{ x: 100, y: 200 };
    var ptr5: &Point = &q;
    var point_value: Point = *ptr5;
    if point_value.x != 100 || point_value.y != 200 {
        return 19;  // 解引用结构体指针应该得到正确的结构体值
    }
    
    // 4.4 解引用数组元素指针
    var arr2: [i32: 3] = [10, 20, 30];
    var ptr6: &i32 = &arr2[1];
    var value2: i32 = *ptr6;
    if value2 != 20 {
        return 20;  // *ptr6 应该是 20
    }
    
    // 4.5 通过解引用修改数组元素
    *ptr6 = 25;
    if arr2[1] != 25 {
        return 21;  // 通过解引用修改后，arr2[1] 应该是 25
    }
    
    // ========== 测试5：一元运算符优先级 ==========
    
    // 5.1 一元运算符优先级高于二元运算符
    var i32_val6: i32 = 5;
    var result9: i32 = -i32_val6 * 2;
    if result9 != -10 {
        return 22;  // -5 * 2 应该是 -10（不是 -(5*2)）
    }
    
    // 5.2 一元运算符结合性（右结合）
    var i32_val7: i32 = 10;
    var result10: i32 = --i32_val7;
    if result10 != 10 {
        return 23;  // --10 应该是 10（两个负号，不是递减）
    }
    
    // 5.3 逻辑非与算术运算
    var bool_val4: bool = false;
    var result11: bool = !bool_val4 && true;
    if result11 != true {
        return 24;  // !false && true 应该是 true
    }
    
    // ========== 测试6：组合使用 ==========
    
    // 6.1 取地址和解引用组合
    var z: i32 = 70;
    var ptr7: &i32 = &z;
    var value3: i32 = *&z;
    if value3 != 70 {
        return 25;  // *&z 应该是 70
    }
    
    // 6.2 负号和逻辑非组合
    var i32_val8: i32 = 1;
    var bool_val5: bool = (-i32_val8 as bool);
    if bool_val5 != true {
        return 26;  // -1 转换为 bool 应该是 true
    }
    
    // 所有测试通过
    return 0;
}

