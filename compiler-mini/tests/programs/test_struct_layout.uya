// 结构体内存布局验证测试
// 根据 UYA_MINI_SPEC.md 2.3 节的结构体内存布局详细规则进行验证

// 测试 1: 基本对齐（无填充）
struct Example1 {
    a: i32,   // 偏移 0，大小 4
    b: i32,   // 偏移 4，大小 4
    c: i32,   // 偏移 8，大小 4
}
// 预期：大小 = 12 字节，对齐 = 4 字节

// 测试 2: 需要填充的结构体
struct Example2 {
    a: byte,  // 偏移 0，大小 1
    b: i32,   // 偏移 4（跳过 1-3 填充），大小 4
    c: byte,  // 偏移 8，大小 1
}
// 预期：大小 = 12 字节（最后填充 3 字节），对齐 = 4 字节

// 测试 3: 嵌套结构体
struct Inner {
    x: i32,  // 偏移 0，大小 4
    y: i32,  // 偏移 4，大小 4
}
// Inner 大小 = 8 字节，对齐 = 4 字节

struct Outer {
    a: byte,        // 偏移 0，大小 1
    inner: Inner,   // 偏移 4（跳过 1-3 填充，对齐到 4），大小 8
    b: byte,        // 偏移 12，大小 1
}
// 预期：大小 = 16 字节（最后填充 3 字节），对齐 = 4 字节

// 测试 4: 数组字段
struct Example4 {
    a: byte,           // 偏移 0，大小 1
    arr: [i32: 3],     // 偏移 4（跳过 1-3 填充，对齐到 4），大小 12
    b: i32,            // 偏移 16，大小 4
}
// 预期：大小 = 20 字节，对齐 = 4 字节

// 测试 5: 结构体大小计算
struct Example5 {
    a: byte,   // 偏移 0，大小 1，对齐 = 1
    b: i32,    // 偏移 4，大小 4，对齐 = 4
    c: i32,    // 偏移 8，大小 4，对齐 = 4
}
// 预期：最后一个字段 c 的偏移 + 大小 = 8 + 4 = 12
// 结构体对齐值 = max(1, 4) = 4
// 最终大小 = 12（已对齐到 4）

// 测试 6: 平台差异（指针和 usize）
struct PlatformStruct {
    ptr: &i32,
    size: usize,
}
// 32位平台：ptr(4B, offset=0) + size(4B, offset=4) = 8字节，对齐=4
// 64位平台：ptr(8B, offset=0) + size(8B, offset=8) = 16字节，对齐=8

// 测试 7: 空结构体
struct Empty {
    // 空结构体
}
// 预期：大小 = 1 字节，对齐 = 1 字节

fn main() i32 {
    // 验证测试 1: 基本对齐
    const size1: i32 = sizeof(Example1);
    const align1: i32 = alignof(Example1);
    if size1 != 12 || align1 != 4 {
        return 1;  // Example1 应该大小为 12 字节，对齐 4 字节
    }
    
    // 验证测试 2: 需要填充的结构体
    const size2: i32 = sizeof(Example2);
    const align2: i32 = alignof(Example2);
    if size2 != 12 || align2 != 4 {
        return 2;  // Example2 应该大小为 12 字节，对齐 4 字节
    }
    
    // 验证测试 3: 嵌套结构体
    const inner_size: i32 = sizeof(Inner);
    const inner_align: i32 = alignof(Inner);
    if inner_size != 8 || inner_align != 4 {
        return 3;  // Inner 应该大小为 8 字节，对齐 4 字节
    }
    
    const outer_size: i32 = sizeof(Outer);
    const outer_align: i32 = alignof(Outer);
    if outer_size != 16 || outer_align != 4 {
        return 4;  // Outer 应该大小为 16 字节，对齐 4 字节
    }
    
    // 验证测试 4: 数组字段
    const size4: i32 = sizeof(Example4);
    const align4: i32 = alignof(Example4);
    if size4 != 20 || align4 != 4 {
        return 5;  // Example4 应该大小为 20 字节，对齐 4 字节
    }
    
    // 验证测试 5: 结构体大小计算
    const size5: i32 = sizeof(Example5);
    const align5: i32 = alignof(Example5);
    if size5 != 12 || align5 != 4 {
        return 6;  // Example5 应该大小为 12 字节，对齐 4 字节
    }
    
    // 验证测试 6: 平台差异（指针和 usize）
    const platform_size: i32 = sizeof(PlatformStruct);
    const platform_align: i32 = alignof(PlatformStruct);
    const ptr_size: i32 = sizeof(&i32);
    const usize_size: i32 = sizeof(usize);
    
    // 指针大小应该是 4（32位）或 8（64位）
    if ptr_size != 4 && ptr_size != 8 {
        return 7;  // 指针大小应该是 4 或 8 字节
    }
    
    // usize 大小应该等于指针大小
    if usize_size != ptr_size {
        return 8;  // usize 大小应该等于指针大小
    }
    
    // PlatformStruct 大小应该是 2 * ptr_size
    if platform_size != ptr_size * 2 {
        return 9;  // PlatformStruct 大小应该是 2 * 指针大小
    }
    
    // PlatformStruct 对齐应该等于指针大小
    if platform_align != ptr_size {
        return 10;  // PlatformStruct 对齐应该等于指针大小
    }
    
    // 验证测试 7: 空结构体
    const empty_size: i32 = sizeof(Empty);
    const empty_align: i32 = alignof(Empty);
    if empty_size != 1 || empty_align != 1 {
        return 11;  // Empty 应该大小为 1 字节，对齐 1 字节
    }
    
    // 验证字段访问（确保布局正确）
    var e1: Example1 = Example1{ a: 1, b: 2, c: 3 };
    if e1.a != 1 || e1.b != 2 || e1.c != 3 {
        return 12;  // Example1 字段访问应该正确
    }
    
    var e2: Example2 = Example2{ a: 1, b: 2, c: 3 };
    if e2.a != 1 || e2.b != 2 || e2.c != 3 {
        return 13;  // Example2 字段访问应该正确（考虑填充）
    }
    
    var e4: Example4 = Example4{ a: 1, arr: [10, 20, 30], b: 4 };
    if e4.a != 1 || e4.arr[0] != 10 || e4.arr[1] != 20 || e4.arr[2] != 30 || e4.b != 4 {
        return 14;  // Example4 字段访问应该正确（包括数组字段）
    }
    
    var outer: Outer = Outer{ a: 1, inner: Inner{ x: 10, y: 20 }, b: 2 };
    if outer.a != 1 || outer.inner.x != 10 || outer.inner.y != 20 || outer.b != 2 {
        return 15;  // Outer 嵌套结构体字段访问应该正确
    }
    
    // 所有测试通过
    return 0;
}

