// 混合类型算术运算测试程序
// 测试 i32 和 usize 混合运算（根据规范，结果类型为较大的类型）

fn add_usize(a: usize, b: usize) usize {
    return a + b;
}

fn main() i32 {
    // ========== 测试1：i32 + usize ==========
    
    var i32_val: i32 = 10;
    var usize_val: usize = 20 as usize;
    
    // i32 + usize → usize（至少有一个是 usize，结果为 usize）
    var result1: usize = (i32_val as usize) + usize_val;
    if result1 != 30 as usize {
        return 1;  // 10 + 20 = 30
    }
    
    // ========== 测试2：usize + i32 ==========
    
    var result2: usize = usize_val + (i32_val as usize);
    if result2 != 30 as usize {
        return 2;  // 20 + 10 = 30
    }
    
    // ========== 测试3：i32 - usize ==========
    
    var result3: usize = (i32_val as usize) - (5 as usize);
    if result3 != 5 as usize {
        return 3;  // 10 - 5 = 5
    }
    
    // ========== 测试4：usize - i32 ==========
    
    var result4: usize = usize_val - (i32_val as usize);
    if result4 != 10 as usize {
        return 4;  // 20 - 10 = 10
    }
    
    // ========== 测试5：i32 * usize ==========
    
    var result5: usize = (i32_val as usize) * usize_val;
    if result5 != 200 as usize {
        return 5;  // 10 * 20 = 200
    }
    
    // ========== 测试6：usize * i32 ==========
    
    var result6: usize = usize_val * (i32_val as usize);
    if result6 != 200 as usize {
        return 6;  // 20 * 10 = 200
    }
    
    // ========== 测试7：i32 / usize ==========
    
    var i32_val2: i32 = 20;
    var usize_val2: usize = 4 as usize;
    var result7: usize = (i32_val2 as usize) / usize_val2;
    if result7 != 5 as usize {
        return 7;  // 20 / 4 = 5
    }
    
    // ========== 测试8：usize / i32 ==========
    
    var result8: usize = usize_val2 / (i32_val2 as usize);
    if result8 != 0 as usize {
        return 8;  // 4 / 20 = 0（整数除法）
    }
    
    // ========== 测试9：i32 % usize ==========
    
    var i32_val3: i32 = 17;
    var usize_val3: usize = 5 as usize;
    var result9: usize = (i32_val3 as usize) % usize_val3;
    if result9 != 2 as usize {
        return 9;  // 17 % 5 = 2
    }
    
    // ========== 测试10：usize % i32 ==========
    
    var result10: usize = usize_val3 % (i32_val3 as usize);
    if result10 != 5 as usize {
        return 10;  // 5 % 17 = 5
    }
    
    // ========== 测试11：复杂混合运算 ==========
    
    var i32_val4: i32 = 5;
    var usize_val4: usize = 3 as usize;
    var result11: usize = ((i32_val4 as usize) + usize_val4) * (2 as usize);
    if result11 != 16 as usize {
        return 11;  // (5 + 3) * 2 = 16
    }
    
    // ========== 测试12：混合运算在函数调用中 ==========
    
    var i32_val5: i32 = 10;
    var usize_val5: usize = 20 as usize;
    var result12: usize = add_usize(i32_val5 as usize, usize_val5);
    if result12 != 30 as usize {
        return 12;  // add_usize(10, 20) = 30
    }
    
    // ========== 测试13：混合运算在条件表达式中 ==========
    
    var i32_val6: i32 = 10;
    var usize_val6: usize = 20 as usize;
    if (i32_val6 as usize) < usize_val6 {
        // 应该进入这里
    } else {
        return 13;  // 10 < 20 应该是 true
    }
    
    // ========== 测试14：两个 i32 运算（结果仍为 i32） ==========
    
    var i32_val7: i32 = 10;
    var i32_val8: i32 = 20;
    var result13: i32 = i32_val7 + i32_val8;
    if result13 != 30 {
        return 14;  // 10 + 20 = 30（i32 类型）
    }
    
    // ========== 测试15：两个 usize 运算（结果仍为 usize） ==========
    
    var usize_val7: usize = 15 as usize;
    var usize_val8: usize = 5 as usize;
    var result14: usize = usize_val7 + usize_val8;
    if result14 != 20 as usize {
        return 15;  // 15 + 5 = 20（usize 类型）
    }
    
    // ========== 测试16：sizeof 和混合运算 ==========
    
    var ptr_size: i32 = @size_of(&i32);
    var usize_size: i32 = @size_of(usize);
    // 验证 usize 大小等于指针大小（规范要求）
    if usize_size != ptr_size {
        return 16;  // usize 大小应该等于指针大小
    }
    
    // 所有测试通过
    return 0;
}

