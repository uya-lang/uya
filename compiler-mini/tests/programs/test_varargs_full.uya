// 可变参数与 @params 全面测试
// 覆盖：extern/fn 形参 ...、printf(fmt, ...) 转发、@params 元组、@params.0/.1、const p = @params
// 说明：单元素元组 (i32) 当前解析为括号类型，故单参函数用 return n 而非 @params

extern fn printf(fmt: *byte, ...) i32;

// 1. 可变参数转发（零开销）
fn wrap_printf(fmt: *byte, ...) i32 {
    return printf(fmt, ...);
}

// 2. @params 存到元组变量后访问 .0 .1
fn add_two(a: i32, b: i32) i32 {
    const p: (i32, i32) = @params;
    return p.0 + p.1;
}

// 3. 直接使用 @params.0、@params.1
fn mul_two(x: i32, y: i32) i32 {
    return @params.0 * @params.1;
}

// 4. 单参数（不用 @params，因 (i32) 解析为括号类型非单元素元组）
fn identity_one(n: i32) i32 {
    return n;
}

// 5. 三参数 @params
fn sum_three(a: i32, b: i32, c: i32) i32 {
    const t: (i32, i32, i32) = @params;
    return t.0 + t.1 + t.2;
}

// 7. 直接调用 extern 可变参数（无 ... 转发）
fn test_direct() i32 {
    printf("direct: %d %d\n", 1, 2);
    return 0;
}

fn main() i32 {
    const r1: i32 = add_two(10, 20);
    wrap_printf("add_two(10,20)=%d\n", r1);
    if r1 != 30 {
        return 1;
    }

    const r2: i32 = mul_two(5, 6);
    wrap_printf("mul_two(5,6)=%d\n", r2);
    if r2 != 30 {
        return 2;
    }

    const r3: i32 = identity_one(42);
    if r3 != 42 {
        return 3;
    }

    const r4: i32 = sum_three(1, 2, 3);
    wrap_printf("sum_three(1,2,3)=%d\n", r4);
    if r4 != 6 {
        return 4;
    }

    test_direct();

    wrap_printf("all varargs tests ok\n");
    return 0;
}
