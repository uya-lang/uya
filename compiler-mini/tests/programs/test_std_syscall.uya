// test_std_syscall.uya
// 测试 syscall 包装函数（不使用模块系统，直接定义）

// 系统调用号
const SYS_write: i64 = 1;
const SYS_open: i64 = 2;
const SYS_close: i64 = 3;
const SYS_getpid: i64 = 39;

// 文件访问模式
const O_RDONLY: i64 = 0;
const O_WRONLY: i64 = 1;
const O_RDWR: i64 = 2;
const O_CREAT: i64 = 64;
const O_TRUNC: i64 = 512;

// 文件权限
const S_IRWXU: i64 = 448; // 0o700

// 标准文件描述符
const STDOUT_FILENO: i64 = 1;

// sys_write: 向文件描述符写入数据
fn sys_write(fd: i64, buf: i64, count: i64) !i64 {
    const result: !i64 = @syscall(SYS_write, fd, buf, count);
    return result;
}

// sys_open: 打开文件
fn sys_open(path: i64, flags: i64, mode: i64) !i64 {
    const result: !i64 = @syscall(SYS_open, path, flags, mode);
    return result;
}

// sys_close: 关闭文件描述符
fn sys_close(fd: i64) !i64 {
    const result: !i64 = @syscall(SYS_close, fd);
    return result;
}

// sys_getpid: 获取当前进程ID
fn sys_getpid() !i64 {
    const result: !i64 = @syscall(SYS_getpid);
    return result;
}

fn main() i32 {
    const msg1: *byte = "Hello from syscall wrappers!\n";
    const len1: i64 = 30;
    _ = sys_write(STDOUT_FILENO, msg1 as i64, len1) catch {
        return 1;
    };

    const path: *byte = "/tmp/test_file.txt";
    const fd_result: !i64 = sys_open(path as i64, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);
    const fd: i64 = fd_result catch {
        return 2;
    };

    const msg2: *byte = "Writing via syscall!\n";
    const len2: i64 = 21;
    _ = sys_write(fd, msg2 as i64, len2) catch {
        _ = sys_close(fd);
        return 3;
    };

    _ = sys_close(fd) catch {
        return 4;
    };

    const pid_result: !i64 = sys_getpid();
    _ = pid_result catch {
        return 5;
    };

    return 0;
}

