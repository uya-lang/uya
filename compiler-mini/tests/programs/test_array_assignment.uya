// 数组赋值测试程序
// 测试数组的按值复制赋值

struct Point {
    x: i32,
    y: i32,
}

fn process_array(arr: [i32: 3]) i32 {
    var sum: i32 = 0;
    var i: i32 = 0;
    while i < len(arr) {
        sum = sum + arr[i];
        i = i + 1;
    }
    // 修改数组元素（不影响原数组）
    arr[0] = 999;
    return sum;
}

fn create_array() [i32: 3] {
    return [100, 200, 300];
}

fn main() i32 {
    // ========== 测试1：基本数组赋值（按值复制） ==========
    
    // 1.1 i32 数组赋值
    var arr1: [i32: 3] = [1, 2, 3];
    var arr2: [i32: 3] = arr1;  // 按值复制
    if arr2[0] != 1 || arr2[1] != 2 || arr2[2] != 3 {
        return 1;  // arr2 应该复制了 arr1 的值
    }
    
    // 1.2 修改原数组不影响复制的数组
    arr1[0] = 100;
    if arr2[0] != 1 {
        return 2;  // arr2 不应该被影响（按值复制）
    }
    
    // 1.3 修改复制的数组不影响原数组
    arr2[1] = 200;
    if arr1[1] != 2 {
        return 3;  // arr1 不应该被影响
    }
    
    // ========== 测试2：byte 数组赋值 ==========
    
    var arr3: [byte: 4] = [10, 20, 30, 40];
    var arr4: [byte: 4] = arr3;
    if arr4[0] != 10 || arr4[1] != 20 || arr4[2] != 30 || arr4[3] != 40 {
        return 4;  // arr4 应该复制了 arr3 的值
    }
    
    arr3[0] = 100;
    if arr4[0] != 10 {
        return 5;  // arr4 不应该被影响
    }
    
    // ========== 测试3：结构体数组赋值 ==========
    
    var arr5: [Point: 2] = [
        Point{ x: 1, y: 2 },
        Point{ x: 3, y: 4 },
    ];
    var arr6: [Point: 2] = arr5;  // 按值复制（复制所有结构体）
    
    if arr6[0].x != 1 || arr6[0].y != 2 || arr6[1].x != 3 || arr6[1].y != 4 {
        return 6;  // arr6 应该复制了 arr5 的值
    }
    
    // 修改原数组不影响复制的数组
    arr5[0].x = 100;
    if arr6[0].x != 1 {
        return 7;  // arr6 不应该被影响
    }
    
    // 修改复制的数组不影响原数组
    arr6[1].y = 200;
    if arr5[1].y != 4 {
        return 8;  // arr5 不应该被影响
    }
    
    // ========== 测试4：数组字面量赋值 ==========
    
    var arr7: [i32: 3] = [10, 20, 30];
    var arr8: [i32: 3] = arr7;
    if arr8[0] != 10 || arr8[1] != 20 || arr8[2] != 30 {
        return 9;  // arr8 应该复制了 arr7 的值
    }
    
    // ========== 测试5：空数组字面量赋值 ==========
    
    var arr9: [i32: 5] = [];
    var arr10: [i32: 5] = arr9;
    // 注意：空数组字面量表示未初始化，内容未定义
    // 这里只测试赋值语法本身
    
    // ========== 测试6：数组作为函数参数（按值传递） ==========
    
    var arr11: [i32: 3] = [1, 2, 3];
    var sum: i32 = process_array(arr11);
    if sum != 6 {
        return 10;  // sum 应该是 6
    }
    if arr11[0] != 1 {
        return 11;  // arr11 不应该被函数修改（按值传递）
    }
    
    // ========== 测试7：数组作为函数返回值 ==========
    
    var arr12: [i32: 3] = create_array();
    if arr12[0] != 100 || arr12[1] != 200 || arr12[2] != 300 {
        return 12;  // arr12 应该包含返回值
    }
    
    // ========== 测试8：多维数组赋值 ==========
    
    var arr13: [[i32: 2]: 2] = [
        [1, 2],
        [3, 4],
    ];
    var arr14: [[i32: 2]: 2] = arr13;  // 按值复制
    
    if arr14[0][0] != 1 || arr14[0][1] != 2 || arr14[1][0] != 3 || arr14[1][1] != 4 {
        return 13;  // arr14 应该复制了 arr13 的值
    }
    
    arr13[0][0] = 999;
    if arr14[0][0] != 1 {
        return 14;  // arr14 不应该被影响
    }
    
    // 所有测试通过
    return 0;
}

