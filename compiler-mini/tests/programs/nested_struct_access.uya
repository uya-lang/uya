// 嵌套结构体访问测试
// 测试深层嵌套的结构体字段访问

struct Point {
    x: i32,
    y: i32,
}

struct Rect {
    top_left: Point,
    bottom_right: Point,
}

struct Box {
    rect: Rect,
    depth: i32,
}

fn get_point_x(p: Point) i32 {
    return p.x;
}

fn get_rect_width(r: Rect) i32 {
    return r.bottom_right.x - r.top_left.x;
}

fn main() i32 {
    const p1: Point = Point{ x: 10, y: 20 };
    const p2: Point = Point{ x: 50, y: 60 };
    const rect: Rect = Rect{ top_left: p1, bottom_right: p2 };
    const box: Box = Box{ rect: rect, depth: 30 };
    
    // 测试嵌套字段访问（rect 已移入 box，只用 box.rect）
    if box.rect.top_left.x != 10 {
        return 1;
    }
    if box.rect.bottom_right.y != 60 {
        return 2;
    }
    const width: i32 = box.rect.bottom_right.x - box.rect.top_left.x;
    if width != 40 {
        return 3;
    }
    
    // 测试结构体整体赋值后嵌套字段访问（先移动 box 再使用 new_box.rect）
    var new_box: Box = box;
    if new_box.rect.top_left.x != 10 || new_box.rect.bottom_right.y != 60 {
        return 6;
    }
    
    // 测试函数调用嵌套结构体参数（传参移动）
    const rect_width: i32 = get_rect_width(new_box.rect);
    if rect_width != 40 {
        return 5;
    }
    
    // 测试函数调用中的嵌套访问（用新 Point，避免移动后使用）
    const px: Point = Point{ x: 10, y: 20 };
    const x: i32 = get_point_x(px);
    if x != 10 {
        return 4;
    }
    
    return 0;
}

