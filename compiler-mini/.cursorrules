# Uya Mini 编译器开发规则

本文档包含 Uya Mini 编译器的开发规则和重要参考文档。

## 当前状态

项目 v0.1.0 已达成自举。详见项目根目录 `RELEASE_v0.1.0.md`。

## 代码质量约束（严格执行）

- 所有代码必须使用**中文注释**
- 函数和数据结构必须添加中文注释说明
- 复杂逻辑必须添加中文注释解释
- **每个函数不超过 200 行**（严格限制）
- **每个源文件不超过 1500 行**（严格限制）
- 超过限制必须拆分：提取辅助函数或创建新文件

## TDD 开发流程（强制要求）

**所有功能实现必须遵循 TDD（测试驱动开发）流程**：

1. **Red（红）**：先编写测试用例
   - 创建测试文件（或添加测试用例）
   - 测试应该描述期望的行为
   - 运行测试确保失败（因为功能未实现）

2. **Green（绿）**：实现最小代码使测试通过
   - 实现满足测试的最小代码
   - 运行测试确保通过
   - 不要过度设计

3. **Refactor（重构）**：重构优化代码
   - 在测试通过的基础上重构
   - 改善代码质量、可读性
   - 确保所有测试仍然通过

**重要原则**：
- **不能简化**：必须完整实现功能，不能偷懒
- **不能跳过测试**：每个功能都必须有对应的测试
- **小步迭代**：一次实现一个小功能，运行测试，再继续

## 内存管理约束（严格）

- **禁止使用堆分配**：不能使用 `malloc`、`calloc`、`realloc`、`free`
- 使用 Arena 分配器：大型静态缓冲区 + bump pointer
- 所有数据结构（AST 节点、Token、字符串）从 Arena 分配
- 固定大小限制：AST 节点池、Token 池等使用固定大小数组
- **注意**：LLVM API 内部会使用堆分配，但编译器自身代码不使用堆分配

## 项目结构

```
compiler-mini/
├── spec/
│   └── UYA_MINI_SPEC.md          # 语言规范（重要参考）
├── src/
│   ├── arena.h / arena.c          # Arena 分配器
│   ├── lexer.h / lexer.c          # 词法分析器
│   ├── parser.h / parser.c        # 语法分析器
│   ├── checker.h / checker.c      # 类型检查器（简化，支持结构体）
│   ├── codegen.h / codegen.c      # 代码生成器（LLVM C API）
│   ├── ast.h / ast.c              # AST 定义（简化，支持结构体）
│   └── main.c                     # 主程序
├── tests/                         # 测试用例
├── uya-src/                       # Uya 自举源码
└── Makefile                       # 构建脚本（需要链接 LLVM 库）
```

## 实现优先级（按依赖顺序）

1. Arena 分配器（无依赖）
2. AST 定义（依赖 Arena）
3. Lexer（依赖 AST）
4. Parser（依赖 Lexer/AST）
5. Checker（依赖 Parser/AST，支持结构体类型检查）
6. CodeGen（依赖 AST/Checker，使用 LLVM C API）
7. Main（协调所有模块）

## C99 编码规范

- 使用 C99 标准
- 使用 `-Wall -Wextra -pedantic` 编译选项
- 所有注释使用中文
- 函数和结构体必须添加中文注释
- 变量名使用英文，但必须有中文注释说明用途

## LLVM C API 使用规范

- 使用 LLVM C API 直接从 AST 生成 LLVM IR
- 需要链接 LLVM 库（如 `-llvm`）
- 包含头文件：`<llvm-c/Core.h>`, `<llvm-c/Target.h>`, `<llvm-c/TargetMachine.h>` 等
- LLVM API 调用需要添加中文注释说明

## 结构体支持

Uya Mini 包含结构体支持，编译器内部数据结构可以直接使用结构体：

- 结构体声明：`struct Name { field1: Type1, field2: Type2 }`
- 结构体类型检查
- 结构体字面量和字段访问
- LLVM 结构体类型生成（`LLVMStructType()`）

## 测试要求

- 每个模块都应该有测试用例
- 测试用例放在 `tests/` 目录
- 测试应该验证基本功能正确性
- 测试通过后验证代码质量约束

### 语法规范修复后的测试用例要求（强制）

**重要规则**：根据 `spec/UYA_MINI_SPEC.md` 语法规范修复或实现功能后，**必须添加相应的测试用例**。

1. **测试用例位置**：
   - 测试用例必须添加到 `tests/` 目录
   - 简单测试可以直接放在 `tests/` 根目录
   - 复杂测试或相关测试可以放在 `tests/programs/` 子目录
   - 测试文件命名：使用描述性名称，如 `test_<功能名>.uya`

2. **测试用例内容**：
   - 测试用例应该覆盖修复或实现的功能
   - 测试用例应该验证语法规范中定义的行为
   - 测试用例应该包括正常情况和边界情况
   - 测试用例应该能够独立编译和运行

3. **测试用例验证**：
   - 使用 `tests/run_programs.sh` 运行测试用例
   - 确保测试用例能够成功编译
   - 确保测试用例能够正确运行并产生预期结果
   - 如果测试失败，需要修复实现或测试用例

4. **测试用例示例**：
   ```uya
   // tests/test_new_feature.uya
   // 测试新功能的示例
   fn main() i32 {
       // 测试代码
       return 0;
   }
   ```

5. **工作流程**：
   - 修复或实现功能后，立即添加测试用例
   - 运行测试用例验证修复是否正确
   - 如果测试失败，检查实现是否符合语法规范
   - 确保所有相关测试用例都通过

**注意**：不能跳过测试用例的添加，这是强制要求。

## 代码审查检查点

- [ ] 所有代码使用中文注释
- [ ] 函数和数据结构有中文注释说明
- [ ] **所有函数 < 200 行**（严格检查）
- [ ] **所有源文件 < 1500 行**（严格检查）
- [ ] **遵循 TDD 流程**（先写测试，再实现）
- [ ] **功能完整实现**（不能简化，不能偷懒）
- [ ] 无堆分配（不使用 malloc/free）
- [ ] 使用 Arena 分配器
- [ ] 代码可以编译
- [ ] **所有测试通过**
- [ ] **根据语法规范修复后已添加测试用例**（强制要求）
## 重要参考文档

- `spec/UYA_MINI_SPEC.md` - Uya Mini 语言规范（**必须参考**）
- `../uya.md` - Uya 语言完整规范
- `../RELEASE_v0.1.0.md` - v0.1.0 版本说明与自举说明

## AI 辅助开发提示

当进行编译器开发时：
1. 首先查看 `spec/UYA_MINI_SPEC.md` 了解语言规范
2. 参考 `../RELEASE_v0.1.0.md` 了解当前状态（v0.1.0 已自举）
3. **必须遵循 TDD 流程**：先写测试，再实现功能
4. **不能简化功能**：必须完整实现，不能偷懒
5. **严格代码质量**：函数 < 200 行，文件 < 1500 行
6. **根据语法规范修复后必须添加测试用例**：修复或实现功能后，必须在 `tests/` 目录添加相应的测试用例，并使用 `tests/run_programs.sh` 验证

## 代码注释规范

所有代码必须使用中文注释：

```c
// 示例：函数注释
// 创建一个新的 AST 节点
// 参数：type - 节点类型，line - 行号，column - 列号
// 返回：新创建的 AST 节点指针，失败返回 NULL
ASTNode *ast_new_node(ASTNodeType type, int line, int column) {
    // 从 Arena 分配器分配内存
    // ...
}

// 示例：结构体注释
// 词法分析器结构
typedef struct {
    char *buffer;      // 源代码缓冲区
    size_t position;   // 当前读取位置
    int line;          // 当前行号
    int column;        // 当前列号
} Lexer;
```

## 分部实现指南

如果单个会话无法完成一个模块，可以分部实现：

1. **记录当前进度**：在代码注释或提交信息中明确已实现与待实现部分
2. **保持测试可用**：确保已实现的代码可以编译和测试
3. **逐步完善**：每次会话完成一部分，逐步完善整个模块

**重要**：不能因为上下文限制就简化功能，必须完整实现。

