# Uya Mini 编译器开发规则

本文档包含 Uya Mini 编译器的开发规则和重要参考文档。

## ⚠️ 多上下文协作说明

**重要**：这是一个自举编译器项目，单个 Cursor 上下文可能无法完成全部工作。

### 多上下文协作原则

1. **每次开始新会话时（重要！）**：
   - **必须首先阅读 `PROGRESS.md`** 了解当前进度
   - 查看 `TODO.md` 了解待完成任务
   - 查看 `CONTEXT_SWITCH.md` 了解上下文切换指南
   - 确认上次会话的完成状态
   - 从 `PROGRESS.md` 标记的"下一步行动"开始工作

2. **会话间协作**：
   - 完成一个模块后，**立即更新 `PROGRESS.md`**
   - 更新 `PROGRESS.md` 中的"下一步行动"
   - 更新 `TODO.md` 中的任务状态（可选）
   - 提交代码变更（如果使用版本控制）

3. **上下文切换检查点**：
   - 确保当前模块的基本功能已完成
   - 所有测试通过（或至少代码可以编译）
   - 代码符合质量约束
   - **必须更新 `PROGRESS.md`**，标记完成状态和下一步行动

4. **继续工作时**：
   - **严格按照 `PROGRESS.md` 中的"下一步行动"执行**
   - 按依赖顺序实现（Arena → AST → Lexer → Parser → Checker → CodeGen → Main）
   - 不要跳过已完成的模块
   - 不要重复已完成的工作

## 代码质量约束（严格执行）

- 所有代码必须使用**中文注释**
- 函数和数据结构必须添加中文注释说明
- 复杂逻辑必须添加中文注释解释
- **每个函数不超过 200 行**（严格限制）
- **每个源文件不超过 1500 行**（严格限制）
- 超过限制必须拆分：提取辅助函数或创建新文件

## TDD 开发流程（强制要求）

**所有功能实现必须遵循 TDD（测试驱动开发）流程**：

1. **Red（红）**：先编写测试用例
   - 创建测试文件（或添加测试用例）
   - 测试应该描述期望的行为
   - 运行测试确保失败（因为功能未实现）

2. **Green（绿）**：实现最小代码使测试通过
   - 实现满足测试的最小代码
   - 运行测试确保通过
   - 不要过度设计

3. **Refactor（重构）**：重构优化代码
   - 在测试通过的基础上重构
   - 改善代码质量、可读性
   - 确保所有测试仍然通过

**重要原则**：
- **不能简化**：必须完整实现功能，不能偷懒
- **不能跳过测试**：每个功能都必须有对应的测试
- **小步迭代**：一次实现一个小功能，运行测试，再继续

## 内存管理约束（严格）

- **禁止使用堆分配**：不能使用 `malloc`、`calloc`、`realloc`、`free`
- 使用 Arena 分配器：大型静态缓冲区 + bump pointer
- 所有数据结构（AST 节点、Token、字符串）从 Arena 分配
- 固定大小限制：AST 节点池、Token 池等使用固定大小数组
- **注意**：LLVM API 内部会使用堆分配，但编译器自身代码不使用堆分配

## 项目结构

```
compiler-mini/
├── spec/
│   └── UYA_MINI_SPEC.md          # 语言规范（重要参考）
├── src/
│   ├── arena.h / arena.c          # Arena 分配器
│   ├── lexer.h / lexer.c          # 词法分析器
│   ├── parser.h / parser.c        # 语法分析器
│   ├── checker.h / checker.c      # 类型检查器（简化，支持结构体）
│   ├── codegen.h / codegen.c      # 代码生成器（LLVM C API）
│   ├── ast.h / ast.c              # AST 定义（简化，支持结构体）
│   └── main.c                     # 主程序
├── tests/                         # 测试用例
├── Makefile                       # 构建脚本（需要链接 LLVM 库）
├── PROGRESS.md                    # 进度跟踪文档（重要！）
├── TODO.md                        # 详细任务列表
└── CONTEXT_SWITCH.md              # 上下文切换指南
```

## 实现优先级（按依赖顺序）

1. Arena 分配器（无依赖）
2. AST 定义（依赖 Arena）
3. Lexer（依赖 AST）
4. Parser（依赖 Lexer/AST）
5. Checker（依赖 Parser/AST，支持结构体类型检查）
6. CodeGen（依赖 AST/Checker，使用 LLVM C API）
7. Main（协调所有模块）

## C99 编码规范

- 使用 C99 标准
- 使用 `-Wall -Wextra -pedantic` 编译选项
- 所有注释使用中文
- 函数和结构体必须添加中文注释
- 变量名使用英文，但必须有中文注释说明用途

## LLVM C API 使用规范

- 使用 LLVM C API 直接从 AST 生成 LLVM IR
- 需要链接 LLVM 库（如 `-llvm`）
- 包含头文件：`<llvm-c/Core.h>`, `<llvm-c/Target.h>`, `<llvm-c/TargetMachine.h>` 等
- LLVM API 调用需要添加中文注释说明

## 结构体支持

Uya Mini 包含结构体支持，编译器内部数据结构可以直接使用结构体：

- 结构体声明：`struct Name { field1: Type1, field2: Type2 }`
- 结构体类型检查
- 结构体字面量和字段访问
- LLVM 结构体类型生成（`LLVMStructType()`）

## 测试要求

- 每个模块都应该有测试用例
- 测试用例放在 `tests/` 目录
- 测试应该验证基本功能正确性
- 测试通过后验证代码质量约束

## 代码审查检查点

- [ ] 所有代码使用中文注释
- [ ] 函数和数据结构有中文注释说明
- [ ] **所有函数 < 200 行**（严格检查）
- [ ] **所有源文件 < 1500 行**（严格检查）
- [ ] **遵循 TDD 流程**（先写测试，再实现）
- [ ] **功能完整实现**（不能简化，不能偷懒）
- [ ] 无堆分配（不使用 malloc/free）
- [ ] 使用 Arena 分配器
- [ ] 代码可以编译
- [ ] **所有测试通过**
- [ ] 更新 PROGRESS.md（多上下文协作）

## 重要参考文档

- `spec/UYA_MINI_SPEC.md` - Uya Mini 语言规范（**必须参考**）
- `../uya.md` - Uya 语言完整规范
- `../uya_ai_prompt.md` - Uya 语言 AI 提示词
- `../compiler/architecture.md` - Uya 编译器架构设计

## AI 辅助开发提示

当进行编译器开发时：
1. 首先查看 `spec/UYA_MINI_SPEC.md` 了解语言规范
2. 查看 `PROGRESS.md` 了解当前进度和下一步行动
3. 查看 `TODO.md` 了解任务索引，然后查看对应的 `TODO_phase*.md` 了解详细任务
4. **必须遵循 TDD 流程**：先写测试，再实现功能
5. **可以分部实现**：如果上下文限制，可以分多次会话完成一个模块
6. **不能简化功能**：必须完整实现，不能偷懒
7. **严格代码质量**：函数 < 200 行，文件 < 1500 行
8. 参考 `../compiler/src/` 了解现有编译器实现（但需要改为无堆分配）
9. 实现功能后更新 `PROGRESS.md` 和对应的 `TODO_phase*.md`

## 代码注释规范

所有代码必须使用中文注释：

```c
// 示例：函数注释
// 创建一个新的 AST 节点
// 参数：type - 节点类型，line - 行号，column - 列号
// 返回：新创建的 AST 节点指针，失败返回 NULL
ASTNode *ast_new_node(ASTNodeType type, int line, int column) {
    // 从 Arena 分配器分配内存
    // ...
}

// 示例：结构体注释
// 词法分析器结构
typedef struct {
    char *buffer;      // 源代码缓冲区
    size_t position;   // 当前读取位置
    int line;          // 当前行号
    int column;        // 当前列号
} Lexer;
```

## 分部实现指南

如果单个会话无法完成一个模块，可以分部实现：

1. **记录当前进度**：在 `PROGRESS.md` 中记录已实现的部分
2. **标记暂停点**：明确标记哪些函数/功能已实现，哪些待实现
3. **保持测试可用**：确保已实现的代码可以编译和测试
4. **下次继续**：从 `PROGRESS.md` 标记的位置继续实现
5. **逐步完善**：每次会话完成一部分，逐步完善整个模块

**重要**：不能因为上下文限制就简化功能，必须完整实现。

