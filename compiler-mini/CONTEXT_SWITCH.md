# 上下文切换指南

当 Cursor 上下文满了，需要在新会话中继续工作时，请按照以下步骤操作：

## 🔄 快速恢复步骤

### 1. 新会话开始时

打开 Cursor 后，立即执行以下操作：

1. **阅读当前进度**
   ```bash
   # 查看进度文档
   cat compiler-mini/PROGRESS.md
   ```

2. **查看待办任务**
   ```bash
   # 查看详细任务列表
   cat compiler-mini/TODO.md
   ```

3. **查看规则文件**
   ```bash
   # 确认开发规则
   cat compiler-mini/.cursorrules
   ```

4. **查看语言规范**
   ```bash
   # 确认语言规范（重要参考）
   cat compiler-mini/spec/UYA_MINI_SPEC.md
   ```

### 2. 确认当前状态

检查以下内容：

- ✅ 查看 `PROGRESS.md` 中的"已完成模块"部分
- ✅ 查看 `PROGRESS.md` 中的"下一步行动"
- ✅ 确认上次会话完成的工作状态
- ✅ 检查代码是否可以编译（如果可能）
- ✅ 确认语言规范了解（`spec/UYA_MINI_SPEC.md`）

### 3. 继续执行计划

根据 `PROGRESS.md` 中的"下一步行动"，继续实现：

1. **从标记的模块开始**
   - 不要重复已完成的工作
   - 按照依赖顺序实现（Arena → AST → Lexer → Parser → Checker → CodeGen → Main）

2. **遵循 TDD 开发流程**
   - **Red（红）**：先编写测试用例，运行测试确保失败
   - **Green（绿）**：实现最小代码使测试通过
   - **Refactor（重构）**：重构优化代码，保持测试通过
   - 添加中文注释
   - **不能简化功能**：必须完整实现，不能偷懒

3. **保持代码质量**
   - 所有代码使用中文注释
   - **函数 < 200 行，文件 < 1500 行**（严格限制）
   - 不使用堆分配（malloc/free）
   - 使用 Arena 分配器
   - 遵循 C99 标准

### 4. 完成模块后

立即更新进度：

1. **更新 PROGRESS.md**
   - 将完成的模块标记为 ✅
   - 更新"下一步行动"
   - 记录完成时间
   - 记录遇到的问题和解决方案

2. **更新 TODO.md（可选）**
   - 标记已完成的任务项

3. **提交代码（如果使用 git）**
   ```bash
   git add compiler-mini/
   git commit -m "feat: 完成 [模块名称] 实现"
   ```

## 📋 检查清单

在新会话开始前，确认：

- [ ] 已阅读 `PROGRESS.md`
- [ ] 已阅读 `TODO.md`（了解详细任务）
- [ ] 已阅读 `.cursorrules`（了解开发规范）
- [ ] 已了解语言规范（`spec/UYA_MINI_SPEC.md`）
- [ ] 了解当前进度状态
- [ ] 知道下一步要做什么
- [ ] 确认依赖的模块已完成

在模块完成后，确认：

- [ ] **遵循了 TDD 流程**（先写测试，再实现）
- [ ] **功能完整实现**（不能简化，不能偷懒）
- [ ] **所有函数 < 200 行，文件 < 1500 行**
- [ ] 所有代码使用中文注释
- [ ] 无堆分配（不使用 malloc/free）
- [ ] 使用 Arena 分配器
- [ ] **所有测试通过**
- [ ] 代码可以编译（或至少语法正确）
- [ ] 已更新 `PROGRESS.md`
- [ ] 已提交代码（如果使用版本控制）

## 🔍 关键文件说明

| 文件 | 用途 | 何时查看 |
|------|------|----------|
| `PROGRESS.md` | 当前进度和状态 | 每次新会话开始时 |
| `TODO.md` | 详细任务列表 | 需要了解具体任务时 |
| `.cursorrules` | 开发规则和规范 | 新会话开始时确认规则 |
| `spec/UYA_MINI_SPEC.md` | 语言规范（重要！） | 实现功能前必须参考 |
| `.cursor/plans/*.plan.md` | 原始实现计划 | 需要了解整体架构时 |

## 💡 提示

1. **从 PROGRESS.md 开始**：这是最重要的文件，包含当前状态
2. **参考语言规范**：实现前必须查看 `spec/UYA_MINI_SPEC.md`
3. **按顺序实现**：不要跳过依赖的模块
4. **小步提交**：完成一个模块就更新进度，不要等到全部完成
5. **保持一致性**：遵循已有的代码风格和结构
6. **中文注释**：所有代码必须使用中文注释
7. **无堆分配**：严格遵守无堆分配约束

## 🚨 常见问题

**Q: 如何知道从哪里继续？**
A: 查看 `PROGRESS.md` 中的"下一步行动"部分

**Q: 如果上次会话没有完成模块怎么办？**
A: 查看代码状态，如果基本功能已实现但测试未完成，继续完成测试和优化

**Q: 如何确认代码质量？**
A: 检查代码是否使用中文注释，是否遵循 TDD 流程，函数是否 < 200 行，文件是否 < 1500 行，是否使用堆分配，是否使用 Arena 分配器，所有测试是否通过，是否可以编译

**Q: 如果上下文限制无法完成一个模块怎么办？**
A: 可以分部实现，但必须：
- 在 PROGRESS.md 中详细记录已完成的部分和待完成的部分
- 确保已实现的代码可以编译和测试
- 下次会话从 PROGRESS.md 标记的位置继续
- **不能因为上下文限制就简化功能，必须完整实现**

**Q: 如何拆分大文件？**
A: 如果文件超过 1500 行，必须拆分为多个文件。例如：
- `parser.c` → `parser.c`（核心）+ `parser_expression.c` + `parser_statement.c`
- `codegen.c` → `codegen.c`（核心）+ `codegen_expr.c` + `codegen_stmt.c`

**Q: 可以并行实现多个模块吗？**
A: 不建议，因为模块之间有依赖关系。按照依赖顺序实现更安全。

**Q: LLVM API 调用需要注意什么？**
A: LLVM API 内部会使用堆分配，这是允许的。但编译器自身代码不能使用堆分配。

**Q: 结构体支持如何实现？**
A: 参考 `spec/UYA_MINI_SPEC.md` 中的结构体语法和 LLVM 结构体处理说明。

## 📝 示例：新会话开始

```bash
# 1. 查看当前进度
cat compiler-mini/PROGRESS.md

# 输出示例：
# 下一步行动: 继续实现阶段2：Arena 分配器，实现 arena_alloc 函数

# 2. 查看具体任务
grep -A 20 "阶段2" compiler-mini/TODO.md

# 3. 查看语言规范（如果需要）
grep -A 10 "结构体" compiler-mini/spec/UYA_MINI_SPEC.md

# 4. 开始实现（根据 PROGRESS.md 的指示）
# 实现 arena.c 中的 arena_alloc 函数...
```

## 📚 参考实现

如果需要参考现有编译器实现：

- `../compiler/src/` - 现有的 C 编译器实现（但需要注意：现有实现使用堆分配，需要改为 Arena 分配器）
- `../compiler/architecture.md` - 编译器架构说明

**注意**：参考现有实现时，需要：
- 移除所有 malloc/free 调用，改用 Arena 分配器
- 添加中文注释
- 简化功能（仅实现 Uya Mini 子集）
- 代码生成改为使用 LLVM C API

