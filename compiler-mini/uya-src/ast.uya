// ast.uya - AST 节点创建和操作
// 从 compiler-mini/src/ast.c 和 ast.h 重新覆盖式翻译
//
// 注意：Uya 没有 union，所有 union 字段都转换为结构体的独立字段（扁平化）

// match 模式种类
enum MatchPatternKind {
    MATCH_PAT_LITERAL,   // 字面量（整数、true、false）
    MATCH_PAT_ENUM,      // 枚举变体（EnumName.Variant）
    MATCH_PAT_UNION,     // 联合体变体（.variant(bind)）
    MATCH_PAT_ERROR,     // 错误类型（error.Name）
    MATCH_PAT_BIND,      // 变量绑定（identifier 捕获值）
    MATCH_PAT_WILDCARD,  // 通配符 _
    MATCH_PAT_ELSE,      // else 分支
}

// match 臂结构（Uya 无 union，扁平化为独立字段）
// 字面量臂时用 literal_int_value / literal_is_bool 避免对 literal_expr 指针的 . 访问（C 需 ->）
struct ASTMatchArm {
    kind: MatchPatternKind,
    literal_expr: &ASTNode,
    literal_int_value: i32,   // LITERAL 且为数字时的值
    literal_is_bool: i32,     // LITERAL 且为 bool 时为 1
    enum_name: &byte,
    variant_name: &byte,
    error_name: &byte,
    var_name: &byte,
    result_expr: &ASTNode,
    result_is_block: i32,  // 1 表示 result_expr 为 AST_BLOCK，避免对 result_expr 指针的 .type 访问
}

// 枚举变体结构
struct EnumVariant {
    name: &byte,
    value: &byte,  // 显式值字符串（若指定 = NUM），否则 null
}

// AST 节点类型枚举（与 C 版本 ast.h 一致）
enum ASTNodeType {
    AST_PROGRAM,
    AST_ENUM_DECL,
    AST_ERROR_DECL,    // 预定义错误声明（error Name;）
    AST_INTERFACE_DECL, // 接口声明（interface I { fn method(self: *Self,...) Ret; ... }）
    AST_STRUCT_DECL,
    AST_UNION_DECL,    // 联合体声明（union Name { variant1: T1, variant2: T2 }）
    AST_METHOD_BLOCK,  // 方法块（StructName { fn method(...) { ... } ... }）
    AST_FN_DECL,
    AST_VAR_DECL,
    AST_DESTRUCTURE_DECL,  // 解构声明（const (x, y) = expr）
    AST_USE_STMT,         // use 语句（use path; 或 use path.item; 或 use path as alias;）
    AST_IF_STMT,
    AST_WHILE_STMT,
    AST_FOR_STMT,
    AST_BREAK_STMT,
    AST_CONTINUE_STMT,
    AST_RETURN_STMT,
    AST_DEFER_STMT,     // defer 语句（作用域结束 LIFO 执行）
    AST_ERRDEFER_STMT,  // errdefer 语句（仅错误返回时 LIFO 执行）
    AST_TEST_STMT,      // test 语句（test "description" { body }）
    AST_ASSIGN,
    AST_EXPR_STMT,
    AST_BLOCK,
    AST_BINARY_EXPR,
    AST_UNARY_EXPR,
    AST_CALL_EXPR,
    AST_MEMBER_ACCESS,
    AST_ARRAY_ACCESS,
    AST_SLICE_EXPR,     // 切片表达式（base[start:len]，结果类型 &[T] 或 &[T: N]）
    AST_STRUCT_INIT,
    AST_ARRAY_LITERAL,
    AST_TUPLE_LITERAL,  // 元组字面量（(expr1, expr2, ...)）
    AST_SIZEOF,
    AST_LEN,
    AST_ALIGNOF,
    AST_CAST_EXPR,
    AST_IDENTIFIER,
    AST_UNDERSCORE,  // 忽略占位 _（仅用于赋值左侧、解构，不能引用）
    AST_NUMBER,
    AST_FLOAT,
    AST_BOOL,
    AST_INT_LIMIT,
    AST_STRING,
    AST_STRING_INTERP,  // 字符串插值 "text${expr}text" 或 "text${expr:spec}text"，结果为 [i8: N]
    AST_PARAMS,   // @params 内置变量（函数体内参数元组）
    AST_TRY_EXPR,       // try expr（错误传播）
    AST_CATCH_EXPR,     // expr catch [|err|] { stmts }（错误捕获）
    AST_ERROR_VALUE,    // error.Name（错误值，用于 return error.X）
    AST_MATCH_EXPR,     // match expr { pat => expr, ... else => expr }
    AST_TYPE_NAMED,
    AST_TYPE_POINTER,
    AST_TYPE_ARRAY,
    AST_TYPE_SLICE,     // 切片类型（&[T] 或 &[T: N]）
    AST_TYPE_TUPLE,  // 元组类型（(T1, T2, ...)）
    AST_TYPE_ERROR_UNION,  // 错误联合类型 !T
}

// 字符串插值段（用于 AST_STRING_INTERP）
struct ASTStringInterpSegment {
    is_text: i32,       // 1=纯文本段，0=插值表达式段
    text: &byte,        // 纯文本段内容（is_text=1 时）
    expr: &ASTNode,     // 插值表达式（is_text=0 时）
    format_spec: &byte, // 格式说明符（如 ".2f"，可选）
}

// AST 节点结构（Uya 无 union，所有变体字段扁平化为独立字段）
struct ASTNode {
    type: ASTNodeType,
    line: i32,
    column: i32,
    filename: &byte,
    // program（指针数组在 C 中为 T**，Uya 中用 & & T 表示）
    program_decls: & & ASTNode,
    program_decl_count: i32,
    // enum_decl
    enum_decl_name: &byte,
    enum_decl_variants: &EnumVariant,
    enum_decl_variant_count: i32,
    enum_decl_is_export: i32,  // 1 表示 export enum，0 表示私有
    // error_decl（预定义错误声明 error Name;）
    error_decl_name: &byte,
    error_decl_is_export: i32,  // 1 表示 export error，0 表示私有
    // interface_decl（interface I { fn method(self: *Self,...) Ret; ... }）
    interface_decl_name: &byte,
    interface_decl_method_sigs: & & ASTNode,
    interface_decl_method_sig_count: i32,
    interface_decl_is_export: i32,  // 1 表示 export interface，0 表示私有
    // struct_decl
    struct_decl_name: &byte,
    struct_decl_interface_names: & & byte,  // 实现的接口名称数组（可为 null）
    struct_decl_interface_count: i32,
    struct_decl_fields: & & ASTNode,
    struct_decl_field_count: i32,
    struct_decl_methods: & & ASTNode,  // 内部方法数组（AST_FN_DECL 节点，可为 null）
    struct_decl_method_count: i32,     // 内部方法数量
    struct_decl_is_export: i32,  // 1 表示 export struct，0 表示私有
    // union_decl（union Name { variant1: T1, variant2: T2 [ , fn ... ] }）
    union_decl_name: &byte,
    union_decl_variants: & & ASTNode,  // 变体数组（变体是 AST_VAR_DECL 节点）
    union_decl_variant_count: i32,
    union_decl_methods: & & ASTNode,   // 内部方法数组（AST_FN_DECL 节点，可为 null；extern union 无方法）
    union_decl_method_count: i32,
    union_decl_is_extern: i32,  // 1 表示 extern union（C 互操作，仅生成 union，无 tagged 包装）
    union_decl_is_export: i32,  // 1 表示 export union，0 表示私有
    // method_block（StructName/UnionName { fn method(...) { ... } ... }）
    method_block_struct_name: &byte,
    method_block_union_name: &byte,    // 联合体名称（为 null 时表示结构体方法块）
    method_block_methods: & & ASTNode,
    method_block_method_count: i32,
    // fn_decl
    fn_decl_name: &byte,
    fn_decl_params: & & ASTNode,
    fn_decl_param_count: i32,
    fn_decl_return_type: &ASTNode,
    fn_decl_body: &ASTNode,
    fn_decl_is_varargs: i32,
    fn_decl_is_export: i32,  // 1 表示 export fn，0 表示私有
    // var_decl
    var_decl_name: &byte,
    var_decl_type: &ASTNode,
    var_decl_init: &ASTNode,
    var_decl_is_const: i32,
    var_decl_was_moved: i32,   // 移动语义：1 表示该绑定曾被移动，离开作用域时不调用 drop
    var_decl_is_export: i32,  // 1 表示 export const，0 表示私有（仅顶层 const 声明使用）
    // destructure_decl（const (x, y) = expr）
    destructure_decl_names: & & byte,
    destructure_decl_name_count: i32,
    destructure_decl_is_const: i32,
    destructure_decl_init: &ASTNode,
    // use_stmt（use path; 或 use path.item; 或 use path as alias;）
    use_stmt_path_segments: & & byte,  // 模块路径段数组（如 ["std", "io"] 表示 std.io，存储在 Arena）
    use_stmt_path_segment_count: i32,   // 路径段数量
    use_stmt_item_name: &byte,          // 可选：导入的特定项名称（如 use std.io.read_file 中的 "read_file"，为 null 表示导入整个模块）
    use_stmt_alias: &byte,              // 可选：别名（如 use std.io as io 中的 "io"，为 null 表示无别名）
    // binary_expr
    binary_expr_left: &ASTNode,
    binary_expr_op: i32,
    binary_expr_right: &ASTNode,
    // unary_expr
    unary_expr_op: i32,
    unary_expr_operand: &ASTNode,
    // try_expr（try expr）
    try_expr_operand: &ASTNode,
    // catch_expr（expr catch [|err|] { stmts }）
    catch_expr_operand: &ASTNode,
    catch_expr_err_name: &byte,
    catch_expr_catch_block: &ASTNode,
    // error_value（error.Name）
    error_value_name: &byte,
    // match_expr（match expr { pat => expr, ... }）
    match_expr_expr: &ASTNode,
    match_expr_arms: &ASTMatchArm,
    match_expr_arm_count: i32,
    // call_expr
    call_expr_callee: &ASTNode,
    call_expr_args: & & ASTNode,
    call_expr_arg_count: i32,
    call_expr_has_ellipsis_forward: i32,  // 1 表示末尾为 ... 转发可变参数
    // member_access
    member_access_object: &ASTNode,
    member_access_field_name: &byte,
    // array_access
    array_access_array: &ASTNode,
    array_access_index: &ASTNode,
    // slice_expr（base[start:len]）
    slice_expr_base: &ASTNode,
    slice_expr_start_expr: &ASTNode,
    slice_expr_len_expr: &ASTNode,
    // struct_init
    struct_init_struct_name: &byte,
    struct_init_field_names: & & byte,
    struct_init_field_values: & & ASTNode,
    struct_init_field_count: i32,
    // array_literal（[expr1, ...] 或 [value: N]）
    array_literal_elements: & & ASTNode,
    array_literal_element_count: i32,
    array_literal_repeat_count_expr: &ASTNode,
    // tuple_literal（(expr1, expr2, ...)）
    tuple_literal_elements: & & ASTNode,
    tuple_literal_element_count: i32,
    // sizeof_expr
    sizeof_expr_target: &ASTNode,
    sizeof_expr_is_type: i32,
    // len_expr
    len_expr_array: &ASTNode,
    // alignof_expr
    alignof_expr_target: &ASTNode,
    alignof_expr_is_type: i32,
    // cast_expr（expr as type 或 expr as! type）
    cast_expr_expr: &ASTNode,
    cast_expr_target_type: &ASTNode,
    cast_expr_is_force_cast: i32,  // 1 表示 as!（强转，返回 !T），0 表示 as
    // identifier
    identifier_name: &byte,
    // number
    number_value: i32,
    // float_literal
    float_literal_value: f64,
    // bool_literal
    bool_literal_value: i32,
    // int_limit (max/min)
    int_limit_is_max: i32,
    int_limit_resolved_kind: i32,
    // string_literal
    string_literal_value: &byte,
    // string_interp（"text${expr}text" 或 "text${expr:spec}text"）
    string_interp_segments: &ASTStringInterpSegment,
    string_interp_segment_count: i32,
    string_interp_computed_size: i32,  // 由 checker 填充
    // if_stmt
    if_stmt_condition: &ASTNode,
    if_stmt_then_branch: &ASTNode,
    if_stmt_else_branch: &ASTNode,
    // while_stmt
    while_stmt_condition: &ASTNode,
    while_stmt_body: &ASTNode,
    // for_stmt
    for_stmt_array: &ASTNode,
    for_stmt_var_name: &byte,
    for_stmt_is_ref: i32,
    for_stmt_is_range: i32,
    for_stmt_range_start: &ASTNode,
    for_stmt_range_end: &ASTNode,
    for_stmt_body: &ASTNode,
    // return_stmt
    return_stmt_expr: &ASTNode,
    // defer_stmt（defer stmt 或 defer { ... }）
    defer_stmt_body: &ASTNode,
    // errdefer_stmt（errdefer stmt 或 errdefer { ... }）
    errdefer_stmt_body: &ASTNode,
    // test_stmt（test "description" { body }）
    test_stmt_description: &byte,  // 测试说明（字符串存储在 Arena 中）
    test_stmt_body: &ASTNode,      // 测试体（AST_BLOCK）
    // assign
    assign_dest: &ASTNode,
    assign_src: &ASTNode,
    // block
    block_stmts: & & ASTNode,
    block_stmt_count: i32,
    // type_named
    type_named_name: &byte,
    // type_pointer
    type_pointer_pointed_type: &ASTNode,
    type_pointer_is_ffi_pointer: i32,
    // type_array
    type_array_element_type: &ASTNode,
    type_array_size_expr: &ASTNode,
    // type_slice（&[T] 或 &[T: N]）
    type_slice_element_type: &ASTNode,
    type_slice_size_expr: &ASTNode,
    // type_tuple（(T1, T2, ...)）
    type_tuple_element_types: & & ASTNode,
    type_tuple_element_count: i32,
    // type_error_union（!T）
    type_error_union_payload_type: &ASTNode,
}

// 创建新的 AST 节点
fn ast_new_node(type: ASTNodeType, line: i32, column: i32, arena: &Arena, filename: &byte) &ASTNode {
    if arena == null {
        return null;
    }
    const node: &ASTNode = arena_alloc(arena, @size_of(ASTNode)) as &ASTNode;
    if node == null {
        return null;
    }
    node.type = type;
    node.line = line;
    node.column = column;
    node.filename = filename;
    node.program_decls = null;
    node.program_decl_count = 0;
    node.enum_decl_name = null;
    node.enum_decl_variants = null;
    node.enum_decl_variant_count = 0;
    node.enum_decl_is_export = 0;
    node.error_decl_name = null;
    node.error_decl_is_export = 0;
    node.interface_decl_name = null;
    node.interface_decl_method_sigs = null;
    node.interface_decl_method_sig_count = 0;
    node.interface_decl_is_export = 0;
    node.struct_decl_name = null;
    node.struct_decl_interface_names = null;
    node.struct_decl_interface_count = 0;
    node.struct_decl_fields = null;
    node.struct_decl_field_count = 0;
    node.struct_decl_methods = null;
    node.struct_decl_method_count = 0;
    node.struct_decl_is_export = 0;
    node.union_decl_name = null;
    node.union_decl_variants = null;
    node.union_decl_variant_count = 0;
    node.union_decl_methods = null;
    node.union_decl_method_count = 0;
    node.union_decl_is_extern = 0;
    node.union_decl_is_export = 0;
    node.method_block_struct_name = null;
    node.method_block_union_name = null;
    node.method_block_methods = null;
    node.method_block_method_count = 0;
    node.fn_decl_name = null;
    node.fn_decl_params = null;
    node.fn_decl_param_count = 0;
    node.fn_decl_return_type = null;
    node.fn_decl_body = null;
    node.fn_decl_is_varargs = 0;
    node.fn_decl_is_export = 0;
    node.var_decl_name = null;
    node.var_decl_type = null;
    node.var_decl_init = null;
    node.var_decl_is_const = 0;
    node.var_decl_was_moved = 0;
    node.var_decl_is_export = 0;
    node.destructure_decl_names = null;
    node.destructure_decl_name_count = 0;
    node.destructure_decl_is_const = 0;
    node.destructure_decl_init = null;
    node.use_stmt_path_segments = null;
    node.use_stmt_path_segment_count = 0;
    node.use_stmt_item_name = null;
    node.use_stmt_alias = null;
    node.binary_expr_left = null;
    node.binary_expr_op = 0;
    node.binary_expr_right = null;
    node.unary_expr_op = 0;
    node.unary_expr_operand = null;
    node.try_expr_operand = null;
    node.catch_expr_operand = null;
    node.catch_expr_err_name = null;
    node.catch_expr_catch_block = null;
    node.error_value_name = null;
    node.match_expr_expr = null;
    node.match_expr_arms = null;
    node.match_expr_arm_count = 0;
    node.call_expr_callee = null;
    node.call_expr_args = null;
    node.call_expr_arg_count = 0;
    node.call_expr_has_ellipsis_forward = 0;
    node.member_access_object = null;
    node.member_access_field_name = null;
    node.array_access_array = null;
    node.array_access_index = null;
    node.slice_expr_base = null;
    node.slice_expr_start_expr = null;
    node.slice_expr_len_expr = null;
    node.struct_init_struct_name = null;
    node.struct_init_field_names = null;
    node.struct_init_field_values = null;
    node.struct_init_field_count = 0;
    node.array_literal_elements = null;
    node.array_literal_element_count = 0;
    node.array_literal_repeat_count_expr = null;
    node.tuple_literal_elements = null;
    node.tuple_literal_element_count = 0;
    node.sizeof_expr_target = null;
    node.sizeof_expr_is_type = 0;
    node.len_expr_array = null;
    node.alignof_expr_target = null;
    node.alignof_expr_is_type = 0;
    node.cast_expr_expr = null;
    node.cast_expr_target_type = null;
    node.cast_expr_is_force_cast = 0;
    node.identifier_name = null;
    node.number_value = 0;
    node.float_literal_value = 0.0;
    node.bool_literal_value = 0;
    node.int_limit_is_max = 0;
    node.int_limit_resolved_kind = 0;
    node.string_literal_value = null;
    node.string_interp_segments = null;
    node.string_interp_segment_count = 0;
    node.string_interp_computed_size = 0;
    node.if_stmt_condition = null;
    node.if_stmt_then_branch = null;
    node.if_stmt_else_branch = null;
    node.while_stmt_condition = null;
    node.while_stmt_body = null;
    node.for_stmt_array = null;
    node.for_stmt_var_name = null;
    node.for_stmt_is_ref = 0;
    node.for_stmt_is_range = 0;
    node.for_stmt_range_start = null;
    node.for_stmt_range_end = null;
    node.for_stmt_body = null;
    node.return_stmt_expr = null;
    node.defer_stmt_body = null;
    node.errdefer_stmt_body = null;
    node.test_stmt_description = null;
    node.test_stmt_body = null;
    node.assign_dest = null;
    node.assign_src = null;
    node.block_stmts = null;
    node.block_stmt_count = 0;
    node.type_named_name = null;
    node.type_pointer_pointed_type = null;
    node.type_pointer_is_ffi_pointer = 0;
    node.type_array_element_type = null;
    node.type_array_size_expr = null;
    node.type_slice_element_type = null;
    node.type_slice_size_expr = null;
    node.type_tuple_element_types = null;
    node.type_tuple_element_count = 0;
    node.type_error_union_payload_type = null;
    return node;
}

const MAX_MERGE_PROGRAMS: i32 = 64;

// 合并多个 ASTNodeType.AST_PROGRAM 节点为一个程序节点
// 参数：programs - 程序节点数组（元素类型为 &ASTNode），count - 数量，arena - Arena
fn ast_merge_programs(programs: [&ASTNode: MAX_MERGE_PROGRAMS], count: i32, arena: &Arena) &ASTNode {
    if count <= 0 || arena == null {
        return null;
    }
    var i: i32 = 0;
    while i < count {
        const p: &ASTNode = programs[i];
        if p == null || p.type != ASTNodeType.AST_PROGRAM {
            return null;
        }
        i = i + 1;
    }
    var total_decl_count: i32 = 0;
    i = 0;
    while i < count {
        total_decl_count = total_decl_count + programs[i].program_decl_count;
        i = i + 1;
    }
    const first: &ASTNode = programs[0];
    const merged: &ASTNode = ast_new_node(ASTNodeType.AST_PROGRAM, first.line, first.column, arena, first.filename);
    if merged == null {
        return null;
    }
    if total_decl_count <= 0 {
        merged.program_decls = null;
        merged.program_decl_count = 0;
        return merged;
    }
    const decls: & & ASTNode = arena_alloc(arena, @size_of(&ASTNode) * total_decl_count as usize) as & & ASTNode;
    if decls == null {
        return null;
    }
    var decl_index: i32 = 0;
    i = 0;
    while i < count {
        const program: &ASTNode = programs[i];
        var j: i32 = 0;
        while j < program.program_decl_count {
            decls[decl_index] = program.program_decls[j];
            decl_index = decl_index + 1;
            j = j + 1;
        }
        i = i + 1;
    }
    merged.program_decls = decls;
    merged.program_decl_count = total_decl_count;
    return merged;
}
