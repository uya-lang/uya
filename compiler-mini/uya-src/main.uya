// main.uya - 主程序模块
// 编译器的入口点，协调所有编译阶段：词法分析 → 语法分析 → 类型检查 → 代码生成
//
// 注意：需要先包含 arena.uya、lexer.uya、parser.uya、checker.uya、codegen.uya 和 str_utils.uya
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 外部函数声明 =====
// 注意：C 标准库函数（strlen, strcmp, fprintf, fopen, fread, fclose, fgetc, get_argc, get_argv 等）在 extern_decls.uya 中声明
// 编译时需要包含 extern_decls.uya 文件

// Arena 函数（来自 arena.uya）
extern fn arena_init(arena: &Arena, buffer: &void, size: i32) void;

// Lexer 函数（来自 lexer.uya）
extern fn lexer_init(lexer: &Lexer, source: &byte, source_len: i32, filename: *byte, arena: &Arena) i32;

// Parser 函数（来自 parser.uya）
extern fn parser_init(parser: &Parser, lexer: &Lexer, arena: &Arena) i32;
extern fn parser_parse(parser: &Parser) &ASTNode;

// Checker 函数（来自 checker.uya）
extern fn checker_init(checker: &TypeChecker, arena: &Arena) i32;
extern fn checker_check(checker: &TypeChecker, ast: &ASTNode) i32;
extern fn checker_get_error_count(checker: &TypeChecker) i32;

// CodeGen 函数（来自 codegen.uya）
extern fn codegen_new(codegen: &CodeGenerator, arena: &Arena, module_name: &byte) i32;
extern fn codegen_generate(codegen: &CodeGenerator, ast: &ASTNode, output_file: &byte) i32;

// ===== 常量定义 =====

// 文件读取缓冲区大小（与 Lexer 的缓冲区大小相同）
const FILE_BUFFER_SIZE: i32 = 1024 * 1024;  // 1MB

// Arena 分配器缓冲区大小
const ARENA_BUFFER_SIZE: i32 = 2 * 1024 * 1024;  // 2MB

// 最大输入文件数量
const MAX_INPUT_FILES: i32 = 64;

// EOF 常量（文件结束符）
const EOF: i32 = -1;

// ===== 辅助函数 =====

// 读取文件内容到缓冲区
// 参数：filename - 文件名
//       buffer - 缓冲区（固定大小数组）
//       buffer_size - 缓冲区大小
// 返回：成功返回读取的字节数，失败返回 -1
// 注意：文件大小不能超过缓冲区大小
fn read_file_content(filename: *byte, buffer: &byte, buffer_size: i32) i32 {
    if filename == null || buffer == null || buffer_size <= 0 {
        return -1;
    }
    
    const file: *void = fopen(filename, "rb" as *byte);  // 二进制模式读取
    if file == null {
        return -1;
    }
    
    // 读取文件内容（保留一个字节用于 '\0'）
    const bytes_read: i32 = fread(buffer as *void, 1, buffer_size - 1, file);
    
    // 检查是否还有更多数据（文件太大）
    if bytes_read >= buffer_size - 1 {
        const c: i32 = fgetc(file);
        fclose(file);
        if c != EOF {
            // 文件还有更多数据，文件太大
            return -1;
        }
    } else {
        fclose(file);
    }
    
    // 添加字符串结束符
    buffer[bytes_read] = 0;
    
    return bytes_read;
}

// 打印使用说明
// 参数：program_name - 程序名称
fn print_usage(program_name: *byte) void {
    if program_name == null {
        return;
    }
    fprintf(2 as *void, "用法: %s <输入文件> -o <输出文件>\n", program_name);
    fprintf(2 as *void, "示例: %s program.uya -o program\n", program_name);
}

// 解析命令行参数
// 参数：input_files - 输出参数：输入文件名数组（固定大小数组，存储 *byte 指针）
//       input_file_count - 输出参数：输入文件数量
//       output_file - 输出参数：输出文件名（固定大小数组，存储 *byte 指针）
// 返回：成功返回 0，失败返回 -1
// 注意：在 Uya Mini 中，使用 extern 函数获取命令行参数
// 注意：由于 Uya Mini 不支持嵌套指针，使用固定大小数组存储指针
fn parse_args(input_files: [*byte: MAX_INPUT_FILES], input_file_count: &i32, output_file: [*byte: 1]) i32 {
    const argc: i32 = get_argc();
    if argc < 4 {
        if argc > 0 {
            const program_name: *byte = get_argv(0);
            if program_name != null {
                print_usage(program_name);
            }
        }
        return -1;
    }
    
    // 简单的参数解析：程序名 [输入文件...] -o <输出文件>
    input_file_count[0] = 0;
    output_file[0] = null;
    
    var i: i32 = 1;
    while i < argc {
        const arg: *byte = get_argv(i);
        if arg == null {
            i = i + 1;
            continue;
        }
        
        // 检查是否是 -o 选项
        if strcmp(arg, "-o" as *byte) == 0 {
            if i + 1 < argc {
                output_file[0] = get_argv(i + 1);
                i = i + 2;  // 跳过 -o 和输出文件名
            } else {
                fprintf(2 as *void, "错误: -o 选项需要指定输出文件名\n");
                return -1;
            }
        } else {
            // 检查是否是选项（以 - 开头）
            if arg[0] != 45 {  // 45 是 '-' 的 ASCII 码
                // 非选项参数，应该是输入文件
                if input_file_count[0] >= MAX_INPUT_FILES {
                    fprintf(2 as *void, "错误: 输入文件数量超过最大限制 (%d)\n", MAX_INPUT_FILES);
                    return -1;
                }
                input_files[input_file_count[0]] = arg;
                input_file_count[0] = input_file_count[0] + 1;
            }
        }
        i = i + 1;
    }
    
    if input_file_count[0] == 0 {
        fprintf(2 as *void, "错误: 未指定输入文件\n");
        if argc > 0 {
            const program_name: *byte = get_argv(0);
            if program_name != null {
                print_usage(program_name);
            }
        }
        return -1;
    }
    
    if output_file[0] == null {
        fprintf(2 as *void, "错误: 未指定输出文件（使用 -o 选项）\n");
        if argc > 0 {
            const program_name: *byte = get_argv(0);
            if program_name != null {
                print_usage(program_name);
            }
        }
        return -1;
    }
    
    return 0;
}

// 主编译函数（多文件版本）
// 协调所有编译阶段：词法分析 → 语法分析 → AST 合并 → 类型检查 → 代码生成
// 参数：input_files - 输入文件名数组
//       input_file_count - 输入文件数量
//       output_file - 输出文件名
// 返回：成功返回 0，失败返回非 0
fn compile_files(input_files: [*byte: MAX_INPUT_FILES], input_file_count: i32, output_file: *byte) i32 {
    if input_file_count <= 0 || output_file == null {
        return 1;
    }
    
    // Arena 分配器缓冲区（栈上分配）
    var arena_buffer: [byte: ARENA_BUFFER_SIZE] = [];
    
    // 初始化 Arena 分配器（所有文件共享同一个 Arena）
    // 手动初始化 Arena 结构体字段
    // 注意：Uya Mini 要求变量必须初始化，所以使用字节数组作为存储空间，然后手动设置字段
    var arena_storage: [byte: 16] = [];  // Arena 结构体大小约为 16 字节（3个字段：&byte + i32 + i32）
    var arena: &Arena = &arena_storage[0] as &Arena;
    // 手动初始化字段
    arena.buffer = &arena_buffer[0];
    arena.size = ARENA_BUFFER_SIZE;
    arena.offset = 0;
    
    // 存储每个文件的 AST_PROGRAM 节点（栈上分配，只存储指针）
    var programs: [&ASTNode: MAX_INPUT_FILES] = [];
    
    // 单个文件的缓冲区（栈上分配，每次处理一个文件）
    var file_buffer: [byte: FILE_BUFFER_SIZE] = [];
    
    // 解析每个文件
    var i: i32 = 0;
    while i < input_file_count {
        const input_file: *byte = input_files[i];
        if input_file == null {
            i = i + 1;
            continue;
        }
        
        // 读取文件内容
        const file_size: i32 = read_file_content(input_file, &file_buffer[0], FILE_BUFFER_SIZE);
        if file_size < 0 {
            fprintf(2 as *void, "错误: 无法读取文件 '%s'\n", input_file);
            return 1;
        }
        
        // 1. 词法分析
        // 使用零初始化的字节数组作为结构体的存储空间，通过指针访问
        var lexer_storage: [byte: 32] = [];  // Lexer 结构体大小约为 32 字节
        var lexer: &Lexer = &lexer_storage[0] as &Lexer;
        if lexer_init(lexer, &file_buffer[0], file_size, input_file, arena) != 0 {
            fprintf(2 as *void, "错误: Lexer 初始化失败: %s\n", input_file);
            return 1;
        }
        
        // 2. 语法分析
        // 使用零初始化的字节数组作为结构体的存储空间，通过指针访问
        var parser_storage: [byte: 24] = [];  // Parser 结构体大小约为 24 字节
        var parser: &Parser = &parser_storage[0] as &Parser;
        if parser_init(parser, lexer, arena) != 0 {
            fprintf(2 as *void, "错误: Parser 初始化失败: %s\n", input_file);
            return 1;
        }
        
        const ast: &ASTNode = parser_parse(parser);
        if ast == null {
            fprintf(2 as *void, "错误: 语法分析失败: %s\n", input_file);
            return 1;
        }
        
        if ast.type != AST_PROGRAM {
            fprintf(2 as *void, "错误: 解析结果不是程序节点: %s\n", input_file);
            return 1;
        }
        
        programs[i] = ast;
        i = i + 1;
    }
    
    // 3. 合并所有 AST_PROGRAM 节点
    // 注意：ast_merge_programs 函数需要在 ast.uya 中实现
    // 这里先简化处理：如果只有一个文件，直接使用该文件的 AST
    var merged_ast: &ASTNode = null;
    if input_file_count == 1 {
        merged_ast = programs[0];
    } else {
        // TODO: 实现多文件 AST 合并
        fprintf(2 as *void, "错误: 多文件 AST 合并功能尚未实现\n");
        return 1;
    }
    
    if merged_ast == null {
        fprintf(2 as *void, "错误: AST 合并失败\n");
        return 1;
    }
    
    // 4. 类型检查
    // 使用零初始化的字节数组作为结构体的存储空间，通过指针访问
    var checker_storage: [byte: 200] = [];  // TypeChecker 结构体大小约为 200 字节
    var checker: &TypeChecker = &checker_storage[0] as &TypeChecker;
    if checker_init(checker, arena) != 0 {
        fprintf(2 as *void, "错误: TypeChecker 初始化失败\n");
        return 1;
    }
    
    if checker_check(checker, merged_ast) != 0 {
        const error_count: i32 = checker_get_error_count(checker);
        fprintf(2 as *void, "错误: 类型检查失败（错误数量: %d）\n", error_count);
        return 1;
    }
    
    // 5. 代码生成
    // 使用第一个输入文件名作为模块名
    const module_name: *byte = input_files[0];
    
    // 使用零初始化的字节数组作为结构体的存储空间，通过指针访问
    var codegen_storage: [byte: 2000] = [];  // CodeGenerator 结构体大小约为 2000 字节
    var codegen: &CodeGenerator = &codegen_storage[0] as &CodeGenerator;
    if codegen_new(codegen, arena, module_name) != 0 {
        fprintf(2 as *void, "错误: CodeGenerator 初始化失败\n");
        return 1;
    }
    
    if codegen_generate(codegen, merged_ast, output_file) != 0 {
        fprintf(2 as *void, "错误: 代码生成失败\n");
        return 1;
    }
    
    return 0;
}

// 主函数
// 返回：成功返回 0，失败返回非 0
// 注意：在 Uya Mini 中，main 函数签名是 fn main() i32，不支持 argc 和 argv
//       使用 extern 函数 get_argc() 和 get_argv() 获取命令行参数
fn main() i32 {
    var input_files: [*byte: MAX_INPUT_FILES] = [];
    var input_file_count: i32 = 0;
    var output_file: [*byte: 1] = [];
    
    // 解析命令行参数
    if parse_args(input_files, &input_file_count, output_file) != 0 {
        return 1;
    }
    
    // 编译文件
    const result: i32 = compile_files(input_files, input_file_count, output_file[0]);
    
    return result;
}
