// main.uya - 编译器主程序
// 从 compiler-mini/src/main.c 覆盖式翻译
// 注意：入口为 uya_main()，由 bridge.c 调用；命令行参数通过 get_argc/get_argv 获取

// ===== 外部函数（bridge 与 C 标准库在 extern_decls.uya 中声明）=====
// 本文件依赖 extern_decls.uya 中的 get_argc, get_argv, get_stderr, fopen, fread, fclose, fgetc, fprintf, strcmp, strrchr, snprintf

// 后端类型
enum BackendType {
    BACKEND_LLVM,
    BACKEND_C99
}

// 文件读取缓冲区大小（与 Lexer 一致）
const FILE_BUFFER_SIZE: i32 = 1024 * 1024;

// Arena 缓冲区大小（64MB，自举 18 个文件 + for 范围等 AST 需更大空间）
const ARENA_BUFFER_SIZE: i32 = 64 * 1024 * 1024;

// 最大输入文件数
const MAX_INPUT_FILES: i32 = 64;

// 全局缓冲区（替代 C 的 static 数组，零初始化）
var arena_buffer: [byte: ARENA_BUFFER_SIZE] = [];
var file_buffer: [byte: FILE_BUFFER_SIZE] = [];

// 读取文件内容到缓冲区
// 成功返回读取字节数，失败返回 -1
// 注意：filename 用 &byte，调用 fopen 时转为 *byte
fn read_file_content(filename: &byte, buffer: &byte, buffer_size: usize) i32 {
    const file: *void = fopen(filename as *byte, "rb" as *byte);
    if file == null {
        return -1;
    }
    const bytes_read: usize = fread(buffer as *byte, 1, buffer_size - 1, file);
    const c: i32 = fgetc(file);
    if bytes_read >= buffer_size - 1 {
        fclose(file);
        if c != -1 {
            return -1;
        }
    } else {
        fclose(file);
    }
    buffer[bytes_read] = 0 as byte;
    return bytes_read as i32;
}

// 打印使用说明（program_name 用 &byte，传给 fprintf 时转为 *byte）
fn print_usage(program_name: &byte) void {
    const stderr: *void = get_stderr();
    fprintf(stderr, "用法: %s [输入文件...] -o <输出文件> [选项]\n" as *byte, program_name as *byte);
    fprintf(stderr, "示例: %s program.uya -o program\n" as *byte, program_name as *byte);
    fprintf(stderr, "示例: %s program.uya -o program.c --c99  # 生成 C99 代码\n" as *byte, program_name as *byte);
    fprintf(stderr, "\n选项:\n" as *byte);
    fprintf(stderr, "  --c99                使用 C99 后端生成 C 代码\n" as *byte);
    fprintf(stderr, "  --line-directives    启用 #line 指令生成（C99 后端）\n" as *byte);
    fprintf(stderr, "  --no-line-directives 禁用 #line 指令生成\n" as *byte);
}

// 解析命令行参数
// input_file_indices: 填充前 *input_file_count 个为输入文件在 argv 中的下标
// 返回：0 成功，-1 失败
fn parse_args(
    input_file_indices: &i32,
    input_file_count: &i32,
    output_file_index: &i32,
    backend_type: &BackendType,
    emit_line_directives: &i32
) i32 {
    const argc: i32 = get_argc();
    if argc < 4 {
        print_usage(get_argv(0) as &byte);
        return -1;
    }
    input_file_count[0] = 0;
    output_file_index[0] = -1;
    backend_type[0] = BackendType.BACKEND_LLVM;
    emit_line_directives[0] = 0;

    var i: i32 = 1;
    while i < argc {
        const arg: *byte = get_argv(i);
        if strcmp(arg, "-o" as *byte) == 0 {
            if i + 1 < argc {
                output_file_index[0] = i + 1;
                i = i + 1;
            } else {
                fprintf(get_stderr(), "错误: -o 选项需要指定输出文件名\n" as *byte);
                return -1;
            }
        } else if strcmp(arg, "--c99" as *byte) == 0 {
            backend_type[0] = BackendType.BACKEND_C99;
        } else if strcmp(arg, "--no-line-directives" as *byte) == 0 {
            emit_line_directives[0] = 0;
        } else if strcmp(arg, "--line-directives" as *byte) == 0 {
            emit_line_directives[0] = 1;
        } else {
            const c: byte = arg[0];
            if c != 45 {
                if input_file_count[0] >= MAX_INPUT_FILES {
                    fprintf(get_stderr(), "错误: 输入文件数量超过最大限制 (%d)\n" as *byte, MAX_INPUT_FILES);
                    return -1;
                }
                const idx: i32 = input_file_count[0];
                input_file_indices[idx] = i;
                input_file_count[0] = idx + 1;
            }
        }
        i = i + 1;
    }

    if input_file_count[0] == 0 {
        fprintf(get_stderr(), "错误: 未指定输入文件\n" as *byte);
        print_usage(get_argv(0) as &byte);
        return -1;
    }
    if output_file_index[0] < 0 {
        fprintf(get_stderr(), "错误: 未指定输出文件（使用 -o 选项）\n" as *byte);
        print_usage(get_argv(0) as &byte);
        return -1;
    }
    const out_idx: i32 = output_file_index[0];
    const out_path: *byte = get_argv(out_idx);
    if backend_type[0] == BackendType.BACKEND_LLVM {
        const ext: *byte = strrchr(out_path, 46);
        if ext != null && strcmp(ext, ".c" as *byte) == 0 {
            backend_type[0] = BackendType.BACKEND_C99;
        }
    }
    return 0;
}

// 主编译函数：词法 → 语法 → AST 合并 → 类型检查 → 代码生成
fn compile_files(
    input_file_indices: &i32,
    input_file_count: i32,
    output_file_index: i32,
    backend: BackendType,
    emit_line_directives: i32
) i32 {
    const stderr: *void = get_stderr();
    fprintf(stderr, "=== 开始编译 ===\n" as *byte);
    fprintf(stderr, "输入文件数量: %d\n" as *byte, input_file_count);
    var i: i32 = 0;
    while i < input_file_count {
        const idx_i: i32 = input_file_indices[i];
    fprintf(stderr, "  %d: %s\n" as *byte, i, get_argv(idx_i));
        i = i + 1;
    }
    const output_file: *byte = get_argv(output_file_index);
    fprintf(stderr, "输出文件: %s\n" as *byte, output_file);
    fprintf(stderr, "=== 词法/语法分析 ===\n" as *byte);
    var backend_str: *byte = "LLVM" as *byte;
    if backend == BackendType.BACKEND_C99 {
        backend_str = "C99" as *byte;
    }
    fprintf(stderr, "后端类型: %s\n" as *byte, backend_str);

    var arena: Arena = Arena { buffer: null, size: 0 as usize, offset: 0 as usize };
    arena_init(&arena, &arena_buffer[0], ARENA_BUFFER_SIZE as usize);

    var programs: [&ASTNode: MAX_INPUT_FILES] = [];

    i = 0;
    while i < input_file_count {
        const file_idx: i32 = input_file_indices[i];
        const input_path: *byte = get_argv(file_idx);
        const file_size: i32 = read_file_content(input_path as &byte, &file_buffer[0], FILE_BUFFER_SIZE as usize);
        if file_size < 0 {
            fprintf(stderr, "错误: 无法读取文件 '%s' (可能文件太大或不存在)\n" as *byte, input_path);
            return 1;
        }
        var lexer: Lexer = Lexer { buffer: [], buffer_size: 0 as usize, position: 0 as usize, line: 0, column: 0, filename: null };
        const input_path_ref: &byte = input_path as &byte;
        if lexer_init(&lexer, &file_buffer[0], file_size as usize, input_path_ref, &arena) != 0 {
            fprintf(stderr, "错误: Lexer 初始化失败: %s\n" as *byte, input_path);
            return 1;
        }
        var parser: Parser = Parser { lexer: null, current_token: null, arena: null, context: ParserContext.PARSER_CONTEXT_NORMAL };
        if parser_init(&parser, &lexer, &arena) != 0 {
            fprintf(stderr, "错误: Parser 初始化失败: %s\n" as *byte, input_path);
            return 1;
        }
        const ast: &ASTNode = parser_parse(&parser);
        if ast == null {
            fprintf(stderr, "错误: 语法分析失败: %s\n" as *byte, input_path);
            return 1;
        }
        if ast.type != ASTNodeType.AST_PROGRAM {
            fprintf(stderr, "错误: 解析结果不是程序节点: %s\n" as *byte, input_path);
            return 1;
        }
        programs[i] = ast;
        fprintf(stderr, "  解析完成: %s\n" as *byte, input_path);
        i = i + 1;
    }
    fprintf(stderr, "=== 词法/语法分析完成，共 %d 个文件 ===\n" as *byte, input_file_count);

    fprintf(stderr, "=== AST 合并阶段 ===\n" as *byte);
    const merged_ast: &ASTNode = ast_merge_programs(programs, input_file_count, &arena);
    if merged_ast == null {
        fprintf(stderr, "错误: AST 合并失败\n" as *byte);
        return 1;
    }
    fprintf(stderr, "AST 合并完成，共 %d 个声明\n" as *byte, merged_ast.program_decl_count);

    fprintf(stderr, "=== 类型检查阶段 ===\n" as *byte);
    const void_type: Type = Type { kind: TypeKind.TYPE_VOID, enum_name: null, struct_name: null, pointer_to: null, is_ffi_pointer: 0, element_type: null, array_size: 0 };
    var checker: TypeChecker = TypeChecker { arena: null, symbol_table: SymbolTable { slots: [], count: 0 }, function_table: FunctionTable { slots: [], count: 0 }, scope_level: 0, loop_depth: 0, program_node: null, error_count: 0, default_filename: null, current_return_type: void_type, in_function: 0, in_defer_or_errdefer: 0 };
    var default_filename: *byte = "(unknown)" as *byte;
    if input_file_count > 0 {
        default_filename = get_argv(input_file_indices[0]);
    }
    if checker_init(&checker, &arena, default_filename as &byte) != 0 {
        fprintf(stderr, "错误: TypeChecker 初始化失败\n" as *byte);
        return 1;
    }
    if checker_check(&checker, merged_ast) != 0 {
        fprintf(stderr, "错误: 类型检查失败（错误数量: %d）\n" as *byte, checker_get_error_count(&checker));
        const err_msg: &byte = get_last_checker_error();
        if err_msg != null {
            fprintf(stderr, "最后错误: %s\n" as *byte, err_msg as *byte);
        }
        return 1;
    }
    if checker_get_error_count(&checker) > 0 {
        fprintf(stderr, "错误: 类型检查失败（错误数量: %d）\n" as *byte, checker_get_error_count(&checker));
        const err_msg: &byte = get_last_checker_error();
        if err_msg != null {
            fprintf(stderr, "最后错误: %s\n" as *byte, err_msg as *byte);
        }
        return 1;
    }
    fprintf(stderr, "类型检查通过\n" as *byte);

    fprintf(stderr, "=== 代码生成阶段 ===\n" as *byte);
    const first_file_idx: i32 = input_file_indices[0];
    const module_name: *byte = get_argv(first_file_idx);
    fprintf(stderr, "模块名: %s\n" as *byte, module_name);

    if backend == BackendType.BACKEND_C99 {
        const out_file: *void = fopen(output_file, "w" as *byte);
        if out_file == null {
            fprintf(stderr, "错误: 无法打开输出文件 '%s'\n" as *byte, output_file);
            return 1;
        }
        var c99_codegen: C99CodeGenerator = C99CodeGenerator { };
        if c99_codegen_new(&c99_codegen, &arena, out_file, module_name as &byte, emit_line_directives) != 0 {
            fprintf(stderr, "错误: C99CodeGenerator 初始化失败\n" as *byte);
            fclose(out_file);
            return 1;
        }
        if c99_codegen_generate(&c99_codegen, merged_ast, output_file as &byte) != 0 {
            fprintf(stderr, "错误: C99 代码生成失败\n" as *byte);
            c99_codegen_free(&c99_codegen);
            fclose(out_file);
            return 1;
        }
        c99_codegen_free(&c99_codegen);
        fclose(out_file);
        fprintf(stderr, "代码生成完成: %s\n" as *byte, output_file);
    } else {
        fprintf(stderr, "错误: 当前自举版本仅支持 C99 后端（请使用 --c99）\n" as *byte);
        return 1;
    }
    return 0;
}

// 程序入口（由 bridge.c 调用，重命名为 uya_main）
fn uya_main() i32 {
    var input_file_indices: [i32: 64] = [];
    var input_file_count: i32 = 0;
    var output_file_index: i32 = -1;
    var backend: BackendType = BackendType.BACKEND_LLVM;
    var emit_line_directives: i32 = 0;

    if parse_args(&input_file_indices[0], &input_file_count, &output_file_index, &backend, &emit_line_directives) != 0 {
        return 1;
    }
    const result: i32 = compile_files(&input_file_indices[0], input_file_count, output_file_index, backend, emit_line_directives);
    if result != 0 {
        return result;
    }
    return 0;
}
