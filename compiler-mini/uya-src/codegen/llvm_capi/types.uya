// types.uya - 代码生成器 types 模块
// 使用 LLVM C API 生成 LLVM IR 并编译为二进制代码
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

fn codegen_get_base_type(codegen: &CodeGenerator, type_kind: TypeKind) &void {
    if codegen == null {
        return null;
    }
    
    if type_kind == TYPE_I32 {
        // i32 类型映射到 LLVM Int32 类型（全局类型，不依赖context）
        return LLVMInt32Type() as &void;
    } else if type_kind == TYPE_USIZE {
        // usize 类型：平台相关的无符号大小类型
        // 根据目标平台的指针大小确定 usize 的大小
        // 注意：Uya Mini 简化实现，默认使用 64 位（大多数现代平台）
        // 如果需要精确的平台检测，需要调用 LLVM API 获取目标平台信息
        // 这里简化处理，默认返回 64 位类型
        return LLVMInt64Type() as &void;
    } else if type_kind == TYPE_BOOL {
        // bool 类型映射到 LLVM Int1 类型（1位整数，更精确，全局类型）
        return LLVMInt1Type() as &void;
    } else if type_kind == TYPE_BYTE {
        // byte 类型映射到 LLVM Int8 类型（8位无符号整数，全局类型）
        return LLVMInt8Type() as &void;
    } else if type_kind == TYPE_VOID {
        // void 类型映射到 LLVM Void 类型（全局类型）
        return LLVMVoidType() as &void;
    } else {
        // 不支持的类型（如 TYPE_STRUCT）
        return null;
    }
}

fn codegen_get_struct_type(codegen: &CodeGenerator, struct_name: &byte) &void {
    if codegen == null || struct_name == null {
        return null;
    }
    
    // 在结构体类型映射表中查找
    var i: i32 = 0;
    while i < codegen.struct_type_count {
        if strcmp(codegen.struct_types[i].name, struct_name) == 0 {
            return codegen.struct_types[i].llvm_type as &void;
        }
        i = i + 1;
    }
    
    // 未找到
    return null;
}

fn get_llvm_type_from_ast(codegen: &CodeGenerator, type_node: &ASTNode) &void {
    if codegen == null || type_node == null {
        return null;
    }
    
    if type_node.type == AST_TYPE_NAMED {
        // 命名类型（基础类型或结构体类型）
        const type_name: &byte = type_node.type_named_name;
        if type_name == null {
            return null;
        }
        
        // 基础类型
        if strcmp(type_name, "i32") == 0 {
            return codegen_get_base_type(codegen, TYPE_I32);
        } else if strcmp(type_name, "usize") == 0 {
            return codegen_get_base_type(codegen, TYPE_USIZE);
        } else if strcmp(type_name, "bool") == 0 {
            return codegen_get_base_type(codegen, TYPE_BOOL);
        } else if strcmp(type_name, "byte") == 0 {
            return codegen_get_base_type(codegen, TYPE_BYTE);
        } else if strcmp(type_name, "void") == 0 {
            return codegen_get_base_type(codegen, TYPE_VOID);
        }
        
        // 枚举类型或结构体类型
        // 先检查是否是枚举类型（枚举类型在LLVM中就是i32类型）
        const enum_decl: &ASTNode = find_enum_decl(codegen, type_name);
        if enum_decl != null {
            // 枚举类型，返回i32类型（默认底层类型）
            return codegen_get_base_type(codegen, TYPE_I32);
        }
        
        // 结构体类型（必须在注册表中查找）
        return codegen_get_struct_type(codegen, type_name);
    } else if type_node.type == AST_TYPE_POINTER {
        // 指针类型（&T 或 *T）
        // 普通指针和 FFI 指针在 LLVM 中都映射为指针类型
        const pointed_type: &ASTNode = type_node.type_pointer_pointed_type;
        if pointed_type == null {
            return null;
        }
        
        // 递归获取指向的类型的 LLVM 类型
        const pointed_llvm_type: &void = get_llvm_type_from_ast(codegen, pointed_type);
        if pointed_llvm_type == null {
            return null;
        }
        
        // 创建指针类型（地址空间 0，默认）
        return LLVMPointerType(pointed_llvm_type as *void, 0) as &void;
    } else if type_node.type == AST_TYPE_ARRAY {
        // 数组类型（[T: N]）
        const element_type: &ASTNode = type_node.type_array_element_type;
        const size_expr: &ASTNode = type_node.type_array_size_expr;
        if element_type == null || size_expr == null {
            return null;
        }
        
        // 数组大小必须是编译期常量（数字字面量）
        if size_expr.type != AST_NUMBER {
            return null;  // 数组大小必须是编译期常量
        }
        
        const array_size: i32 = size_expr.number_value;
        if array_size < 0 {
            return null;  // 数组大小必须非负
        }
        
        // 递归获取元素类型的 LLVM 类型
        const element_llvm_type: &void = get_llvm_type_from_ast(codegen, element_type);
        if element_llvm_type == null {
            return null;
        }
        
        // 创建数组类型
        return LLVMArrayType(element_llvm_type as *void, array_size) as &void;
    } else {
        // 不支持的类型
        return null;
    }
}

fn codegen_register_struct_type(codegen: &CodeGenerator, struct_decl: &ASTNode) i32 {
    if codegen == null || struct_decl == null || struct_decl.type != AST_STRUCT_DECL {
        return -1;
    }
    
    const struct_name: &byte = struct_decl.struct_decl_name;
    if struct_name == null {
        return -1;
    }
    
    // 检查是否已经注册
    if codegen_get_struct_type(codegen, struct_name) as *void != null {
        return 0;  // 已注册，返回成功
    }
    
    // 检查映射表是否已满
    if codegen.struct_type_count >= STRUCT_TYPE_MAP_SIZE {
        return -1;  // 映射表已满
    }
    
    const field_count: i32 = struct_decl.struct_decl_field_count;
    if field_count < 0 {
        return -1;
    }
    
    // 准备字段类型数组
    // 使用固定大小数组（栈分配，无堆分配）
    // 注意：最多支持16个字段（如果超过需要调整）
    if field_count > 16 {
        return -1;  // 字段数过多
    }
    
    var field_types: [*void: 16] = [];
    var i: i32 = 0;
    
    // 遍历字段，获取每个字段的LLVM类型
    while i < field_count {
        const field: &ASTNode = struct_decl.struct_decl_fields[i];
        if field == null || field.type != AST_VAR_DECL {
            return -1;
        }
        
        const field_type_node: &ASTNode = field.var_decl_type;
        const field_llvm_type: *void = get_llvm_type_from_ast(codegen, field_type_node) as *void;
        if field_llvm_type == null {
            return -1;  // 字段类型无效或未找到（结构体类型需要先注册）
        }
        
        field_types[i] = field_llvm_type;
        i = i + 1;
    }
    
    // 创建LLVM结构体类型
    var struct_type: *void = null;
    if field_count == 0 {
        // 空结构体
        struct_type = LLVMStructTypeInContext(codegen.context, null, 0, 0);
    } else {
        // 非空结构体（packed=0，使用默认对齐）
        // 注意：需要将数组转换为指针传递给 LLVM API
        struct_type = LLVMStructTypeInContext(codegen.context, &field_types[0] as *void, field_count, 0);
    }
    
    if struct_type == null {
        return -1;
    }
    
    // 注册到映射表
    const idx: i32 = codegen.struct_type_count;
    codegen.struct_types[idx].name = struct_name;  // 名称已经在Arena中
    codegen.struct_types[idx].llvm_type = struct_type;
    codegen.struct_types[idx].ast_node = struct_decl;  // 存储 AST 节点引用
    codegen.struct_type_count = codegen.struct_type_count + 1;
    
    return 0;
}

fn codegen_pre_register_struct_types(codegen: &CodeGenerator) void {
    if codegen == null {
        return;
    }

    // 注册 TypeChecker 结构体（在 checker.uya 中定义）
    codegen_register_struct_type_by_name(codegen, "TypeChecker" as &byte);

    // 注册其他已知结构体
    // 注意：这里只注册最基本的结构体，避免依赖关系问题
    // 复杂的结构体将在后续的正常注册过程中处理
}

fn codegen_register_struct_type_by_name(codegen: &CodeGenerator, struct_name: &byte) i32 {
    if codegen == null || struct_name == null {
        return -1;
    }

    // 检查是否已经注册
    var i: i32 = 0;
    while i < codegen.struct_type_count {
        if codegen.struct_types[i].name != null &&
           strcmp(codegen.struct_types[i].name, struct_name) == 0 {
            return 0;  // 已经注册
        }
        i = i + 1;
    }

    // 检查是否有空间
    if codegen.struct_type_count >= STRUCT_TYPE_MAP_SIZE {
        return -1;  // 空间不足
    }

    // 创建空的结构体类型
    const llvm_type: *void = LLVMStructCreateNamed(codegen.context, struct_name);
    if llvm_type == null {
        return -1;
    }

    // 注册到表中
    codegen.struct_types[codegen.struct_type_count].name = struct_name;
    codegen.struct_types[codegen.struct_type_count].llvm_type = llvm_type;
    codegen.struct_types[codegen.struct_type_count].ast_node = null;  // 预注册没有 AST 节点
    codegen.struct_type_count = codegen.struct_type_count + 1;

    return 0;
}

