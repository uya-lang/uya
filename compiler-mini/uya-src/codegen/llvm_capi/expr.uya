// expr.uya - 代码生成器 expr 模块
// 使用 LLVM C API 生成 LLVM IR 并编译为二进制代码
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

fn codegen_gen_struct_comparison(codegen: &CodeGenerator, _left_val: &void, _right_val: &void, struct_decl: &ASTNode, is_equal: i32) &void {
    const left_val:*void = _left_val as *void;
    const right_val:*void = _right_val as *void;
    if codegen == null || left_val == null || right_val == null || struct_decl == null || 
       struct_decl.type != AST_STRUCT_DECL {
        return null;
    }
    
    const field_count: i32 = struct_decl.struct_decl_field_count;
    
    // 处理空结构体（0个字段）
    if field_count == 0 {
        // 空结构体总是相等
        const bool_type: *void = codegen_get_base_type(codegen, TYPE_BOOL) as *void;
        if bool_type == null {
            return null;
        }
        var bool_value: usize = 0;
        if is_equal != 0 {
            bool_value = 1;
        } else {
            bool_value = 0;
        }
        return LLVMConstInt(bool_type, bool_value, 0) as &void;
    }
    
    // 对于每个字段，提取并比较字段值
    // 最多支持16个字段
    if field_count > 16 {
        return null;  // 字段数过多
    }
    
    var field_comparisons: [*void: 16] = [];
    var valid_comparisons: i32 = 0;
    
    var i: i32 = 0;
    while i < field_count {
        const field: &ASTNode = struct_decl.struct_decl_fields[i];
        if field == null || field.type != AST_VAR_DECL {
            return null;
        }
        
        const field_type_node: &ASTNode = field.var_decl_type;
        if field_type_node == null || field_type_node.type != AST_TYPE_NAMED {
            return null;
        }
        
        const field_type_name: &byte = field_type_node.type_named_name;
        if field_type_name == null {
            return null;
        }
        
        // 提取字段值
        const left_field: *void = LLVMBuildExtractValue(codegen.builder, left_val, i, "");
        const right_field: *void = LLVMBuildExtractValue(codegen.builder, right_val, i, "");
        if left_field == null || right_field == null {
            return null;
        }
        
        // 根据字段类型进行比较
        var field_eq: *void = null;
        
        if strcmp(field_type_name, "i32") == 0 || strcmp(field_type_name, "bool") == 0 {
            // 基础类型（i32、bool）：使用整数比较
            field_eq = LLVMBuildICmp(codegen.builder, LLVMIntEQ, left_field, right_field, "");
        } else {
            // 嵌套结构体类型：递归调用结构体比较
            const field_type: *void = LLVMTypeOf(left_field);
            if field_type == null {
                return null;
            }
            const nested_struct_name: &byte = find_struct_name_from_type(codegen, field_type as &void);
            if nested_struct_name == null {
                return null;
            }
            
            const nested_struct_decl: &ASTNode = find_struct_decl(codegen, nested_struct_name);
            if nested_struct_decl == null {
                return null;
            }
            
            // 递归调用结构体比较（使用 == 比较，然后根据 is_equal 决定是否取反）
            field_eq = codegen_gen_struct_comparison(
                codegen,
                left_field as &void,
                right_field as &void,
                nested_struct_decl,
                1  // 使用 == 比较
            ) as *void;
        }
        
        if field_eq == null {
            return null;
        }
        
        field_comparisons[valid_comparisons] = field_eq;
        valid_comparisons = valid_comparisons + 1;
        i = i + 1;
    }
    
    // 组合所有字段比较结果（逻辑与）
    if valid_comparisons == 0 {
        return null;
    }
    
    var result: *void = field_comparisons[0];
    i = 1;
    while i < valid_comparisons {
        result = LLVMBuildAnd(codegen.builder, result, field_comparisons[i], "");
        if result == null {
            return null;
        }
        i = i + 1;
    }
    
    // 如果是 != 比较，对结果取反
    if is_equal == 0 {
        const bool_type: *void = codegen_get_base_type(codegen, TYPE_BOOL) as *void;
        if bool_type == null {
            return null;
        }
        const one: *void = LLVMConstInt(bool_type, 1 as usize, 0) as *void;
        result = LLVMBuildXor(codegen.builder, result, one, "");  // XOR 1 实现取反
    }
    
    return result as &void;
}

fn codegen_gen_expr(codegen: &CodeGenerator, expr: &ASTNode) &void {
    if codegen == null || expr == null || codegen.builder == null {
        return null;
    }
    
    if expr.type == AST_NUMBER {
        // 数字字面量：创建 i32 常量
        const value: i32 = expr.number_value;
        const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32) as *void;
        if i32_type == null {
            return null;
        }
        return LLVMConstInt(i32_type, value as usize, 1) as &void;  // 1 表示有符号
    } else if expr.type == AST_BOOL {
        // 布尔字面量：创建 i1 常量（true=1, false=0）
        const value: i32 = expr.bool_literal_value;
        const bool_type: *void = codegen_get_base_type(codegen, TYPE_BOOL) as *void;
        if bool_type == null {
            return null;
        }
        var bool_value: usize = 0;
        if value != 0 {
            bool_value = 1;
        } else {
            bool_value = 0;
        }
        return LLVMConstInt(bool_type, bool_value, 0) as &void;  // 0 表示无符号（布尔值）
    } else if expr.type == AST_STRING {
        // 字符串字面量：创建全局字符串常量，返回指向它的指针（*byte 类型）
        const str_value: &byte = expr.string_literal_value;
        if str_value == null {
            return null;
        }
        
        // 计算字符串长度（不包括 null 终止符，LLVMConstStringInContext 会自动添加）
        const str_len: i32 = strlen(str_value);
        
        // 创建 i8 数组类型（字符串长度 + 1 个 null 终止符）
        const i8_type: *void = LLVMInt8Type();
        const array_type: *void = LLVMArrayType(i8_type, str_len + 1);
        
        // 创建字符串常量值（LLVMConstStringInContext 会自动添加 null 终止符）
        // 参数：context, string, length, dontNullTerminate
        // dontNullTerminate = 0 表示自动添加 null 终止符
        const str_const: *void = LLVMConstStringInContext(codegen.context, str_value, str_len, 0);
        if str_const == null {
            return null;
        }
        
        // 生成唯一的全局变量名称
        const str_id: i32 = codegen.string_literal_counter;
        codegen.string_literal_counter = codegen.string_literal_counter + 1;
        
        // 创建全局变量名称（使用固定大小数组）
        var global_name: [byte: 64] = [];
        snprintf(&global_name[0] as *byte, 64, "str.%d", str_id);
        
        // 将名称复制到 Arena
        const name_len: i32 = strlen(&global_name[0] as *byte);
        const name_copy: &byte = arena_alloc(codegen.arena, name_len + 1) as &byte;
        if name_copy == null {
            return null;
        }
        memcpy(name_copy as *void, &global_name[0] as *void, name_len + 1);
        
        // 创建全局变量（类型为数组）
        const global_var: *void = LLVMAddGlobal(codegen.module, array_type, name_copy);
        if global_var == null {
            return null;
        }
        
        // 设置初始值为字符串常量
        LLVMSetInitializer(global_var, str_const);
        
        // 设置为常量（不可变）
        LLVMSetGlobalConstant(global_var, 1);
        
        // 设置链接属性（内部链接）
        // 注意：LLVMInternalLinkage 已在 llvm_api.uya 中定义
        LLVMSetLinkage(global_var, LLVMInternalLinkage);
        
        // 全局变量本身就是一个指针，可以直接返回
        return global_var as &void;
    } else if expr.type == AST_IDENTIFIER {
        // 标识符（变量）：从变量表查找并加载值
        const var_name: &byte = expr.identifier_name;
        if var_name == null {
            return null;
        }
        
        // 查找变量（先查找局部变量，再查找全局变量）
        const var_map: &VarMap = lookup_var(codegen, var_name);
        if var_map != null {
            // 局部变量：加载值
            return LLVMBuildLoad2(codegen.builder, var_map.type, var_map.value, var_name) as &void;
        }
        
        // 查找全局变量
        const global_var_map: &GlobalVarMap = lookup_global_var(codegen, var_name);
        if global_var_map != null {
            // 全局变量：加载值
            return LLVMBuildLoad2(codegen.builder, global_var_map.type, global_var_map.global_var, var_name) as &void;
        }
        
        // 检查是否是 null 标识符
        if strcmp(var_name, "null") == 0 {
            // null 标识符：返回 null 指针（类型需要从上下文推断）
            // 注意：这里简化处理，实际实现中需要从上下文获取类型
            // 对于 null，通常需要从比较操作的另一侧获取类型
            return null;  // 需要从上下文推断类型
        }
        
        return null;  // 变量未找到
    } else if expr.type == AST_UNARY_EXPR {
        // 一元表达式（!, -, &, *）
        const operand: &ASTNode = expr.unary_expr_operand;
        if operand == null {
            return null;
        }
        
        const op: TokenType = expr.unary_expr_op;
        
        if op == TokenType.TOKEN_AMPERSAND {
            // 取地址运算符：&expr
            // 操作数必须是左值（变量、字段访问等）
            // 对于标识符（变量），直接从变量表获取指针
            if operand.type == AST_IDENTIFIER {
                const var_name: &byte = operand.identifier_name;
                if var_name == null {
                    return null;
                }
                const var_map: &VarMap = lookup_var(codegen, var_name);
                if var_map == null {
                    // 尝试查找全局变量
                    const global_var_map: &GlobalVarMap = lookup_global_var(codegen, var_name);
                    if global_var_map != null {
                        return global_var_map.global_var as &void;
                    }
                    return null;  // 变量未找到
                }
                // 变量指针已经是地址，直接返回
                return var_map.value as &void;
            }
            // 对于其他表达式（如字段访问、数组访问），尝试使用 lvalue_address 获取左值地址
            const addr: *void = codegen_gen_lvalue_address(codegen, operand);
            if addr != null {
                // 成功获取左值地址，直接返回
                return addr as &void;
            }
            // 如果 lvalue_address 失败，可能是非左值表达式
            // 对于这种情况，先计算表达式值，然后分配临时空间存储值
            const operand_val: *void = codegen_gen_expr(codegen, operand) as *void;
            if operand_val == null {
                return null;
            }
            const operand_type: *void = LLVMTypeOf(operand_val);
            if operand_type == null {
                return null;
            }
            // 使用 alloca 分配临时空间
            const temp_ptr: *void = LLVMBuildAlloca(codegen.builder, operand_type, "");
            if temp_ptr == null {
                return null;
            }
            // store 值到临时空间
            LLVMBuildStore(codegen.builder, operand_val, temp_ptr);
            // 返回临时空间的地址
            return temp_ptr as &void;
        } else if op == TokenType.TOKEN_ASTERISK {
            // 解引用运算符：*expr
            // 操作数必须是指针类型
            // 如果操作数是标识符，从 AST 类型节点获取指向的类型（避免使用 LLVMGetElementType）
            var operand_val: *void = null;
            var pointed_type: *void = null;
            
            if operand.type == AST_IDENTIFIER {
                // 优化：对于标识符，从变量表获取 AST 类型节点，然后从 AST 重新构建指向的类型
                const var_name: &byte = operand.identifier_name;
                if var_name != null {
                    const var_ast_type: &ASTNode = lookup_var_ast_type(codegen, var_name);
                    if var_ast_type != null && var_ast_type.type == AST_TYPE_POINTER {
                        // 从 AST 类型节点获取指向的类型节点
                        const pointed_ast_type: &ASTNode = var_ast_type.type_pointer_pointed_type;
                        if pointed_ast_type != null {
                            // 从 AST 类型节点重新构建指向类型的 LLVM 类型
                            pointed_type = get_llvm_type_from_ast(codegen, pointed_ast_type) as *void;
                            if pointed_type != null {
                                // 需要加载指针变量的值（指针变量本身存储的是指针值）
                                const var_map: &VarMap = lookup_var(codegen, var_name);
                                if var_map != null {
                                    // 加载指针变量的值（即指针值本身）
                                    operand_val = LLVMBuildLoad2(codegen.builder, var_map.type, var_map.value, var_name);
                                }
                            }
                        }
                    }
                }
            }
            
            // 如果优化路径失败，使用通用方法
            if operand_val == null || pointed_type == null {
                operand_val = codegen_gen_expr(codegen, operand) as *void;
                if operand_val == null {
                    return null;
                }
                const operand_type: *void = LLVMTypeOf(operand_val);
                if operand_type == null {
                    return null;
                }
                // 检查操作数类型是否为指针类型
                if LLVMGetTypeKind(operand_type) != LLVMPointerTypeKind {
                    return null;  // 操作数不是指针类型
                }
                // 获取指针指向的类型（通用方法仍然使用 LLVMGetElementType）
                pointed_type = LLVMGetElementType(operand_type);
                if pointed_type == null {
                    return null;
                }
            }
            
            // 使用 LLVMBuildLoad2 加载指针指向的值
            return LLVMBuildLoad2(codegen.builder, pointed_type, operand_val, "") as &void;
        }
        
        // 处理其他一元运算符（!, -）
        const operand_val: *void = codegen_gen_expr(codegen, operand);
        if operand_val == null {
            return null;
        }
        
        // 简化实现：假设操作数类型可以从operand_val获取
        const operand_type: *void = LLVMTypeOf(operand_val);
        if operand_type == null {
            return null;
        }
        
        if op == TokenType.TOKEN_EXCLAMATION {
            // 逻辑非：!operand
            // 对于布尔值（i1），使用 XOR 1
            if LLVMGetTypeKind(operand_type) == LLVMIntegerTypeKind {
                const one: *void = LLVMConstInt(operand_type, 1 as usize, 0) as &void;
                return LLVMBuildXor(codegen.builder, operand_val, one, "") as &void;
            }
        } else if op == TokenType.TOKEN_MINUS {
            // 一元负号：-operand
            // 对于整数，使用 sub 0, operand
            if LLVMGetTypeKind(operand_type) == LLVMIntegerTypeKind {
                const zero: *void = LLVMConstInt(operand_type, 0 as usize, 1) as &void;
                return LLVMBuildSub(codegen.builder, zero, operand_val, "") as &void;
            }
        }
        
        return null;
    } else if expr.type == AST_BINARY_EXPR {
        // 二元表达式（算术、比较、逻辑运算符）
        const left: &ASTNode = expr.binary_expr_left;
        const right: &ASTNode = expr.binary_expr_right;
        if left == null || right == null {
            return null;
        }
        
        const op: TokenType = expr.binary_expr_op;
        
        // 特殊处理逻辑运算符（&&, ||）以实现短路求值
        if op == TokenType.TOKEN_LOGICAL_AND || op == TokenType.TOKEN_LOGICAL_OR {
            // 获取当前基本块
            const current_bb: *void = LLVMGetInsertBlock(codegen.builder);
            if current_bb == null {
                return null;
            }
            
            // 获取当前基本块所在的函数
            const func: *void = LLVMGetBasicBlockParent(current_bb);
            if func == null {
                return null;
            }
            
            // 生成左操作数
            var left_val: *void = codegen_gen_expr(codegen, left) as *void;
            if left_val == null {
                return null;
            }
            
            // 检查左操作数类型是否为i1（布尔类型）
            const left_type: *void = LLVMTypeOf(left_val);
            if left_type == null || LLVMGetTypeKind(left_type) != LLVMIntegerTypeKind || LLVMGetIntTypeWidth(left_type) != 1 {
                fprintf(2 as *void, "错误: 逻辑运算符左操作数必须是布尔类型 (i1)\n");
                return null;
            }
            
            // 创建临时变量来存储结果
            const result: *void = LLVMBuildAlloca(codegen.builder, left_type, "bool_result" as *byte);
            if result == null {
                return null;
            }
            
            // 创建基本块（使用计数器生成唯一名称）
            const bb_id: i32 = codegen.basic_block_counter;
            codegen.basic_block_counter = codegen.basic_block_counter + 1;
            
            var then_name: [byte: 32] = [];
            var else_name: [byte: 32] = [];
            var merge_name: [byte: 32] = [];
            snprintf(&then_name[0] as *byte, 32, "logical_then.%d", bb_id);
            snprintf(&else_name[0] as *byte, 32, "logical_else.%d", bb_id);
            snprintf(&merge_name[0] as *byte, 32, "logical_merge.%d", bb_id);
            const then_bb: *void = LLVMAppendBasicBlock(func, &then_name[0] as *byte);
            const else_bb: *void = LLVMAppendBasicBlock(func, &else_name[0] as *byte);
            const merge_bb: *void = LLVMAppendBasicBlock(func, &merge_name[0] as *byte);
            
            if op == TokenType.TOKEN_LOGICAL_AND {
                // 短路与：if (left) then evaluate right else result = false
                LLVMBuildCondBr(codegen.builder, left_val, then_bb, else_bb);
                
                // then_bb：计算右操作数
                LLVMPositionBuilderAtEnd(codegen.builder, then_bb);
                const right_val: *void = codegen_gen_expr(codegen, right) as *void;
                if right_val == null {
                    return null;
                }
                // 检查右操作数类型是否为i1（布尔类型）
                const right_type: *void = LLVMTypeOf(right_val);
                if right_type == null || LLVMGetTypeKind(right_type) != LLVMIntegerTypeKind || LLVMGetIntTypeWidth(right_type) != 1 {
                    fprintf(2 as *void, "错误: 逻辑运算符右操作数必须是布尔类型 (i1)\n");
                    return null;
                }
                LLVMBuildStore(codegen.builder, right_val, result);
                LLVMBuildBr(codegen.builder, merge_bb);
                
                // else_bb：结果为false
                LLVMPositionBuilderAtEnd(codegen.builder, else_bb);
                LLVMBuildStore(codegen.builder, LLVMConstInt(left_type, 0 as usize, 0) as &void, result);
                LLVMBuildBr(codegen.builder, merge_bb);
            } else if op == TokenType.TOKEN_LOGICAL_OR {
                // 短路或：if (left) then result = true else evaluate right
                LLVMBuildCondBr(codegen.builder, left_val, then_bb, else_bb);
                
                // then_bb：结果为true
                LLVMPositionBuilderAtEnd(codegen.builder, then_bb);
                LLVMBuildStore(codegen.builder, LLVMConstInt(left_type, 1 as usize, 0) as &void, result);
                LLVMBuildBr(codegen.builder, merge_bb);
                
                // else_bb：计算右操作数
                LLVMPositionBuilderAtEnd(codegen.builder, else_bb);
                const right_val: *void = codegen_gen_expr(codegen, right) as *void;
                if right_val == null {
                    return null;
                }
                // 检查右操作数类型是否为i1（布尔类型）
                const right_type: *void = LLVMTypeOf(right_val);
                if right_type == null || LLVMGetTypeKind(right_type) != LLVMIntegerTypeKind || LLVMGetIntTypeWidth(right_type) != 1 {
                    fprintf(2 as *void, "错误: 逻辑运算符右操作数必须是布尔类型 (i1)\n");
                    return null;
                }
                LLVMBuildStore(codegen.builder, right_val, result);
                LLVMBuildBr(codegen.builder, merge_bb);
            }
            
            // merge_bb：加载结果
            LLVMPositionBuilderAtEnd(codegen.builder, merge_bb);
            return LLVMBuildLoad2(codegen.builder, left_type, result, "") as &void;
        }
        
        // 处理其他二元表达式（算术、比较运算符）
        var left_val: *void = codegen_gen_expr(codegen, left) as *void;
        var right_val: *void = codegen_gen_expr(codegen, right) as *void;
        
        // 如果其中一个操作数生成失败，尝试处理 null 标识符
        if left_val == null && left.type == AST_IDENTIFIER {
            const left_name: &byte = left.identifier_name;
            if left_name != null && strcmp(left_name, "null") == 0 {
                // left 是 null 标识符，需要从 right 获取类型
                if right_val != null {
                    const right_type: *void = LLVMTypeOf(right_val);
                    if right_type != null && LLVMGetTypeKind(right_type) == LLVMPointerTypeKind {
                        left_val = LLVMConstNull(right_type);
                    }
                }
            }
        }
        if right_val == null && right.type == AST_IDENTIFIER {
            const right_name: &byte = right.identifier_name;
            if right_name != null && strcmp(right_name, "null") == 0 {
                // right 是 null 标识符，需要从 left 获取类型
                if left_val != null {
                    const left_type: *void = LLVMTypeOf(left_val);
                    if left_type != null && LLVMGetTypeKind(left_type) == LLVMPointerTypeKind {
                        right_val = LLVMConstNull(left_type);
                    }
                }
            }
        }
        
        if left_val == null || right_val == null {
            return null;
        }
        
        // 获取操作数类型
        const left_type: *void = LLVMTypeOf(left_val);
        const right_type: *void = LLVMTypeOf(right_val);
        if left_type == null || right_type == null {
            return null;
        }
        
        // 算术运算符和比较运算符（支持 i32 和 usize 混合运算）
        if LLVMGetTypeKind(left_type) == LLVMIntegerTypeKind && 
           LLVMGetTypeKind(right_type) == LLVMIntegerTypeKind {
            
            // 类型提升：如果操作数类型不同，将 i32 提升为 usize
            const left_width: i32 = LLVMGetIntTypeWidth(left_type);
            const right_width: i32 = LLVMGetIntTypeWidth(right_type);
            
            // 获取 usize 类型（用于类型提升）
            const usize_type: *void = codegen_get_base_type(codegen, TYPE_USIZE) as *void;
            if usize_type == null {
                return null;
            }
            const usize_width: i32 = LLVMGetIntTypeWidth(usize_type);
            
            // 标记是否至少有一个操作数是 usize（用于决定使用有符号还是无符号运算）
            var is_usize_op: i32 = 0;
            
            // 如果左操作数是 i32，右操作数是 usize，将左操作数提升为 usize
            if left_width == 32 && right_width == usize_width {
                left_val = LLVMBuildZExt(codegen.builder, left_val, usize_type, "");
                is_usize_op = 1;
            }
            // 如果左操作数是 usize，右操作数是 i32，将右操作数提升为 usize
            else if left_width == usize_width && right_width == 32 {
                right_val = LLVMBuildZExt(codegen.builder, right_val, usize_type, "");
                is_usize_op = 1;
            }
            // 如果两个操作数都是 usize
            else if left_width == usize_width && right_width == usize_width {
                is_usize_op = 1;
            }
            
            // 算术运算符（i32 或 usize）
            if op == TokenType.TOKEN_PLUS {
                return LLVMBuildAdd(codegen.builder, left_val, right_val, "") as &void;
            } else if op == TokenType.TOKEN_MINUS {
                return LLVMBuildSub(codegen.builder, left_val, right_val, "") as &void;
            } else if op == TokenType.TOKEN_ASTERISK {
                return LLVMBuildMul(codegen.builder, left_val, right_val, "") as &void;
            } else if op == TokenType.TOKEN_SLASH {
                // 除法：根据操作数类型选择有符号或无符号除法
                if is_usize_op != 0 {
                    return LLVMBuildUDiv(codegen.builder, left_val, right_val, "") as &void;
                } else {
                    return LLVMBuildSDiv(codegen.builder, left_val, right_val, "") as &void;
                }
            } else if op == TokenType.TOKEN_PERCENT {
                // 取模：根据操作数类型选择有符号或无符号取模
                if is_usize_op != 0 {
                    return LLVMBuildURem(codegen.builder, left_val, right_val, "") as &void;
                } else {
                    return LLVMBuildSRem(codegen.builder, left_val, right_val, "") as &void;
                }
            }
            // 比较运算符（返回 i1 布尔值）
            else if op == TokenType.TOKEN_EQUAL {
                // 相等比较：根据操作数类型选择有符号或无符号比较
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntEQ, left_val, right_val, "") as &void;
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntEQ, left_val, right_val, "") as &void;
                }
            } else if op == TokenType.TOKEN_NOT_EQUAL {
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntNE, left_val, right_val, "") as &void;
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntNE, left_val, right_val, "") as &void;
                }
            } else if op == TokenType.TOKEN_LESS {
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntULT, left_val, right_val, "") as &void;
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntSLT, left_val, right_val, "") as &void;
                }
            } else if op == TokenType.TOKEN_GREATER {
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntUGT, left_val, right_val, "") as &void;
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntSGT, left_val, right_val, "") as &void;
                }
            } else if op == TokenType.TOKEN_LESS_EQUAL {
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntULE, left_val, right_val, "") as &void;
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntSLE, left_val, right_val, "") as &void;
                }
            } else if op == TokenType.TOKEN_GREATER_EQUAL {
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntUGE, left_val, right_val, "") as &void;
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntSGE, left_val, right_val, "") as &void;
                }
            }
        }
        
        // 指针比较（==, !=）
        if LLVMGetTypeKind(left_type) == LLVMPointerTypeKind && 
           LLVMGetTypeKind(right_type) == LLVMPointerTypeKind {
            if op == TokenType.TOKEN_EQUAL {
                return LLVMBuildICmp(codegen.builder, LLVMIntEQ, left_val, right_val, "") as &void;
            } else if op == TokenType.TOKEN_NOT_EQUAL {
                return LLVMBuildICmp(codegen.builder, LLVMIntNE, left_val, right_val, "") as &void;
            }
            // 指针不支持其他比较运算符（<, >, <=, >=）
            return null;
        }
        
        // 结构体比较运算符（仅支持 == 和 !=）
        if LLVMGetTypeKind(left_type) == LLVMStructTypeKind &&
           LLVMGetTypeKind(right_type) == LLVMStructTypeKind {
            
            // 仅支持 == 和 != 运算符
            if op == TokenType.TOKEN_EQUAL || op == TokenType.TOKEN_NOT_EQUAL {
                // 从LLVM类型查找结构体名称
                const struct_name: &byte = find_struct_name_from_type(codegen, left_type as &void);
                if struct_name == null {
                    return null;
                }
                
                // 查找结构体声明
                const struct_decl: &ASTNode = find_struct_decl(codegen, struct_name);
                if struct_decl == null {
                    return null;
                }
                
                // 调用结构体比较函数
                var is_equal: i32 = 0;
                if op == TokenType.TOKEN_EQUAL {
                    is_equal = 1;
                } else {
                    is_equal = 0;
                }
                return codegen_gen_struct_comparison(
                    codegen,
                    left_val as &void,
                    right_val as &void,
                    struct_decl,
                    is_equal
                );
            }
            // 结构体不支持其他比较运算符（<, >, <=, >=）
            return null;
        }
        
        return null;
    } else if expr.type == AST_CALL_EXPR {
        // 函数调用表达式
        const callee: &ASTNode = expr.call_expr_callee;
        if callee == null || callee.type != AST_IDENTIFIER {
            return null;
        }
        
        const func_name: &byte = callee.identifier_name;
        if func_name == null {
            return null;
        }
        
        // 查找函数
        var func_type: *void = null;
        var func: *void = null;
        const func_map: &FuncMap = lookup_func(codegen, func_name, func_type as &void);
        if func_map != null {
            func = func_map.func;
            func_type = func_map.func_type;
        } else {
            // 函数未在函数表中找到，尝试查找外部函数
            func = LLVMGetNamedFunction(codegen.module, func_name);
            if func != null {
                // 找到外部函数，获取函数类型
                func_type = LLVMTypeOf(func);
                if func_type == null {
                    return null;  // 无法获取函数类型
                }
                // 注意：LLVMTypeOf 对于函数值返回的是函数类型，可以直接使用
            } else {
                return null;  // 函数未找到
            }
        }
        
        // 生成参数值
        const arg_count: i32 = expr.call_expr_arg_count;
        if arg_count > MAX_FUNC_PARAMS {
            return null;  // 参数过多
        }
        
        // 获取函数参数类型（用于类型检查和转换）
        // 使用 LLVMGetParam 获取参数，然后 LLVMTypeOf 获取类型
        var param_types: [*void: MAX_FUNC_PARAMS] = [];
        var i: i32 = 0;
        while i < arg_count {
            const param: *void = LLVMGetParam(func, i);
            if param != null {
                param_types[i] = LLVMTypeOf(param);
            } else {
                param_types[i] = null;
            }
            i = i + 1;
        }
        
        var arg_values: [*void: MAX_FUNC_PARAMS] = [];
        i = 0;
        while i < arg_count {
            // 直接访问固定大小数组，不需要嵌套指针
            const arg_expr: &ASTNode = expr.call_expr_args[i];
            if arg_expr == null {
                return null;
            }
            var arg_val: *void = codegen_gen_expr(codegen, arg_expr) as *void;
            if arg_val == null {
                return null;
            }
            
            // 检查参数类型是否匹配，如果不匹配则进行类型转换
            const param_type: *void = param_types[i];
            if param_type != null {
                const arg_type: *void = LLVMTypeOf(arg_val);
                if arg_type != null && arg_type != param_type {
                    // 类型不匹配，需要进行类型转换
                    const param_type_kind: i32 = LLVMGetTypeKind(param_type);
                    const arg_type_kind: i32 = LLVMGetTypeKind(arg_type);
                    
                    if param_type_kind == LLVMIntegerTypeKind && arg_type_kind == LLVMIntegerTypeKind {
                        // 整数类型之间的转换
                        const param_width: i32 = LLVMGetIntTypeWidth(param_type);
                        const arg_width: i32 = LLVMGetIntTypeWidth(arg_type);
                        
                        if param_width < arg_width {
                            // 截断转换（例如 i32 -> i8）
                            arg_val = LLVMBuildTrunc(codegen.builder, arg_val, param_type, "");
                        } else if param_width > arg_width {
                            // 零扩展转换（例如 i8 -> i32，byte 是无符号的，使用零扩展）
                            arg_val = LLVMBuildZExt(codegen.builder, arg_val, param_type, "");
                        }
                        // 如果宽度相同，类型应该相同，不需要转换
                    } else if param_type_kind == LLVMPointerTypeKind {
                        if arg_type_kind == LLVMPointerTypeKind {
                            // 指针类型到指针类型：使用 bitcast 进行转换
                            // 在 LLVM 中，相同地址空间的指针可以通过 bitcast 转换
                            arg_val = LLVMBuildBitCast(codegen.builder, arg_val, param_type, "");
                        } else if arg_type_kind == LLVMArrayTypeKind {
                            // 数组类型到指针类型：数组值需要先转换为指针
                            // 在 LLVM 中，数组值不能直接转换为指针，需要先 alloca 然后获取地址
                            // 但这里我们简化处理：如果参数类型是指针，而实际参数是数组值，
                            // 说明代码生成有问题，应该返回错误
                            // 注意：数组字面量应该返回指针而不是值，或者数组变量应该返回指针
                            // 这里暂时跳过，让 LLVM 验证失败来发现这个问题
                            // TODO: 修复数组字面量和数组变量的代码生成，确保返回指针
                        }
                    }
                    // 其他类型不匹配的情况：结构体、数组等需要完全匹配，不能转换
                }
            }
            
            arg_values[i] = arg_val;
            i = i + 1;
        }
        
        // 调用函数（LLVM 18 使用 LLVMBuildCall2）
        return LLVMBuildCall2(codegen.builder, func_type, func, &arg_values[0] as *void, arg_count, "") as &void;
    } else if expr.type == AST_MEMBER_ACCESS {
        // 字段访问或枚举值访问：使用 GEP + Load 获取字段值，或返回枚举值常量
        const object: &ASTNode = expr.member_access_object;
        const field_name: &byte = expr.member_access_field_name;
        
        if object == null || field_name == null {
            return null;
        }
        
        // 检查是否是枚举值访问（EnumName.Variant）
        // 如果对象是标识符且不是变量，可能是枚举类型名称
        if object.type == AST_IDENTIFIER {
            const enum_name: &byte = object.identifier_name;
            if enum_name != null {
                // 检查是否是枚举类型名称（先检查变量表，如果不是变量，可能是枚举类型）
                const var_map: &VarMap = lookup_var(codegen, enum_name);
                if var_map == null {
                    // 不是变量，可能是枚举类型名称
                    const enum_decl: &ASTNode = find_enum_decl(codegen, enum_name);
                    if enum_decl != null {
                        // 是枚举类型，查找变体索引
                        const variant_index: i32 = find_enum_variant_index(enum_decl, field_name);
                        if variant_index >= 0 {
                            // 获取枚举值（显式值或计算值）
                            const enum_value: i32 = get_enum_variant_value(enum_decl, variant_index);
                            if enum_value < 0 {
                                return null;
                            }
                            
                            // 找到变体，返回i32常量
                            const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32) as *void;
                            if i32_type == null {
                                return null;
                            }
                            return LLVMConstInt(i32_type, enum_value as usize, 0) as &void;
                        }
                        // 变体不存在
                        return null;
                    }
                }
            }
        }
        
        // 如果对象是标识符（变量），从变量表获取结构体名称
        var struct_name: &byte = null;
        var object_ptr: *void = null;
        
        if object.type == AST_IDENTIFIER {
            const var_name: &byte = object.identifier_name;
            if var_name != null {
                const var_map: &VarMap = lookup_var(codegen, var_name);
                if var_map != null {
                    object_ptr = var_map.value;
                    struct_name = lookup_var_struct_name(codegen, var_name);
                    
                    // 检查变量类型是否是指针类型（无论 struct_name 是否设置）
                    const var_ast_type: &ASTNode = lookup_var_ast_type(codegen, var_name);
                    if var_ast_type != null && var_ast_type.type == AST_TYPE_POINTER {
                        // 变量是指针类型，需要加载指针值
                        const var_type: *void = lookup_var_type(codegen, var_name) as *void;
                        if var_type != null && object_ptr != null {
                            // 加载指针变量的值（即指针值本身）
                            object_ptr = LLVMBuildLoad2(codegen.builder, var_type, object_ptr, var_name);
                            
                            // 从指针类型中获取指向的结构体类型名称
                            const pointed_type: &ASTNode = var_ast_type.type_pointer_pointed_type;
                            if pointed_type != null && pointed_type.type == AST_TYPE_NAMED {
                                struct_name = pointed_type.type_named_name;
                            }
                        }
                    }
                } else {
                    // 尝试查找全局变量
                    const global_var_map: &GlobalVarMap = lookup_global_var(codegen, var_name);
                    if global_var_map != null {
                        object_ptr = global_var_map.global_var;
                        struct_name = global_var_map.struct_name;
                    }
                }
            }
        }
        
        if object_ptr == null {
            // 对象不是标识符或变量未找到，生成对象表达式
            const object_val: *void = codegen_gen_expr(codegen, object) as *void;
            if object_val == null {
                return null;
            }
            
            // 对于非标识符对象（如结构体字面量、嵌套字段访问），需要先 store 到临时变量
            // 获取对象类型
            const object_type: *void = LLVMTypeOf(object_val);
            if object_type == null {
                return null;
            }
            
            // 确定实际的结构体类型（用于查找结构体名称和 GEP）
            var actual_struct_type: *void = null;
            if LLVMGetTypeKind(object_type) == LLVMPointerTypeKind {
                // 对象是指针类型，获取指向的类型
                actual_struct_type = LLVMGetElementType(object_type);
            } else if LLVMGetTypeKind(object_type) == LLVMStructTypeKind {
                // 对象是结构体类型
                actual_struct_type = object_type;
            }
            
            // 使用 alloca 分配临时空间（使用对象类型）
            object_ptr = LLVMBuildAlloca(codegen.builder, object_type, "");
            if object_ptr == null {
                return null;
            }
            
            // store 对象值到临时变量
            LLVMBuildStore(codegen.builder, object_val, object_ptr);
            
            // 获取结构体名称
            if object.type == AST_STRUCT_INIT {
                // 对于结构体字面量，可以从 AST 获取结构体名称
                struct_name = object.struct_init_struct_name;
            } else if struct_name == null {
                // 对于嵌套字段访问等其他情况，尝试从 LLVM 类型中查找结构体名称
                if actual_struct_type != null && LLVMGetTypeKind(actual_struct_type) == LLVMStructTypeKind {
                    struct_name = find_struct_name_from_type(codegen, actual_struct_type as &void);
                }
            }
        }
        
        if struct_name == null {
            return null;  // 无法确定结构体名称
        }
        
        // 查找结构体声明
        const struct_decl: &ASTNode = find_struct_decl(codegen, struct_name);
        if struct_decl == null {
            return null;
        }
        
        // 查找字段索引
        const field_index: i32 = find_struct_field_index(struct_decl, field_name);
        if field_index < 0 {
            return null;  // 字段不存在
        }
        
        // 获取结构体类型
        const struct_type: *void = codegen_get_struct_type(codegen, struct_name) as *void;
        if struct_type == null {
            return null;
        }
        
        // 确定用于 GEP 的指针值
        // 如果 object_ptr 是指向指针的指针（即对象是指针类型），需要先加载
        var gep_base: *void = object_ptr;
        const object_ptr_type: *void = LLVMTypeOf(object_ptr);
        if object_ptr_type != null && LLVMGetTypeKind(object_ptr_type) == LLVMPointerTypeKind {
            const pointed_type: *void = LLVMGetElementType(object_ptr_type);
            if pointed_type != null && LLVMGetTypeKind(pointed_type) == LLVMPointerTypeKind {
                // object_ptr 是指向指针的指针，需要先加载
                gep_base = LLVMBuildLoad2(codegen.builder, pointed_type, object_ptr, "");
                if gep_base == null {
                    return null;
                }
            }
        }
        
        // 使用 GEP 获取字段地址
        const i32_type: *void = LLVMInt32Type();
        const indices: [*void: 2] = [
            LLVMConstInt(i32_type, 0 as usize, 0) as &void,  // 结构体指针本身
            LLVMConstInt(i32_type, field_index as usize, 0) as &void  // 字段索引
        ];
        
        const field_ptr: *void = LLVMBuildGEP2(codegen.builder, struct_type, gep_base, &indices[0] as *void, 2, "");
        if field_ptr == null {
            return null;
        }
        
        // 获取字段类型（从结构体声明中）
        if field_index >= struct_decl.struct_decl_field_count {
            return null;
        }
        const field: &ASTNode = struct_decl.struct_decl_fields[field_index];
        if field == null || field.type != AST_VAR_DECL {
            return null;
        }
        const field_type_node: &ASTNode = field.var_decl_type;
        const field_type: *void = get_llvm_type_from_ast(codegen, field_type_node);
        if field_type == null {
            return null;
        }
        
        // load 字段值
        return LLVMBuildLoad2(codegen.builder, field_type, field_ptr, "") as &void;
    } else if expr.type == AST_ARRAY_ACCESS {
        // 数组访问：复用左值地址生成逻辑，再进行 load
        const element_ptr: *void = codegen_gen_lvalue_address(codegen, expr) as *void;
        if element_ptr == null {
            return null;
        }
        
        if element_ptr == 1 as *void {
            return null;
        }
        
        const element_ptr_type: *void = LLVMTypeOf(element_ptr);
        if element_ptr_type == null {
            return null;
        }
        
        const element_ptr_type_kind: i32 = LLVMGetTypeKind(element_ptr_type);
        if element_ptr_type_kind != LLVMPointerTypeKind {
            return null;
        }
        
        // 尝试从数组表达式的类型获取元素类型
        var element_type: *void = null;
        const array_expr: &ASTNode = expr.array_access_array;
        
        // 优先从指针类型获取元素类型（这是最可靠的方法）
        element_type = LLVMGetElementType(element_ptr_type);
        if element_type != null && element_type != 1 as *void {
            // 检查获取的类型是否是数组类型
            // 如果是数组类型，需要递归获取其元素类型（处理嵌套数组）
            var current_type: *void = element_type;
            while current_type != null && LLVMGetTypeKind(current_type) == LLVMArrayTypeKind {
                current_type = LLVMGetElementType(current_type);
                if current_type == null || current_type == 1 as *void {
                    break;
                }
            }
            if current_type != null && current_type != 1 as *void {
                element_type = current_type;
            }
        } else {
            element_type = null;  // 重置，尝试其他方法
        }
        
        // 如果从指针类型获取失败，尝试从变量表或AST获取
        if element_type == null {
            if array_expr != null && array_expr.type == AST_IDENTIFIER {
                // 数组表达式是标识符，从变量表获取类型
                const array_var_name: &byte = array_expr.identifier_name;
                if array_var_name != null {
                    const array_type: *void = lookup_var_type(codegen, array_var_name);
                    if array_type != null {
                        const array_type_kind: i32 = LLVMGetTypeKind(array_type);
                        if array_type_kind == LLVMArrayTypeKind {
                            // 从数组类型获取元素类型
                            element_type = LLVMGetElementType(array_type);
                        } else if array_type_kind == LLVMPointerTypeKind {
                            // 变量类型是指针类型，从 AST 获取指向的类型
                            const var_ast_type: &ASTNode = lookup_var_ast_type(codegen, array_var_name);
                            if var_ast_type != null && var_ast_type.type == AST_TYPE_POINTER {
                                const pointed_type_node: &ASTNode = var_ast_type.type_pointer_pointed_type;
                                if pointed_type_node != null {
                                    // 如果指向的类型是数组类型，获取元素类型
                                    if pointed_type_node.type == AST_TYPE_ARRAY {
                                        const element_type_node: &ASTNode = pointed_type_node.type_array_element_type;
                                        if element_type_node != null {
                                            element_type = get_llvm_type_from_ast(codegen, element_type_node) as *void;
                                        }
                                    } else {
                                        // 指向的类型不是数组类型，直接使用指向的类型作为元素类型
                                        element_type = get_llvm_type_from_ast(codegen, pointed_type_node) as *void;
                                    }
                                }
                            }
                        }
                    }
                }
            } else if array_expr != null && array_expr.type == AST_ARRAY_ACCESS {
                // 嵌套数组访问：递归获取类型
                // 找到最底层的标识符
                var current_expr: &ASTNode = array_expr;
                var depth: i32 = 0;
                const max_depth: i32 = 10;  // 防止无限递归
                
                while current_expr != null && current_expr.type == AST_ARRAY_ACCESS && depth < max_depth {
                    current_expr = current_expr.array_access_array;
                    depth = depth + 1;
                }
                
                if current_expr != null && current_expr.type == AST_IDENTIFIER {
                    const base_var_name: &byte = current_expr.identifier_name;
                    if base_var_name != null {
                        const base_var_type: *void = lookup_var_type(codegen, base_var_name);
                        if base_var_type != null && LLVMGetTypeKind(base_var_type) == LLVMArrayTypeKind {
                            // 递归获取元素类型（根据嵌套深度）
                            var current_type: *void = base_var_type;
                            var i: i32 = 0;
                            while i < depth && current_type != null {
                                if LLVMGetTypeKind(current_type) == LLVMArrayTypeKind {
                                    current_type = LLVMGetElementType(current_type);
                                } else {
                                    break;
                                }
                                i = i + 1;
                            }
                            if current_type != null && LLVMGetTypeKind(current_type) == LLVMArrayTypeKind {
                                // 当前类型是数组，获取其元素类型
                                element_type = LLVMGetElementType(current_type);
                            } else if current_type != null {
                                // 当前类型不是数组，就是元素类型
                                element_type = current_type;
                            }
                        }
                    }
                }
            }
        }
        
        // 如果所有方法都失败，报告错误
        if element_type == null {
            var filename: &byte = expr.filename;
            if filename == null {
                filename = "<unknown>" as &byte;
            }
            fprintf(2 as *void, "错误: 无法获取数组元素类型 (%s:%d:%d)\n", 
                    filename as *byte, expr.line, expr.column);
            return null;
        }
        
        const load_result: *void = LLVMBuildLoad2(codegen.builder, element_type, element_ptr, "");
        if load_result == null {
            return null;
        }
        
        return load_result as &void;
    } else if expr.type == AST_STRUCT_INIT {
        // 结构体字面量：使用 alloca + store 创建结构体值
        const struct_name: &byte = expr.struct_init_struct_name;
        const field_count: i32 = expr.struct_init_field_count;
        // 直接访问固定大小数组，不需要嵌套指针变量
        
        if struct_name == null {
            return null;
        }
        
        // 获取结构体类型
        const struct_type: *void = codegen_get_struct_type(codegen, struct_name) as *void;
        if struct_type == null {
            return null;
        }
        
        // 查找结构体声明（用于字段索引映射）
        const struct_decl: &ASTNode = find_struct_decl(codegen, struct_name);
        if struct_decl == null {
            return null;
        }
        
        // 使用 alloca 分配栈空间
        const struct_ptr: *void = LLVMBuildAlloca(codegen.builder, struct_type, "" as *byte);
        if struct_ptr == null {
            return null;
        }
        
        // 生成每个字段的值并 store 到结构体中
        // 注意：字段值需要按照结构体声明中的字段顺序存储
        // 但 AST_STRUCT_INIT 中的字段可能是任意顺序的（使用字段名称）
        // 所以我们需要根据字段名称找到字段索引
        
        if field_count > 16 {
            return null;  // 字段数过多
        }
        
        // 为每个字段生成值并 store
        // 使用 GEP (GetElementPtr) 获取每个字段的地址，然后 store 字段值
        var i: i32 = 0;
        while i < field_count {
            const field_name: &byte = expr.struct_init_field_names[i];
            const field_value: &ASTNode = expr.struct_init_field_values[i];
            
            if field_name == null || field_value == null {
                return null;
            }
            
            // 查找字段索引
            const field_index: i32 = find_struct_field_index(struct_decl, field_name);
            if field_index < 0 {
                return null;  // 字段不存在
            }
            
            // 生成字段值
            const field_val: *void = codegen_gen_expr(codegen, field_value);
            if field_val == null {
                return null;
            }
            
            // 使用 GEP 获取字段地址（字段索引是 unsigned int）
            const i32_type: *void = LLVMInt32Type();
            const indices: [*void: 2] = [
                LLVMConstInt(i32_type, 0 as usize, 0) as &void,  // 结构体指针本身
                LLVMConstInt(i32_type, field_index as usize, 0) as &void  // 字段索引
            ];

            const field_ptr: *void = LLVMBuildGEP2(codegen.builder, struct_type, struct_ptr, &indices[0] as *void, 2, "" as *byte);
            if field_ptr == null {
                return null;
            }
            
            // store 字段值到字段地址
            LLVMBuildStore(codegen.builder, field_val, field_ptr);
            
            i = i + 1;
        }
        
        // 返回结构体值（load 结构体指针）
        return LLVMBuildLoad2(codegen.builder, struct_type, struct_ptr, "" as *byte) as &void;
    } else if expr.type == AST_ARRAY_LITERAL {
        // 数组字面量：使用 alloca + store 创建数组值
        const element_count: i32 = expr.array_literal_element_count;
        // 直接访问固定大小数组，不需要嵌套指针变量
        
        if element_count == 0 {
            // 空数组：无法推断类型，返回null
            return null;
        }
        
        // 从第一个元素生成值以推断元素类型
        const first_element_val: *void = codegen_gen_expr(codegen, expr.array_literal_elements[0]);
        if first_element_val == null {
            return null;
        }
        
        const element_type: *void = LLVMTypeOf(first_element_val);
        if element_type == null {
            return null;
        }
        
        // 创建数组类型
        const array_type: *void = LLVMArrayType(element_type, element_count);
        if array_type == null {
            return null;
        }
        
        // 使用 alloca 分配数组空间
        const array_ptr: *void = LLVMBuildAlloca(codegen.builder, array_type, "" as *byte);
        if array_ptr == null {
            return null;
        }
        
        // 为每个元素生成值并 store 到数组中
        var i: i32 = 0;
        while i < element_count {
            const element: &ASTNode = expr.array_literal_elements[i];
            if element == null {
                return null;
            }
            
            // 生成元素值
            const element_val: *void = codegen_gen_expr(codegen, element);
            if element_val == null {
                return null;
            }
            
            // 使用 GEP 获取元素地址
            const i32_type: *void = LLVMInt32Type();
            const indices: [*void: 2] = [
                LLVMConstInt(i32_type, 0 as usize, 0) as &void,  // 数组指针本身
                LLVMConstInt(i32_type, i as usize, 0) as &void  // 元素索引
            ];
            
            const element_ptr: *void = LLVMBuildGEP2(codegen.builder, array_type, array_ptr, &indices[0] as *void, 2, "" as *byte);
            if element_ptr == null {
                return null;
            }
            
            // store 元素值到元素地址
            LLVMBuildStore(codegen.builder, element_val, element_ptr);
            
            i = i + 1;
        }
        
        // 返回数组值（load 数组指针）
        return LLVMBuildLoad2(codegen.builder, array_type, array_ptr, "" as *byte) as &void;
    } else if expr.type == AST_SIZEOF {
        // sizeof 表达式：返回类型大小（i32 常量）
        const target: &ASTNode = expr.sizeof_expr_target;
        const is_type: i32 = expr.sizeof_expr_is_type;
        
        if target == null {
            return null;
        }
        
        var llvm_type: *void = null;
        
        if is_type != 0 {
            // target 是类型节点
            llvm_type = get_llvm_type_from_ast(codegen, target) as *void;
        } else {
            // target 是表达式节点，需要获取类型而不生成代码
            // 对于标识符（变量），直接从变量表获取类型
            if target.type == AST_IDENTIFIER {
                const var_name: &byte = target.identifier_name;
                if var_name == null {
                    return null;
                }
                llvm_type = lookup_var_type(codegen, var_name) as *void;
                // 如果变量表中找不到，可能是枚举类型或结构体类型名称（在 sizeof 中）
                // 尝试作为类型名称处理
                if llvm_type == null {
                    // 先检查是否是枚举类型（枚举类型在LLVM中就是i32类型）
                    const enum_decl: &ASTNode = find_enum_decl(codegen, var_name);
                    if enum_decl != null {
                        llvm_type = codegen_get_base_type(codegen, TYPE_I32) as *void;
                    } else {
                        // 检查是否是结构体类型
                        const struct_type: *void = codegen_get_struct_type(codegen, var_name);
                        if struct_type != null {
                            llvm_type = struct_type;
                        } else {
                            return null;
                        }
                    }
                }
            } else if target.type == AST_ARRAY_ACCESS {
                // 数组访问表达式（如 arr2d[0]）：获取元素类型
                // 先获取数组表达式的类型
                const array_expr: &ASTNode = target.array_access_array;
                if array_expr == null {
                    return null;
                }
                
                var array_type: *void = null;
                if array_expr.type == AST_IDENTIFIER {
                    const var_name: &byte = array_expr.identifier_name;
                    if var_name != null {
                        array_type = lookup_var_type(codegen, var_name) as *void;
                    }
                } else {
                    // 对于嵌套数组访问，需要递归处理
                    // 生成数组表达式的值以获取类型
                    const array_val: *void = codegen_gen_expr(codegen, array_expr);
                    if array_val == null {
                        return null;
                    }
                    array_type = LLVMTypeOf(array_val);
                }
                
                if array_type == null {
                    return null;
                }
                
                // 获取元素类型
                const array_type_kind: i32 = LLVMGetTypeKind(array_type);
                if array_type_kind == LLVMArrayTypeKind {
                    // 数组类型：获取元素类型
                    llvm_type = LLVMGetElementType(array_type);
                } else if array_type_kind == LLVMPointerTypeKind {
                    // 指针类型：获取指向的类型
                    const pointed_type: *void = LLVMGetElementType(array_type);
                    if pointed_type != null && LLVMGetTypeKind(pointed_type) == LLVMArrayTypeKind {
                        // 指向数组的指针：获取数组元素类型
                        llvm_type = LLVMGetElementType(pointed_type);
                    } else {
                        // 指向单个元素的指针：元素类型就是指向的类型
                        llvm_type = pointed_type;
                    }
                } else {
                    return null;
                }
            } else {
                // 对于其他表达式类型，生成代码以获取类型
                const target_val: *void = codegen_gen_expr(codegen, target);
                if target_val == null {
                    return null;
                }
                llvm_type = LLVMTypeOf(target_val);
            }
        }
        
        if llvm_type == null {
            return null;
        }
        
        // 获取类型大小（字节数）
        // 注意：这里使用简化实现，对于基础类型直接返回常量
        // 对于复杂类型（结构体、数组），需要使用 TargetData 获取准确大小
        var size: usize = 0;
        
        const kind: i32 = LLVMGetTypeKind(llvm_type);
        if kind == LLVMIntegerTypeKind {
            // 整数类型：根据位宽计算字节数
            const width: i32 = LLVMGetIntTypeWidth(llvm_type);
            size = ((width + 7) / 8) as usize;  // 向上取整到字节
        } else if kind == LLVMPointerTypeKind {
            // 指针类型：使用 TargetData API 获取指针大小（平台相关）
            // 注意：DataLayout 应该在 codegen_generate() 的第零步就已经设置
            const target_data: *void = LLVMGetModuleDataLayout(codegen.module);
            if target_data == null {
                // 如果无法获取 TargetData，返回错误（不应该发生，因为 DataLayout 已设置）
                return null;
            }
            size = LLVMPointerSize(target_data) as usize;
        } else if kind == LLVMArrayTypeKind {
            // 数组类型：元素大小 * 元素数量
            const element_type: *void = LLVMGetElementType(llvm_type);
            const element_count: i32 = LLVMGetArrayLength(llvm_type);
            // 获取元素大小（递归计算）
            const element_kind: i32 = LLVMGetTypeKind(element_type);
            var element_size: usize = 0;
            if element_kind == LLVMIntegerTypeKind {
                const width: i32 = LLVMGetIntTypeWidth(element_type);
                element_size = ((width + 7) / 8) as usize;
            } else if element_kind == LLVMPointerTypeKind {
                // 指针类型：使用 TargetData API 获取指针大小（平台相关）
                const target_data: *void = LLVMGetModuleDataLayout(codegen.module);
                if target_data == null {
                    return null;
                }
                element_size = LLVMPointerSize(target_data) as usize;
            } else if element_kind == LLVMStructTypeKind {
                // 结构体类型的数组：使用 TargetData 获取元素大小
                const target_data: *void = LLVMGetModuleDataLayout(codegen.module);
                if target_data == null {
                    return null;  // 模块的 DataLayout 未设置
                }
                element_size = LLVMStoreSizeOfType(target_data, element_type) as usize;
            } else {
                // 其他复杂类型，无法计算大小
                return null;
            }
            size = element_size * (element_count as usize);
        } else if kind == LLVMStructTypeKind {
            // 结构体类型：使用 TargetData 获取准确大小
            const target_data: *void = LLVMGetModuleDataLayout(codegen.module);
            if target_data == null {
                return null;  // 模块的 DataLayout 未设置
            }
            // 使用 LLVMStoreSizeOfType 获取结构体的存储大小（字节数）
            size = LLVMStoreSizeOfType(target_data, llvm_type) as usize;
            
            // 特殊处理：空结构体的大小应该是 1 字节（规范要求）
            // LLVM 对空结构体返回 0，但根据规范（2.3.6 节），空结构体大小为 1 字节
            if size == 0 {
                // 检查是否是空结构体（通过检查字段数）
                const element_count: i32 = LLVMCountStructElementTypes(llvm_type);
                if element_count == 0 {
                    size = 1;  // 空结构体大小为 1 字节
                }
            }
        } else {
            // 其他类型，无法计算大小
            return null;
        }
        
        // 创建 i32 常量
        const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32) as *void;
        if i32_type == null {
            return null;
        }
        return LLVMConstInt(i32_type, size as usize, 0) as &void;  // 无符号整数
    } else if expr.type == AST_ALIGNOF {
        // alignof 表达式：返回类型对齐值（i32 常量）
        const target: &ASTNode = expr.alignof_expr_target;
        const is_type: i32 = expr.alignof_expr_is_type;
        
        if target == null {
            return null;
        }
        
        var llvm_type: *void = null;
        
        if is_type != 0 {
            // target 是类型节点
            llvm_type = get_llvm_type_from_ast(codegen, target) as *void;
        } else {
            // target 是表达式节点，需要获取类型而不生成代码
            // 对于标识符（变量），直接从变量表获取类型
            if target.type == AST_IDENTIFIER {
                const var_name: &byte = target.identifier_name;
                if var_name == null {
                    return null;
                }
                llvm_type = lookup_var_type(codegen, var_name) as *void;
                // 如果变量表中找不到，可能是枚举类型或结构体类型名称（在 alignof 中）
                // 尝试作为类型名称处理
                if llvm_type == null {
                    // 先检查是否是枚举类型（枚举类型在LLVM中就是i32类型）
                    const enum_decl: &ASTNode = find_enum_decl(codegen, var_name);
                    if enum_decl != null {
                        llvm_type = codegen_get_base_type(codegen, TYPE_I32) as *void;
                    } else {
                        // 检查是否是结构体类型
                        const struct_type: *void = codegen_get_struct_type(codegen, var_name);
                        if struct_type != null {
                            llvm_type = struct_type;
                        } else {
                            return null;
                        }
                    }
                }
            } else {
                // 对于其他表达式类型，生成代码以获取类型
                const target_val: *void = codegen_gen_expr(codegen, target);
                if target_val == null {
                    return null;
                }
                llvm_type = LLVMTypeOf(target_val);
            }
        }
        
        if llvm_type == null {
            return null;
        }
        
        // 获取类型对齐值（字节数）
        // 使用 TargetData 获取准确的对齐值
        const target_data: *void = LLVMGetModuleDataLayout(codegen.module);
        if target_data == null {
            return null;  // 模块的 DataLayout 未设置
        }
        
        var alignment: usize = 0;
        
        const kind: i32 = LLVMGetTypeKind(llvm_type);
        if kind == LLVMIntegerTypeKind {
            // 整数类型：使用 TargetData 获取对齐值
            alignment = LLVMABIAlignmentOfType(target_data, llvm_type) as usize;
        } else if kind == LLVMPointerTypeKind {
            // 指针类型：使用 TargetData 获取对齐值（平台相关）
            alignment = LLVMABIAlignmentOfType(target_data, llvm_type) as usize;
        } else if kind == LLVMArrayTypeKind {
            // 数组类型：对齐值等于元素类型的对齐值
            const element_type: *void = LLVMGetElementType(llvm_type);
            if element_type == null {
                return null;
            }
            alignment = LLVMABIAlignmentOfType(target_data, element_type) as usize;
        } else if kind == LLVMStructTypeKind {
            // 结构体类型：使用 TargetData 获取对齐值（等于最大字段对齐值）
            alignment = LLVMABIAlignmentOfType(target_data, llvm_type) as usize;
        } else {
            // 其他类型，无法计算对齐值
            return null;
        }
        
        // 创建 i32 常量
        const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32) as *void;
        if i32_type == null {
            return null;
        }
        return LLVMConstInt(i32_type, alignment as usize, 0) as &void;  // 无符号整数
    } else if expr.type == AST_LEN {
        // len 表达式：返回数组元素个数（i32 常量）
        const array_expr: &ASTNode = expr.len_expr_array;
        
        if array_expr == null {
            return null;
        }
        
        var array_type: *void = null;
        
        // 获取数组表达式的类型
        if array_expr.type == AST_IDENTIFIER {
            // 标识符（变量）：从变量表获取类型
            const var_name: &byte = array_expr.identifier_name;
            if var_name == null {
                return null;
            }
            array_type = lookup_var_type(codegen, var_name) as *void;
        } else if array_expr.type == AST_ARRAY_ACCESS {
            // 数组访问表达式（如 arr2d[0]）：获取元素类型（可能是数组）
            // 先获取数组表达式的类型
            const nested_array_expr: &ASTNode = array_expr.array_access_array;
            if nested_array_expr == null {
                return null;
            }
            
            var nested_array_type: *void = null;
            if nested_array_expr.type == AST_IDENTIFIER {
                const var_name: &byte = array_expr.array_access_array.identifier_name;
                if var_name != null {
                    nested_array_type = lookup_var_type(codegen, var_name) as *void;
                }
            } else {
                // 对于更深层的嵌套，生成代码以获取类型
                const nested_array_val: *void = codegen_gen_expr(codegen, nested_array_expr);
                if nested_array_val == null {
                    return null;
                }
                nested_array_type = LLVMTypeOf(nested_array_val);
            }
            
            if nested_array_type == null {
                return null;
            }
            
            // 获取元素类型（可能是数组）
            const nested_array_type_kind: i32 = LLVMGetTypeKind(nested_array_type);
            if nested_array_type_kind == LLVMArrayTypeKind {
                // 数组类型：元素类型就是数组的元素类型（可能是另一个数组）
                array_type = LLVMGetElementType(nested_array_type);
            } else if nested_array_type_kind == LLVMPointerTypeKind {
                // 指针类型：获取指向的类型
                const pointed_type: *void = LLVMGetElementType(nested_array_type);
                if pointed_type != null && LLVMGetTypeKind(pointed_type) == LLVMArrayTypeKind {
                    // 指向数组的指针：获取数组元素类型
                    array_type = LLVMGetElementType(pointed_type);
                } else {
                    // 指向单个元素的指针：元素类型就是指向的类型
                    array_type = pointed_type;
                }
            } else {
                return null;
            }
        } else {
            // 其他表达式类型：生成代码以获取类型
            const array_val: *void = codegen_gen_expr(codegen, array_expr);
            if array_val == null {
                return null;
            }
            array_type = LLVMTypeOf(array_val);
        }
        
        if array_type == null {
            return null;
        }
        
        // 验证是数组类型
        const kind: i32 = LLVMGetTypeKind(array_type);
        if kind != LLVMArrayTypeKind {
            return null;  // 不是数组类型
        }
        
        // 获取数组长度（元素个数）
        const element_count: i32 = LLVMGetArrayLength(array_type);
        
        // 创建 i32 常量
        const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32) as *void;
        if i32_type == null {
            return null;
        }
        return LLVMConstInt(i32_type, element_count as usize, 0) as &void;  // 无符号整数
    } else if expr.type == AST_ASSIGN {
        // 赋值表达式：生成赋值代码并返回赋值后的值（用于链式赋值）
        const dest: &ASTNode = expr.assign_dest;
        const src: &ASTNode = expr.assign_src;
        
        if dest == null || src == null {
            return null;
        }
        
        // 生成目标左值表达式的地址
        const dest_ptr: *void = codegen_gen_lvalue_address(codegen, dest) as *void;
        if dest_ptr == null {
            return null;
        }
        
        // 获取目标类型（用于 null 字面量处理）
        const dest_ptr_type: *void = LLVMTypeOf(dest_ptr);
        if dest_ptr_type == null {
            return null;
        }
        const dest_type: *void = LLVMGetElementType(dest_ptr_type);
        if dest_type == null {
            return null;
        }
        
        // 特殊处理 null 字面量
        var src_val: *void = null;
        if src.type == AST_IDENTIFIER {
            const src_name: &byte = src.identifier_name;
            if src_name != null && strcmp(src_name, "null") == 0 {
                // null 字面量：检查目标类型是否为指针类型
                const dest_type_kind: i32 = LLVMGetTypeKind(dest_type);
                if dest_type_kind == LLVMPointerTypeKind {
                    src_val = LLVMConstNull(dest_type);
                } else {
                    return null;
                }
            }
        }
        
        // 如果不是 null 字面量，正常生成源表达式值
        if src_val == null {
            src_val = codegen_gen_expr(codegen, src);
            if src_val == null {
                return null;
            }
        }
        
        // store 值到目标地址
        LLVMBuildStore(codegen.builder, src_val, dest_ptr);
        
        // 返回赋值后的值（load 目标地址的值）
        return LLVMBuildLoad2(codegen.builder, dest_type, dest_ptr, "") as &void;
    } else if expr.type == AST_CAST_EXPR {
        // 类型转换表达式（expr as type）
        const expr_node: &ASTNode = expr.cast_expr_expr;
        const target_type_node: &ASTNode = expr.cast_expr_target_type;
        
        if expr_node == null || target_type_node == null {
            return null;
        }
        
        // 生成源表达式代码
        const source_val: *void = codegen_gen_expr(codegen, expr_node);
        if source_val == null {
            return null;
        }
        
        // 获取目标类型
        const target_type: *void = get_llvm_type_from_ast(codegen, target_type_node) as *void;
        if target_type == null {
            return null;
        }
        
        const source_type: *void = LLVMTypeOf(source_val);
        if source_type == null {
            return null;
        }
        const source_kind: i32 = LLVMGetTypeKind(source_type);
        const target_kind: i32 = LLVMGetTypeKind(target_type);
        
        // 根据源类型和目标类型进行转换
        if source_kind == LLVMIntegerTypeKind && target_kind == LLVMIntegerTypeKind {
            const source_width: i32 = LLVMGetIntTypeWidth(source_type);
            const target_width: i32 = LLVMGetIntTypeWidth(target_type);
            
            // 获取 usize 类型宽度（用于判断 i32 ↔ usize 转换）
            const usize_type: *void = codegen_get_base_type(codegen, TYPE_USIZE) as *void;
            var usize_width: i32 = 0;
            if usize_type != null {
                usize_width = LLVMGetIntTypeWidth(usize_type);
            }
            
            if source_width == 32 && target_width == 8 {
                // i32 as byte：截断转换（保留低 8 位）
                return LLVMBuildTrunc(codegen.builder, source_val, target_type, "" as *byte) as &void;
            } else if source_width == 8 && target_width == 32 {
                // byte as i32：零扩展转换（无符号扩展）
                return LLVMBuildZExt(codegen.builder, source_val, target_type, "" as *byte) as &void;
            } else if source_width == 32 && target_width == 1 {
                // i32 as bool：非零值为 true，零值为 false
                const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32) as *void;
                if i32_type == null {
                    return null;
                }
                const zero: *void = LLVMConstInt(i32_type, 0 as usize, 1) as &void;  // 有符号零
                return LLVMBuildICmp(codegen.builder, LLVMIntNE, source_val, zero, "" as *byte) as &void;
            } else if source_width == 1 && target_width == 32 {
                // bool as i32：true 转换为 1，false 转换为 0（零扩展）
                return LLVMBuildZExt(codegen.builder, source_val, target_type, "" as *byte) as &void;
            } else if source_width == 32 && target_width == usize_width && usize_width > 0 {
                // i32 as usize：零扩展转换（如果 usize 是 64 位）或直接使用（如果 usize 是 32 位）
                if usize_width > 32 {
                    return LLVMBuildZExt(codegen.builder, source_val, target_type, "" as *byte) as &void;
                } else {
                    // 32位平台：usize 也是 32 位，使用零扩展（虽然是 no-op）
                    return LLVMBuildZExt(codegen.builder, source_val, target_type, "" as *byte) as &void;
                }
            } else if source_width == usize_width && target_width == 32 && usize_width > 0 {
                // usize as i32：截断转换（如果 usize 是 64 位）或直接使用（如果 usize 是 32 位）
                if usize_width > 32 {
                    return LLVMBuildTrunc(codegen.builder, source_val, target_type, "" as *byte) as &void;
                } else {
                    // 32位平台：usize 也是 32 位，使用截断（虽然是 no-op）
                    return LLVMBuildTrunc(codegen.builder, source_val, target_type, "" as *byte) as &void;
                }
            }
        }
        
        // 不支持的转换（类型检查阶段应该已经拒绝）
        return null;
    }
    
    // 其他未知表达式类型
    return null;
}

