// funcs.uya - 代码生成器 funcs 模块
// 使用 LLVM C API 生成 LLVM IR 并编译为二进制代码
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

fn lookup_func(codegen: &CodeGenerator, name: &byte, _func_type: &void) &FuncMap {
    const func_type:*void = _func_type as *void;

    if codegen == null || name == null {
        return null;
    }
    
    // 线性查找
    var i: i32 = 0;
    while i < codegen.func_map_count {
        if codegen.func_map[i].name != null && strcmp(codegen.func_map[i].name, name) == 0 {
            // 如果提供了 func_type，验证类型是否匹配
            if func_type != null && codegen.func_map[i].func_type != func_type {
                return null;  // 类型不匹配
            }
            return &codegen.func_map[i];
        }
        i = i + 1;
    }
    
    return null;  // 未找到
}

fn add_func(codegen: &CodeGenerator, func_name: &byte, _func: &void, _func_type: &void) i32 {
    const func:*void = _func as *void;
    const func_type:*void = _func_type as *void;

    if codegen == null || func_name == null || func == null || func_type == null {
        return -1;
    }
    
    // 检查映射表是否已满
    if codegen.func_map_count >= FUNC_MAP_SIZE {
        return -1;  // 映射表已满
    }
    
    // 添加到映射表
    const idx: i32 = codegen.func_map_count;
    codegen.func_map[idx].name = func_name;
    codegen.func_map[idx].func = func;
    codegen.func_map[idx].func_type = func_type;
    codegen.func_map_count = codegen.func_map_count + 1;
    
    return 0;
}

fn codegen_declare_function(codegen: &CodeGenerator, fn_decl: &ASTNode) i32 {
    if codegen == null || fn_decl == null || fn_decl.type != AST_FN_DECL {
        return -1;
    }
    
    const func_name: &byte = fn_decl.fn_decl_name;
    const return_type_node: &ASTNode = fn_decl.fn_decl_return_type;
    const param_count: i32 = fn_decl.fn_decl_param_count;
    // 直接访问固定大小数组，不需要嵌套指针变量
    
    if func_name == null || return_type_node == null {
        return -1;
    }
    
    // 检查函数是否已经声明（在函数表中查找）
    var func_type_check: *void = null;
    const func_map_check: &FuncMap = lookup_func(codegen, func_name, func_type_check as &void);
    if func_map_check != null {
        return 0;  // 已在函数表中，跳过
    }
    
    // 获取返回类型
    const return_type: *void = get_llvm_type_from_ast(codegen, return_type_node) as *void;
    if return_type == null {
        return -1;
    }
    
    // 准备参数类型数组
    if param_count > MAX_FUNC_PARAMS {
        return -1;
    }
    
    var param_types: [*void: MAX_FUNC_PARAMS] = [];
    var i: i32 = 0;
    while i < param_count {
        const param: &ASTNode = fn_decl.fn_decl_params[i];
        if param == null || param.type != AST_VAR_DECL {
            return -1;
        }
        
        const param_type_node: &ASTNode = param.var_decl_type;
        const param_type: *void = get_llvm_type_from_ast(codegen, param_type_node) as *void;
        if param_type == null {
            return -1;
        }
        
        param_types[i] = param_type;
        i = i + 1;
    }
    
    // 创建函数类型（最后一个参数 isVarArg 表示是否为可变参数函数）
    const is_varargs: i32 = fn_decl.fn_decl_is_varargs;
    const func_type: *void = LLVMFunctionType(return_type, &param_types[0] as *void, param_count, is_varargs);
    if func_type == null {
        return -1;
    }
    
    // 创建函数声明（添加到模块）
    const func: *void = LLVMAddFunction(codegen.module, func_name, func_type);
    if func == null {
        return -1;
    }
    
    // 添加到函数表
    if add_func(codegen, func_name, func as &void, func_type as &void) != 0 {
        return -1;
    }
    
    return 0;
}

