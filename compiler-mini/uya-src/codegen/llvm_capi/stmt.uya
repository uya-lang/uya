// stmt.uya - 代码生成器 stmt 模块
// 使用 LLVM C API 生成 LLVM IR 并编译为二进制代码
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

fn gen_branch_with_terminator(codegen: &CodeGenerator, _branch_bb: &void, branch_stmt: &ASTNode, _target_bb: &void) i32 {
    const branch_bb:*void = _branch_bb as *void;
    const target_bb:*void = _target_bb as *void;

    if codegen == null || branch_bb == null || branch_stmt == null || target_bb == null {
        return -1;
    }
    
    // 定位构建器到分支基本块
    LLVMPositionBuilderAtEnd(codegen.builder, branch_bb);
    
    // 生成分支代码（可能包含嵌套控制流，构建器可能被移动到其他基本块）
    if codegen_gen_stmt(codegen, branch_stmt) != 0 {
        return -1;
    }
    
    // 检查当前构建器所在的基本块是否有终止符
    // 如果分支包含嵌套控制流，构建器可能已经移动到其他基本块
    const current_bb: *void = LLVMGetInsertBlock(codegen.builder);
    if current_bb != null {
        const terminator: *void = LLVMGetBasicBlockTerminator(current_bb);
        if terminator == null {
            // 当前基本块没有终止符，添加跳转到目标基本块
            LLVMBuildBr(codegen.builder, target_bb);
        }
    } else {
        // 构建器不在任何块中，设置到分支块并添加跳转
        LLVMPositionBuilderAtEnd(codegen.builder, branch_bb);
        LLVMBuildBr(codegen.builder, target_bb);
    }
    
    return 0;
}

fn codegen_gen_stmt(codegen: &CodeGenerator, stmt: &ASTNode) i32 {
    if codegen == null || stmt == null || codegen.builder == null {
        return -1;
    }
    
    if stmt.type == AST_VAR_DECL {
        // 变量声明：使用 alloca 分配栈空间，如果有初始值则 store
        const var_name: &byte = stmt.var_decl_name;
        const var_type: &ASTNode = stmt.var_decl_type;
        const init_expr: &ASTNode = stmt.var_decl_init;
        
        if var_name == null || var_type == null {
            return -1;
        }
        
        // 获取变量类型
        const llvm_type: *void = get_llvm_type_from_ast(codegen, var_type) as *void;
        if llvm_type == null {
            return -1;
        }
        
        // 提取结构体名称（如果类型是结构体类型）
        var struct_name: &byte = null;
        if var_type.type == AST_TYPE_NAMED {
            const type_name: &byte = var_type.type_named_name;
            if type_name != null && strcmp(type_name, "i32") != 0 && strcmp(type_name, "bool") != 0 && strcmp(type_name, "byte") != 0 && strcmp(type_name, "void") != 0 {
                // 可能是结构体类型
                if codegen_get_struct_type(codegen, type_name) as *void != null {
                    struct_name = type_name;  // 名称已经在 Arena 中
                }
            }
        }
        
        // 使用 alloca 分配栈空间（放到函数入口基本块，避免支配性/终止符相关验证错误）
        const var_ptr: *void = build_entry_alloca(codegen, llvm_type, var_name);
        if var_ptr == null {
            return -1;
        }
        
        // 添加到变量表
        if add_var(codegen, var_name, var_ptr as &void, llvm_type as &void, struct_name, var_type) != 0 {
            return -1;
        }
        
        // 如果有初始值，生成初始值代码并 store
        if init_expr != null {
            var init_val: *void = null;
            
            // 特殊处理空数组字面量：如果变量类型是数组类型，空数组表示未初始化
            var is_empty_array_literal: i32 = 0;
            if init_expr != null && init_expr.type == AST_ARRAY_LITERAL &&
               init_expr.array_literal_element_count == 0 {
                // 检查变量类型是否为数组类型（即使 llvm_type 为 null，也尝试从 AST 类型节点判断）
                var is_array_type: i32 = 0;
                if llvm_type != null {
                    const llvm_type_kind: i32 = LLVMGetTypeKind(llvm_type);
                    if llvm_type_kind == LLVMArrayTypeKind {
                        is_array_type = 1;
                    }
                }
                // 如果 llvm_type 检查失败，尝试从 AST 类型节点判断
                if is_array_type == 0 && var_type != null && var_type.type == AST_TYPE_ARRAY {
                    // 从 AST 类型节点判断是否为数组类型
                    is_array_type = 1;
                }
                
                if is_array_type != 0 {
                    // 空数组字面量用于数组类型变量，不进行初始化（变量已通过 alloca 分配，内容未定义）
                    // 跳过初始化代码生成
                    init_val = null;
                    is_empty_array_literal = 1;  // 标记为空数组字面量，避免后续尝试生成表达式
                }
            }
            // 特殊处理 null 标识符：检查是否是 null 字面量
            if init_val == null && is_empty_array_literal == 0 && init_expr.type == AST_IDENTIFIER {
                const init_name: &byte = init_expr.identifier_name;
                if init_name != null && strcmp(init_name, "null") == 0 {
                    // null 字面量：检查变量类型是否为指针类型
                    if llvm_type != null {
                        const llvm_type_kind: i32 = LLVMGetTypeKind(llvm_type);
                        if llvm_type_kind == LLVMPointerTypeKind {
                            init_val = LLVMConstNull(llvm_type);
                        } else {
                            var filename: &byte = stmt.filename;
                            if filename == null {
                                filename = "<unknown>" as &byte;
                            }
                            fprintf(2 as *void, "错误: 变量 %s 的类型不是指针类型，不能初始化为 null (%s:%d:%d)\n", 
                                    var_name, filename as *byte, stmt.line, stmt.column);
                            return -1;
                        }
                    }
                }
            }
            
            // 如果不是特殊处理的情况，使用通用方法生成初始值
            // 注意：is_empty_array_literal 已经在上面检查过了，这里不需要重复检查
            if init_val == null && is_empty_array_literal == 0 {
                init_val = codegen_gen_expr(codegen, init_expr);
                if init_val == null {
                    // 添加源码位置信息
                    var filename: &byte = stmt.filename;
                    if filename == null {
                        filename = "<unknown>" as &byte;
                    }
                    
                    // 放宽检查：在编译器自举时，某些函数可能尚未声明，导致表达式生成失败
                    // 尝试生成默认值（0 或 null）作为占位符
                    if llvm_type != null {
                        const type_kind: i32 = LLVMGetTypeKind(llvm_type);
                        if type_kind == LLVMIntegerTypeKind {
                            init_val = LLVMConstInt(llvm_type, 0 as usize, 0);
                        } else if type_kind == LLVMPointerTypeKind {
                            init_val = LLVMConstNull(llvm_type);
                        } else if type_kind == LLVMArrayTypeKind {
                            // 数组类型：无法生成默认值，跳过初始化（数组已通过 alloca 分配）
                            // 这是允许的，因为空数组字面量表示未初始化
                            init_val = null;
                        } else if type_kind == LLVMStructTypeKind {
                            // 结构体类型：生成零初始化的结构体常量
                            const field_count: i32 = LLVMCountStructElementTypes(llvm_type);
                            if field_count > 0 && field_count <= 32 {
                                var field_types: [*void: 32] = [];
                                var field_values: [*void: 32] = [];
                                LLVMGetStructElementTypes(llvm_type, &field_types[0] as *void);
                                var i: i32 = 0;
                                while i < field_count {
                                    const field_type: *void = field_types[i];
                                    const field_kind: i32 = LLVMGetTypeKind(field_type);
                                    if field_kind == LLVMIntegerTypeKind {
                                        field_values[i] = LLVMConstInt(field_type, 0 as usize, 0);
                                    } else {
                                        field_values[i] = LLVMConstNull(field_type);
                                    }
                                    i = i + 1;
                                }
                                init_val = LLVMConstStruct(&field_values[0] as *void, field_count, 0);
                            }
                        }
                    }
                    
                    // 如果仍然无法生成默认值，对于数组类型允许跳过初始化
                    if init_val == null {
                        var is_array_type_fallback: i32 = 0;
                        if llvm_type != null {
                            const type_kind: i32 = LLVMGetTypeKind(llvm_type);
                            if type_kind == LLVMArrayTypeKind {
                                is_array_type_fallback = 1;
                            }
                        }
                        // 如果 llvm_type 检查失败，尝试从 AST 类型节点判断
                        if is_array_type_fallback == 0 && var_type != null && var_type.type == AST_TYPE_ARRAY {
                            is_array_type_fallback = 1;
                        }
                        
                        if is_array_type_fallback != 0 {
                            // 数组类型：允许跳过初始化（空数组字面量或表达式生成失败）
                            // 不打印错误信息，因为这是允许的情况
                            // 继续执行，不返回错误
                        } else {
                            fprintf(2 as *void, "错误: 变量 %s 的初始值表达式生成失败 (%s:%d:%d)\n", 
                                    var_name, filename as *byte, stmt.line, stmt.column);
                            fprintf(2 as *void, "错误: 无法为变量 %s 生成默认初始值 (%s:%d:%d)\n", 
                                    var_name, filename as *byte, stmt.line, stmt.column);
                            return -1;
                        }
                    } else {
                        fprintf(2 as *void, "警告: 变量 %s 的初始值表达式生成失败，使用默认值 (%s:%d:%d)\n", 
                                var_name, filename as *byte, stmt.line, stmt.column);
                    }
                }
                
                // 检查 init_val 是否是标记值
                if init_val == 1 as *void {
                    var filename: &byte = stmt.filename;
                    if filename == null {
                        filename = "<unknown>" as &byte;
                    }
                    fprintf(2 as *void, "错误: 变量 %s 的初始值表达式返回标记值 (%s:%d:%d)\n", 
                            var_name, filename as *byte, stmt.line, stmt.column);
                    return -1;
                }
                
                // 验证 init_val 的类型是否有效
                if init_val != null {
                    const init_val_type: &void = safe_LLVMTypeOf(init_val as &void);
                    if init_val_type == null {
                        var filename: &byte = stmt.filename;
                        if filename == null {
                            filename = "<unknown>" as &byte;
                        }
                        fprintf(2 as *void, "错误: 变量 %s 的初始值类型无效 (%s:%d:%d)\n", 
                                var_name, filename as *byte, stmt.line, stmt.column);
                        return -1;
                    }
                }
            }
            
            // 如果有初始值（空数组字面量时 init_val 为 null，跳过 store）
            if init_val != null {
                // 检查类型是否匹配，如果不匹配则进行类型转换
                const init_type: &void = safe_LLVMTypeOf(init_val as &void);
                if (init_type as *void) != llvm_type {
                    // 类型不匹配，需要进行类型转换
                    const var_type_kind: i32 = LLVMGetTypeKind(llvm_type);
                    const init_type_kind: i32 = LLVMGetTypeKind(init_type as *void);
                    
                    if var_type_kind == LLVMIntegerTypeKind && init_type_kind == LLVMIntegerTypeKind {
                        // 整数类型之间的转换
                        const var_width: i32 = LLVMGetIntTypeWidth(llvm_type);
                        const init_width: i32 = LLVMGetIntTypeWidth(init_type as *void);
                        
                        if var_width < init_width {
                            // 截断转换（例如 i32 -> i8）
                            init_val = LLVMBuildTrunc(codegen.builder, init_val, llvm_type, "");
                        } else if var_width > init_width {
                            // 零扩展转换（例如 i8 -> i32，byte 是无符号的，使用零扩展）
                            init_val = LLVMBuildZExt(codegen.builder, init_val, llvm_type, "");
                        }
                        // 如果宽度相同，类型应该相同，不需要转换
                    } else if var_type_kind == LLVMArrayTypeKind && init_type_kind == LLVMArrayTypeKind {
                        // 数组类型：检查元素类型和长度是否匹配
                        const var_element_type: &void = safe_LLVMGetElementType(llvm_type as &void);
                        const init_element_type: &void = safe_LLVMGetElementType(init_type);
                        const var_length: i32 = LLVMGetArrayLength(llvm_type);
                        const init_length: i32 = LLVMGetArrayLength(init_type as *void);
                        
                        if var_element_type != null && init_element_type != null && 
                           var_length == init_length {
                            // 长度相同，检查元素类型
                            const var_element_kind: i32 = LLVMGetTypeKind(var_element_type as *void);
                            const init_element_kind: i32 = LLVMGetTypeKind(init_element_type as *void);
                            
                            if var_element_kind == LLVMIntegerTypeKind && init_element_kind == LLVMIntegerTypeKind {
                                const var_element_width: i32 = LLVMGetIntTypeWidth(var_element_type);
                                const init_element_width: i32 = LLVMGetIntTypeWidth(init_element_type);
                                
                                // 如果元素类型宽度相同，类型应该匹配（可能是不同的类型实例）
                                // 对于这种情况，直接使用 init_val（LLVM 会处理类型匹配）
                                if var_element_width == init_element_width {
                                    // 元素类型宽度相同，允许赋值（LLVM 会处理）
                                } else {
                                    // 元素类型宽度不同，无法转换
                                    var filename: &byte = stmt.filename;
                                    if filename == null {
                                        filename = "<unknown>" as &byte;
                                    }
                                    fprintf(2 as *void, "错误: 数组类型不匹配 (元素类型或长度不同: var=[%d x %p], init=[%d x %p]) (%s:%d:%d)\n", 
                                            var_length, var_element_type, init_length, init_element_type,
                                            filename as *byte, stmt.line, stmt.column);
                                    return -1;
                                }
                            } else if var_element_type != init_element_type {
                                // 元素类型不匹配
                                var filename: &byte = stmt.filename;
                                if filename == null {
                                    filename = "<unknown>" as &byte;
                                }
                                fprintf(2 as *void, "错误: 数组类型不匹配 (元素类型或长度不同: var=[%d x %p], init=[%d x %p]) (%s:%d:%d)\n", 
                                        var_length, var_element_type, init_length, init_element_type,
                                        filename as *byte, stmt.line, stmt.column);
                                return -1;
                            }
                        } else {
                            // 长度不同或元素类型无效
                            var filename: &byte = stmt.filename;
                            if filename == null {
                                filename = "<unknown>" as &byte;
                            }
                            fprintf(2 as *void, "错误: 数组类型不匹配 (元素类型或长度不同: var=[%d x %p], init=[%d x %p]) (%s:%d:%d)\n", 
                                    var_length, var_element_type, init_length, init_element_type,
                                    filename as *byte, stmt.line, stmt.column);
                            return -1;
                        }
                    }
                    // 其他类型不匹配的情况会在类型检查阶段被拒绝
                }
                
                LLVMBuildStore(codegen.builder, init_val, var_ptr);
            }
        }
        
        return 0;
    } else if stmt.type == AST_RETURN_STMT {
        // return 语句：生成返回值并返回（void函数返回null）
        const return_expr: &ASTNode = stmt.return_stmt_expr;
        
        if return_expr != null {
            // 有返回值：生成返回值表达式并返回
            const return_val: *void = codegen_gen_expr(codegen, return_expr);
            if return_val == null {
                return -1;
            }
            LLVMBuildRet(codegen.builder, return_val);
        } else {
            // void 返回
            LLVMBuildRetVoid(codegen.builder);
        }
        
        return 0;
    } else if stmt.type == AST_ASSIGN {
        // 赋值语句：生成源表达式值，store 到目标左值表达式
        const dest: &ASTNode = stmt.assign_dest;
        const src: &ASTNode = stmt.assign_src;
        
        if dest == null || src == null {
            return -1;
        }
        
        // 生成目标左值表达式的地址
        const dest_ptr: *void = codegen_gen_lvalue_address(codegen, dest) as *void;
        if dest_ptr == null {
            return -1;  // 无法生成左值地址（不支持的类型或错误）
        }
        
        // 获取目标类型（用于 null 字面量处理）
        const dest_ptr_type: &void = safe_LLVMTypeOf(dest_ptr as &void);
        if dest_ptr_type == null {
            return -1;
        }
        const dest_type: &void = safe_LLVMGetElementType(dest_ptr_type);
        if dest_type == null {
            return -1;
        }
        
        // 特殊处理 null 字面量
        var src_val: *void = null;
        if src.type == AST_IDENTIFIER {
            const src_name: &byte = src.identifier_name;
            if src_name != null && strcmp(src_name, "null") == 0 {
                // null 字面量：检查目标类型是否为指针类型
                const dest_type_kind: i32 = LLVMGetTypeKind(dest_type as *void);
                if dest_type_kind == LLVMPointerTypeKind {
                    src_val = LLVMConstNull(dest_type);
                } else {
                    var filename: &byte = stmt.filename;
                    if filename == null {
                        filename = "<unknown>" as &byte;
                    }
                    fprintf(2 as *void, "错误: 赋值目标类型不是指针，不能赋 null (%s:%d:%d)\n", 
                            filename as *byte, stmt.line, stmt.column);
                    return -1;
                }
            }
        }
        
        // 如果不是 null 字面量，正常生成源表达式值
        if src_val == null {
            src_val = codegen_gen_expr(codegen, src);
            if src_val == null {
                return -1;
            }
        }
        
        // store 值到目标地址
        // LLVMBuildStore 会自动处理类型匹配
        LLVMBuildStore(codegen.builder, src_val, dest_ptr);
        
        return 0;
    } else if stmt.type == AST_EXPR_STMT {
        // 表达式语句：根据 parser 实现，表达式语句直接返回表达式节点
        // 而不是 AST_EXPR_STMT 节点，所以这里不应该被执行
        // 但为了完整性，如果遇到这种情况，尝试将其当作表达式处理
        const expr_val: *void = codegen_gen_expr(codegen, stmt);
        // 忽略返回值（即使失败也返回0，因为表达式语句的返回值不重要）
        return 0;
    } else if stmt.type == AST_BLOCK {
        // 代码块：递归处理语句列表
        const stmt_count: i32 = stmt.block_stmt_count;
        // 直接访问固定大小数组，不需要嵌套指针变量
        
        var i: i32 = 0;
        while i < stmt_count {
            const stmt_node: &ASTNode = stmt.block_stmts[i];
            if stmt_node != null {
                const result: i32 = codegen_gen_stmt(codegen, stmt_node);
                if result != 0 {
                    // 生成详细的错误信息（包含原因和建议）
                    report_stmt_error(codegen, stmt_node, i, "在代码块中" as *byte);
                    return -1;
                }
            }
            i = i + 1;
        }
        
        return 0;
    } else if stmt.type == AST_IF_STMT {
        // if 语句：创建条件分支基本块
        const condition: &ASTNode = stmt.if_stmt_condition;
        const then_branch: &ASTNode = stmt.if_stmt_then_branch;
        const else_branch: &ASTNode = stmt.if_stmt_else_branch;
        
        if condition == null || then_branch == null {
            return -1;
        }
        
        // 生成条件表达式
        const cond_val: *void = codegen_gen_expr(codegen, condition);
        if cond_val == null {
            fprintf(2 as *void, "错误: 条件表达式生成失败\n");
            return -1;
        }
        
        // 获取当前函数
        const current_bb: *void = LLVMGetInsertBlock(codegen.builder);
        if current_bb == null {
            return -1;
        }
        const current_func: *void = LLVMGetBasicBlockParent(current_bb);
        if current_func == null {
            return -1;
        }
        
        // 创建基本块（使用计数器生成唯一名称）
        const bb_id: i32 = codegen.basic_block_counter;
        codegen.basic_block_counter = codegen.basic_block_counter + 1;
        
        var then_name: [byte: 32] = [];
        var end_name: [byte: 32] = [];
        snprintf(&then_name[0] as *byte, 32, "if.then.%d", bb_id);
        snprintf(&end_name[0] as *byte, 32, "if.end.%d", bb_id);
        const then_bb: *void = LLVMAppendBasicBlock(current_func, &then_name[0] as *byte);
        const end_bb: *void = LLVMAppendBasicBlock(current_func, &end_name[0] as *byte);
        
            // 生成条件分支指令
            if else_branch != null {
                // 有else分支
                var else_name: [byte: 32] = [];
                snprintf(&else_name[0] as *byte, 32, "if.else.%d", bb_id);
                const else_bb: *void = LLVMAppendBasicBlock(current_func, &else_name[0] as *byte);
                
                // 生成条件分支指令
                LLVMBuildCondBr(codegen.builder, cond_val, then_bb, else_bb);
                
                // 生成then分支代码（使用 gen_branch_with_terminator 确保控制流正确）
                if gen_branch_with_terminator(codegen, then_bb, then_branch, end_bb) != 0 {
                    return -1;
                }

                // 生成else分支代码（使用 gen_branch_with_terminator 确保控制流正确）
                if gen_branch_with_terminator(codegen, else_bb as &void, else_branch, end_bb as &void) != 0 {
                    return -1;
                }
            } else {
                // 没有else分支
                // 生成条件分支指令
                LLVMBuildCondBr(codegen.builder, cond_val, then_bb, end_bb);

                // 生成then分支代码（使用 gen_branch_with_terminator 确保控制流正确）
                if gen_branch_with_terminator(codegen, then_bb, then_branch, end_bb) != 0 {
                    return -1;
                }
            }

            // 确保构建器在 end_bb 中，并且 end_bb 有终止符（如果需要的话）
            // 注意：end_bb 通常不需要终止符，因为它是控制流的汇聚点
            LLVMPositionBuilderAtEnd(codegen.builder, end_bb);
        
        return 0;
    } else if stmt.type == AST_WHILE_STMT {
        // while 语句：暂时不支持
        return -1;
        // while 语句：创建循环基本块
        const condition: &ASTNode = stmt.while_stmt_condition;
        const body: &ASTNode = stmt.while_stmt_body;
        
        if condition == null || body == null {
            return -1;
        }
        
        // 获取当前函数
        const current_bb: *void = LLVMGetInsertBlock(codegen.builder);
        if current_bb == null {
            return -1;
        }
        const current_func: *void = LLVMGetBasicBlockParent(current_bb);
        if current_func == null {
            return -1;
        }
        
        // 创建基本块：cond（条件检查）、body（循环体）、end（结束）
        const bb_id: i32 = codegen.basic_block_counter;
        codegen.basic_block_counter = codegen.basic_block_counter + 1;
        
        var cond_name: [byte: 32] = [];
        var body_name: [byte: 32] = [];
        var end_name: [byte: 32] = [];
        snprintf(&cond_name[0] as *byte, 32, "while.cond.%d", bb_id);
        snprintf(&body_name[0] as *byte, 32, "while.body.%d", bb_id);
        snprintf(&end_name[0] as *byte, 32, "while.end.%d", bb_id);
        const cond_bb: *void = LLVMAppendBasicBlock(current_func, &cond_name[0] as *byte);
        const body_bb: *void = LLVMAppendBasicBlock(current_func, &body_name[0] as *byte);
        const end_bb: *void = LLVMAppendBasicBlock(current_func, &end_name[0] as *byte);
        
        // 将循环基本块推入栈（用于 break/continue）
        if codegen.loop_stack_depth >= LOOP_STACK_SIZE {
            return -1;  // 循环嵌套过深
        }
        codegen.loop_stack[codegen.loop_stack_depth].cond_bb = cond_bb;
        codegen.loop_stack[codegen.loop_stack_depth].end_bb = end_bb;
        codegen.loop_stack[codegen.loop_stack_depth].inc_bb = null;  // while 循环没有 inc_bb
        codegen.loop_stack_depth = codegen.loop_stack_depth + 1;
        
        // 跳转到条件检查
        LLVMBuildBr(codegen.builder, cond_bb);
        
        // 生成条件检查
        LLVMPositionBuilderAtEnd(codegen.builder, cond_bb);
        const cond_val: *void = codegen_gen_expr(codegen, condition);
        if cond_val == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;  // 错误恢复：弹出栈
            return -1;
        }
        LLVMBuildCondBr(codegen.builder, cond_val, body_bb, end_bb);
        
        // 生成循环体
        LLVMPositionBuilderAtEnd(codegen.builder, body_bb);
        if codegen_gen_stmt(codegen, body) != 0 {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;  // 错误恢复：弹出栈
            return -1;
        }
        
        // 检查循环体结束前是否需要跳转（如果已经有终止符，不需要再跳转）
        // 注意：为了确保正确性，我们总是检查 body_bb 本身是否有终止符
        const terminator: *void = LLVMGetBasicBlockTerminator(body_bb);
        if terminator == null {
            // 循环体结束前跳转到条件检查（continue 会跳过这里）
            LLVMPositionBuilderAtEnd(codegen.builder, body_bb);
            LLVMBuildBr(codegen.builder, cond_bb);
        }
        
        // 从栈中弹出循环信息
        codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
        
        // 设置构建器到 end 基本块
        LLVMPositionBuilderAtEnd(codegen.builder, end_bb);
        
        return 0;
    } else if stmt.type == AST_BREAK_STMT {
        // break 语句：跳转到循环结束基本块
        if codegen.loop_stack_depth == 0 {
            return -1;  // break 不在循环中（类型检查应该已经检查过了）
        }
        const end_bb: *void = codegen.loop_stack[codegen.loop_stack_depth - 1].end_bb;
        LLVMBuildBr(codegen.builder, end_bb);
        return 0;
    } else if stmt.type == AST_CONTINUE_STMT {
        // continue 语句：跳转到循环递增基本块（for 循环）或条件检查基本块（while 循环）
        if codegen.loop_stack_depth == 0 {
            return -1;  // continue 不在循环中（类型检查应该已经检查过了）
        }
        const inc_bb: *void = codegen.loop_stack[codegen.loop_stack_depth - 1].inc_bb;
        if inc_bb != null {
            // for 循环：跳转到递增基本块
            LLVMBuildBr(codegen.builder, inc_bb);
        } else {
            // while 循环：跳转到条件检查基本块
            const cond_bb: *void = codegen.loop_stack[codegen.loop_stack_depth - 1].cond_bb;
            LLVMBuildBr(codegen.builder, cond_bb);
        }
        return 0;
    } else if stmt.type == AST_FOR_STMT {
        // for 语句：暂时不支持
        return -1;
        // for 语句：数组遍历循环
        const array_expr: &ASTNode = stmt.for_stmt_array;
        const var_name: &byte = stmt.for_stmt_var_name;
        const is_ref: i32 = stmt.for_stmt_is_ref;
        const body: &ASTNode = stmt.for_stmt_body;
        
        if array_expr == null || var_name == null || body == null {
            return -1;
        }
        
        // 获取当前函数
        const current_bb: *void = LLVMGetInsertBlock(codegen.builder);
        if current_bb == null {
            return -1;
        }
        const current_func: *void = LLVMGetBasicBlockParent(current_bb);
        if current_func == null {
            return -1;
        }
        
        // 创建基本块：init（初始化）、cond（条件检查）、body（循环体）、inc（递增）、end（结束）
        const bb_id: i32 = codegen.basic_block_counter;
        codegen.basic_block_counter = codegen.basic_block_counter + 1;
        
        var init_name: [byte: 32] = [];
        var cond_name: [byte: 32] = [];
        var body_name: [byte: 32] = [];
        var inc_name: [byte: 32] = [];
        var end_name: [byte: 32] = [];
        snprintf(&init_name[0] as *byte, 32, "for.init.%d", bb_id);
        snprintf(&cond_name[0] as *byte, 32, "for.cond.%d", bb_id);
        snprintf(&body_name[0] as *byte, 32, "for.body.%d", bb_id);
        snprintf(&inc_name[0] as *byte, 32, "for.inc.%d", bb_id);
        snprintf(&end_name[0] as *byte, 32, "for.end.%d", bb_id);
        const init_bb: *void = LLVMAppendBasicBlock(current_func, &init_name[0] as *byte);
        const cond_bb: *void = LLVMAppendBasicBlock(current_func, &cond_name[0] as *byte);
        const body_bb: *void = LLVMAppendBasicBlock(current_func, &body_name[0] as *byte);
        const inc_bb: *void = LLVMAppendBasicBlock(current_func, &inc_name[0] as *byte);
        const end_bb: *void = LLVMAppendBasicBlock(current_func, &end_name[0] as *byte);
        
        // 将循环基本块推入栈（用于 break/continue）
        if codegen.loop_stack_depth >= LOOP_STACK_SIZE {
            return -1;  // 循环嵌套过深
        }
        codegen.loop_stack[codegen.loop_stack_depth].cond_bb = cond_bb;
        codegen.loop_stack[codegen.loop_stack_depth].end_bb = end_bb;
        codegen.loop_stack[codegen.loop_stack_depth].inc_bb = inc_bb;  // for 循环有 inc_bb
        codegen.loop_stack_depth = codegen.loop_stack_depth + 1;
        
        // 在当前基本块分配循环索引变量 i（在所有基本块中使用）
        const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32) as *void;
        if i32_type == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 分配循环索引变量 i（在当前基本块中分配，这样可以在所有后续基本块中使用）
        const index_ptr: *void = build_entry_alloca(codegen, i32_type, "");
        if index_ptr == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 获取数组变量的地址（指针）
        // 对于数组变量，我们使用 lvalue_address 获取其地址，而不是加载整个数组的值
        const array_ptr: *void = codegen_gen_lvalue_address(codegen, array_expr) as *void;
        if array_ptr == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 获取数组类型：如果 array_expr 是标识符，从变量表获取类型；否则从指针类型推导
        var array_type: *void = null;
        if array_expr.type == AST_IDENTIFIER {
            // 标识符：从变量表获取类型（变量表中存储的是数组类型，不是指针类型）
            const array_var_name: &byte = array_expr.identifier_name;
            array_type = lookup_var_type(codegen, array_var_name) as *void;
            if array_type == null {
                codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
                return -1;
            }
        } else {
            // 其他表达式：从指针类型推导数组类型
            const array_ptr_type: &void = safe_LLVMTypeOf(array_ptr as &void);
            if array_ptr_type == null || LLVMGetTypeKind(array_ptr_type as *void) != LLVMPointerTypeKind {
                codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
                return -1;
            }
            array_type = safe_LLVMGetElementType(array_ptr_type) as *void;
            if array_type == null {
                codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
                return -1;
            }
        }
        
        // 验证是数组类型
        if LLVMGetTypeKind(array_type) != LLVMArrayTypeKind {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;  // 不是数组类型
        }
        
        // 获取数组长度：从 AST 类型节点获取数组大小
        var array_length: i32 = 0;
        if array_expr.type == AST_IDENTIFIER {
            const array_var_name: &byte = array_expr.identifier_name;
            const array_ast_type: &ASTNode = lookup_var_ast_type(codegen, array_var_name);
            if array_ast_type != null && array_ast_type.type == AST_TYPE_ARRAY {
                const size_expr: &ASTNode = array_ast_type.type_array_size_expr;
                if size_expr != null && size_expr.type == AST_NUMBER {
                    array_length = size_expr.number_value;
                }
            }
        }
        if array_length <= 0 {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;  // 无法获取数组长度
        }
        const array_length_val: *void = LLVMConstInt(i32_type, array_length, 0) as &void;
        
        // 获取元素类型
        const element_type: &void = safe_LLVMGetElementType(array_type as &void);
        if element_type == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 确定循环变量类型
        var loop_var_type: *void = null;
        var loop_var_ast_type: &ASTNode = null;
        
        if is_ref != 0 {
            // 引用迭代：循环变量是指向元素的指针
            loop_var_type = LLVMPointerType(element_type, 0);
            // 简化处理：暂时不创建 AST 类型节点
        } else {
            // 值迭代：循环变量是元素值
            loop_var_type = element_type;
            // 简化处理：暂时不创建 AST 类型节点
        }
        
        // 分配循环变量空间（在当前基本块中分配，这样可以在所有后续基本块中使用）
        const loop_var_ptr: *void = build_entry_alloca(codegen, loop_var_type, "");
        if loop_var_ptr == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 添加循环变量到变量表（在循环开始前添加一次，而不是每次迭代都添加）
        if add_var(codegen, var_name, loop_var_ptr as &void, loop_var_type as &void, null, loop_var_ast_type) != 0 {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 跳转到初始化基本块
        LLVMBuildBr(codegen.builder, init_bb);
        
        // 生成初始化代码（初始化循环索引 i = 0）
        LLVMPositionBuilderAtEnd(codegen.builder, init_bb);
        LLVMBuildStore(codegen.builder, LLVMConstInt(i32_type, 0 as usize, 0) as &void, index_ptr);
        
        // 跳转到条件检查
        LLVMBuildBr(codegen.builder, cond_bb);
        
        // 生成条件检查（i < array_length）
        LLVMPositionBuilderAtEnd(codegen.builder, cond_bb);
        const index_val: *void = LLVMBuildLoad2(codegen.builder, i32_type, index_ptr, "");
        if index_val == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        const cond_val: *void = LLVMBuildICmp(codegen.builder, LLVMIntSLT, index_val, array_length_val, "");
        if cond_val == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        LLVMBuildCondBr(codegen.builder, cond_val, body_bb, end_bb);
        
        // 生成循环体
        LLVMPositionBuilderAtEnd(codegen.builder, body_bb);
        
        // 重新加载索引值（因为在不同的基本块中，index_val 不可用）
        const index_val_body: *void = LLVMBuildLoad2(codegen.builder, i32_type, index_ptr, "");
        if index_val_body == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 生成循环变量（值迭代：load array[i]，引用迭代：getelementptr array[i]）
        const i32_type_for_gep: *void = LLVMInt32Type();
        const indices: [*void: 2] = [
            LLVMConstInt(i32_type_for_gep, 0, 0) as &void,  // 数组指针本身
            index_val_body  // 元素索引（运行时值）
        ];
        
        const element_ptr: *void = LLVMBuildGEP2(codegen.builder, array_type, array_ptr, &indices[0] as *void, 2, "");
        if element_ptr == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        var loop_var_val: *void = null;
        
        if is_ref != 0 {
            // 引用迭代：循环变量是指向元素的指针
            loop_var_val = element_ptr;
        } else {
            // 值迭代：循环变量是元素值
            loop_var_val = LLVMBuildLoad2(codegen.builder, element_type as *void, element_ptr, "");
            if loop_var_val == null {
                codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
                return -1;
            }
        }
        
        // 存储循环变量值（变量已经在循环开始前添加到变量表）
        LLVMBuildStore(codegen.builder, loop_var_val, loop_var_ptr);
        
        // 生成循环体代码
        if codegen_gen_stmt(codegen, body) != 0 {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 检查循环体结束前是否需要跳转（如果已经有终止符，不需要再跳转）
        // 注意：为了确保正确性，我们总是检查 body_bb 本身是否有终止符
        const terminator: *void = LLVMGetBasicBlockTerminator(body_bb);
        if terminator == null {
            // 循环体结束前跳转到递增基本块（continue 会跳过这里）
            LLVMPositionBuilderAtEnd(codegen.builder, body_bb);
            LLVMBuildBr(codegen.builder, inc_bb);
        }
        
        // 生成递增代码（i = i + 1）
        LLVMPositionBuilderAtEnd(codegen.builder, inc_bb);
        const index_val_inc: *void = LLVMBuildLoad2(codegen.builder, i32_type, index_ptr, "");
        if index_val_inc == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        const index_val_next: *void = LLVMBuildAdd(codegen.builder, index_val_inc, LLVMConstInt(i32_type, 1 as usize, 0) as &void, "");
        if index_val_next == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        LLVMBuildStore(codegen.builder, index_val_next, index_ptr);
        
        // 跳转到条件检查
        LLVMBuildBr(codegen.builder, cond_bb);
        
        // 从栈中弹出循环信息
        codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
        
        // 设置构建器到 end 基本块
        LLVMPositionBuilderAtEnd(codegen.builder, end_bb);
        
        return 0;
    } else if stmt.type == AST_FN_DECL || stmt.type == AST_STRUCT_DECL || 
              stmt.type == AST_ENUM_DECL || stmt.type == AST_PROGRAM {
        // 声明节点不应该作为语句处理（应该在程序级别处理）
        // 在编译器自举时，某些代码块可能包含这些节点，跳过它们
        return 0;
    }
    
    // 其他未知语句类型
    // 如果是表达式节点（表达式语句），尝试将其当作表达式处理
    const expr_val: *void = codegen_gen_expr(codegen, stmt);
    // 忽略返回值（即使失败也返回0，因为表达式语句的返回值不重要）
    return 0;
}

