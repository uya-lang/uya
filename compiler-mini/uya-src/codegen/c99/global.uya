// global.uya - C99 代码生成器全局变量模块
// 提供全局变量生成功能
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 外部函数声明 =====
// C 标准库函数（在 extern_decls.uya 中声明）

fn gen_global_init_expr(codegen: &C99CodeGenerator, expr: &ASTNode) void {
    if expr == null {
        return;
    }
    
    if expr.type == ASTNodeType.AST_STRUCT_INIT {
        // 对于全局作用域，生成标准初始化器列表，不使用复合字面量
        const field_count: i32 = expr.struct_init_field_count;
        fputc(123, codegen.output as *void);  // '{'
        var i: i32 = 0;
        while i < field_count {
            const safe_field_name: &byte = get_safe_c_identifier(codegen, expr.struct_init_field_names[i]);
            fprintf(codegen.output as *void, ".%s = " as *byte, safe_field_name as *byte);
            gen_global_init_expr(codegen, expr.struct_init_field_values[i]);
            if i < field_count - 1 {
                fputs(", " as *byte, codegen.output as *void);
            }
            i = i + 1;
        }
        fputc(125, codegen.output as *void);  // '}'
    } else if expr.type == ASTNodeType.AST_ARRAY_LITERAL {
        const element_count: i32 = expr.array_literal_element_count;
        const repeat_count_expr: &ASTNode = expr.array_literal_repeat_count_expr;
        fputc(123, codegen.output as *void);  // '{'
        if repeat_count_expr != null && element_count >= 1 {
            var nn: i32 = eval_const_expr(codegen, repeat_count_expr);
            if nn <= 0 {
                nn = 1;
            }
            var i: i32 = 0;
            while i < nn {
                gen_global_init_expr(codegen, expr.array_literal_elements[0]);
                if i < nn - 1 {
                    fputs(", " as *byte, codegen.output as *void);
                }
                i = i + 1;
            }
        } else {
            var i: i32 = 0;
            while i < element_count {
                gen_global_init_expr(codegen, expr.array_literal_elements[i]);
                if i < element_count - 1 {
                    fputs(", " as *byte, codegen.output as *void);
                }
                i = i + 1;
            }
        }
        fputc(125, codegen.output as *void);  // '}'
    } else {
        // 对于其他表达式类型（数字、布尔值、字符串等），使用标准生成方式
        gen_expr(codegen, expr);
    }
}

// 生成全局变量定义
fn gen_global_var(codegen: &C99CodeGenerator, var_decl: &ASTNode) void {
    if var_decl == null || var_decl.type != ASTNodeType.AST_VAR_DECL {
        return;
    }
    
    const var_name: &byte = get_safe_c_identifier(codegen, var_decl.var_decl_name);
    const var_type: &ASTNode = var_decl.var_decl_type;
    const init_expr: &ASTNode = var_decl.var_decl_init;
    const is_const: i32 = var_decl.var_decl_is_const;
    
    if var_name == null || var_type == null {
        return;
    }
    
    var type_c: &byte = null;
    
    // 检查是否为数组类型
    if var_type.type == ASTNodeType.AST_TYPE_ARRAY {
        // 对于数组类型（包括多维数组），使用 c99_type_to_c 处理整个类型
        // 它会正确处理多维数组，例如 [[byte: PATH_MAX]: MAX_INPUT_FILES] -> uint8_t[64][4096]
        const full_type_c: &byte = c99_type_to_c(codegen, var_type);
        
        // 解析类型字符串，分离基类型和数组维度
        // 例如："uint8_t[64][4096]" -> 基类型="uint8_t", 维度="[64][4096]"
        const first_bracket: *byte = strchr(full_type_c as *byte, 91);  // '['
        if first_bracket != null {
            // 找到第一个 '['，分割基类型和维度
            const base_len: i32 = ptr_diff(first_bracket, full_type_c as *byte);
            const base_type: &byte = arena_alloc(codegen.arena, base_len + 1) as &byte;
            if base_type != null {
                memcpy(base_type as *void, full_type_c as *void, base_len);
                base_type[base_len] = 0;
                
                // 维度部分是从 '[' 开始到结尾
                const dimensions: *byte = full_type_c as *byte + base_len;
                
                // 生成数组声明：const base_type var_name dimensions
                if is_const != 0 {
                    fprintf(codegen.output as *void, "const %s %s%s" as *byte, base_type as *byte, var_name as *byte, dimensions);
                } else {
                    fprintf(codegen.output as *void, "%s %s%s" as *byte, base_type as *byte, var_name as *byte, dimensions);
                }
                type_c = base_type;  // 保存基类型用于后续使用
            } else {
                // 分配失败，回退到简单处理
                type_c = full_type_c;
                if is_const != 0 {
                    fprintf(codegen.output as *void, "const %s %s" as *byte, type_c as *byte, var_name as *byte);
                } else {
                    fprintf(codegen.output as *void, "%s %s" as *byte, type_c as *byte, var_name as *byte);
                }
            }
        } else {
            // 没有找到 '['，可能是错误情况，回退到简单处理
            type_c = full_type_c;
            if is_const != 0 {
                fprintf(codegen.output as *void, "const %s %s" as *byte, type_c as *byte, var_name as *byte);
            } else {
                fprintf(codegen.output as *void, "%s %s" as *byte, type_c as *byte, var_name as *byte);
            }
        }
    } else {
        type_c = c99_type_to_c(codegen, var_type);
        if is_const != 0 {
            fprintf(codegen.output as *void, "const %s %s", type_c as *byte, var_name as *byte);
        } else {
            fprintf(codegen.output as *void, "%s %s", type_c as *byte, var_name as *byte);
        }
    }
    
    // 初始化表达式（使用全局作用域兼容的生成方式）
    if init_expr != null {
        fputs(" = " as *byte, codegen.output as *void);
        gen_global_init_expr(codegen, init_expr);
    }
    
    fputs(";\n" as *byte, codegen.output as *void);
    
    // 添加到全局变量表（可选，用于后续引用）
    if codegen.global_variable_count < C99_MAX_GLOBAL_VARS {
        codegen.global_variables[codegen.global_variable_count].name = var_name;
        codegen.global_variables[codegen.global_variable_count].type_c = type_c;
        codegen.global_variables[codegen.global_variable_count].is_const = is_const;
        codegen.global_variable_count = codegen.global_variable_count + 1;
    }
}

