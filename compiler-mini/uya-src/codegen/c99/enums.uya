// enums.uya - C99 代码生成器枚举模块
// 提供枚举定义生成功能
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 外部函数声明 =====
// C 标准库函数（在 extern_decls.uya 中声明）

fn find_enum_decl_c99(codegen: &C99CodeGenerator, enum_name: &byte) &ASTNode {
    if codegen == null || enum_name == null || codegen.program_node == null {
        return null;
    }
    
    const decl_count: i32 = codegen.program_node.program_decl_count;
    
    var i: i32 = 0;
    while i < decl_count {
        const decl: &ASTNode = codegen.program_node.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_ENUM_DECL {
            const decl_name: &byte = decl.enum_decl_name;
            if decl_name != null && strcmp(decl_name as *byte, enum_name as *byte) == 0 {
                return decl;
            }
        }
        i = i + 1;
    }
    
    return null;
}

// 查找枚举变体的值（返回-1表示未找到）
fn find_enum_variant_value(codegen: &C99CodeGenerator, enum_decl: &ASTNode, variant_name: &byte) i32 {
    // codegen 参数未使用，但保留以保持接口一致性
    if enum_decl == null || enum_decl.type != ASTNodeType.AST_ENUM_DECL || variant_name == null {
        return -1;
    }
    
    const variants: &EnumVariant = enum_decl.enum_decl_variants;
    const variant_count: i32 = enum_decl.enum_decl_variant_count;
    var current_value: i32 = 0;
    
    var i: i32 = 0;
    while i < variant_count {
        const variant: &EnumVariant = variants + i;
        if variant.name == null {
            i = i + 1;
            continue;
        }
        
        // 确定当前变体的值
        if variant.value != null {
            current_value = atoi(variant.value as *byte);
        }
        
        // 检查是否匹配
        if strcmp(variant.name as *byte, variant_name as *byte) == 0 {
            return current_value;
        }
        
        // 如果没有显式值，下一个变体的值会自动递增
        if variant.value == null {
            current_value = current_value + 1;
        }
        
        i = i + 1;
    }
    
    return -1;
}

fn is_enum_defined(codegen: &C99CodeGenerator, enum_name: &byte) i32 {
    var i: i32 = 0;
    while i < codegen.enum_definition_count {
        if strcmp(codegen.enum_definitions[i].name as *byte, enum_name as *byte) == 0 {
            const result: i32 = codegen.enum_definitions[i].defined;
            return result;
        }
        i = i + 1;
    }
    return 0;
}

// 检查枚举是否已添加到表中
fn is_enum_in_table(codegen: &C99CodeGenerator, enum_name: &byte) i32 {
    var i: i32 = 0;
    while i < codegen.enum_definition_count {
        if strcmp(codegen.enum_definitions[i].name as *byte, enum_name as *byte) == 0 {
            return 1;
        }
        i = i + 1;
    }
    return 0;
}

// 标记枚举已定义
fn mark_enum_defined(codegen: &C99CodeGenerator, enum_name: &byte) void {
    var i: i32 = 0;
    while i < codegen.enum_definition_count {
        if strcmp(codegen.enum_definitions[i].name as *byte, enum_name as *byte) == 0 {
            codegen.enum_definitions[i].defined = 1;
            return;
        }
        i = i + 1;
    }
}

// 添加枚举定义
fn add_enum_definition(codegen: &C99CodeGenerator, enum_name: &byte) void {
    // 如果已存在，则返回
    var i: i32 = 0;
    while i < codegen.enum_definition_count {
        if strcmp(codegen.enum_definitions[i].name as *byte, enum_name as *byte) == 0 {
            return;
        }
        i = i + 1;
    }
    
    if codegen.enum_definition_count < C99_MAX_ENUM_DEFINITIONS {
        codegen.enum_definitions[codegen.enum_definition_count].name = enum_name;
        codegen.enum_definitions[codegen.enum_definition_count].defined = 0;
        codegen.enum_definition_count = codegen.enum_definition_count + 1;
    }
}

// 生成枚举定义
fn gen_enum_definition(codegen: &C99CodeGenerator, enum_decl: &ASTNode) i32 {
    if enum_decl == null || enum_decl.type != ASTNodeType.AST_ENUM_DECL {
        return -1;
    }
    
    const enum_name: &byte = get_safe_c_identifier(codegen, enum_decl.enum_decl_name);
    if enum_name == null {
        return -1;
    }
    
    // 如果已定义，跳过
    if is_enum_defined(codegen, enum_name) != 0 {
        return 0;
    }
    
    // 添加枚举定义标记
    add_enum_definition(codegen, enum_name);
    
    // 输出枚举定义
    c99_emit_indent(codegen);
    fprintf(codegen.output as *void, "enum %s {\n" as *byte, enum_name as *byte);
    codegen.indent_level = codegen.indent_level + 1;
    
    const variants: &EnumVariant = enum_decl.enum_decl_variants;
    const variant_count: i32 = enum_decl.enum_decl_variant_count;
    var current_value: i32 = 0;
    
    var i: i32 = 0;
    while i < variant_count {
        const variant: &EnumVariant = variants + i;
        if variant.name == null {
            return -1;
        }
        
        // 确定变体的值
        if variant.value != null {
            // 有显式值，使用atoi转换
            const safe_variant_name: &byte = get_safe_c_identifier(codegen, variant.name);
            current_value = atoi(variant.value as *byte);
            c99_emit_indent(codegen);
            fprintf(codegen.output as *void, "%s = %d" as *byte, safe_variant_name as *byte, current_value);
        } else {
            // 无显式值，使用当前值（从0开始或基于前一个值）
            const safe_variant_name2: &byte = get_safe_c_identifier(codegen, variant.name);
            c99_emit_indent(codegen);
            fprintf(codegen.output as *void, "%s" as *byte, safe_variant_name2 as *byte);
            // 当前值保持不变，供下一个变体使用（C中隐式递增）
        }
        
        // 添加逗号（除非是最后一个）
        if i < variant_count - 1 {
            fputs("," as *byte, codegen.output as *void);
        }
        fputs("\n" as *byte, codegen.output as *void);
        
        // 如果没有显式值，下一个变体的值会自动递增
        if variant.value == null {
            current_value = current_value + 1;
        }
        
        i = i + 1;
    }
    
    codegen.indent_level = codegen.indent_level - 1;
    c99_emit_indent(codegen);
    fputs("};\n" as *byte, codegen.output as *void);
    
    // 标记为已定义
    mark_enum_defined(codegen, enum_name);
    return 0;
}

