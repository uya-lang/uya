// stmt.uya - C99 代码生成器语句模块
// 提供语句代码生成功能
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 外部函数声明 =====
// C 标准库函数（在 extern_decls.uya 中声明）

fn gen_stmt(codegen: &C99CodeGenerator, stmt: &ASTNode) void {
    if stmt == null {
        return;
    }
    
    // 生成 #line 指令，指向语句的位置（如果行号有效）
    if stmt.line > 0 {
        emit_line_directive(codegen, stmt.line, stmt.filename);
    }
    
    if stmt.type == ASTNodeType.AST_EXPR_STMT {
        // 表达式语句的数据存储在表达式的节点中，直接忽略此节点
        return;
    } else if stmt.type == ASTNodeType.AST_ASSIGN {
        const dest: &ASTNode = stmt.assign_dest;
        const src: &ASTNode = stmt.assign_src;
        
        // 检查左侧是否是数组类型
        var is_array_assign: i32 = 0;
        if dest.type == ASTNodeType.AST_IDENTIFIER {
            const var_name: &byte = dest.identifier_name;
            // 检查局部变量
            var i: i32 = codegen.local_variable_count - 1;
            while i >= 0 {
                if strcmp(codegen.local_variables[i].name as *byte, var_name as *byte) == 0 {
                    const type_c: &byte = codegen.local_variables[i].type_c;
                    if type_c != null && strchr(type_c as *byte, 91) != null {  // '['
                        is_array_assign = 1;
                    }
                    break;
                }
                i = i - 1;
            }
            // 检查全局变量
            if is_array_assign == 0 {
                i = 0;
                while i < codegen.global_variable_count {
                    if strcmp(codegen.global_variables[i].name as *byte, var_name as *byte) == 0 {
                        const type_c2: &byte = codegen.global_variables[i].type_c;
                        if type_c2 != null && strchr(type_c2 as *byte, 91) != null {  // '['
                            is_array_assign = 1;
                        }
                        break;
                    }
                    i = i + 1;
                }
            }
        }
        
        if is_array_assign != 0 {
            // 数组赋值：使用 memcpy
            c99_emit(codegen, "memcpy(" as *byte);
            gen_expr(codegen, dest);
            fputs(", " as *byte, codegen.output as *void);
            gen_expr(codegen, src);
            fputs(", sizeof(" as *byte, codegen.output as *void);
            gen_expr(codegen, dest);
            fputs("));\n" as *byte, codegen.output as *void);
        } else {
            // 普通赋值
            c99_emit(codegen, "" as *byte);
            gen_expr(codegen, dest);
            fputs(" = " as *byte, codegen.output as *void);
            gen_expr(codegen, src);
            fputs(";\n" as *byte, codegen.output as *void);
        }
    } else if stmt.type == ASTNodeType.AST_RETURN_STMT {
        const expr: &ASTNode = stmt.return_stmt_expr;
        
        // 检查函数返回类型是否为数组
        var is_array_return: i32 = 0;
        const return_type: &ASTNode = codegen.current_function_return_type;
        if return_type != null && return_type.type == ASTNodeType.AST_TYPE_ARRAY {
            is_array_return = 1;
        }
        
        if is_array_return != 0 && expr != null {
            // 返回数组类型：需要包装在结构体中
            const struct_name: &byte = get_array_wrapper_struct_name(codegen, return_type);
            if struct_name != null {
                // 生成包装结构体定义（如果尚未生成）
                gen_array_wrapper_struct(codegen, return_type, struct_name);
                
                // 生成返回语句：return (struct uya_array_xxx) { .data = { ... } };
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "return (struct %s) { .data = " as *byte, struct_name as *byte);
                
                if expr.type == ASTNodeType.AST_ARRAY_LITERAL {
                    fputc(123, codegen.output as *void);  // '{'
                    const element_count: i32 = expr.array_literal_element_count;
                    const repeat_count_expr: &ASTNode = expr.array_literal_repeat_count_expr;
                    if repeat_count_expr != null && element_count >= 1 {
                        var nn: i32 = eval_const_expr(codegen, repeat_count_expr);
                        if nn <= 0 {
                            nn = 1;
                        }
                        var i: i32 = 0;
                        while i < nn {
                            if i > 0 {
                                fputs(", " as *byte, codegen.output as *void);
                            }
                            gen_expr(codegen, expr.array_literal_elements[0]);
                            i = i + 1;
                        }
                    } else {
                        var i: i32 = 0;
                        while i < element_count {
                            if i > 0 {
                                fputs(", " as *byte, codegen.output as *void);
                            }
                            gen_expr(codegen, expr.array_literal_elements[i]);
                            i = i + 1;
                        }
                    }
                    fputc(125, codegen.output as *void);  // '}'
                } else {
                    // 其他表达式（如变量）
                    gen_expr(codegen, expr);
                }
                
                fputs(" };\n" as *byte, codegen.output as *void);
            } else {
                // 回退到普通返回
                c99_emit(codegen, "return " as *byte);
                gen_expr(codegen, expr);
                fputs(";\n" as *byte, codegen.output as *void);
            }
        } else {
            // 非数组返回类型，正常处理
            // 检查返回类型是否为 void
            var is_void: i32 = 0;
            if return_type != null && return_type.type == ASTNodeType.AST_TYPE_NAMED {
                const type_name: &byte = return_type.type_named_name;
                if type_name != null && strcmp(type_name as *byte, "void" as *byte) == 0 {
                    is_void = 1;
                }
            }
            
            if is_void != 0 && expr == null {
                // void 函数且无返回值：生成 return;
                c99_emit(codegen, "return;\n" as *byte);
            } else {
                // 非 void 函数或 void 函数有返回值（错误情况，但让编译器处理）
                c99_emit(codegen, "return " as *byte);
                if expr != null {
                    gen_expr(codegen, expr);
                } else {
                    fputs("0" as *byte, codegen.output as *void);
                }
                fputs(";\n" as *byte, codegen.output as *void);
            }
        }
    } else if stmt.type == ASTNodeType.AST_BLOCK {
        const stmt_count: i32 = stmt.block_stmt_count;
        var i: i32 = 0;
        while i < stmt_count {
            gen_stmt(codegen, stmt.block_stmts[i]);
            i = i + 1;
        }
    } else if stmt.type == ASTNodeType.AST_VAR_DECL {
        const var_name: &byte = get_safe_c_identifier(codegen, stmt.var_decl_name);
        const var_type: &ASTNode = stmt.var_decl_type;
        const init_expr: &ASTNode = stmt.var_decl_init;
        const is_const: i32 = stmt.var_decl_is_const;
        
        // 计算类型字符串
        var type_c: &byte = null;
        var stored_type_c: &byte = null;  // 用于存储到变量表的完整类型字符串
        var stored_type_c_for_pointer: &byte = null;  // 用于存储指针类型的完整类型字符串（包括 const）
        if var_type.type == ASTNodeType.AST_TYPE_ARRAY {
            // 使用 c99_type_to_c 来处理数组类型（包括多维数组）
            // 它会返回正确的格式，如 "int32_t[3][2]" 对于 [[i32: 2]: 3]
            type_c = c99_type_to_c(codegen, var_type);
            
            // 保存完整的类型字符串（包括 const 和维度）用于存储到变量表
            if type_c != null {
                const type_len: i32 = strlen(type_c as *byte);
                if is_const != 0 {
                    // 为 "const " 前缀分配空间
                    stored_type_c = arena_alloc(codegen.arena, type_len + 7) as &byte;
                    if stored_type_c != null {
                        snprintf(stored_type_c as *byte, type_len + 7, "const %s" as *byte, type_c as *byte);
                    }
                } else {
                    stored_type_c = c99_arena_strdup(codegen.arena, type_c);
                }
            }
            
            // 解析类型字符串，分离基类型和数组维度
            // 例如："int32_t[3][2]" -> 基类型="int32_t", 维度="[3][2]"
            // 或者 "int32_t[3]" -> 基类型="int32_t", 维度="[3]"
            const first_bracket: *byte = strchr(type_c as *byte, 91);  // '['
            if first_bracket != null {
                // 找到第一个 '['，分割基类型和维度
                const base_len: i32 = ptr_diff(first_bracket, type_c as *byte);
                const base_type: &byte = arena_alloc(codegen.arena, base_len + 1) as &byte;
                if base_type != null {
                    memcpy(base_type as *void, type_c as *void, base_len);
                    base_type[base_len] = 0;
                    
                    // 维度部分是从 '[' 开始到结尾
                    const dimensions: *byte = type_c as *byte + base_len;
                    
                    // 生成数组声明：const base_type var_name dimensions
                    if is_const != 0 {
                        fprintf(codegen.output as *void, "const %s %s%s" as *byte, base_type as *byte, var_name as *byte, dimensions);
                    } else {
                        fprintf(codegen.output as *void, "%s %s%s" as *byte, base_type as *byte, var_name as *byte, dimensions);
                    }
                    type_c = null; // 已处理，避免后续重复输出
                }
            }
            
            // 如果上面的解析失败，回退到简单处理
            if type_c != null {
                if is_const != 0 {
                    c99_emit_indent(codegen);
                    fprintf(codegen.output as *void, "const %s %s" as *byte, type_c as *byte, var_name as *byte);
                } else {
                    c99_emit_indent(codegen);
                    fprintf(codegen.output as *void, "%s %s" as *byte, type_c as *byte, var_name as *byte);
                }
            }
        } else {
            // 非数组类型
            type_c = c99_type_to_c(codegen, var_type);
            // 为存储到变量表准备完整的类型字符串（包括 const 修饰符）
            if is_const != 0 && var_type.type == ASTNodeType.AST_TYPE_POINTER {
                // 检查是否是指向数组的指针类型（格式：T (*)[N]）
                const open_paren: *byte = strstr(type_c as *byte, "(*" as *byte);
                if open_paren != null {
                    // 找到对应的 ')' 和 '['
                    const close_paren: *byte = strchr(open_paren, 41);  // ')'
                    const bracket: *byte = strchr(open_paren, 91);  // '['
                    if close_paren != null && bracket != null && close_paren < bracket {
                        // 这是指向数组的指针：T (*)[N]
                        // 需要生成：T (* const var_name)[N]
                        const prefix_len: i32 = ptr_diff(open_paren, type_c as *byte);
                        const suffix_len: i32 = strlen(bracket);
                        // 注意：Uya Mini 不支持 %.*s，需要手动处理
                        var temp_buf: [byte: 256] = [];
                        var j: i32 = 0;
                        while j < prefix_len && j < 255 {
                            temp_buf[j] = type_c[j];
                            j = j + 1;
                        }
                        temp_buf[j] = 0;
                        fprintf(codegen.output as *void, "%s(* const %s)%s" as *byte, &temp_buf[0] as *byte, var_name as *byte, bracket);
                        // 存储类型字符串：T (* const)[N]（用于变量表）
                        const total_len: i32 = prefix_len + suffix_len + 10; // "(* const)" + null
                        stored_type_c_for_pointer = arena_alloc(codegen.arena, total_len) as &byte;
                        if stored_type_c_for_pointer != null {
                            var temp_buf2: [byte: 256] = [];
                            j = 0;
                            while j < prefix_len && j < 255 {
                                temp_buf2[j] = type_c[j];
                                j = j + 1;
                            }
                            temp_buf2[j] = 0;
                            snprintf(stored_type_c_for_pointer as *byte, total_len, "%s(* const)%s" as *byte, &temp_buf2[0] as *byte, bracket);
                        }
                    } else {
                        // 普通指针：T * -> T * const var_name
                        c99_emit_indent(codegen);
                        fprintf(codegen.output as *void, "%s const %s" as *byte, type_c as *byte, var_name as *byte);
                        // 存储类型字符串：T * const（用于变量表）
                        const str_len: i32 = strlen(type_c as *byte) + 7; // " const" + null
                        stored_type_c_for_pointer = arena_alloc(codegen.arena, str_len) as &byte;
                        if stored_type_c_for_pointer != null {
                            snprintf(stored_type_c_for_pointer as *byte, str_len, "%s const" as *byte, type_c as *byte);
                        }
                    }
                } else {
                    // 普通指针：T * -> T * const var_name
                    c99_emit_indent(codegen);
                    fprintf(codegen.output as *void, "%s const %s" as *byte, type_c as *byte, var_name as *byte);
                    // 存储类型字符串：T * const（用于变量表）
                    const str_len2: i32 = strlen(type_c as *byte) + 7; // " const" + null
                        stored_type_c_for_pointer = arena_alloc(codegen.arena, str_len2) as &byte;
                        if stored_type_c_for_pointer != null {
                            snprintf(stored_type_c_for_pointer as *byte, str_len2, "%s const" as *byte, type_c as *byte);
                    }
                }
            } else if is_const != 0 {
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "const %s %s" as *byte, type_c as *byte, var_name as *byte);
                // 存储类型字符串：const T（用于变量表）
                const str_len3: i32 = strlen(type_c as *byte) + 7; // "const " + null
                stored_type_c_for_pointer = arena_alloc(codegen.arena, str_len3) as &byte;
                if stored_type_c_for_pointer != null {
                    snprintf(stored_type_c_for_pointer as *byte, str_len3, "const %s" as *byte, type_c as *byte);
                }
            } else {
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "%s %s" as *byte, type_c as *byte, var_name as *byte);
            }
        }
        
        // *关键修改*：在生成初始化表达式之前，先将变量添加到局部变量表
        // 这样如果初始化表达式或后续表达式使用了这个变量，就能正确识别其类型
        var type_to_store: &byte = null;
        if var_type.type == ASTNodeType.AST_TYPE_ARRAY && stored_type_c != null {
            type_to_store = stored_type_c;
        } else if stored_type_c_for_pointer != null {
            type_to_store = stored_type_c_for_pointer;
        } else if var_type.type == ASTNodeType.AST_TYPE_POINTER && is_const != 0 && type_c != null {
            // 如果 stored_type_c_for_pointer 为 NULL（arena_alloc 失败），但类型是指针且是 const，
            // 手动构造类型字符串：T * const
            const str_len4: i32 = strlen(type_c as *byte) + 7; // " const" + null
            const manual_type: &byte = arena_alloc(codegen.arena, str_len4) as &byte;
            if manual_type != null {
                snprintf(manual_type as *byte, str_len4, "%s const" as *byte, type_c as *byte);
                type_to_store = manual_type;
            } else {
                // 如果还是失败，使用 type_c（至少包含 *，应该能被识别为指针）
                type_to_store = type_c;
            }
        } else if var_type.type == ASTNodeType.AST_TYPE_POINTER && type_c != null {
            // 非 const 指针：直接使用 type_c（应该包含 *）
            type_to_store = type_c;
        } else {
            type_to_store = type_c;
        }
        if var_name != null && type_to_store != null && codegen.local_variable_count < C99_MAX_LOCAL_VARS {
            codegen.local_variables[codegen.local_variable_count].name = var_name;
            codegen.local_variables[codegen.local_variable_count].type_c = type_to_store;
            codegen.local_variable_count = codegen.local_variable_count + 1;
        }
        
        if init_expr != null {
            // 检查是否是空结构体初始化（field_count == 0）
            // 如果是，改为手动初始化，避免 gcc 生成错误的 memset 调用
            var is_empty_struct_init: i32 = 0;
            var struct_decl_for_empty_init: &ASTNode = null;
            if init_expr.type == ASTNodeType.AST_STRUCT_INIT {
                const field_count: i32 = init_expr.struct_init_field_count;
                if field_count == 0 {
                    // 空结构体初始化：从初始化表达式中获取结构体名称
                    const struct_name: &byte = get_safe_c_identifier(codegen, init_expr.struct_init_struct_name);
                    if struct_name != null {
                        struct_decl_for_empty_init = find_struct_decl_c99(codegen, struct_name);
                        if struct_decl_for_empty_init != null {
                            is_empty_struct_init = 1;
                        }
                    }
                }
            }
            
            // 检查是否是数组类型且初始化表达式是函数调用（返回数组）
            var is_array_from_function: i32 = 0;
            if var_type.type == ASTNodeType.AST_TYPE_ARRAY && init_expr.type == ASTNodeType.AST_CALL_EXPR {
                // 需要检查函数返回类型是否为数组
                // 这里简化处理：假设函数调用返回数组类型
                is_array_from_function = 1;
            }
            
            // 检查是否是数组类型且初始化表达式是另一个数组（需要memcpy）
            var needs_memcpy: i32 = 0;
            if var_type.type == ASTNodeType.AST_TYPE_ARRAY && init_expr.type == ASTNodeType.AST_IDENTIFIER {
                needs_memcpy = 1;
            }
            
            // 检查是否是结构体初始化且包含数组字段（初始化值是标识符）
            // 在C中，数组不能直接赋值，需要使用memcpy
            var struct_init_needs_memcpy: i32 = 0;
            if init_expr.type == ASTNodeType.AST_STRUCT_INIT && is_empty_struct_init == 0 {
                const struct_name2: &byte = get_safe_c_identifier(codegen, init_expr.struct_init_struct_name);
                const struct_decl: &ASTNode = find_struct_decl_c99(codegen, struct_name2);
                if struct_decl != null {
                    const field_count2: i32 = init_expr.struct_init_field_count;
                    var i: i32 = 0;
                    while i < field_count2 {
                        const field_name: &byte = init_expr.struct_init_field_names[i];
                        const field_type: &ASTNode = c99_find_struct_field_type(codegen, struct_decl, field_name);
                        if field_type != null && field_type.type == ASTNodeType.AST_TYPE_ARRAY {
                            const field_value: &ASTNode = init_expr.struct_init_field_values[i];
                            if field_value != null && field_value.type == ASTNodeType.AST_IDENTIFIER {
                                struct_init_needs_memcpy = 1;
                                break;
                            }
                        }
                        i = i + 1;
                    }
                }
            }
            
            if is_empty_struct_init != 0 {
                // 空结构体初始化：手动初始化各个字段，避免 gcc 生成错误的 memset 调用
                // 先完成变量声明（不包含初始化）
                fputs(";\n" as *byte, codegen.output as *void);
                
                const struct_decl2: &ASTNode = struct_decl_for_empty_init;
                const field_count3: i32 = struct_decl2.struct_decl_field_count;
                
                if field_count3 > 0 {
                var i2: i32 = 0;
                while i2 < field_count3 {
                    const field: &ASTNode = struct_decl2.struct_decl_fields[i2];
                    if field != null && field.type == ASTNodeType.AST_VAR_DECL {
                        const field_name2: &byte = get_safe_c_identifier(codegen, field.var_decl_name);
                        const field_type2: &ASTNode = field.var_decl_type;
                        
                        if field_name2 != null && field_type2 != null {
                            // 根据字段类型生成初始化代码
                            if field_type2.type == ASTNodeType.AST_TYPE_POINTER {
                                // 指针类型：初始化为 NULL
                                c99_emit_indent(codegen);
                                fprintf(codegen.output as *void, "%s.%s = NULL;\n" as *byte, var_name as *byte, field_name2 as *byte);
                            } else if field_type2.type == ASTNodeType.AST_TYPE_ARRAY {
                                // 数组类型：使用 memset 清零
                                c99_emit_indent(codegen);
                                fprintf(codegen.output as *void, "memset(%s.%s, 0, sizeof(%s.%s));\n" as *byte, var_name as *byte, field_name2 as *byte, var_name as *byte, field_name2 as *byte);
                            } else {
                                // 其他类型（整数、浮点数等）：初始化为 0
                                c99_emit_indent(codegen);
                                fprintf(codegen.output as *void, "%s.%s = 0;\n" as *byte, var_name as *byte, field_name2 as *byte);
                            }
                        }
                    }
                    i2 = i2 + 1;
                }
                } else {
                    // 空结构体（AST 无字段）：与 C 编译器一致，整体零初始化
                    c99_emit_indent(codegen);
                    fprintf(codegen.output as *void, "memset(&%s, 0, sizeof(%s));\n" as *byte, var_name as *byte, var_name as *byte);
                }
            } else if is_array_from_function != 0 {
                // 从函数调用接收数组：需要从包装结构体中提取
                // 先完成变量声明（不包含初始化）
                fputs(";\n" as *byte, codegen.output as *void);
                // 然后使用 memcpy 从结构体中提取数组
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "memcpy(%s" as *byte, var_name as *byte);
                fputs(", " as *byte, codegen.output as *void);
                gen_expr(codegen, init_expr);
                fputs(".data, sizeof(" as *byte, codegen.output as *void);
                fprintf(codegen.output as *void, "%s" as *byte, var_name as *byte);
                fputs("));\n" as *byte, codegen.output as *void);
            } else if needs_memcpy != 0 {
                // 数组初始化：使用memcpy
                fputs(";\n" as *byte, codegen.output as *void);
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "memcpy(%s" as *byte, var_name as *byte);
                fputs(", " as *byte, codegen.output as *void);
                gen_expr(codegen, init_expr);
                fputs(", sizeof(" as *byte, codegen.output as *void);
                fprintf(codegen.output as *void, "%s" as *byte, var_name as *byte);
                fputs("));\n" as *byte, codegen.output as *void);
            } else if struct_init_needs_memcpy != 0 {
                // 结构体初始化包含数组字段：先声明变量，然后使用复合字面量初始化非数组字段，最后用memcpy复制数组字段
                fputs(" = " as *byte, codegen.output as *void);
                
                // 生成复合字面量，但数组字段使用空初始化
                const struct_name3: &byte = get_safe_c_identifier(codegen, init_expr.struct_init_struct_name);
                const struct_decl3: &ASTNode = find_struct_decl_c99(codegen, struct_name3);
                const field_count4: i32 = init_expr.struct_init_field_count;
                
                fprintf(codegen.output as *void, "(struct %s){" as *byte, struct_name3 as *byte);
                var i3: i32 = 0;
                while i3 < field_count4 {
                    const safe_field_name: &byte = get_safe_c_identifier(codegen, init_expr.struct_init_field_names[i3]);
                    const field_type3: &ASTNode = c99_find_struct_field_type(codegen, struct_decl3, init_expr.struct_init_field_names[i3]);
                    const field_value2: &ASTNode = init_expr.struct_init_field_values[i3];
                    
                    fprintf(codegen.output as *void, ".%s = " as *byte, safe_field_name as *byte);
                    
                    // 如果是数组字段且初始化值是标识符，使用空初始化（后续用memcpy填充）
                    if field_type3 != null && field_type3.type == ASTNodeType.AST_TYPE_ARRAY && 
                        field_value2 != null && field_value2.type == ASTNodeType.AST_IDENTIFIER {
                        fputs("{}" as *byte, codegen.output as *void);
                    } else {
                        gen_expr(codegen, field_value2);
                    }
                    
                    if i3 < field_count4 - 1 {
                        fputs(", " as *byte, codegen.output as *void);
                    }
                    i3 = i3 + 1;
                }
                fputs("};\n" as *byte, codegen.output as *void);
                
                // 使用memcpy复制数组字段
                i3 = 0;
                while i3 < field_count4 {
                    const field_name3: &byte = init_expr.struct_init_field_names[i3];
                    const field_type4: &ASTNode = c99_find_struct_field_type(codegen, struct_decl3, field_name3);
                    const field_value3: &ASTNode = init_expr.struct_init_field_values[i3];
                    
                    if field_type4 != null && field_type4.type == ASTNodeType.AST_TYPE_ARRAY && 
                        field_value3 != null && field_value3.type == ASTNodeType.AST_IDENTIFIER {
                        const safe_field_name2: &byte = get_safe_c_identifier(codegen, field_name3);
                        c99_emit_indent(codegen);
                        fprintf(codegen.output as *void, "memcpy(%s.%s, " as *byte, var_name as *byte, safe_field_name2 as *byte);
                        gen_expr(codegen, field_value3);
                        fprintf(codegen.output as *void, ", sizeof(%s.%s));\n" as *byte, var_name as *byte, safe_field_name2 as *byte);
                    }
                    i3 = i3 + 1;
                }
            } else {
                // 普通初始化
                fputs(" = " as *byte, codegen.output as *void);
                gen_expr(codegen, init_expr);
                fputs(";\n" as *byte, codegen.output as *void);
            }
        } else {
            fputs(";\n" as *byte, codegen.output as *void);
        }
    } else if stmt.type == ASTNodeType.AST_IF_STMT {
        const condition: &ASTNode = stmt.if_stmt_condition;
        const then_branch: &ASTNode = stmt.if_stmt_then_branch;
        const else_branch: &ASTNode = stmt.if_stmt_else_branch;
        
        c99_emit_indent(codegen);
        fputs("if (" as *byte, codegen.output as *void);
        gen_expr(codegen, condition);
        fputs(") {\n" as *byte, codegen.output as *void);
        codegen.indent_level = codegen.indent_level + 1;
        gen_stmt(codegen, then_branch);
        codegen.indent_level = codegen.indent_level - 1;
        c99_emit(codegen, "}" as *byte);
        if else_branch != null {
            fputs(" else {\n" as *byte, codegen.output as *void);
            codegen.indent_level = codegen.indent_level + 1;
            gen_stmt(codegen, else_branch);
            codegen.indent_level = codegen.indent_level - 1;
            c99_emit(codegen, "}" as *byte);
        }
        fputs("\n" as *byte, codegen.output as *void);
    } else if stmt.type == ASTNodeType.AST_WHILE_STMT {
        const condition: &ASTNode = stmt.while_stmt_condition;
        const body: &ASTNode = stmt.while_stmt_body;
        
        c99_emit_indent(codegen);
        fputs("while (" as *byte, codegen.output as *void);
        gen_expr(codegen, condition);
        fputs(") {\n" as *byte, codegen.output as *void);
        codegen.indent_level = codegen.indent_level + 1;
        gen_stmt(codegen, body);
        codegen.indent_level = codegen.indent_level - 1;
        c99_emit(codegen, "}\n" as *byte);
    } else if stmt.type == ASTNodeType.AST_FOR_STMT {
        // Uya Mini 的 for 循环是数组遍历：for item in array { ... }
        const array: &ASTNode = stmt.for_stmt_array;
        const var_name2: &byte = get_safe_c_identifier(codegen, stmt.for_stmt_var_name);
        const is_ref: i32 = stmt.for_stmt_is_ref;
        const body2: &ASTNode = stmt.for_stmt_body;
        
        // 获取数组元素类型
        var elem_type_c: &byte = get_array_element_type(codegen, array);
        if elem_type_c == null {
            // 如果无法推断类型，使用int作为默认类型
            elem_type_c = ("int32_t" as *byte) as &byte;
        }
        
        // 生成临时变量保存数组和长度
        c99_emit_indent(codegen);
        fputs("{\n" as *byte, codegen.output as *void);
        codegen.indent_level = codegen.indent_level + 1;
                c99_emit_indent(codegen);
                fputs("// for loop - array traversal\n" as *byte, codegen.output as *void);
                // 生成数组长度计算
                c99_emit_indent(codegen);
                fputs("size_t _len = sizeof(" as *byte, codegen.output as *void);
                gen_expr(codegen, array);
                fputs(") / sizeof(" as *byte, codegen.output as *void);
                gen_expr(codegen, array);
                fputs("[0]);\n" as *byte, codegen.output as *void);
                c99_emit_indent(codegen);
                fputs("for (size_t _i = 0; _i < _len; _i++) {\n" as *byte, codegen.output as *void);
        codegen.indent_level = codegen.indent_level + 1;
        if is_ref != 0 {
            // 引用迭代：生成指针类型
            // 检查 elem_type_c 是否包含数组维度（如 "int32_t[2]"）
            const bracket: *byte = strchr(elem_type_c as *byte, 91);  // '['
            if bracket != null {
                // 数组类型：分离基类型和维度
                const base_len: i32 = ptr_diff(bracket, elem_type_c as *byte);
                // 注意：Uya Mini 不支持 %.*s，需要手动处理
                var temp_buf: [byte: 256] = [];
                var j: i32 = 0;
                while j < base_len && j < 255 {
                    temp_buf[j] = elem_type_c[j];
                    j = j + 1;
                }
                temp_buf[j] = 0;
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "%s *%s = &" as *byte, &temp_buf[0] as *byte, var_name2 as *byte);
                gen_expr(codegen, array);
                fputs("[_i];\n" as *byte, codegen.output as *void);
            } else {
                // 非数组类型：直接使用
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "%s *%s = &" as *byte, elem_type_c as *byte, var_name2 as *byte);
                gen_expr(codegen, array);
                fputs("[_i];\n" as *byte, codegen.output as *void);
            }
        } else {
            // 值迭代：生成值类型
            // 检查 elem_type_c 是否包含数组维度（如 "int32_t[2]"）
            const bracket2: *byte = strchr(elem_type_c as *byte, 91);  // '['
            if bracket2 != null {
                // 数组类型：使用 memcpy 复制数组内容
                // 转换为 C 数组声明格式 "base_type var_name[dims]"
                const base_len2: i32 = ptr_diff(bracket2, elem_type_c as *byte);
                // 注意：Uya Mini 不支持 %.*s，需要手动处理
                var temp_buf2: [byte: 256] = [];
                var j2: i32 = 0;
                while j2 < base_len2 && j2 < 255 {
                    temp_buf2[j2] = elem_type_c[j2];
                    j2 = j2 + 1;
                }
                temp_buf2[j2] = 0;
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "%s %s%s;\n" as *byte, &temp_buf2[0] as *byte, var_name2 as *byte, bracket2);
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "memcpy(%s, " as *byte, var_name2 as *byte);
                gen_expr(codegen, array);
                fprintf(codegen.output as *void, "[_i], sizeof(%s));\n" as *byte, var_name2 as *byte);
            } else {
                // 非数组类型：直接使用
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "%s %s = " as *byte, elem_type_c as *byte, var_name2 as *byte);
                gen_expr(codegen, array);
                fputs("[_i];\n" as *byte, codegen.output as *void);
            }
        }
        gen_stmt(codegen, body2);
        codegen.indent_level = codegen.indent_level - 1;
        c99_emit(codegen, "}\n" as *byte);
        codegen.indent_level = codegen.indent_level - 1;
        c99_emit(codegen, "}\n" as *byte);
    } else if stmt.type == ASTNodeType.AST_BREAK_STMT {
        c99_emit(codegen, "break;\n" as *byte);
    } else if stmt.type == ASTNodeType.AST_CONTINUE_STMT {
        c99_emit(codegen, "continue;\n" as *byte);
    } else {
        // 检查是否为表达式节点
        if stmt.type >= ASTNodeType.AST_BINARY_EXPR && stmt.type <= ASTNodeType.AST_STRING {
            c99_emit(codegen, "" as *byte);
            gen_expr(codegen, stmt);
            fputs(";\n" as *byte, codegen.output as *void);
        }
        // 忽略其他语句
    }
}

