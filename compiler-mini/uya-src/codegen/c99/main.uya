// main.uya - C99 代码生成器 main 模块
// 生成 C99 源代码
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义
// 注意：gen_function_prototype 和 gen_function 在 function.uya 中定义，
//       由于 function.uya 在 main.uya 之前编译，函数已经可见

// 递归收集 AST 中使用的切片类型，以便输出对应 struct
fn collect_slice_types_from_node(codegen: &C99CodeGenerator, node: &ASTNode) void {
    if codegen == null || node == null {
        return;
    }
    if node.type == ASTNodeType.AST_VAR_DECL && node.var_decl_type != null {
        if node.var_decl_type.type == ASTNodeType.AST_TYPE_SLICE {
            c99_type_to_c(codegen, node.var_decl_type);
        }
        collect_slice_types_from_node(codegen, node.var_decl_type);
        if node.var_decl_init != null {
            collect_slice_types_from_node(codegen, node.var_decl_init);
        }
        return;
    }
    if node.type == ASTNodeType.AST_FN_DECL {
        if node.fn_decl_return_type != null {
            if node.fn_decl_return_type.type == ASTNodeType.AST_TYPE_SLICE {
                c99_type_to_c(codegen, node.fn_decl_return_type);
            }
            collect_slice_types_from_node(codegen, node.fn_decl_return_type);
        }
        var j: i32 = 0;
        while j < node.fn_decl_param_count && node.fn_decl_params != null {
            const p: &ASTNode = node.fn_decl_params[j];
            if p != null {
                collect_slice_types_from_node(codegen, p);
            }
            j = j + 1;
        }
        if node.fn_decl_body != null {
            collect_slice_types_from_node(codegen, node.fn_decl_body);
        }
        return;
    }
    if node.type == ASTNodeType.AST_BLOCK && node.block_stmts != null {
        var i: i32 = 0;
        while i < node.block_stmt_count {
            collect_slice_types_from_node(codegen, node.block_stmts[i]);
            i = i + 1;
        }
        return;
    }
    if node.type == ASTNodeType.AST_IF_STMT {
        collect_slice_types_from_node(codegen, node.if_stmt_condition);
        collect_slice_types_from_node(codegen, node.if_stmt_then_branch);
        if node.if_stmt_else_branch != null {
            collect_slice_types_from_node(codegen, node.if_stmt_else_branch);
        }
        return;
    }
    if node.type == ASTNodeType.AST_WHILE_STMT {
        collect_slice_types_from_node(codegen, node.while_stmt_condition);
        collect_slice_types_from_node(codegen, node.while_stmt_body);
        return;
    }
    if node.type == ASTNodeType.AST_FOR_STMT {
        collect_slice_types_from_node(codegen, node.for_stmt_array);
        collect_slice_types_from_node(codegen, node.for_stmt_body);
        return;
    }
    if node.type == ASTNodeType.AST_RETURN_STMT && node.return_stmt_expr != null {
        collect_slice_types_from_node(codegen, node.return_stmt_expr);
        return;
    }
    if node.type == ASTNodeType.AST_ASSIGN {
        collect_slice_types_from_node(codegen, node.assign_dest);
        collect_slice_types_from_node(codegen, node.assign_src);
        return;
    }
    if node.type == ASTNodeType.AST_SLICE_EXPR {
        collect_slice_types_from_node(codegen, node.slice_expr_base);
        collect_slice_types_from_node(codegen, node.slice_expr_start_expr);
        collect_slice_types_from_node(codegen, node.slice_expr_len_expr);
        return;
    }
    if node.type == ASTNodeType.AST_BINARY_EXPR {
        collect_slice_types_from_node(codegen, node.binary_expr_left);
        collect_slice_types_from_node(codegen, node.binary_expr_right);
    } else if node.type == ASTNodeType.AST_UNARY_EXPR {
        collect_slice_types_from_node(codegen, node.unary_expr_operand);
    } else if node.type == ASTNodeType.AST_TRY_EXPR {
        collect_slice_types_from_node(codegen, node.try_expr_operand);
    } else if node.type == ASTNodeType.AST_MEMBER_ACCESS {
        collect_slice_types_from_node(codegen, node.member_access_object);
    } else if node.type == ASTNodeType.AST_ARRAY_ACCESS {
        collect_slice_types_from_node(codegen, node.array_access_array);
        collect_slice_types_from_node(codegen, node.array_access_index);
    } else if node.type == ASTNodeType.AST_CALL_EXPR {
        collect_slice_types_from_node(codegen, node.call_expr_callee);
        var i: i32 = 0;
        while i < node.call_expr_arg_count && node.call_expr_args != null {
            collect_slice_types_from_node(codegen, node.call_expr_args[i]);
            i = i + 1;
        }
    } else if node.type == ASTNodeType.AST_CAST_EXPR {
        collect_slice_types_from_node(codegen, node.cast_expr_expr);
        if node.cast_expr_target_type != null {
            collect_slice_types_from_node(codegen, node.cast_expr_target_type);
        }
    } else if node.type == ASTNodeType.AST_LEN {
        collect_slice_types_from_node(codegen, node.len_expr_array);
    } else if node.type == ASTNodeType.AST_SIZEOF && node.sizeof_expr_target != null {
        if node.sizeof_expr_is_type != 0 && node.sizeof_expr_target.type == ASTNodeType.AST_TYPE_SLICE {
            c99_type_to_c(codegen, node.sizeof_expr_target);
        }
        collect_slice_types_from_node(codegen, node.sizeof_expr_target);
    }
}

// 生成 C99 代码
fn c99_codegen_generate(codegen: &C99CodeGenerator, ast: &ASTNode, output_file: &byte) i32 {
    if codegen == null || ast == null || output_file == null {
        return -1;
    }
    
    // 检查是否是程序节点
    if ast.type != ASTNodeType.AST_PROGRAM {
        return -1;
    }
    
    // 保存程序节点引用
    codegen.program_node = ast;
    
    // 输出文件头
    fputs("// C99 代码由 Uya Mini 编译器生成\n" as *byte, codegen.output as *void);
    fputs("// 使用 -std=c99 编译\n" as *byte, codegen.output as *void);
    fputs("//\n" as *byte, codegen.output as *void);
    fputs("#include <stdint.h>\n" as *byte, codegen.output as *void);
    fputs("#include <stdbool.h>\n" as *byte, codegen.output as *void);
    fputs("#include <stddef.h>\n" as *byte, codegen.output as *void);
    fputs("#include <stdarg.h>\n" as *byte, codegen.output as *void);  // for va_list (variadic forward)
    fputs("#include <string.h>\n" as *byte, codegen.output as *void);  // for memcmp
    fputs("#include <stdio.h>\n" as *byte, codegen.output as *void);  // for standard I/O functions (printf, puts, etc.)
    fputs("\n" as *byte, codegen.output as *void);
    // C99 兼容的 alignof 宏（使用 offsetof 技巧）
    fputs("// C99 兼容的 alignof 实现\n" as *byte, codegen.output as *void);
    fputs("#define uya_alignof(type) offsetof(struct { char c; type t; }, t)\n" as *byte, codegen.output as *void);
    fputs("\n" as *byte, codegen.output as *void);
    
    // 第一步：收集所有字符串常量（从全局变量初始化和函数体）
    const decl_count: i32 = ast.program_decl_count;
    
    var i: i32 = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null {
            collect_string_constants_from_decl(codegen, decl);
        }
        i = i + 1;
    }
    
    // 第二步：输出字符串常量定义（在所有其他代码之前）
    emit_string_constants(codegen);
    fputs("\n" as *byte, codegen.output as *void);
    
    // 第三步：注册所有错误声明（用于 return error.X 等）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_ERROR_DECL {
            if decl.error_decl_name != null {
                c99_get_or_add_error_id(codegen, decl.error_decl_name);
            }
        }
        i = i + 1;
    }
    
    // 第四步：收集所有结构体和枚举定义（添加到表中但不生成代码）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null {
            if decl.type == ASTNodeType.AST_STRUCT_DECL {
                const struct_name: &byte = get_safe_c_identifier(codegen, decl.struct_decl_name);
                if is_struct_in_table(codegen, struct_name) == 0 {
                    add_struct_definition(codegen, struct_name);
                }
            } else if decl.type == ASTNodeType.AST_ENUM_DECL {
                const enum_name: &byte = get_safe_c_identifier(codegen, decl.enum_decl_name);
                if is_enum_in_table(codegen, enum_name) == 0 {
                    add_enum_definition(codegen, enum_name);
                }
            }
        }
        i = i + 1;
    }
    
    // 第五步：生成所有结构体的前向声明（解决相互依赖）
    i = 0;
    while i < codegen.struct_definition_count {
        if is_struct_defined(codegen, codegen.struct_definitions[i].name) == 0 {
            fprintf(codegen.output as *void, "struct %s;\n" as *byte, codegen.struct_definitions[i].name as *byte);
        }
        i = i + 1;
    }
    if codegen.struct_definition_count > 0 {
        fputs("\n" as *byte, codegen.output as *void);
    }
    
    // 第五步：生成所有枚举定义（在结构体之前，因为结构体可能使用枚举类型）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_ENUM_DECL {
            gen_enum_definition(codegen, decl);
            fputs("\n" as *byte, codegen.output as *void);
        }
        i = i + 1;
    }
    
    // 第七步：生成所有结构体定义（在枚举之后）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_STRUCT_DECL {
            gen_struct_definition(codegen, decl);
            fputs("\n" as *byte, codegen.output as *void);
        }
        i = i + 1;
    }
    
    // 第七步 a：收集所有使用的切片类型（递归遍历 AST）
    i = 0;
    while i < decl_count {
        collect_slice_types_from_node(codegen, ast.program_decls[i]);
        i = i + 1;
    }
    // 第七步 b：生成切片结构体（&[T] -> struct uya_slice_X）
    emit_pending_slice_structs(codegen);
    if codegen.slice_struct_count > 0 {
        fputs("\n" as *byte, codegen.output as *void);
    }
    
    // 第八步：生成所有函数的前向声明（解决相互递归调用）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_FN_DECL {
            gen_function_prototype(codegen, decl);
        }
        i = i + 1;
    }
    fputs("\n" as *byte, codegen.output as *void);
    
    // 第九步：生成所有声明（全局变量、函数定义）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null {
            if decl.type == ASTNodeType.AST_STRUCT_DECL || decl.type == ASTNodeType.AST_ENUM_DECL {
                // 已在前面生成
            } else if decl.type == ASTNodeType.AST_VAR_DECL {
                gen_global_var(codegen, decl);
                fputs("\n" as *byte, codegen.output as *void);
            } else if decl.type == ASTNodeType.AST_FN_DECL {
                // 只生成有函数体的定义（外部函数由前向声明处理）
                gen_function(codegen, decl);
                fputs("\n" as *byte, codegen.output as *void);
            } else {
                // 忽略其他声明类型（暂时）
            }
        }
        i = i + 1;
    }
    
    return 0;
}

