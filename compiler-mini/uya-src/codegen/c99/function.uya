// function.uya - C99 代码生成器函数模块
// 提供函数声明和定义生成功能
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 外部函数声明 =====
// C 标准库函数（在 extern_decls.uya 中声明）

// 查找函数声明
fn find_function_decl_c99(codegen: &C99CodeGenerator, func_name: &byte) &ASTNode {
    if codegen == null || func_name == null || codegen.program_node == null {
        return null;
    }
    
    const decl_count: i32 = codegen.program_node.program_decl_count;
    
    var i: i32 = 0;
    while i < decl_count {
        const decl: &ASTNode = codegen.program_node.program_decls[i];
        if decl != null && decl.type == ASTNodeType.AST_FN_DECL {
            const decl_name: &byte = decl.fn_decl_name;
            if decl_name != null && strcmp(decl_name as *byte, func_name as *byte) == 0 {
                return decl;
            }
        }
        i = i + 1;
    }
    
    return null;
}

fn format_param_type(codegen: &C99CodeGenerator, type_c: &byte, param_name: &byte, output: &void) void {
    // codegen 参数未使用，但保留以保持接口一致性
    if type_c == null || param_name == null {
        return;
    }
    
    // 特殊处理：如果是 copy_type 函数的第一个参数且类型是 "struct Type *" 或 "const struct Type *"，则改为 "const struct Type *"
    // 检查当前函数名是否为 copy_type（通过 codegen.current_function_decl）
    var is_copy_type_param: i32 = 0;
    if codegen != null && codegen.current_function_decl != null {
        const fn_name: &byte = codegen.current_function_decl.fn_decl_name;
        if fn_name != null && strcmp(fn_name as *byte, "copy_type" as *byte) == 0 {
            // 检查参数类型是否为 "struct Type *" 或已经是 "const struct Type *"
            if strcmp(type_c as *byte, "struct Type *" as *byte) == 0 {
                is_copy_type_param = 1;
            } else if strcmp(type_c as *byte, "const struct Type *" as *byte) == 0 {
                is_copy_type_param = 1;
            }
        }
    }
    
    // 检查是否是指向数组的指针（包含 "(*)" 和 "[数字]"）
    // 例如：uint8_t (*)[4096] -> uint8_t (*param_name)[4096]
    const paren_star: *byte = strstr(type_c as *byte, "(*)" as *byte);
    if paren_star != null {
        // 是指向数组的指针，需要将 param_name 插入到 (*) 中
        const before_paren: i32 = ptr_diff(paren_star, type_c as *byte);
        const after_paren: *byte = paren_star + 3;  // 跳过 "(*)"
        // 输出：base_type (*param_name)[dims]
        var temp_buf: [byte: 256] = [];
        var i: i32 = 0;
        while i < before_paren && i < 255 {
            temp_buf[i] = type_c[i];
            i = i + 1;
        }
        temp_buf[i] = 0;
        fprintf(output, "%s (*%s)%s" as *byte, &temp_buf[0] as *byte, param_name as *byte, after_paren);
    } else {
        // 检查是否是数组类型（包含 [数字]）
        const bracket: *byte = strchr(type_c as *byte, 91);  // '['
        if bracket != null {
            // 提取元素类型（bracket之前的部分）
            const str_len: i32 = ptr_diff(bracket, type_c as *byte);
            // 注意：Uya Mini 不支持 %.*s，需要手动处理
            // 简化处理：使用临时缓冲区
            var temp_buf: [byte: 256] = [];
            var i: i32 = 0;
            while i < str_len && i < 255 {
                temp_buf[i] = type_c[i];
                i = i + 1;
            }
            temp_buf[i] = 0;
            fprintf(output, "%s %s%s" as *byte, &temp_buf[0] as *byte, param_name as *byte, bracket);
        } else {
            // 非数组类型
            // 检查是否是指针类型（包含 '*'）
            // 如果是指针类型，格式应该是 "type * name"（* 紧跟在类型后面）
            // c99_type_to_c 已经返回了正确的格式（如 "struct Type *"），所以直接输出即可
            // 特殊处理 copy_type 函数：将 "struct Type *" 改为 "const struct Type *"
            if is_copy_type_param != 0 {
                fprintf(output, "const struct Type * %s" as *byte, param_name as *byte);
            } else {
                fprintf(output, "%s %s" as *byte, type_c as *byte, param_name as *byte);
            }
        }
    }
}

// 检查是否是标准库函数（需要特殊处理参数类型）
fn is_stdlib_function(func_name: &byte) i32 {
    if func_name == null {
        return 0;
    }
    // 标准库函数列表：这些函数的字符串参数应该是 const char * 而不是 uint8_t *
    // I/O 函数
    if strcmp(func_name as *byte, "printf" as *byte) == 0 ||
        strcmp(func_name as *byte, "sprintf" as *byte) == 0 ||
        strcmp(func_name as *byte, "fprintf" as *byte) == 0 ||
        strcmp(func_name as *byte, "snprintf" as *byte) == 0 ||
        strcmp(func_name as *byte, "scanf" as *byte) == 0 ||
        strcmp(func_name as *byte, "fscanf" as *byte) == 0 ||
        strcmp(func_name as *byte, "sscanf" as *byte) == 0 ||
        strcmp(func_name as *byte, "puts" as *byte) == 0 ||
        strcmp(func_name as *byte, "fputs" as *byte) == 0 ||
        strcmp(func_name as *byte, "putchar" as *byte) == 0 ||
        strcmp(func_name as *byte, "getchar" as *byte) == 0 ||
        strcmp(func_name as *byte, "gets" as *byte) == 0 ||
        strcmp(func_name as *byte, "fgets" as *byte) == 0 {
        return 1;
    }
    // 字符串处理函数
    if strcmp(func_name as *byte, "strcmp" as *byte) == 0 ||
        strcmp(func_name as *byte, "strncmp" as *byte) == 0 ||
        strcmp(func_name as *byte, "strlen" as *byte) == 0 ||
        strcmp(func_name as *byte, "strcpy" as *byte) == 0 ||
        strcmp(func_name as *byte, "strncpy" as *byte) == 0 ||
        strcmp(func_name as *byte, "strcat" as *byte) == 0 ||
        strcmp(func_name as *byte, "strncat" as *byte) == 0 ||
        strcmp(func_name as *byte, "strstr" as *byte) == 0 ||
        strcmp(func_name as *byte, "strchr" as *byte) == 0 ||
        strcmp(func_name as *byte, "strrchr" as *byte) == 0 ||
        strcmp(func_name as *byte, "strdup" as *byte) == 0 ||
        strcmp(func_name as *byte, "strndup" as *byte) == 0 {
        return 1;
    }
    // 内存操作函数
    if strcmp(func_name as *byte, "memcpy" as *byte) == 0 ||
        strcmp(func_name as *byte, "memset" as *byte) == 0 ||
        strcmp(func_name as *byte, "memcmp" as *byte) == 0 ||
        strcmp(func_name as *byte, "memmove" as *byte) == 0 {
        return 1;
    }
    // 文件 I/O 函数
    if strcmp(func_name as *byte, "fopen" as *byte) == 0 ||
        strcmp(func_name as *byte, "fread" as *byte) == 0 ||
        strcmp(func_name as *byte, "fwrite" as *byte) == 0 ||
        strcmp(func_name as *byte, "fclose" as *byte) == 0 ||
        strcmp(func_name as *byte, "fgetc" as *byte) == 0 ||
        strcmp(func_name as *byte, "fputc" as *byte) == 0 ||
        strcmp(func_name as *byte, "fgets" as *byte) == 0 ||
        strcmp(func_name as *byte, "fputs" as *byte) == 0 ||
        strcmp(func_name as *byte, "fflush" as *byte) == 0 {
        return 1;
    }
    return 0;
}

// 生成函数原型（前向声明）
// 注意：此函数在 main.uya 中被调用，但由于 function.uya 在 main.uya 之前编译，函数已经可见
fn gen_function_prototype(codegen: &C99CodeGenerator, fn_decl: &ASTNode) void {
    if fn_decl == null || fn_decl.type != ASTNodeType.AST_FN_DECL {
        return;
    }
    
    // 设置当前函数声明（用于 format_param_type 中的 copy_type 检查）
    const saved_current_function_decl: &ASTNode = codegen.current_function_decl;
    codegen.current_function_decl = fn_decl;
    
    const func_name: &byte = get_safe_c_identifier(codegen, fn_decl.fn_decl_name);
    const return_type: &ASTNode = fn_decl.fn_decl_return_type;
    const param_count: i32 = fn_decl.fn_decl_param_count;
    const is_varargs: i32 = fn_decl.fn_decl_is_varargs;
    const body: &ASTNode = fn_decl.fn_decl_body;
    
    // 检查是否为extern函数（body为NULL表示extern函数）
    var is_extern: i32 = 0;
    if body == null {
        is_extern = 1;
    }
    
    // 检查是否是标准库函数
    const is_stdlib: i32 = is_stdlib_function(func_name);
    
    // 返回类型（如果是数组类型，转换为指针类型）
    const return_c: &byte = convert_array_return_type(codegen, return_type);
    
    // 对于标准库函数，不生成 extern 声明（应该包含相应的头文件）
    if is_extern != 0 && is_stdlib != 0 {
        // 标准库函数应该包含相应的头文件（如 <stdio.h>），不生成 extern 声明
        // 这样可以避免与标准库的声明冲突
        return;
    }
    
    // 特殊处理：main 函数需要重命名为 uya_main（符合 Uya 规范：main 函数无参数）
    // 注意：Uya Mini 不支持三元运算符，使用 if-else 代替
    var is_main: i32 = 0;
    if fn_decl.fn_decl_name != null && strcmp(fn_decl.fn_decl_name as *byte, "main" as *byte) == 0 {
        is_main = 1;
    }
    
    if is_main != 0 {
        // main 函数生成 uya_main 的前向声明（使用外层的 return_c）
        fprintf(codegen.output, "%s uya_main(void);\n" as *byte, return_c as *byte);
        return;
    }
    
    // 对于extern函数，添加extern关键字
    if is_extern != 0 {
        fprintf(codegen.output, "extern %s %s(" as *byte, return_c as *byte, func_name as *byte);
    } else {
        fprintf(codegen.output, "%s %s(" as *byte, return_c as *byte, func_name as *byte);
    }
    
    // 检查是否为 copy_type 函数（需要 const 限定符）
    var is_copy_type: i32 = 0;
    if fn_decl.fn_decl_name != null && strcmp(fn_decl.fn_decl_name as *byte, "copy_type" as *byte) == 0 {
        is_copy_type = 1;
    }
    
    // 参数列表
    var i: i32 = 0;
    while i < param_count {
        const param: &ASTNode = fn_decl.fn_decl_params[i];
        if param != null && param.type == ASTNodeType.AST_VAR_DECL {
            const param_name: &byte = get_safe_c_identifier(codegen, param.var_decl_name);
            const param_type: &ASTNode = param.var_decl_type;
            var param_type_c: &byte = c99_type_to_c(codegen, param_type);
            
            // 特殊处理 copy_type 函数：将第一个参数类型改为 const struct Type *
            if is_copy_type != 0 && i == 0 {
                // 对于 copy_type 函数，第一个参数类型必须是 const struct Type *
                // 直接替换，不检查原始类型（因为 copy_type 的参数类型总是 &Type，即 struct Type *）
                param_type_c = ("const struct Type *" as *byte) as &byte;
            }
            
            // 对于 extern 函数，检查大结构体参数（>16字节），转换为指针类型
            // 根据 x86-64 System V ABI，大于 16 字节的结构体通过指针传递
            if is_extern != 0 && param_type.type == ASTNodeType.AST_TYPE_NAMED {
                const struct_size: i32 = calculate_struct_size(codegen, param_type);
                if struct_size > 16 {
                    // 大结构体：转换为指针类型
                    // 注意：如果是 copy_type 函数，保持 const struct Type *
                    if is_copy_type != 0 && i == 0 {
                        param_type_c = ("const struct Type *" as *byte) as &byte;
                    } else {
                        param_type_c = c99_type_to_c(codegen, param_type);
                    }
                    fprintf(codegen.output, "%s *%s" as *byte, param_type_c as *byte, param_name as *byte);
                    if i < param_count - 1 {
                        fputs(", " as *byte, codegen.output);
                    }
                    i = i + 1;
                    continue;
                }
            }
            
            // 对于标准库函数，将 uint8_t * 转换为 const char *
            if is_stdlib != 0 && param_type.type == ASTNodeType.AST_TYPE_POINTER {
                const pointed_type: &ASTNode = param_type.type_pointer_pointed_type;
                if pointed_type != null && pointed_type.type == ASTNodeType.AST_TYPE_NAMED {
                    const pointed_name: &byte = pointed_type.type_named_name;
                    if pointed_name != null && strcmp(pointed_name as *byte, "byte" as *byte) == 0 {
                        // 将 uint8_t * 替换为 const char *
                        param_type_c = ("const char *" as *byte) as &byte;
                    }
                }
            }
            
            // 数组参数：在参数名后添加 _param 后缀，函数内部会创建副本
            if param_type.type == ASTNodeType.AST_TYPE_ARRAY {
                // 数组参数格式：T name_param[N]
                const bracket: *byte = strchr(param_type_c as *byte, 91);  // '['
                if bracket != null {
                    const str_len: i32 = ptr_diff(bracket, param_type_c as *byte);
                    // 注意：Uya Mini 不支持 %.*s，需要手动处理
                    var temp_buf: [byte: 256] = [];
                    var j: i32 = 0;
                    while j < str_len && j < 255 {
                        temp_buf[j] = param_type_c[j];
                        j = j + 1;
                    }
                    temp_buf[j] = 0;
                    fprintf(codegen.output, "%s %s_param%s" as *byte, &temp_buf[0] as *byte, param_name as *byte, bracket);
                } else {
                    fprintf(codegen.output, "%s %s_param" as *byte, param_type_c as *byte, param_name as *byte);
                }
            } else if param_type.type == ASTNodeType.AST_TYPE_SLICE {
                // Slice 类型参数：通过指针传递（slice 是引用类型）
                fprintf(codegen.output, "%s *%s" as *byte, param_type_c as *byte, param_name as *byte);
            } else {
                // 对于 copy_type 函数，直接输出 const struct Type *，不调用 format_param_type
                if is_copy_type != 0 && i == 0 {
                    fprintf(codegen.output, "const struct Type * %s" as *byte, param_name as *byte);
                } else {
                    format_param_type(codegen, param_type_c, param_name, codegen.output);
                }
            }
            if i < param_count - 1 {
                fputs(", " as *byte, codegen.output);
            }
        }
        i = i + 1;
    }
    
    // 处理可变参数
    if is_varargs != 0 {
        if param_count > 0 {
            fputs(", " as *byte, codegen.output);
        }
        fputs("..." as *byte, codegen.output);
    }
    
    fputs(");\n" as *byte, codegen.output);
    
    // 恢复当前函数声明
    codegen.current_function_decl = saved_current_function_decl;
}

// 生成函数定义
// 注意：此函数在 main.uya 中被调用，但由于 function.uya 在 main.uya 之前编译，函数已经可见
fn gen_function(codegen: &C99CodeGenerator, fn_decl: &ASTNode) void {
    if fn_decl == null || fn_decl.type != ASTNodeType.AST_FN_DECL {
        return;
    }
    
    const func_name: &byte = get_safe_c_identifier(codegen, fn_decl.fn_decl_name);
    const return_type: &ASTNode = fn_decl.fn_decl_return_type;
    const param_count: i32 = fn_decl.fn_decl_param_count;
    const is_varargs: i32 = fn_decl.fn_decl_is_varargs;
    const body: &ASTNode = fn_decl.fn_decl_body;
    
    // 如果没有函数体（外部函数），则不生成定义
    if body == null {
        return;
    }
    
    // 生成 #line 指令，指向函数定义的位置
    emit_line_directive(codegen, fn_decl.line, fn_decl.filename);
    
    // 特殊处理：main 函数需要重命名为 uya_main（符合 Uya 规范：main 函数无参数）
    // 注意：Uya Mini 不支持三元运算符，使用 if-else 代替
    var is_main: i32 = 0;
    if fn_decl.fn_decl_name != null && strcmp(fn_decl.fn_decl_name as *byte, "main" as *byte) == 0 {
        is_main = 1;
    }
    
    // 返回类型（如果是数组类型，转换为指针类型）
    const return_c: &byte = convert_array_return_type(codegen, return_type);
    
    // 声明循环变量 i（在 if-else 之前声明，确保在所有分支都可见）
    var i: i32 = 0;
    
    if is_main != 0 {
        // main 函数重命名为 uya_main（符合 Uya 规范：main 函数无参数）
        fprintf(codegen.output, "%s uya_main(void)" as *byte, return_c as *byte);
    } else {
        fprintf(codegen.output, "%s %s(" as *byte, return_c as *byte, func_name as *byte);
        
        // 检查是否为 copy_type 函数（需要 const 限定符）
        var is_copy_type: i32 = 0;
        if fn_decl.fn_decl_name != null && strcmp(fn_decl.fn_decl_name as *byte, "copy_type" as *byte) == 0 {
            is_copy_type = 1;
        }
        
        // 参数列表
        i = 0;
        while i < param_count {
            const param: &ASTNode = fn_decl.fn_decl_params[i];
            if param != null && param.type == ASTNodeType.AST_VAR_DECL {
                const param_name: &byte = get_safe_c_identifier(codegen, param.var_decl_name);
                const param_type: &ASTNode = param.var_decl_type;
                var param_type_c: &byte = c99_type_to_c(codegen, param_type);
                
                // 特殊处理 copy_type 函数：将第一个参数类型改为 const struct Type *
                if is_copy_type != 0 && i == 0 {
                    // 对于 copy_type 函数，第一个参数类型必须是 const struct Type *
                    // 直接替换，不检查原始类型（因为 copy_type 的参数类型总是 &Type，即 struct Type *）
                    param_type_c = ("const struct Type *" as *byte) as &byte;
                }
                
                // 数组参数：在参数名后添加 _param 后缀，函数内部会创建副本
                if param_type.type == ASTNodeType.AST_TYPE_ARRAY {
                    // 数组参数格式：T name_param[N]
                    const bracket: *byte = strchr(param_type_c as *byte, 91);  // '['
                    if bracket != null {
                        const str_len: i32 = ptr_diff(bracket, param_type_c as *byte);
                        // 注意：Uya Mini 不支持 %.*s，需要手动处理
                        var temp_buf: [byte: 256] = [];
                        var j: i32 = 0;
                        while j < str_len && j < 255 {
                            temp_buf[j] = param_type_c[j];
                            j = j + 1;
                        }
                        temp_buf[j] = 0;
                        fprintf(codegen.output, "%s %s_param%s" as *byte, &temp_buf[0] as *byte, param_name as *byte, bracket);
                    } else {
                        fprintf(codegen.output, "%s %s_param" as *byte, param_type_c as *byte, param_name as *byte);
                    }
                } else if param_type.type == ASTNodeType.AST_TYPE_SLICE {
                    // Slice 类型参数：通过指针传递（slice 是引用类型）
                    fprintf(codegen.output, "%s *%s" as *byte, param_type_c as *byte, param_name as *byte);
                } else {
                    // 对于 copy_type 函数，直接输出 const struct Type *，不调用 format_param_type
                    if is_copy_type != 0 && i == 0 {
                        fprintf(codegen.output, "const struct Type * %s" as *byte, param_name as *byte);
                    } else {
                        format_param_type(codegen, param_type_c, param_name, codegen.output);
                    }
                }
                if i < param_count - 1 {
                    fputs(", " as *byte, codegen.output);
                }
            }
            i = i + 1;
        }
        
        // 处理可变参数
        if is_varargs != 0 {
            if param_count > 0 {
                fputs(", " as *byte, codegen.output);
            }
            fputs("..." as *byte, codegen.output);
        }
    }
    
    // 添加函数体开始
    if is_main != 0 {
        fputs(" {\n" as *byte, codegen.output);
        // 在 main 函数开始时调用测试运行器（只有在有测试时才调用）
        if codegen.test_count > 0 {
            fputs("    uya_run_tests();\n" as *byte, codegen.output);
        }
    } else {
        fputs(") {\n" as *byte, codegen.output);
    }
    codegen.indent_level = codegen.indent_level + 1;
    
    // 保存当前函数的返回类型（用于生成返回语句）
    codegen.current_function_return_type = return_type;
    
    // 保存当前函数声明（用于 @params 与 ... 转发）
    const saved_current_function_decl: &ASTNode = codegen.current_function_decl;
    codegen.current_function_decl = fn_decl;
    
    // 保存函数开始时的局部变量表状态（用于函数结束时恢复）
    // 每个函数有自己独立的局部变量表，函数结束后恢复之前的状态
    const saved_local_variable_count: i32 = codegen.local_variable_count;
    const saved_current_depth: i32 = codegen.current_depth;
    
    // 重置当前函数的局部变量表（从 0 开始）
    // 这样每个函数都有自己独立的局部变量表，避免大文件时表被填满
    // 参数和局部变量都从索引 0 开始添加
    codegen.local_variable_count = 0;
    codegen.current_depth = 0;
    
    // 处理数组参数：为数组参数创建局部副本（实现按值传递）
    i = 0;
    while i < param_count {
        const param: &ASTNode = fn_decl.fn_decl_params[i];
        if param != null && param.type == ASTNodeType.AST_VAR_DECL {
            const param_name: &byte = get_safe_c_identifier(codegen, param.var_decl_name);
            const param_type: &ASTNode = param.var_decl_type;
            
            if param_type.type == ASTNodeType.AST_TYPE_ARRAY {
                // 数组参数：创建局部数组副本
                const array_type_c: &byte = c99_type_to_c(codegen, param_type);
                // 解析数组类型格式：int32_t[3] -> int32_t arr[3]
                const bracket: *byte = strchr(array_type_c as *byte, 91);  // '['
                c99_emit_indent(codegen);
                fputs("// 数组参数按值传递：创建局部副本\n" as *byte, codegen.output);
                if bracket != null {
                    const str_len: i32 = ptr_diff(bracket, array_type_c as *byte);
                    // 注意：Uya Mini 不支持 %.*s，需要手动处理
                    var temp_buf: [byte: 256] = [];
                    var j: i32 = 0;
                    while j < str_len && j < 255 {
                        temp_buf[j] = array_type_c[j];
                        j = j + 1;
                    }
                    temp_buf[j] = 0;
                    fprintf(codegen.output, "    %s %s%s;\n" as *byte, &temp_buf[0] as *byte, param_name as *byte, bracket);
                } else {
                    c99_emit_indent(codegen);
                    fprintf(codegen.output, "%s %s;\n" as *byte, array_type_c as *byte, param_name as *byte);
                }
                c99_emit_indent(codegen);
                fprintf(codegen.output, "    memcpy(%s, %s_param, sizeof(%s));\n" as *byte, param_name as *byte, param_name as *byte, param_name as *byte);
                
                // 将参数名注册为局部数组（而不是参数）
                if param_name != null && codegen.local_variable_count < C99_MAX_LOCAL_VARS {
                    codegen.local_variables[codegen.local_variable_count].name = param.var_decl_name;  // 使用原始名称
                    codegen.local_variables[codegen.local_variable_count].type_c = array_type_c;
                    codegen.local_variable_count = codegen.local_variable_count + 1;
                }
            } else {
                // 非数组参数：正常添加到局部变量表
                var param_type_c: &byte = c99_type_to_c(codegen, param_type);
                // 对于 slice 类型参数，需要添加 * 后缀（因为 slice 参数通过指针传递）
                if param_type.type == ASTNodeType.AST_TYPE_SLICE {
                    // 为 slice 类型添加指针后缀
                    const len: usize = strlen(param_type_c as *byte) + 3;  // 类型 + " *" + null
                    const ptr_type: &byte = arena_alloc(codegen.arena, len) as &byte;
                    if ptr_type != null {
                        var dst: &byte = ptr_type;
                        const src: *byte = param_type_c as *byte;
                        var j: i32 = 0;
                        while src[j] != 0 {
                            dst[j] = src[j];
                            j = j + 1;
                        }
                        dst[j] = 32;  // ' '
                        dst[j + 1] = 42;  // '*'
                        dst[j + 2] = 0;  // '\0'
                        param_type_c = ptr_type;
                    }
                }
                if param_name != null && param_type_c != null && codegen.local_variable_count < C99_MAX_LOCAL_VARS {
                    codegen.local_variables[codegen.local_variable_count].name = param.var_decl_name;
                    codegen.local_variables[codegen.local_variable_count].type_c = param_type_c;
                    codegen.local_variable_count = codegen.local_variable_count + 1;
                }
            }
        }
        i = i + 1;
    }
    
    // 生成函数体
    gen_stmt(codegen, body);
    
    // 检查函数体是否以 return 结尾
    var has_return: i32 = 0;
    if body != null && body.type == ASTNodeType.AST_BLOCK {
        const stmts: & & ASTNode = body.block_stmts;
        const stmt_count: i32 = body.block_stmt_count;
        var j: i32 = stmt_count - 1;
        while j >= 0 {
            const s: &ASTNode = stmts[j];
            if s != null && s.type != ASTNodeType.AST_DEFER_STMT && s.type != ASTNodeType.AST_ERRDEFER_STMT {
                if s.type == ASTNodeType.AST_RETURN_STMT {
                    has_return = 1;
                } else {
                    has_return = 0;
                }
                break;
            }
            j = j - 1;
        }
    }
    
    // 如果返回类型是 !void 且函数体没有显式返回，添加默认返回语句
    if has_return == 0 && return_type != null && return_type.type == ASTNodeType.AST_TYPE_ERROR_UNION {
        const payload_node: &ASTNode = return_type.type_error_union_payload_type;
        var is_void_payload: i32 = 0;
        if payload_node == null {
            is_void_payload = 1;
        } else if payload_node.type == ASTNodeType.AST_TYPE_NAMED && payload_node.type_named_name != null &&
            strcmp(payload_node.type_named_name as *byte, "void" as *byte) == 0 {
            is_void_payload = 1;
        }
        if is_void_payload != 0 {
            // !void 类型：返回成功的错误联合
            c99_emit_indent(codegen);
            fprintf(codegen.output as *void, "return (%s){ .error_id = 0 };\n" as *byte, return_c as *byte);
        }
    }
    
    // 清除当前函数的返回类型
    codegen.current_function_return_type = null;
    
    // 恢复当前函数声明
    codegen.current_function_decl = saved_current_function_decl;
    
    // 恢复函数开始时的局部变量表状态
    // 这样下一个函数可以从干净的状态开始
    codegen.local_variable_count = saved_local_variable_count;
    codegen.current_depth = saved_current_depth;
    
    codegen.indent_level = codegen.indent_level - 1;
    c99_emit_indent(codegen);
    fputs("}\n" as *byte, codegen.output);
}

// 是否该结构体类型有 drop 方法（规范 §12）
fn type_has_drop_c99(codegen: &C99CodeGenerator, struct_name: &byte) i32 {
    if find_method_in_struct_c99(codegen, struct_name, "drop" as *byte) != null {
        return 1;
    }
    return 0;
}

// 生成方法函数的前向声明（uya_StructName_methodname）
fn gen_method_prototype(codegen: &C99CodeGenerator, fn_decl: &ASTNode, struct_name: &byte) void {
    if fn_decl == null || fn_decl.type != ASTNodeType.AST_FN_DECL || struct_name == null {
        return;
    }
    const method_name: &byte = fn_decl.fn_decl_name;
    const c_name: &byte = get_method_c_name(codegen, struct_name, method_name);
    if c_name == null {
        return;
    }
    const return_c: &byte = convert_array_return_type(codegen, fn_decl.fn_decl_return_type);
    const params: & & ASTNode = fn_decl.fn_decl_params;
    const param_count: i32 = fn_decl.fn_decl_param_count;
    fprintf(codegen.output as *void, "%s %s(" as *byte, return_c as *byte, c_name as *byte);
    var i: i32 = 0;
    while i < param_count {
        const param: &ASTNode = params[i];
        if param == null || param.type != ASTNodeType.AST_VAR_DECL {
            i = i + 1;
            continue;
        }
        const param_name: &byte = get_safe_c_identifier(codegen, param.var_decl_name);
        var const_self: i32 = 0;
        if i == 0 { const_self = 1; }
        const param_type_c: &byte = c99_type_to_c_with_self_opt(codegen, param.var_decl_type, struct_name, const_self);
        format_param_type(codegen, param_type_c, param_name, codegen.output as *void);
        if i < param_count - 1 {
            fputs(", " as *byte, codegen.output as *void);
        }
        i = i + 1;
    }
    fputs(");\n" as *byte, codegen.output as *void);
}

// 生成方法函数定义（uya_StructName_methodname）
fn gen_method_function(codegen: &C99CodeGenerator, fn_decl: &ASTNode, struct_name: &byte) void {
    if fn_decl == null || fn_decl.type != ASTNodeType.AST_FN_DECL || struct_name == null || fn_decl.fn_decl_body == null {
        return;
    }
    const method_name: &byte = fn_decl.fn_decl_name;
    const c_name: &byte = get_method_c_name(codegen, struct_name, method_name);
    if c_name == null {
        return;
    }
    const return_c: &byte = convert_array_return_type(codegen, fn_decl.fn_decl_return_type);
    const params: & & ASTNode = fn_decl.fn_decl_params;
    const param_count: i32 = fn_decl.fn_decl_param_count;
    emit_line_directive(codegen, fn_decl.line, fn_decl.filename);
    fprintf(codegen.output as *void, "%s %s(" as *byte, return_c as *byte, c_name as *byte);
    var i: i32 = 0;
    while i < param_count {
        const param: &ASTNode = params[i];
        if param == null || param.type != ASTNodeType.AST_VAR_DECL {
            i = i + 1;
            continue;
        }
        const param_name: &byte = get_safe_c_identifier(codegen, param.var_decl_name);
        var const_self: i32 = 0;
        if i == 0 { const_self = 1; }
        const param_type_c: &byte = c99_type_to_c_with_self_opt(codegen, param.var_decl_type, struct_name, const_self);
        format_param_type(codegen, param_type_c, param_name, codegen.output as *void);
        if i < param_count - 1 {
            fputs(", " as *byte, codegen.output as *void);
        }
        i = i + 1;
    }
    fputs(") {\n" as *byte, codegen.output as *void);
    codegen.indent_level = codegen.indent_level + 1;
    codegen.current_function_return_type = fn_decl.fn_decl_return_type;
    const saved_current_function_decl: &ASTNode = codegen.current_function_decl;
    codegen.current_function_decl = fn_decl;
    const saved_method_struct: &byte = codegen.current_method_struct_name;
    codegen.current_method_struct_name = struct_name;
    const saved_local_count: i32 = codegen.local_variable_count;
    const saved_depth: i32 = codegen.current_depth;
    codegen.local_variable_count = 0;
    codegen.current_depth = 0;
    i = 0;
    while i < param_count {
        const param: &ASTNode = params[i];
        if param != null && param.type == ASTNodeType.AST_VAR_DECL {
            const param_name: &byte = get_safe_c_identifier(codegen, param.var_decl_name);
            var const_self: i32 = 0;
        if i == 0 { const_self = 1; }
        const param_type_c: &byte = c99_type_to_c_with_self_opt(codegen, param.var_decl_type, struct_name, const_self);
            if param_name != null && param_type_c != null && codegen.local_variable_count < C99_MAX_LOCAL_VARS {
                codegen.local_variables[codegen.local_variable_count].name = param.var_decl_name;
                codegen.local_variables[codegen.local_variable_count].type_c = param_type_c;
                codegen.local_variable_count = codegen.local_variable_count + 1;
            }
        }
        i = i + 1;
    }
    if method_name != null && strcmp(method_name as *byte, "drop" as *byte) == 0 {
        const struct_decl: &ASTNode = find_struct_decl_c99(codegen, struct_name);
        const self_safe: &byte = get_safe_c_identifier(codegen, "self" as *byte);
        if struct_decl != null && struct_decl.struct_decl_fields != null && self_safe != null {
            const fc: i32 = struct_decl.struct_decl_field_count;
            var fi: i32 = fc - 1;
            while fi >= 0 {
                const field: &ASTNode = struct_decl.struct_decl_fields[fi];
                if field == null || field.type != ASTNodeType.AST_VAR_DECL || field.var_decl_name == null {
                    fi = fi - 1;
                    continue;
                }
                const ft: &ASTNode = field.var_decl_type;
                if ft == null || ft.type != ASTNodeType.AST_TYPE_NAMED || ft.type_named_name == null {
                    fi = fi - 1;
                    continue;
                }
                const field_type_name: &byte = ft.type_named_name;
                if type_has_drop_c99(codegen, field_type_name) == 0 {
                    fi = fi - 1;
                    continue;
                }
                const drop_c: &byte = get_method_c_name(codegen, field_type_name, "drop" as *byte);
                const field_safe: &byte = get_safe_c_identifier(codegen, field.var_decl_name);
                if drop_c != null && field_safe != null {
                    c99_emit_indent(codegen);
                    fprintf(codegen.output as *void, "/* drop field */ %s(%s.%s);\n" as *byte, drop_c as *byte, self_safe as *byte, field_safe as *byte);
                }
                fi = fi - 1;
            }
        }
    }
    gen_stmt(codegen, fn_decl.fn_decl_body);
    
    // 检查函数体是否以 return 结尾
    var has_return: i32 = 0;
    if fn_decl.fn_decl_body != null && fn_decl.fn_decl_body.type == ASTNodeType.AST_BLOCK {
        const stmts: & & ASTNode = fn_decl.fn_decl_body.block_stmts;
        const stmt_count: i32 = fn_decl.fn_decl_body.block_stmt_count;
        var j: i32 = stmt_count - 1;
        while j >= 0 {
            const s: &ASTNode = stmts[j];
            if s != null && s.type != ASTNodeType.AST_DEFER_STMT && s.type != ASTNodeType.AST_ERRDEFER_STMT {
                if s.type == ASTNodeType.AST_RETURN_STMT {
                    has_return = 1;
                } else {
                    has_return = 0;
                }
                break;
            }
            j = j - 1;
        }
    }
    
    // 如果返回类型是 !void 且函数体没有显式返回，添加默认返回语句
    if has_return == 0 && fn_decl.fn_decl_return_type != null && fn_decl.fn_decl_return_type.type == ASTNodeType.AST_TYPE_ERROR_UNION {
        const payload_node: &ASTNode = fn_decl.fn_decl_return_type.type_error_union_payload_type;
        var is_void_payload: i32 = 0;
        if payload_node == null {
            is_void_payload = 1;
        } else if payload_node.type == ASTNodeType.AST_TYPE_NAMED && payload_node.type_named_name != null &&
            strcmp(payload_node.type_named_name as *byte, "void" as *byte) == 0 {
            is_void_payload = 1;
        }
        if is_void_payload != 0 {
            // !void 类型：返回成功的错误联合
            c99_emit_indent(codegen);
            fprintf(codegen.output as *void, "return (%s){ .error_id = 0 };\n" as *byte, return_c as *byte);
        }
    }
    
    codegen.current_function_return_type = null;
    codegen.current_function_decl = saved_current_function_decl;
    codegen.current_method_struct_name = saved_method_struct;
    codegen.local_variable_count = saved_local_count;
    codegen.current_depth = saved_depth;
    codegen.indent_level = codegen.indent_level - 1;
    c99_emit_indent(codegen);
    fputs("}\n" as *byte, codegen.output as *void);
}

// 检查函数是否是泛型函数（有类型参数）
fn is_generic_function_c99(fn_decl: &ASTNode) i32 {
    if fn_decl == null || fn_decl.type != ASTNodeType.AST_FN_DECL {
        return 0;
    }
    if fn_decl.fn_decl_type_param_count > 0 {
        return 1;
    }
    return 0;
}

// 获取单态化函数名称
// 例如：identity<i32> -> identity_i32
fn get_mono_function_name(codegen: &C99CodeGenerator, generic_name: &byte, type_args: & & ASTNode, type_arg_count: i32) &byte {
    if codegen == null || generic_name == null || type_args == null || type_arg_count <= 0 {
        return generic_name;
    }
    
    // 构建后缀
    var suffix: [byte: 256] = [0: 256];
    var suffix_len: i32 = 0;
    
    var i: i32 = 0;
    while i < type_arg_count {
        if i > 0 && suffix_len < 255 {
            suffix[suffix_len] = 95 as byte;  // '_' = 95
            suffix_len = suffix_len + 1;
        }
        
        const type_arg: &ASTNode = type_args[i];
        if type_arg != null && type_arg.type == ASTNodeType.AST_TYPE_NAMED && type_arg.type_named_name != null {
            const type_name: &byte = type_arg.type_named_name;
            var j: i32 = 0;
            while type_name[j] != 0 && suffix_len < 255 {
                suffix[suffix_len] = type_name[j];
                suffix_len = suffix_len + 1;
                j = j + 1;
            }
        } else if type_arg != null && type_arg.type == ASTNodeType.AST_TYPE_POINTER {
            // 指针类型：ptr_T
            const ptr_prefix: &byte = "ptr_";
            var k: i32 = 0;
            while ptr_prefix[k] != 0 && suffix_len < 255 {
                suffix[suffix_len] = ptr_prefix[k];
                suffix_len = suffix_len + 1;
                k = k + 1;
            }
            const pointed: &ASTNode = type_arg.type_pointer_pointed_type;
            if pointed != null && pointed.type == ASTNodeType.AST_TYPE_NAMED && pointed.type_named_name != null {
                const type_name: &byte = pointed.type_named_name;
                var m: i32 = 0;
                while type_name[m] != 0 && suffix_len < 255 {
                    suffix[suffix_len] = type_name[m];
                    suffix_len = suffix_len + 1;
                    m = m + 1;
                }
            }
        }
        i = i + 1;
    }
    suffix[suffix_len] = 0;
    
    // 分配并构建完整名称
    const safe_name: &byte = get_safe_c_identifier(codegen, generic_name);
    const name_len: usize = (strlen(safe_name as *byte) as usize) + 1 + (suffix_len as usize) + 1;
    const mono_name: &byte = arena_alloc(codegen.arena, name_len) as &byte;
    if mono_name == null {
        return generic_name;
    }
    snprintf(mono_name as *byte, name_len, "%s_%s" as *byte, safe_name as *byte, (&suffix[0]) as *byte);
    
    return mono_name;
}

// 在单态化上下文中将类型参数替换为具体类型
fn substitute_type_arg(codegen: &C99CodeGenerator, type_node: &ASTNode) &ASTNode {
    if codegen == null || type_node == null {
        return type_node;
    }
    
    // 如果不在单态化上下文中，直接返回
    if codegen.current_type_params == null || codegen.current_type_param_count == 0 {
        return type_node;
    }
    
    // 对于命名类型，检查是否是类型参数
    if type_node.type == ASTNodeType.AST_TYPE_NAMED && type_node.type_named_name != null {
        const name: &byte = type_node.type_named_name;
        var i: i32 = 0;
        while i < codegen.current_type_param_count {
            if codegen.current_type_params[i].name != null &&
                strcmp(codegen.current_type_params[i].name as *byte, name as *byte) == 0 {
                // 找到匹配的类型参数，返回对应的类型实参
                if codegen.current_type_args != null && i < codegen.current_type_arg_count {
                    return codegen.current_type_args[i];
                }
            }
            i = i + 1;
        }
    }
    
    // 递归处理指针类型 (&T 或 *T)
    if type_node.type == ASTNodeType.AST_TYPE_POINTER && type_node.type_pointer_pointed_type != null {
        const inner_substituted: &ASTNode = substitute_type_arg(codegen, type_node.type_pointer_pointed_type);
        // 如果内部类型被替换了，创建新的指针类型节点
        if inner_substituted != type_node.type_pointer_pointed_type {
            const new_node: &ASTNode = arena_alloc(codegen.arena, @size_of(ASTNode)) as &ASTNode;
            if new_node != null {
                new_node.type = ASTNodeType.AST_TYPE_POINTER;
                new_node.line = type_node.line;
                new_node.column = type_node.column;
                new_node.type_pointer_pointed_type = inner_substituted;
                new_node.type_pointer_is_ffi_pointer = type_node.type_pointer_is_ffi_pointer;
                return new_node;
            }
        }
    }
    
    // 递归处理数组类型 [T: N]
    if type_node.type == ASTNodeType.AST_TYPE_ARRAY && type_node.type_array_element_type != null {
        const elem_substituted: &ASTNode = substitute_type_arg(codegen, type_node.type_array_element_type);
        if elem_substituted != type_node.type_array_element_type {
            const new_node: &ASTNode = arena_alloc(codegen.arena, @size_of(ASTNode)) as &ASTNode;
            if new_node != null {
                new_node.type = ASTNodeType.AST_TYPE_ARRAY;
                new_node.line = type_node.line;
                new_node.column = type_node.column;
                new_node.type_array_element_type = elem_substituted;
                new_node.type_array_size_expr = type_node.type_array_size_expr;
                return new_node;
            }
        }
    }
    
    return type_node;
}

// 获取类型的 C 表示（支持类型参数替换）
fn c99_mono_type_to_c(codegen: &C99CodeGenerator, type_node: &ASTNode) &byte {
    const substituted: &ASTNode = substitute_type_arg(codegen, type_node);
    return c99_type_to_c(codegen, substituted);
}

// 生成单态化函数原型
fn gen_mono_function_prototype(codegen: &C99CodeGenerator, fn_decl: &ASTNode, type_args: & & ASTNode, type_arg_count: i32) void {
    if fn_decl == null || fn_decl.type != ASTNodeType.AST_FN_DECL || type_args == null {
        return;
    }
    
    const orig_name: &byte = fn_decl.fn_decl_name;
    const mono_name: &byte = get_mono_function_name(codegen, orig_name, type_args, type_arg_count);
    const return_type: &ASTNode = fn_decl.fn_decl_return_type;
    const params: & & ASTNode = fn_decl.fn_decl_params;
    const param_count: i32 = fn_decl.fn_decl_param_count;
    const is_varargs: i32 = fn_decl.fn_decl_is_varargs;
    
    // 保存并设置单态化上下文
    const saved_type_params: &TypeParam = codegen.current_type_params;
    const saved_type_param_count: i32 = codegen.current_type_param_count;
    const saved_type_args: & & ASTNode = codegen.current_type_args;
    const saved_type_arg_count: i32 = codegen.current_type_arg_count;
    
    codegen.current_type_params = fn_decl.fn_decl_type_params;
    codegen.current_type_param_count = fn_decl.fn_decl_type_param_count;
    codegen.current_type_args = type_args;
    codegen.current_type_arg_count = type_arg_count;
    
    // 返回类型（替换类型参数）
    const return_c: &byte = c99_mono_type_to_c(codegen, return_type);
    
    fprintf(codegen.output as *void, "%s %s(" as *byte, return_c as *byte, mono_name as *byte);
    
    // 参数列表
    var i: i32 = 0;
    while i < param_count {
        const param: &ASTNode = params[i];
        if param == null || param.type != ASTNodeType.AST_VAR_DECL {
            i = i + 1;
            continue;
        }
        
        const param_name: &byte = get_safe_c_identifier(codegen, param.var_decl_name);
        const param_type: &ASTNode = param.var_decl_type;
        const param_type_c: &byte = c99_mono_type_to_c(codegen, param_type);
        
        format_param_type(codegen, param_type_c, param_name, codegen.output);
        if i < param_count - 1 {
            fputs(", " as *byte, codegen.output as *void);
        }
        i = i + 1;
    }
    
    // 处理可变参数
    if is_varargs != 0 {
        if param_count > 0 {
            fputs(", " as *byte, codegen.output as *void);
        }
        fputs("..." as *byte, codegen.output as *void);
    }
    
    fputs(");\n" as *byte, codegen.output as *void);
    
    // 恢复上下文
    codegen.current_type_params = saved_type_params;
    codegen.current_type_param_count = saved_type_param_count;
    codegen.current_type_args = saved_type_args;
    codegen.current_type_arg_count = saved_type_arg_count;
}

// 生成单态化函数定义
fn gen_mono_function(codegen: &C99CodeGenerator, fn_decl: &ASTNode, type_args: & & ASTNode, type_arg_count: i32) void {
    if fn_decl == null || fn_decl.type != ASTNodeType.AST_FN_DECL || type_args == null {
        return;
    }
    
    const orig_name: &byte = fn_decl.fn_decl_name;
    const mono_name: &byte = get_mono_function_name(codegen, orig_name, type_args, type_arg_count);
    const return_type: &ASTNode = fn_decl.fn_decl_return_type;
    const params: & & ASTNode = fn_decl.fn_decl_params;
    const param_count: i32 = fn_decl.fn_decl_param_count;
    const is_varargs: i32 = fn_decl.fn_decl_is_varargs;
    const body: &ASTNode = fn_decl.fn_decl_body;
    
    // 如果没有函数体，跳过
    if body == null {
        return;
    }
    
    // 保存并设置单态化上下文
    const saved_type_params: &TypeParam = codegen.current_type_params;
    const saved_type_param_count: i32 = codegen.current_type_param_count;
    const saved_type_args: & & ASTNode = codegen.current_type_args;
    const saved_type_arg_count: i32 = codegen.current_type_arg_count;
    
    codegen.current_type_params = fn_decl.fn_decl_type_params;
    codegen.current_type_param_count = fn_decl.fn_decl_type_param_count;
    codegen.current_type_args = type_args;
    codegen.current_type_arg_count = type_arg_count;
    
    // 生成 #line 指令
    emit_line_directive(codegen, fn_decl.line, fn_decl.filename);
    
    // 返回类型（替换类型参数）
    const return_c: &byte = c99_mono_type_to_c(codegen, return_type);
    
    fprintf(codegen.output as *void, "%s %s(" as *byte, return_c as *byte, mono_name as *byte);
    
    // 参数列表
    var i: i32 = 0;
    while i < param_count {
        const param: &ASTNode = params[i];
        if param == null || param.type != ASTNodeType.AST_VAR_DECL {
            i = i + 1;
            continue;
        }
        
        const param_name: &byte = get_safe_c_identifier(codegen, param.var_decl_name);
        const param_type: &ASTNode = param.var_decl_type;
        const param_type_c: &byte = c99_mono_type_to_c(codegen, param_type);
        
        format_param_type(codegen, param_type_c, param_name, codegen.output);
        if i < param_count - 1 {
            fputs(", " as *byte, codegen.output as *void);
        }
        i = i + 1;
    }
    
    // 处理可变参数
    if is_varargs != 0 {
        if param_count > 0 {
            fputs(", " as *byte, codegen.output as *void);
        }
        fputs("..." as *byte, codegen.output as *void);
    }
    
    fputs(") {\n" as *byte, codegen.output as *void);
    
    // 保存当前状态
    const saved_return_type: &ASTNode = codegen.current_function_return_type;
    const saved_current_function_decl: &ASTNode = codegen.current_function_decl;
    const saved_local_count: i32 = codegen.local_variable_count;
    const saved_depth: i32 = codegen.current_depth;
    
    codegen.current_function_return_type = return_type;
    codegen.current_function_decl = fn_decl;
    codegen.indent_level = codegen.indent_level + 1;
    codegen.current_depth = codegen.current_depth + 1;
    
    // 将参数添加到局部变量表
    i = 0;
    while i < param_count {
        const param: &ASTNode = params[i];
        if param != null && param.type == ASTNodeType.AST_VAR_DECL {
            if codegen.local_variable_count < C99_MAX_LOCAL_VARS {
                codegen.local_variables[codegen.local_variable_count].name = param.var_decl_name;
                codegen.local_variables[codegen.local_variable_count].type_c = c99_mono_type_to_c(codegen, param.var_decl_type);
                codegen.local_variables[codegen.local_variable_count].depth = codegen.current_depth;
                codegen.local_variable_count = codegen.local_variable_count + 1;
            }
        }
        i = i + 1;
    }
    
    // 生成函数体
    gen_stmt(codegen, body);
    
    // 恢复状态
    codegen.current_function_return_type = saved_return_type;
    codegen.current_function_decl = saved_current_function_decl;
    codegen.local_variable_count = saved_local_count;
    codegen.current_depth = saved_depth;
    codegen.indent_level = codegen.indent_level - 1;
    
    fputs("}\n" as *byte, codegen.output as *void);
    
    // 恢复单态化上下文
    codegen.current_type_params = saved_type_params;
    codegen.current_type_param_count = saved_type_param_count;
    codegen.current_type_args = saved_type_args;
    codegen.current_type_arg_count = saved_type_arg_count;
}

