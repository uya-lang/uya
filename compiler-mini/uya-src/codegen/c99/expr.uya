// expr.uya - C99 代码生成器表达式模块
// 提供表达式代码生成功能
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 外部函数声明 =====
// C 标准库函数（在 extern_decls.uya 中声明）

// 已知 C 变参函数对应的 va_list 版本（用于 ... 转发）
fn get_vprintf_style_name(c_name: &byte) &byte {
    if c_name == null {
        return null;
    }
    if str_equals(c_name as *byte, "printf" as *byte) != 0 {
        return "vprintf" as &byte;
    }
    if str_equals(c_name as *byte, "sprintf" as *byte) != 0 {
        return "vsprintf" as &byte;
    }
    if str_equals(c_name as *byte, "fprintf" as *byte) != 0 {
        return "vfprintf" as &byte;
    }
    if str_equals(c_name as *byte, "snprintf" as *byte) != 0 {
        return "vsnprintf" as &byte;
    }
    return null;
}

// 根据 C 类型字符串返回无符号类型（用于包装运算）
fn unsigned_type_for_wrapping(type_c: &byte) &byte {
    if type_c == null { return "unsigned" as &byte; }
    if strstr(type_c as *byte, "int8" as *byte) != null { return "uint8_t" as &byte; }
    if strstr(type_c as *byte, "int16" as *byte) != null { return "uint16_t" as &byte; }
    if strstr(type_c as *byte, "int32" as *byte) != null { return "uint32_t" as &byte; }
    if strstr(type_c as *byte, "int64" as *byte) != null { return "uint64_t" as &byte; }
    return "unsigned" as &byte;
}

// 根据 C 类型字符串生成整数极值字面量（用于饱和运算）
fn gen_saturate_limit_from_type_c(codegen: &C99CodeGenerator, type_c: &byte, is_max: i32) void {
    if type_c == null {
        if is_max != 0 { fputs("2147483647" as *byte, codegen.output as *void); } else { fputs("(-2147483647-1)" as *byte, codegen.output as *void); }
        return;
    }
    if strstr(type_c as *byte, "int8" as *byte) != null {
        if is_max != 0 { fputs("127" as *byte, codegen.output as *void); } else { fputs("(-128)" as *byte, codegen.output as *void); }
        return;
    }
    if strstr(type_c as *byte, "int16" as *byte) != null {
        if is_max != 0 { fputs("32767" as *byte, codegen.output as *void); } else { fputs("(-32768)" as *byte, codegen.output as *void); }
        return;
    }
    if strstr(type_c as *byte, "int32" as *byte) != null {
        if is_max != 0 { fputs("2147483647" as *byte, codegen.output as *void); } else { fputs("(-2147483647-1)" as *byte, codegen.output as *void); }
        return;
    }
    if strstr(type_c as *byte, "int64" as *byte) != null {
        if is_max != 0 { fputs("9223372036854775807LL" as *byte, codegen.output as *void); } else { fputs("(-9223372036854775807LL-1LL)" as *byte, codegen.output as *void); }
        return;
    }
    if is_max != 0 { fputs("2147483647" as *byte, codegen.output as *void); } else { fputs("(-2147483647-1)" as *byte, codegen.output as *void); }
}

// 根据整数类型与 max/min 生成 C 极值字面量（resolved_kind 为 TypeKind 值）
fn gen_int_limit_literal(codegen: &C99CodeGenerator, is_max: i32, resolved_kind: i32) void {
    if resolved_kind == 0 {
        fputs("0" as *byte, codegen.output as *void);
        return;
    }
    const k: TypeKind = resolved_kind as TypeKind;
    if k == TypeKind.TYPE_I8 {
        if is_max != 0 { fputs("127" as *byte, codegen.output as *void); } else { fputs("(-128)" as *byte, codegen.output as *void); }
    } else if k == TypeKind.TYPE_I16 {
        if is_max != 0 { fputs("32767" as *byte, codegen.output as *void); } else { fputs("(-32768)" as *byte, codegen.output as *void); }
    } else if k == TypeKind.TYPE_I32 {
        if is_max != 0 { fputs("2147483647" as *byte, codegen.output as *void); } else { fputs("(-2147483647-1)" as *byte, codegen.output as *void); }
    } else if k == TypeKind.TYPE_I64 {
        if is_max != 0 { fputs("9223372036854775807LL" as *byte, codegen.output as *void); } else { fputs("(-9223372036854775807LL-1LL)" as *byte, codegen.output as *void); }
    } else if k == TypeKind.TYPE_U8 || k == TypeKind.TYPE_BYTE {
        if is_max != 0 { fputs("255" as *byte, codegen.output as *void); } else { fputs("0" as *byte, codegen.output as *void); }
    } else if k == TypeKind.TYPE_U16 {
        if is_max != 0 { fputs("65535" as *byte, codegen.output as *void); } else { fputs("0" as *byte, codegen.output as *void); }
    } else if k == TypeKind.TYPE_U32 {
        if is_max != 0 { fputs("4294967295U" as *byte, codegen.output as *void); } else { fputs("0" as *byte, codegen.output as *void); }
    } else if k == TypeKind.TYPE_USIZE {
        if is_max != 0 { fputs("((size_t)-1)" as *byte, codegen.output as *void); } else { fputs("0" as *byte, codegen.output as *void); }
    } else if k == TypeKind.TYPE_U64 {
        if is_max != 0 { fputs("18446744073709551615ULL" as *byte, codegen.output as *void); } else { fputs("0" as *byte, codegen.output as *void); }
    } else {
        fputs("0" as *byte, codegen.output as *void);
    }
}

fn c99_emit_string_interp_fill(codegen: &C99CodeGenerator, expr: &ASTNode, buf_name: &byte) void {
    if codegen == null || expr == null || expr.type != ASTNodeType.AST_STRING_INTERP || buf_name == null {
        return;
    }
    const n: i32 = expr.string_interp_segment_count;
    if n <= 0 || expr.string_interp_computed_size <= 0 {
        return;
    }
    const fill_id: i32 = codegen.interp_fill_counter;
    codegen.interp_fill_counter = codegen.interp_fill_counter + 1;
    c99_emit_indent(codegen);
    fprintf(codegen.output as *void, "int _off_%d = 0;\n" as *byte, fill_id);
    var i: i32 = 0;
    while i < n {
        const seg: &ASTStringInterpSegment = &expr.string_interp_segments[i];
        if seg.is_text != 0 {
            var len: usize = 0;
            if seg.text != null {
                len = strlen(seg.text as *byte);
            }
            const cn: &byte = add_string_constant(codegen, seg.text);
            if cn != null {
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "memcpy(%s + _off_%d, %s, %zu);\n" as *byte, buf_name as *byte, fill_id, cn as *byte, len);
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "_off_%d += %zu;\n" as *byte, fill_id, len);
            }
        } else {
            var fmt_buf: [byte: 64] = [];
            fmt_buf[0] = 37;
            var j: i32 = 1;
            if seg.format_spec != null && seg.format_spec[0] != 0 {
                var k: i32 = 0;
                while seg.format_spec[k] != 0 && j < 62 {
                    fmt_buf[j] = seg.format_spec[k];
                    j = j + 1;
                    k = k + 1;
                }
            } else {
                fmt_buf[1] = 100;
                j = 2;
            }
            fmt_buf[j] = 0;
            const fmt_in_arena: &byte = c99_arena_strdup(codegen.arena, &fmt_buf[0] as &byte);
            const fmt_const: &byte = add_string_constant(codegen, fmt_in_arena);
            if fmt_const != null && fmt_in_arena != null {
                c99_emit_indent(codegen);
                fprintf(codegen.output as *void, "_off_%d += sprintf(%s + _off_%d, %s, " as *byte, fill_id, buf_name as *byte, fill_id, fmt_const as *byte);
                gen_expr(codegen, seg.expr);
                fputs(");\n" as *byte, codegen.output as *void);
            }
        }
        i = i + 1;
    }
    c99_emit_indent(codegen);
    fprintf(codegen.output as *void, "%s[_off_%d] = '\\0';\n" as *byte, buf_name as *byte, fill_id);
}

fn gen_expr(codegen: &C99CodeGenerator, expr: &ASTNode) void {
    if expr == null {
        return;
    }
    
    if expr.type == ASTNodeType.AST_NUMBER {
        fprintf(codegen.output as *void, "%d" as *byte, expr.number_value);
    } else if expr.type == ASTNodeType.AST_FLOAT {
        const val: f64 = expr.float_literal_value;
        fprintf(codegen.output as *void, "%.17g" as *byte, val);
    } else if expr.type == ASTNodeType.AST_BOOL {
        if expr.bool_literal_value != 0 {
            fputs("true" as *byte, codegen.output as *void);
        } else {
            fputs("false" as *byte, codegen.output as *void);
        }
    } else if expr.type == ASTNodeType.AST_INT_LIMIT {
        gen_int_limit_literal(codegen, expr.int_limit_is_max, expr.int_limit_resolved_kind);
    } else if expr.type == ASTNodeType.AST_STRING {
        const str_const: &byte = add_string_constant(codegen, expr.string_literal_value);
        if str_const != null {
            fprintf(codegen.output as *void, "%s" as *byte, str_const as *byte);
        } else {
            fputs("\"\"" as *byte, codegen.output as *void);
        }
    } else if expr.type == ASTNodeType.AST_STRING_INTERP {
        if codegen.string_interp_buf != null {
            fputs(codegen.string_interp_buf as *byte, codegen.output as *void);
        } else {
            fputs("((char*)0)" as *byte, codegen.output as *void);
        }
    } else if expr.type == ASTNodeType.AST_ERROR_VALUE {
        var id: i32 = c99_get_or_add_error_id(codegen, expr.error_value_name);
        if id == 0 {
            id = 1;
        }
        fprintf(codegen.output as *void, "%dU" as *byte, id);
    } else if expr.type == ASTNodeType.AST_TRY_EXPR {
        const operand: &ASTNode = expr.try_expr_operand;
        const ret_type: &ASTNode = codegen.current_function_return_type;
        if operand == null {
            fputs("0" as *byte, codegen.output as *void);
            return;
        }
        const operand_union_c: &byte = get_c_type_of_expr(codegen, operand);
        var operand_is_err_union: i32 = 0;
        if operand_union_c != null && strstr(operand_union_c as *byte, "err_union_" as *byte) != null {
            operand_is_err_union = 1;
        }
        if operand_is_err_union == 0 || ret_type == null || ret_type.type != ASTNodeType.AST_TYPE_ERROR_UNION {
            if ret_type != null && ret_type.type == ASTNodeType.AST_TYPE_ERROR_UNION {
                const union_c: &byte = c99_type_to_c(codegen, ret_type);
                fprintf(codegen.output as *void, "({ %s _uya_try_tmp = " as *byte, union_c as *byte);
                gen_expr(codegen, operand);
                fputs("; if (_uya_try_tmp.error_id != 0) return _uya_try_tmp; _uya_try_tmp.value; })" as *byte, codegen.output as *void);
            } else {
                fputs("0" as *byte, codegen.output as *void);
            }
            return;
        }
        const ret_union_c: &byte = c99_type_to_c(codegen, ret_type);
        fprintf(codegen.output as *void, "({ %s _uya_try_tmp = " as *byte, operand_union_c as *byte);
        gen_expr(codegen, operand);
        fprintf(codegen.output as *void, "; if (_uya_try_tmp.error_id != 0) return (%s){ .error_id = _uya_try_tmp.error_id, .value = 0 }; _uya_try_tmp.value; })" as *byte, ret_union_c as *byte);
    } else if expr.type == ASTNodeType.AST_CATCH_EXPR {
        const operand: &ASTNode = expr.catch_expr_operand;
        const block: &ASTNode = expr.catch_expr_catch_block;
        const err_name: &byte = expr.catch_expr_err_name;
        const ret_type: &ASTNode = codegen.current_function_return_type;
        if operand == null || block == null {
            fputs("0" as *byte, codegen.output as *void);
            return;
        }
        const operand_union_c: &byte = get_c_type_of_expr(codegen, operand);
        var operand_is_err_union: i32 = 0;
        if operand_union_c != null && strstr(operand_union_c as *byte, "err_union_" as *byte) != null {
            operand_is_err_union = 1;
        }
        var union_c: &byte = ("int32_t" as *byte) as &byte;
        var payload_c: &byte = ("int32_t" as *byte) as &byte;
        if operand_is_err_union != 0 {
            union_c = operand_union_c;
            if operand != null && operand.type == ASTNodeType.AST_CAST_EXPR && operand.cast_expr_is_force_cast != 0 && operand.cast_expr_target_type != null {
                payload_c = c99_type_to_c(codegen, operand.cast_expr_target_type);
            } else if ret_type != null && ret_type.type == ASTNodeType.AST_TYPE_ERROR_UNION && ret_type.type_error_union_payload_type != null {
                payload_c = c99_type_to_c(codegen, ret_type.type_error_union_payload_type);
            } else {
                payload_c = "int32_t" as &byte;
            }
        } else if ret_type != null && ret_type.type == ASTNodeType.AST_TYPE_ERROR_UNION {
            union_c = c99_type_to_c(codegen, ret_type);
            const payload_node: &ASTNode = ret_type.type_error_union_payload_type;
            if payload_node != null {
                payload_c = c99_type_to_c(codegen, payload_node);
            }
        } else {
            fputs("0" as *byte, codegen.output as *void);
            return;
        }
        const n: i32 = block.block_stmt_count;
        var last_stmt: &ASTNode = null;
        if n > 0 {
            last_stmt = block.block_stmts[n - 1];
        }
        fprintf(codegen.output as *void, "({ %s _uya_catch_result; %s _uya_catch_tmp = " as *byte, payload_c as *byte, union_c as *byte);
        gen_expr(codegen, operand);
        fputs("; if (_uya_catch_tmp.error_id != 0) {\n" as *byte, codegen.output as *void);
        codegen.indent_level = codegen.indent_level + 1;
        if err_name != null {
            const safe: &byte = get_safe_c_identifier(codegen, err_name);
            c99_emit_indent(codegen);
            fprintf(codegen.output as *void, "%s %s = _uya_catch_tmp;\n" as *byte, union_c as *byte, safe as *byte);
        }
        var i: i32 = 0;
        while i < n {
            const s: &ASTNode = block.block_stmts[i];
            if s != null {
                if i == n - 1 && last_stmt != null && last_stmt.type != ASTNodeType.AST_RETURN_STMT {
                    c99_emit_indent(codegen);
                    fputs("_uya_catch_result = (" as *byte, codegen.output as *void);
                    gen_expr(codegen, s);
                    fputs(");\n" as *byte, codegen.output as *void);
                } else {
                    gen_stmt(codegen, s);
                }
            }
            i = i + 1;
        }
        codegen.indent_level = codegen.indent_level - 1;
        c99_emit_indent(codegen);
        fputs("} else _uya_catch_result = _uya_catch_tmp.value; _uya_catch_result; })" as *byte, codegen.output as *void);
    } else if expr.type == ASTNodeType.AST_BINARY_EXPR {
        const left: &ASTNode = expr.binary_expr_left;
        const right: &ASTNode = expr.binary_expr_right;
        const op: TokenType = expr.binary_expr_op as TokenType;
        
        // 错误类型比较：err == error.X 或 error.X == err -> .error_id 比较
        if op == TokenType.TOKEN_EQUAL || op == TokenType.TOKEN_NOT_EQUAL {
            if left != null && right != null {
                if left.type == ASTNodeType.AST_IDENTIFIER && right.type == ASTNodeType.AST_ERROR_VALUE {
                var id: i32 = c99_get_or_add_error_id(codegen, right.error_value_name);
                if id == 0 {
                    id = 1;
                }
                const safe: &byte = get_safe_c_identifier(codegen, left.identifier_name);
                if op == TokenType.TOKEN_NOT_EQUAL {
                    fprintf(codegen.output as *void, "(%s.error_id != %dU)" as *byte, safe as *byte, id);
                } else {
                    fprintf(codegen.output as *void, "(%s.error_id == %dU)" as *byte, safe as *byte, id);
                }
                return;
                }
                if left.type == ASTNodeType.AST_ERROR_VALUE && right.type == ASTNodeType.AST_IDENTIFIER {
                var id: i32 = c99_get_or_add_error_id(codegen, left.error_value_name);
                if id == 0 {
                    id = 1;
                }
                const safe: &byte = get_safe_c_identifier(codegen, right.identifier_name);
                if op == TokenType.TOKEN_NOT_EQUAL {
                    fprintf(codegen.output as *void, "(%dU != %s.error_id)" as *byte, id, safe as *byte);
                } else {
                    fprintf(codegen.output as *void, "(%dU == %s.error_id)" as *byte, id, safe as *byte);
                }
                return;
                }
            }
        }
        
        // 检查是否是结构体比较（== 或 !=）
        var is_struct_comparison: i32 = 0;
        if (op == TokenType.TOKEN_EQUAL || op == TokenType.TOKEN_NOT_EQUAL) && left != null && right != null {
            // 检查左操作数是否是结构体类型
            if left.type == ASTNodeType.AST_IDENTIFIER {
                if is_identifier_struct_type(codegen, left.identifier_name) != 0 {
                    is_struct_comparison = 1;
                }
            } else if left.type == ASTNodeType.AST_STRUCT_INIT {
                is_struct_comparison = 1;
            }
        }
        
        if is_struct_comparison != 0 {
            // 解析出结构体声明，空结构体直接输出 (1)/(0)
            var struct_decl: &ASTNode = null;
            if left.type == ASTNodeType.AST_IDENTIFIER {
                const type_c: &byte = get_identifier_type_c(codegen, left.identifier_name);
                if type_c != null {
                    const struct_prefix: *byte = strstr(type_c as *byte, "struct " as *byte);
                    if struct_prefix != null {
                        const name_start: &byte = (struct_prefix + 7) as &byte;
                        struct_decl = find_struct_decl_c99(codegen, name_start);
                    }
                }
            } else if left.type == ASTNodeType.AST_STRUCT_INIT {
                struct_decl = find_struct_decl_c99(codegen, left.struct_init_struct_name);
            }
            if struct_decl != null && struct_decl.struct_decl_field_count == 0 {
                if op == TokenType.TOKEN_EQUAL {
                    fputs("(1)" as *byte, codegen.output as *void);
                } else if op == TokenType.TOKEN_NOT_EQUAL {
                    fputs("(0)" as *byte, codegen.output as *void);
                }
            } else if struct_decl != null && struct_decl.type == ASTNodeType.AST_STRUCT_DECL && struct_decl.struct_decl_field_count > 0 {
                // 按字段比较，与 C 编译器一致，避免 padding 未初始化导致 memcmp 结果错误
                if op == TokenType.TOKEN_NOT_EQUAL {
                    fputs("(!(" as *byte, codegen.output as *void);
                } else {
                    fputc(40, codegen.output as *void);  // '('
                }
                var i: i32 = 0;
                while i < struct_decl.struct_decl_field_count {
                    const field: &ASTNode = struct_decl.struct_decl_fields[i];
                    if field != null && field.type == ASTNodeType.AST_VAR_DECL {
                        const field_type: &ASTNode = field.var_decl_type;
                        const safe_field: &byte = get_safe_c_identifier(codegen, field.var_decl_name);
                        if safe_field != null {
                            var field_needs_memcmp: i32 = 0;
                            if field_type != null {
                                if field_type.type == ASTNodeType.AST_TYPE_NAMED {
                                    const type_name: &byte = field_type.type_named_name;
                                    if type_name != null && find_struct_decl_c99(codegen, type_name) != null {
                                        field_needs_memcmp = 1;
                                    }
                                } else if field_type.type == ASTNodeType.AST_TYPE_ARRAY {
                                    field_needs_memcmp = 1;
                                }
                            }
                            if field_needs_memcmp != 0 {
                                fputs("(memcmp(&(" as *byte, codegen.output as *void);
                                gen_expr(codegen, left);
                                fputs(")." as *byte, codegen.output as *void);
                                fputs(safe_field as *byte, codegen.output as *void);
                                fputs(", &(" as *byte, codegen.output as *void);
                                gen_expr(codegen, right);
                                fputs(")." as *byte, codegen.output as *void);
                                fputs(safe_field as *byte, codegen.output as *void);
                                fputs(", sizeof((" as *byte, codegen.output as *void);
                                gen_expr(codegen, left);
                                fputs(")." as *byte, codegen.output as *void);
                                fputs(safe_field as *byte, codegen.output as *void);
                                fputs(")) == 0)" as *byte, codegen.output as *void);
                            } else {
                                fputs("((" as *byte, codegen.output as *void);
                                gen_expr(codegen, left);
                                fputs(")." as *byte, codegen.output as *void);
                                fputs(safe_field as *byte, codegen.output as *void);
                                fputs(" == (" as *byte, codegen.output as *void);
                                gen_expr(codegen, right);
                                fputs(")." as *byte, codegen.output as *void);
                                fputs(safe_field as *byte, codegen.output as *void);
                                fputs(")" as *byte, codegen.output as *void);
                            }
                            if i < struct_decl.struct_decl_field_count - 1 {
                                fputs(" && " as *byte, codegen.output as *void);
                            }
                        }
                    }
                    i = i + 1;
                }
                fputc(41, codegen.output as *void);  // ')'
                if op == TokenType.TOKEN_NOT_EQUAL {
                    fputc(41, codegen.output as *void);  // ')'
                }
            } else {
                // 回退：无法按字段比较时用 memcmp，与 C 编译器一致
                fputc(40, codegen.output as *void);  // '('
                if left.type == ASTNodeType.AST_IDENTIFIER {
                    fputs("memcmp(&" as *byte, codegen.output as *void);
                    gen_expr(codegen, left);
                    fputs(", &" as *byte, codegen.output as *void);
                    gen_expr(codegen, right);
                    fputs(", sizeof(" as *byte, codegen.output as *void);
                    gen_expr(codegen, left);
                    fputs("))" as *byte, codegen.output as *void);
                } else if left.type == ASTNodeType.AST_STRUCT_INIT {
                    const struct_name: &byte = left.struct_init_struct_name;
                    fputs("memcmp(&" as *byte, codegen.output as *void);
                    gen_expr(codegen, left);
                    fputs(", &" as *byte, codegen.output as *void);
                    gen_expr(codegen, right);
                    const safe_struct_name: &byte = get_safe_c_identifier(codegen, struct_name);
                    fprintf(codegen.output as *void, ", sizeof(struct %s))" as *byte, safe_struct_name as *byte);
                } else {
                    fputs("memcmp(&" as *byte, codegen.output as *void);
                    gen_expr(codegen, left);
                    fputs(", &" as *byte, codegen.output as *void);
                    gen_expr(codegen, right);
                    fputs(", sizeof(" as *byte, codegen.output as *void);
                    gen_expr(codegen, left);
                    fputs("))" as *byte, codegen.output as *void);
                }
                if op == TokenType.TOKEN_EQUAL {
                    fputs(" == 0)" as *byte, codegen.output as *void);
                } else if op == TokenType.TOKEN_NOT_EQUAL {
                    fputs(" != 0)" as *byte, codegen.output as *void);
                } else {
                    fputc(41, codegen.output as *void);  // ')'
                }
            }
        } else if op == TokenType.TOKEN_PLUS_PIPE || op == TokenType.TOKEN_MINUS_PIPE || op == TokenType.TOKEN_ASTERISK_PIPE ||
            op == TokenType.TOKEN_PLUS_PERCENT || op == TokenType.TOKEN_MINUS_PERCENT || op == TokenType.TOKEN_ASTERISK_PERCENT {
            // 饱和运算 +| -| *| 或包装运算 +% -% *%
            var type_c: &byte = get_c_type_of_expr(codegen, left);
            if type_c == null { type_c = "int32_t" as &byte; }
            if op == TokenType.TOKEN_PLUS_PIPE || op == TokenType.TOKEN_MINUS_PIPE || op == TokenType.TOKEN_ASTERISK_PIPE {
                var base_type: &byte = type_c;
                if type_c != null && strncmp(type_c as *byte, "const " as *byte, 6) == 0 { base_type = (type_c as *byte + 6) as &byte; }
                if base_type == null { base_type = "int32_t" as &byte; }
                fputs("({ " as *byte, codegen.output as *void);
                fprintf(codegen.output as *void, "%s _l = (" as *byte, base_type as *byte);
                gen_expr(codegen, left);
                fputs("); " as *byte, codegen.output as *void);
                fprintf(codegen.output as *void, "%s _r = (" as *byte, base_type as *byte);
                gen_expr(codegen, right);
                fputs("); " as *byte, codegen.output as *void);
                fprintf(codegen.output as *void, "%s _s; " as *byte, base_type as *byte);
                if op == TokenType.TOKEN_PLUS_PIPE {
                    fputs("__builtin_add_overflow(_l, _r, &_s) ? (_l>=0 && _r>=0 ? " as *byte, codegen.output as *void);
                } else if op == TokenType.TOKEN_MINUS_PIPE {
                    fputs("__builtin_sub_overflow(_l, _r, &_s) ? (_l>=0 && _r<0 ? " as *byte, codegen.output as *void);
                } else {
                    fprintf(codegen.output as *void, "%s _res; " as *byte, base_type as *byte);
                    fputs("if (__builtin_mul_overflow(_l, _r, &_s)) _res = ((_l>=0 && _r>=0) || (_l<0 && _r<0)) ? " as *byte, codegen.output as *void);
                }
                gen_saturate_limit_from_type_c(codegen, type_c, 1);
                fputs(" : " as *byte, codegen.output as *void);
                gen_saturate_limit_from_type_c(codegen, type_c, 0);
                if op == TokenType.TOKEN_ASTERISK_PIPE {
                    fputs("; else _res = _s; _res; })" as *byte, codegen.output as *void);
                } else {
                    fputs(") : _s; })" as *byte, codegen.output as *void);
                }
            } else {
                const ut: &byte = unsigned_type_for_wrapping(type_c);
                fprintf(codegen.output as *void, "((%s)((%s)(" as *byte, type_c as *byte, ut as *byte);
                gen_expr(codegen, left);
                if op == TokenType.TOKEN_PLUS_PERCENT { fputs(") + (" as *byte, codegen.output as *void); }
                else if op == TokenType.TOKEN_MINUS_PERCENT { fputs(") - (" as *byte, codegen.output as *void); }
                else { fputs(") * (" as *byte, codegen.output as *void); }
                fprintf(codegen.output as *void, "%s)(" as *byte, ut as *byte);
                gen_expr(codegen, right);
                fputs(")))" as *byte, codegen.output as *void);
            }
        } else {
            // 普通二元表达式
            fputc(40, codegen.output as *void);  // '('
            gen_expr(codegen, left);
            // 操作符映射
            if op == TokenType.TOKEN_PLUS {
                fputs(" + " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_MINUS {
                fputs(" - " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_ASTERISK {
                fputs(" * " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_SLASH {
                fputs(" / " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_PERCENT {
                fputs(" % " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_EQUAL {
                fputs(" == " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_NOT_EQUAL {
                fputs(" != " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_LESS {
                fputs(" < " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_GREATER {
                fputs(" > " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_LESS_EQUAL {
                fputs(" <= " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_GREATER_EQUAL {
                fputs(" >= " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_LOGICAL_AND {
                fputs(" && " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_LOGICAL_OR {
                fputs(" || " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_AMPERSAND {
                fputs(" & " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_PIPE {
                fputs(" | " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_CARET {
                fputs(" ^ " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_LSHIFT {
                fputs(" << " as *byte, codegen.output as *void);
            } else if op == TokenType.TOKEN_RSHIFT {
                fputs(" >> " as *byte, codegen.output as *void);
            } else {
                fputs(" + " as *byte, codegen.output as *void); // 默认为加法
            }
            gen_expr(codegen, right);
            fputc(41, codegen.output as *void);  // ')'
        }
    } else if expr.type == ASTNodeType.AST_UNARY_EXPR {
        const op: TokenType = expr.unary_expr_op as TokenType;
        const operand: &ASTNode = expr.unary_expr_operand;
        fputc(40, codegen.output as *void);  // '('
        if op == TokenType.TOKEN_ASTERISK {
            fputs("*" as *byte, codegen.output as *void);
        } else if op == TokenType.TOKEN_AMPERSAND {
            fputs("&" as *byte, codegen.output as *void);
        } else if op == TokenType.TOKEN_MINUS {
            fputs("-" as *byte, codegen.output as *void);
        } else if op == TokenType.TOKEN_EXCLAMATION {
            fputs("!" as *byte, codegen.output as *void);
        } else if op == TokenType.TOKEN_TILDE {
            fputs("~" as *byte, codegen.output as *void);
        } else if op == TokenType.TOKEN_PLUS {
            fputs("+" as *byte, codegen.output as *void);
        } else {
            fputs("+" as *byte, codegen.output as *void); // 默认
        }
        gen_expr(codegen, operand);
        fputc(41, codegen.output as *void);  // ')'
    } else if expr.type == ASTNodeType.AST_MEMBER_ACCESS {
        const object: &ASTNode = expr.member_access_object;
        const field_name: &byte = expr.member_access_field_name;
        
        if object == null || field_name == null {
            return;
        }
        
        // 检查是否是枚举值访问（EnumName.Variant）
        if object.type == ASTNodeType.AST_IDENTIFIER {
            const enum_name: &byte = object.identifier_name;
            if enum_name != null {
                // 检查是否是枚举类型名称（不检查变量表，直接检查枚举声明）
                const enum_decl: &ASTNode = find_enum_decl_c99(codegen, enum_name);
                if enum_decl != null {
                    // 是枚举类型，查找变体值
                    const enum_value: i32 = find_enum_variant_value(codegen, enum_decl, field_name);
                    if enum_value >= 0 {
                        // 找到变体，直接输出枚举值名称（C中枚举值不需要前缀）
                        const safe_variant_name: &byte = get_safe_c_identifier(codegen, field_name);
                        fprintf(codegen.output as *void, "%s" as *byte, safe_variant_name as *byte);
                        return;
                    }
                }
            }
        }
        
        // 普通字段访问（结构体字段）或元组下标（.0, .1 -> .f0, .f1）
        var safe_field_name: &byte = null;
        if field_name[0] >= 48 && field_name[0] <= 57 {
            const idx: i32 = atoi(field_name as *byte);
            const buf: &byte = arena_alloc(codegen.arena, 16) as &byte;
            if buf != null {
                snprintf(buf as *byte, 16, "f%d" as *byte, idx);
                safe_field_name = buf;
            } else {
                safe_field_name = ("f0" as *byte) as &byte;
            }
        } else {
            safe_field_name = get_safe_c_identifier(codegen, field_name);
        }
        if safe_field_name == null {
            safe_field_name = ("f0" as *byte) as &byte;
        }
        
        // 检查对象是否是指针类型（需要自动解引用）
        var is_pointer: i32 = 0;
        if object.type == ASTNodeType.AST_IDENTIFIER {
            // 标识符：检查变量类型是否是指针
            // 注意：需要使用 get_safe_c_identifier 转换名称，因为变量表中存储的是转换后的名称
            const var_name: &byte = object.identifier_name;
            if var_name != null {
                const safe_name: &byte = get_safe_c_identifier(codegen, var_name);
                is_pointer = is_identifier_pointer_type(codegen, safe_name);
            }
        } else if object.type == ASTNodeType.AST_MEMBER_ACCESS {
            // 嵌套成员访问：检查嵌套访问的结果类型是否是指针
            is_pointer = is_member_access_pointer_type(codegen, object);
        } else if object.type == ASTNodeType.AST_ARRAY_ACCESS {
            // 数组访问：检查数组元素类型是否是指针
            // 例如：programs[i] 如果 programs 的类型是 [&ASTNode: 64]，那么 programs[i] 是指针类型
            is_pointer = is_array_access_pointer_type(codegen, object);
        } else if object.type == ASTNodeType.AST_UNARY_EXPR {
            // 一元表达式：检查操作符
            const op2: TokenType = object.unary_expr_op as TokenType;
            if op2 == TokenType.TOKEN_AMPERSAND {
                // &expr：取地址表达式的结果是指针，但这里访问的是 expr 的字段
                // 实际上不应该发生这种情况，因为 &expr.field 在语法上不合法
                // 但为了安全，我们假设不是指针
                is_pointer = 0;
            } else if op2 == TokenType.TOKEN_ASTERISK {
                // *ptr：解引用表达式的结果是结构体本身，不是指针
                // 所以应该使用 . 而不是 ->
                is_pointer = 0;
            }
            // 其他一元操作符（!, -, +）不影响类型判断
        }
        
        if codegen.emitting_assign_lhs != 0 && object.type == ASTNodeType.AST_IDENTIFIER && object.identifier_name != null &&
            strcmp(object.identifier_name as *byte, "self" as *byte) == 0 && codegen.current_method_struct_name != null {
            const safe_struct: &byte = get_safe_c_identifier(codegen, codegen.current_method_struct_name);
            if safe_struct != null {
                fprintf(codegen.output as *void, "((struct %s *)self)" as *byte, safe_struct as *byte);
            } else {
                gen_expr(codegen, object);
            }
        } else {
            gen_expr(codegen, object);
        }
        if is_pointer != 0 {
            // 指针类型使用 -> 操作符
            fprintf(codegen.output as *void, "->%s" as *byte, safe_field_name as *byte);
        } else {
            // 非指针类型使用 . 操作符
            fprintf(codegen.output as *void, ".%s" as *byte, safe_field_name as *byte);
        }
    } else if expr.type == ASTNodeType.AST_SLICE_EXPR {
        const base: &ASTNode = expr.slice_expr_base;
        const start_expr: &ASTNode = expr.slice_expr_start_expr;
        const len_expr: &ASTNode = expr.slice_expr_len_expr;
        const slice_type_c: &byte = get_c_type_of_expr(codegen, expr);
        var slice_type_str: &byte = ("struct uya_slice_int32_t" as *byte) as &byte;
        if slice_type_c != null {
            slice_type_str = slice_type_c;
        }
        fprintf(codegen.output as *void, "(%s){ .ptr = " as *byte, slice_type_str as *byte);
        if base.type == ASTNodeType.AST_SLICE_EXPR {
            fputc(40, codegen.output as *void);
            gen_expr(codegen, base);
            fputs(").ptr + " as *byte, codegen.output as *void);
        } else if base.type == ASTNodeType.AST_IDENTIFIER {
            const type_c: &byte = get_identifier_type_c(codegen, base.identifier_name);
            if type_c != null && strstr(type_c as *byte, "uya_slice_" as *byte) != null {
                fputc(40, codegen.output as *void);
                gen_expr(codegen, base);
                fputs(").ptr + " as *byte, codegen.output as *void);
            } else {
                gen_expr(codegen, base);
                fputs(" + " as *byte, codegen.output as *void);
            }
        } else {
            gen_expr(codegen, base);
            fputs(" + " as *byte, codegen.output as *void);
        }
        gen_expr(codegen, start_expr);
        fputs(", .len = " as *byte, codegen.output as *void);
        gen_expr(codegen, len_expr);
        fputc(125, codegen.output as *void);  // '}'
    } else if expr.type == ASTNodeType.AST_ARRAY_ACCESS {
        const array: &ASTNode = expr.array_access_array;
        const index: &ASTNode = expr.array_access_index;
        
        if array.type == ASTNodeType.AST_SLICE_EXPR {
            fputc(40, codegen.output as *void);
            gen_expr(codegen, array);
            fputs(").ptr[" as *byte, codegen.output as *void);
            gen_expr(codegen, index);
            fputc(93, codegen.output as *void);
            return;
        }
        if array.type == ASTNodeType.AST_MEMBER_ACCESS {
            const type_c: &byte = get_c_type_of_expr(codegen, array);
            if type_c != null && strstr(type_c as *byte, "uya_slice_" as *byte) != null {
                fputc(40, codegen.output as *void);
                gen_expr(codegen, array);
                fputs(").ptr[" as *byte, codegen.output as *void);
                gen_expr(codegen, index);
                fputc(93, codegen.output as *void);
                return;
            }
        }
        if array.type == ASTNodeType.AST_IDENTIFIER {
            const type_c: &byte = get_identifier_type_c(codegen, array.identifier_name);
            if type_c != null && strstr(type_c as *byte, "uya_slice_" as *byte) != null {
                fputc(40, codegen.output as *void);
                gen_expr(codegen, array);
                fputs(").ptr[" as *byte, codegen.output as *void);
                gen_expr(codegen, index);
                fputc(93, codegen.output as *void);
                return;
            }
        }
        
        // 注意：对于指向数组的指针（如 uint8_t (*)[4096]），
        // 在 C 中可以直接使用 file_paths_buffer[i]，不需要 (*file_paths_buffer)[i]
        // 因为 file_paths_buffer[i] 会自动解引用
        gen_expr(codegen, array);
        fputc(91, codegen.output as *void);  // '['
        gen_expr(codegen, index);
        fputc(93, codegen.output as *void);  // ']'
    } else if expr.type == ASTNodeType.AST_STRUCT_INIT {
        const struct_name: &byte = get_safe_c_identifier(codegen, expr.struct_init_struct_name);
        const field_count: i32 = expr.struct_init_field_count;
        fprintf(codegen.output as *void, "(struct %s){" as *byte, struct_name as *byte);
        var i: i32 = 0;
        while i < field_count {
            const safe_field_name: &byte = get_safe_c_identifier(codegen, expr.struct_init_field_names[i]);
            fprintf(codegen.output as *void, ".%s = " as *byte, safe_field_name as *byte);
            gen_expr(codegen, expr.struct_init_field_values[i]);
            if i < field_count - 1 {
                fputs(", " as *byte, codegen.output as *void);
            }
            i = i + 1;
        }
        fputc(125, codegen.output as *void);  // '}'
    } else if expr.type == ASTNodeType.AST_ARRAY_LITERAL {
        const element_count: i32 = expr.array_literal_element_count;
        const repeat_count_expr: &ASTNode = expr.array_literal_repeat_count_expr;
        fputc(123, codegen.output as *void);  // '{'
        if repeat_count_expr != null && element_count >= 1 {
            var nn: i32 = eval_const_expr(codegen, repeat_count_expr);
            if nn <= 0 {
                nn = 1;
            }
            var i: i32 = 0;
            while i < nn {
                gen_expr(codegen, expr.array_literal_elements[0]);
                if i < nn - 1 {
                    fputs(", " as *byte, codegen.output as *void);
                }
                i = i + 1;
            }
        } else {
            var i: i32 = 0;
            while i < element_count {
                gen_expr(codegen, expr.array_literal_elements[i]);
                if i < element_count - 1 {
                    fputs(", " as *byte, codegen.output as *void);
                }
                i = i + 1;
            }
        }
        fputc(125, codegen.output as *void);  // '}'
    } else if expr.type == ASTNodeType.AST_TUPLE_LITERAL {
        // 元组字面量 (e0, e1, ...) -> (struct { T0 f0; T1 f1; }){ .f0 = e0, .f1 = e1 }
        const elements: & & ASTNode = expr.tuple_literal_elements;
        const n: i32 = expr.tuple_literal_element_count;
        if n <= 0 || elements == null {
            fputs("(struct { int32_t f0; }){ .f0 = 0 }" as *byte, codegen.output as *void);
        } else {
            var total_len: i32 = 64;
            var i: i32 = 0;
            while i < n {
                const et: &byte = get_c_type_of_expr(codegen, elements[i]);
                total_len = total_len + strlen(et as *byte) + 24;
                i = i + 1;
            }
            const type_buf: &byte = arena_alloc(codegen.arena, total_len) as &byte;
            if type_buf == null {
                fputs("(struct { int32_t f0; }){ .f0 = 0 }" as *byte, codegen.output as *void);
            } else {
                var off: i32 = 0;
                off = off + snprintf(type_buf as *byte + off, total_len - off, "struct { " as *byte);
                i = 0;
                while i < n {
                    const et: &byte = get_c_type_of_expr(codegen, elements[i]);
                    var et_str: &byte = ("int32_t" as *byte) as &byte;
                    if et != null {
                        et_str = et;
                    }
                    off = off + snprintf(type_buf as *byte + off, total_len - off, "%s f%d; " as *byte, et_str as *byte, i);
                    i = i + 1;
                }
                snprintf(type_buf as *byte + off, total_len - off, "}" as *byte);
                fprintf(codegen.output as *void, "(%s){" as *byte, type_buf as *byte);
                i = 0;
                while i < n {
                    fprintf(codegen.output as *void, ".f%d = " as *byte, i);
                    gen_expr(codegen, elements[i]);
                    if i < n - 1 {
                        fputs(", " as *byte, codegen.output as *void);
                    }
                    i = i + 1;
                }
                fputc(125, codegen.output as *void);  // '}'
            }
        }
    } else if expr.type == ASTNodeType.AST_PARAMS {
        // @params -> 当前函数参数的元组复合字面量 (struct { T0 f0; ... }){ .f0 = p0, ... }
        const cur_fn: &ASTNode = codegen.current_function_decl;
        if cur_fn == null || cur_fn.type != ASTNodeType.AST_FN_DECL || cur_fn.fn_decl_param_count <= 0 || cur_fn.fn_decl_params == null {
            fputs("(struct { int32_t f0; }){ .f0 = 0 }" as *byte, codegen.output as *void);
        } else {
            const params: & & ASTNode = cur_fn.fn_decl_params;
            const n: i32 = cur_fn.fn_decl_param_count;
            var total_len: i32 = 128;
            var i: i32 = 0;
            while i < n {
                const p: &ASTNode = params[i];
                if p != null && p.type == ASTNodeType.AST_VAR_DECL && p.var_decl_type != null {
                    total_len = total_len + 64;
                }
                i = i + 1;
            }
            const type_buf: &byte = arena_alloc(codegen.arena, total_len) as &byte;
            if type_buf == null {
                fputs("(struct { int32_t f0; }){ .f0 = 0 }" as *byte, codegen.output as *void);
            } else {
                var off: i32 = 0;
                off = off + snprintf(type_buf as *byte + off, total_len - off, "struct { " as *byte);
                i = 0;
                while i < n {
                    const p: &ASTNode = params[i];
                    var et: &byte = "int32_t" as *byte;
                    if p != null && p.type == ASTNodeType.AST_VAR_DECL && p.var_decl_type != null {
                        const etc: &byte = c99_type_to_c(codegen, p.var_decl_type);
                        if etc != null {
                            et = etc;
                        }
                    }
                    off = off + snprintf(type_buf as *byte + off, total_len - off, "%s f%d; " as *byte, et as *byte, i);
                    i = i + 1;
                }
                snprintf(type_buf as *byte + off, total_len - off, "}" as *byte);
                fprintf(codegen.output as *void, "(%s){" as *byte, type_buf as *byte);
                i = 0;
                while i < n {
                    fprintf(codegen.output as *void, ".f%d = " as *byte, i);
                    const p: &ASTNode = params[i];
                    if p != null && p.type == ASTNodeType.AST_VAR_DECL && p.var_decl_name != null {
                        const pname: &byte = get_safe_c_identifier(codegen, p.var_decl_name);
                        fprintf(codegen.output as *void, "%s" as *byte, pname as *byte);
                    } else {
                        fputs("0" as *byte, codegen.output as *void);
                    }
                    if i < n - 1 {
                        fputs(", " as *byte, codegen.output as *void);
                    }
                    i = i + 1;
                }
                fputc(125, codegen.output as *void);  // '}'
            }
        }
    } else if expr.type == ASTNodeType.AST_SIZEOF {
        const target: &ASTNode = expr.sizeof_expr_target;
        const is_type: i32 = expr.sizeof_expr_is_type;
        fputs("sizeof(" as *byte, codegen.output as *void);
        if is_type != 0 {
            // 显式检查是否是结构体类型（即使在 c99_type_to_c 中查找失败）
            if target.type == ASTNodeType.AST_TYPE_NAMED {
                const name: &byte = target.type_named_name;
                if name != null && is_c_keyword(name) == 0 {
                    // 检查是否是结构体（检查是否在表中，不管是否已定义）
                    const safe_name: &byte = get_safe_c_identifier(codegen, name);
                    if is_struct_in_table(codegen, safe_name) != 0 {
                        fprintf(codegen.output as *void, "struct %s" as *byte, safe_name as *byte);
                    } else {
                        // 如果不在表中，尝试从程序节点中查找结构体声明
                        if codegen.program_node != null {
                            const decl_count: i32 = codegen.program_node.program_decl_count;
                            var found: i32 = 0;
                            var i: i32 = 0;
                            while i < decl_count {
                                const decl: &ASTNode = codegen.program_node.program_decls[i];
                                if decl != null && decl.type == ASTNodeType.AST_STRUCT_DECL {
                                    const struct_name: &byte = decl.struct_decl_name;
                                    if struct_name != null {
                                        const safe_struct_name: &byte = get_safe_c_identifier(codegen, struct_name);
                                        if strcmp(safe_struct_name as *byte, safe_name as *byte) == 0 {
                                            fprintf(codegen.output as *void, "struct %s" as *byte, safe_name as *byte);
                                            found = 1;
                                            break;
                                        }
                                    }
                                }
                                i = i + 1;
                            }
                            if found == 0 {
                                // 不是结构体，使用默认类型转换
                                const type_c: &byte = c99_type_to_c(codegen, target);
                                fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                            }
                        } else {
                            const type_c: &byte = c99_type_to_c(codegen, target);
                            fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                        }
                    }
                } else {
                    const type_c: &byte = c99_type_to_c(codegen, target);
                    fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                }
            } else {
                const type_c: &byte = c99_type_to_c(codegen, target);
                // 检查是否是数组指针类型（包含 [数字] *，且 * 在末尾）
                const bracket: *byte = strchr(type_c as *byte, 91);  // '['
                const asterisk: *byte = strrchr(type_c as *byte, 42);  // '*' 从后往前找最后一个 *
                if bracket != null && asterisk != null && bracket < asterisk {
                    // 检查 * 是否在末尾（后面只有空格或结束）
                    const asterisk_offset: i32 = ptr_diff(asterisk, type_c as *byte);
                    var after_asterisk_offset: i32 = asterisk_offset + 1;
                    const type_c_len: i32 = strlen(type_c as *byte);
                    while after_asterisk_offset < type_c_len && type_c[after_asterisk_offset] == 32 {  // ' '
                        after_asterisk_offset = after_asterisk_offset + 1;
                    }
                    if after_asterisk_offset >= type_c_len || type_c[after_asterisk_offset] == 0 {
                        // 数组指针类型：T[N] * -> T(*)[N]
                        // 找到 ']' 的位置
                        const close_bracket: *byte = strchr(bracket, 93);  // ']'
                        if close_bracket != null {
                            const base_len: i32 = ptr_diff(bracket, type_c as *byte);
                            const array_spec_len: i32 = ptr_diff(close_bracket, bracket) + 1;
                            // 注意：Uya Mini 不支持 %.*s，需要手动处理
                            var temp_buf: [byte: 256] = [];
                            var j: i32 = 0;
                            while j < base_len && j < 255 {
                                temp_buf[j] = type_c[j];
                                j = j + 1;
                            }
                            temp_buf[j] = 0;
                            fprintf(codegen.output as *void, "%s(*)" as *byte, &temp_buf[0] as *byte);
                            // 输出数组规格
                            j = 0;
                            while j < array_spec_len && j < 255 {
                                temp_buf[j] = bracket[j];
                                j = j + 1;
                            }
                            temp_buf[j] = 0;
                            fprintf(codegen.output as *void, "%s" as *byte, &temp_buf[0] as *byte);
                        } else {
                            fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                        }
                    } else {
                        fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                    }
                } else {
                    fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                }
            }
        } else {
            // 即使 is_type = 0，也检查是否是结构体标识符（如 sizeof(Point) 中的 Point）
            if target.type == ASTNodeType.AST_IDENTIFIER || target.type == ASTNodeType.AST_TYPE_NAMED {
                var name: &byte = null;
                if target.type == ASTNodeType.AST_IDENTIFIER {
                    name = target.identifier_name;
                } else {
                    name = target.type_named_name;
                }
                if name != null && is_c_keyword(name) == 0 {
                    const safe_name: &byte = get_safe_c_identifier(codegen, name);
                    if is_struct_in_table(codegen, safe_name) != 0 {
                        fprintf(codegen.output as *void, "struct %s" as *byte, safe_name as *byte);
                    } else {
                        var is_enum: i32 = is_enum_in_table(codegen, safe_name);
                        if is_enum == 0 && find_enum_decl_c99(codegen, safe_name) != null {
                            is_enum = 1;
                        }
                        if is_enum != 0 {
                            fprintf(codegen.output as *void, "enum %s" as *byte, safe_name as *byte);
                        } else {
                            gen_expr(codegen, target);
                        }
                    }
                } else {
                    gen_expr(codegen, target);
                }
            } else {
                gen_expr(codegen, target);
            }
        }
        fputc(41, codegen.output as *void);  // ')'
    } else if expr.type == ASTNodeType.AST_LEN {
        const array: &ASTNode = expr.len_expr_array;
        
        if array.type == ASTNodeType.AST_SLICE_EXPR {
            fputc(40, codegen.output as *void);
            gen_expr(codegen, array);
            fputs(").len" as *byte, codegen.output as *void);
            return;
        }
        if array.type == ASTNodeType.AST_MEMBER_ACCESS {
            const type_c: &byte = get_c_type_of_expr(codegen, array);
            if type_c != null && strstr(type_c as *byte, "uya_slice_" as *byte) != null {
                gen_expr(codegen, array);
                fputs(".len" as *byte, codegen.output as *void);
                return;
            }
        }
        if array.type == ASTNodeType.AST_IDENTIFIER {
            const type_c: &byte = get_identifier_type_c(codegen, array.identifier_name);
            if type_c != null && strstr(type_c as *byte, "uya_slice_" as *byte) != null {
                gen_expr(codegen, array);
                fputs(".len" as *byte, codegen.output as *void);
                return;
            }
        }
        
        // 检查数组表达式是否是标识符（局部变量或参数）
        if array.type == ASTNodeType.AST_IDENTIFIER {
            const var_name: &byte = array.identifier_name;
            
            // 查找变量类型以确定数组大小
            var found: i32 = 0;
            var array_size: i32 = -1;
            
            // 检查局部变量
            var i: i32 = codegen.local_variable_count - 1;
            while i >= 0 {
                if strcmp(codegen.local_variables[i].name as *byte, var_name as *byte) == 0 {
                    const type_c: &byte = codegen.local_variables[i].type_c;
                    if type_c != null {
                        // 从类型字符串中提取数组大小，格式如 "int32_t[3]"
                        const bracket: *byte = strchr(type_c as *byte, 91);  // '['
                        if bracket != null {
                            const bracket_offset: i32 = ptr_diff(bracket, type_c as *byte);
                            const close_bracket: *byte = strchr(&type_c[bracket_offset + 1] as *byte, 93);  // ']'
                            if close_bracket != null {
                                // 提取数字部分
                                const num_len: i32 = ptr_diff(close_bracket, bracket) - 1;
                                var num_buf: [byte: 32] = [];
                                if num_len < 32 && num_len > 0 {
                                    memcpy(&num_buf[0] as *void, &type_c[bracket_offset + 1] as *void, num_len);
                                    num_buf[num_len] = 0;
                                    array_size = atoi(&num_buf[0] as *byte);
                                    if array_size > 0 {
                                        fprintf(codegen.output as *void, "%d" as *byte, array_size);
                                        found = 1;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    break;
                }
                i = i - 1;
            }
            
            // 如果找到数组大小，直接输出
            if found != 0 {
                return;
            }
        }
        
        // 备用方案：使用 sizeof 计算（适用于非参数数组）
        // 注意：这只适用于栈分配的数组，不适用于函数参数
        fputs("sizeof(" as *byte, codegen.output as *void);
        gen_expr(codegen, array);
        fputs(") / sizeof((" as *byte, codegen.output as *void);
        gen_expr(codegen, array);
        fputs(")[0])" as *byte, codegen.output as *void);
    } else if expr.type == ASTNodeType.AST_ALIGNOF {
        const target: &ASTNode = expr.alignof_expr_target;
        const is_type: i32 = expr.alignof_expr_is_type;
        
        // 获取类型字符串
        var type_c: &byte = null;
        if is_type != 0 {
            type_c = c99_type_to_c(codegen, target);
        } else {
            // 即使 is_type = 0，也检查是否是类型标识符（如 alignof(usize) 中的 usize）
            if target.type == ASTNodeType.AST_IDENTIFIER {
                const name: &byte = target.identifier_name;
                if name != null && is_c_keyword(name) == 0 {
                    const safe_name: &byte = get_safe_c_identifier(codegen, name);
                    if is_struct_in_table(codegen, safe_name) != 0 {
                        // 结构体类型
                        const str_len: i32 = strlen(safe_name as *byte) + 8;  // "struct " + name + '\0'
                        const buf: &byte = arena_alloc(codegen.arena, str_len) as &byte;
                        if buf != null {
                            snprintf(buf as *byte, str_len, "struct %s" as *byte, safe_name as *byte);
                            type_c = buf;
                        }
                    } else {
                        // 对于变量名，需要获取变量的类型（从局部/全局变量表查找）
                        type_c = get_identifier_type_c(codegen, safe_name);
                        if type_c == null {
                            // 如果找不到，可能是类型名（如 alignof(usize)）
                            type_c = c99_type_to_c(codegen, target);
                        }
                    }
                } else {
                    type_c = c99_type_to_c(codegen, target);
                }
            } else {
                // 其他表达式类型：尝试从变量表查找（如成员访问的基变量）
                type_c = c99_type_to_c(codegen, target);
            }
        }
        
        if type_c == null {
            type_c = ("void" as *byte) as &byte;
        }
        
        // void 类型不能用于 uya_alignof 宏（struct { char c; void t; } 非法），直接输出 1
        if strcmp(type_c as *byte, "void" as *byte) == 0 {
            fputs("1" as *byte, codegen.output as *void);
            return;
        }
        
        // 检查类型是否是数组类型（包含 '['）
        const bracket: *byte = strchr(type_c as *byte, 91);  // '['
        if bracket != null {
            // 数组类型：提取元素类型（数组的对齐值等于元素类型的对齐值）
            const elem_len: i32 = ptr_diff(bracket, type_c as *byte);
            const elem_type: &byte = arena_alloc(codegen.arena, elem_len + 1) as &byte;
            if elem_type != null {
                memcpy(elem_type as *void, type_c as *void, elem_len);
                elem_type[elem_len] = 0;
                // 移除可能的 const 限定符（如果存在）
                if strncmp(elem_type as *byte, "const " as *byte, 6) == 0 {
                    fputs("uya_alignof(" as *byte, codegen.output as *void);
                    fprintf(codegen.output as *void, "%s" as *byte, &elem_type[6] as *byte);
                    fputc(41, codegen.output as *void);  // ')'
                } else {
                    fputs("uya_alignof(" as *byte, codegen.output as *void);
                    fprintf(codegen.output as *void, "%s" as *byte, elem_type as *byte);
                    fputc(41, codegen.output as *void);  // ')'
                }
            } else {
                // 分配失败，回退到原始类型（会失败，但至少不会崩溃）
                fputs("uya_alignof(" as *byte, codegen.output as *void);
                fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                fputc(41, codegen.output as *void);  // ')'
            }
        } else {
            // 非数组类型：直接使用
            fputs("uya_alignof(" as *byte, codegen.output as *void);
            fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
            fputc(41, codegen.output as *void);  // ')'
        }
    } else if expr.type == ASTNodeType.AST_CAST_EXPR {
        const src_expr: &ASTNode = expr.cast_expr_expr;
        const target_type: &ASTNode = expr.cast_expr_target_type;
        const is_force_cast: i32 = expr.cast_expr_is_force_cast;
        const type_c: &byte = c99_type_to_c(codegen, target_type);
        if is_force_cast != 0 {
            // as! 强转：返回 !T，包装为 { .error_id = 0, .value = (T)(expr) }
            const tmp: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_ERROR_UNION, 0, 0, codegen.arena, null);
            var union_c: &byte = "void" as &byte;
            if tmp != null {
                tmp.type_error_union_payload_type = target_type;
                union_c = c99_type_to_c(codegen, tmp);
            }
            var is_void: i32 = 0;
            if target_type != null && target_type.type == ASTNodeType.AST_TYPE_NAMED && target_type.type_named_name != null && strcmp(target_type.type_named_name as *byte, "void" as *byte) == 0 {
                is_void = 1;
            }
            fprintf(codegen.output as *void, "({ %s _uya_asbang = { .error_id = 0" as *byte, union_c as *byte);
            if is_void == 0 {
                fprintf(codegen.output as *void, ", .value = (%s)(" as *byte, type_c as *byte);
                gen_expr(codegen, src_expr);
                fputs(") }; _uya_asbang; })" as *byte, codegen.output as *void);
            } else {
                fputs(" }; " as *byte, codegen.output as *void);
                gen_expr(codegen, src_expr);
                fputs("; _uya_asbang; })" as *byte, codegen.output as *void);
            }
        } else {
            fputc(40, codegen.output as *void);  // '('
            fprintf(codegen.output as *void, "%s)" as *byte, type_c as *byte);
            gen_expr(codegen, src_expr);
        }
    } else if expr.type == ASTNodeType.AST_IDENTIFIER {
        const name: &byte = expr.identifier_name;
        if name != null && strcmp(name as *byte, "null" as *byte) == 0 {
            fputs("NULL" as *byte, codegen.output as *void);
        } else {
            const safe_name: &byte = get_safe_c_identifier(codegen, name);
            fprintf(codegen.output as *void, "%s" as *byte, safe_name as *byte);
        }
    } else if expr.type == ASTNodeType.AST_CALL_EXPR {
        const callee: &ASTNode = expr.call_expr_callee;
        const args: & & ASTNode = expr.call_expr_args;
        const arg_count: i32 = expr.call_expr_arg_count;
        const has_ellipsis: i32 = expr.call_expr_has_ellipsis_forward;
        var callee_name: &byte = null;
        if callee != null && callee.type == ASTNodeType.AST_IDENTIFIER {
            callee_name = callee.identifier_name;
        }

        // 插值仅作 printf/fprintf 格式参数时：脱糖为单次 printf(fmt, ...)，无中间缓冲
        if callee_name != null && args != null && has_ellipsis == 0 {
            if strcmp(callee_name as *byte, "printf" as *byte) == 0 && arg_count == 1 && args[0] != null && args[0].type == ASTNodeType.AST_STRING_INTERP {
                const interp: &ASTNode = args[0];
                const safe: &byte = get_safe_c_identifier(codegen, "printf" as &byte);
                fprintf(codegen.output as *void, "%s(" as *byte, safe as *byte);
                emit_printf_fmt_inline(codegen, interp);
                var i: i32 = 0;
                while i < interp.string_interp_segment_count {
                    const seg: &ASTStringInterpSegment = &interp.string_interp_segments[i];
                    if seg.is_text == 0 && seg.expr != null {
                        fputs(", " as *byte, codegen.output as *void);
                        gen_expr(codegen, seg.expr);
                    }
                    i = i + 1;
                }
                fputc(41, codegen.output as *void);
                return;
            } else if strcmp(callee_name as *byte, "fprintf" as *byte) == 0 && arg_count == 2 && args[1] != null && args[1].type == ASTNodeType.AST_STRING_INTERP {
                const interp: &ASTNode = args[1];
                const safe: &byte = get_safe_c_identifier(codegen, "fprintf" as &byte);
                fprintf(codegen.output as *void, "%s(" as *byte, safe as *byte);
                gen_expr(codegen, args[0]);
                fputs(", " as *byte, codegen.output as *void);
                emit_printf_fmt_inline(codegen, interp);
                var i: i32 = 0;
                while i < interp.string_interp_segment_count {
                    const seg: &ASTStringInterpSegment = &interp.string_interp_segments[i];
                    if seg.is_text == 0 && seg.expr != null {
                        fputs(", " as *byte, codegen.output as *void);
                        gen_expr(codegen, seg.expr);
                    }
                    i = i + 1;
                }
                fputc(41, codegen.output as *void);
                return;
            }
        }

        // 查找函数声明（用于检查参数类型）
        var fn_decl: &ASTNode = null;
        if callee != null && callee.type == ASTNodeType.AST_IDENTIFIER {
            fn_decl = find_function_decl_c99(codegen, callee_name);
        }
        
        // 无 ... 转发的调用不生成 va_list（零开销转发）
        var do_va_forward: i32 = 0;
        if has_ellipsis != 0 && codegen.current_function_decl != null &&
            codegen.current_function_decl.type == ASTNodeType.AST_FN_DECL &&
            codegen.current_function_decl.fn_decl_is_varargs != 0 &&
            codegen.current_function_decl.fn_decl_param_count > 0 &&
            callee_name != null {
            do_va_forward = 1;
        }
        var vname: &byte = null;
        var last_param: &byte = null;
        if do_va_forward != 0 {
            vname = get_vprintf_style_name(callee_name);
            const cur_fn: &ASTNode = codegen.current_function_decl;
            const last_p: &ASTNode = cur_fn.fn_decl_params[cur_fn.fn_decl_param_count - 1];
            if last_p != null && last_p.type == ASTNodeType.AST_VAR_DECL {
                last_param = last_p.var_decl_name;
            }
        }
        var arg_idx: i32 = 0;
        while arg_idx < arg_count && arg_idx < C99_MAX_CALL_ARGS {
            codegen.interp_arg_temp_names[arg_idx] = null;
            arg_idx = arg_idx + 1;
        }
        arg_idx = 0;
        while arg_idx < arg_count && arg_idx < C99_MAX_CALL_ARGS {
            const arg: &ASTNode = expr.call_expr_args[arg_idx];
            if arg != null && arg.type == ASTNodeType.AST_STRING_INTERP && arg.string_interp_computed_size > 0 {
                var name_buf: [byte: 64] = [];
                snprintf(&name_buf[0] as *byte, 64, "__uya_interp_%d" as *byte, codegen.interp_temp_counter);
                codegen.interp_temp_counter = codegen.interp_temp_counter + 1;
                const temp_name: &byte = c99_arena_strdup(codegen.arena, &name_buf[0] as &byte);
                if temp_name != null {
                    codegen.interp_arg_temp_names[arg_idx] = temp_name;
                    c99_emit_indent(codegen);
                    fprintf(codegen.output as *void, "char %s[%d];\n" as *byte, temp_name as *byte, arg.string_interp_computed_size);
                    c99_emit_string_interp_fill(codegen, arg, temp_name);
                }
            }
            arg_idx = arg_idx + 1;
        }
        var did_interface_call: i32 = 0;
        // 联合体变体构造：UnionName.variant(expr) -> (struct uya_tagged_UnionName){ ._tag = index, .u = (union UnionName){ .variant = (expr) } }
        if callee != null && callee.type == ASTNodeType.AST_MEMBER_ACCESS {
            const obj: &ASTNode = callee.member_access_object;
            const method_name: &byte = callee.member_access_field_name;
            if obj != null && obj.type == ASTNodeType.AST_IDENTIFIER && obj.identifier_name != null && arg_count == 1 && expr.call_expr_args != null && expr.call_expr_args[0] != null {
                const union_decl: &ASTNode = find_union_decl_c99(codegen, obj.identifier_name);
                if union_decl != null {
                    const idx: i32 = find_union_variant_index(union_decl, method_name);
                    if idx >= 0 {
                        const uname: &byte = get_safe_c_identifier(codegen, union_decl.union_decl_name);
                        const vname_c: &byte = get_safe_c_identifier(codegen, method_name);
                        if uname != null && vname_c != null {
                            if union_decl.union_decl_is_extern != 0 {
                                fprintf(codegen.output as *void, "((union %s){ .%s = (" as *byte, uname as *byte, vname_c as *byte);
                                gen_expr(codegen, expr.call_expr_args[0]);
                                fputs(") })" as *byte, codegen.output as *void);
                            } else {
                                fprintf(codegen.output as *void, "((struct uya_tagged_%s){ ._tag = %d, .u = (union %s){ .%s = (" as *byte, uname as *byte, idx, uname as *byte, vname_c as *byte);
                                gen_expr(codegen, expr.call_expr_args[0]);
                                fputs(") } })" as *byte, codegen.output as *void);
                            }
                            return;
                        }
                    }
                }
            }
            const obj_type_c: &byte = get_c_type_of_expr(codegen, obj);
            if obj_type_c != null && strstr(obj_type_c as *byte, "uya_interface_" as *byte) != null {
                const p: *byte = strstr(obj_type_c as *byte, "uya_interface_" as *byte);
                const iface_start: &byte = &p[14] as &byte;
                const safe_method: &byte = get_safe_c_identifier(codegen, method_name);
                fprintf(codegen.output as *void, "((struct uya_vtable_%s *)(" as *byte, iface_start as *byte);
                gen_expr(codegen, obj);
                fprintf(codegen.output as *void, ").vtable)->%s((" as *byte, safe_method as *byte);
                gen_expr(codegen, obj);
                fputs(").data" as *byte, codegen.output as *void);
                var i: i32 = 0;
                while i < arg_count {
                    fputs(", " as *byte, codegen.output as *void);
                    if codegen.interp_arg_temp_names[i] != null {
                        fputs("(uint8_t *)" as *byte, codegen.output as *void);
                        fputs(codegen.interp_arg_temp_names[i] as *byte, codegen.output as *void);
                    } else {
                        if expr.call_expr_args[i] != null && expr.call_expr_args[i].type == ASTNodeType.AST_STRING {
                            fputs("(uint8_t *)" as *byte, codegen.output as *void);
                        }
                        gen_expr(codegen, expr.call_expr_args[i]);
                    }
                    i = i + 1;
                }
                fputc(41, codegen.output as *void);
                did_interface_call = 1;
            } else if obj_type_c != null && strstr(obj_type_c as *byte, "uya_interface_" as *byte) == null {
                var base: *byte = obj_type_c as *byte;
                if strncmp(base, "const " as *byte, 6) == 0 { base = base + 6; }
                if strncmp(base, "struct " as *byte, 7) == 0 {
                    const start: *byte = base + 7;
                    var end: *byte = strchr(start, 32);
                    if end == null { end = start + strlen(start); }
                    const asterisk: *byte = strchr(start, 42);
                    if asterisk != null && asterisk < end { end = asterisk; }
                    while end > start && ((end - 1)[0] == 32 || (end - 1)[0] == 9) { end = end - 1; }
                    if end > start {
                        var struct_name_buf: [byte: 128] = [];
                        const slen: i32 = (end - start) as i32;
                        if slen > 0 && slen < 128 {
                            var k: i32 = 0;
                            while k < slen {
                                struct_name_buf[k] = start[k];
                                k = k + 1;
                            }
                            struct_name_buf[slen] = 0;
                            const union_decl: &ASTNode = find_union_decl_by_tagged_c99(codegen, &struct_name_buf[0]);
                            if union_decl != null {
                                const method_fn: &ASTNode = find_method_in_union_c99(codegen, union_decl.union_decl_name, method_name);
                                if method_fn != null {
                                    const cname: &byte = get_method_c_name(codegen, union_decl.union_decl_name, method_name);
                                    if cname != null {
                                        var prefix: &byte = "&" as *byte;
                                        if strchr(obj_type_c as *byte, 42) != null { prefix = "" as *byte; }
                                        fprintf(codegen.output as *void, "%s(%s(" as *byte, cname as *byte, prefix);
                                        gen_expr(codegen, obj);
                                        fputs(")" as *byte, codegen.output as *void);
                                        var i: i32 = 0;
                                        while i < arg_count {
                                            fputs(", " as *byte, codegen.output as *void);
                                            if codegen.interp_arg_temp_names[i] != null {
                                                fputs("(uint8_t *)" as *byte, codegen.output as *void);
                                                fputs(codegen.interp_arg_temp_names[i] as *byte, codegen.output as *void);
                                            } else {
                                                if expr.call_expr_args[i] != null && expr.call_expr_args[i].type == ASTNodeType.AST_STRING {
                                                    fputs("(uint8_t *)" as *byte, codegen.output as *void);
                                                }
                                                gen_expr(codegen, expr.call_expr_args[i]);
                                            }
                                            i = i + 1;
                                        }
                                        fputc(41, codegen.output as *void);
                                        did_interface_call = 1;
                                    }
                                }
                            }
                            if did_interface_call == 0 {
                                const method_fn: &ASTNode = find_method_in_struct_c99(codegen, &struct_name_buf[0], method_name);
                                if method_fn != null {
                                    const cname: &byte = get_method_c_name(codegen, &struct_name_buf[0], method_name);
                                    if cname != null {
                                        var prefix: &byte = "&" as *byte;
                                        if strchr(obj_type_c as *byte, 42) != null { prefix = "" as *byte; }
                                        fprintf(codegen.output as *void, "%s(%s(" as *byte, cname as *byte, prefix);
                                        gen_expr(codegen, obj);
                                        fputs(")" as *byte, codegen.output as *void);
                                        var i: i32 = 0;
                                        while i < arg_count {
                                            fputs(", " as *byte, codegen.output as *void);
                                            if codegen.interp_arg_temp_names[i] != null {
                                                fputs("(uint8_t *)" as *byte, codegen.output as *void);
                                                fputs(codegen.interp_arg_temp_names[i] as *byte, codegen.output as *void);
                                            } else {
                                                if expr.call_expr_args[i] != null && expr.call_expr_args[i].type == ASTNodeType.AST_STRING {
                                                    fputs("(uint8_t *)" as *byte, codegen.output as *void);
                                                }
                                                gen_expr(codegen, expr.call_expr_args[i]);
                                            }
                                            i = i + 1;
                                        }
                                        fputc(41, codegen.output as *void);
                                        did_interface_call = 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if did_interface_call == 0 {
        if do_va_forward != 0 && vname != null && last_param != null {
            const last_safe: &byte = get_safe_c_identifier(codegen, last_param);
            c99_emit(codegen, "((void)0, ({\n" as *byte);
            codegen.indent_level = codegen.indent_level + 1;
            c99_emit(codegen, "va_list uya_va;\n" as *byte);
            c99_emit_indent(codegen);
            fprintf(codegen.output as *void, "va_start(uya_va, %s);\n" as *byte, last_safe as *byte);
            fprintf(codegen.output as *void, "%*sint32_t _uya_ret = %s(" as *byte, codegen.indent_level * 4, "" as *byte, vname as *byte);
            var i: i32 = 0;
            while i < arg_count {
                if i > 0 {
                    fputs(", " as *byte, codegen.output as *void);
                }
                if codegen.interp_arg_temp_names[i] != null {
                    fputs("(uint8_t *)" as *byte, codegen.output as *void);
                    fputs(codegen.interp_arg_temp_names[i] as *byte, codegen.output as *void);
                } else {
                    if expr.call_expr_args[i] != null && expr.call_expr_args[i].type == ASTNodeType.AST_STRING {
                        fputs("(uint8_t *)" as *byte, codegen.output as *void);
                    }
                    gen_expr(codegen, expr.call_expr_args[i]);
                }
                i = i + 1;
            }
            fputs(", uya_va);\n" as *byte, codegen.output as *void);
            c99_emit(codegen, "va_end(uya_va);\n" as *byte);
            c99_emit(codegen, "_uya_ret;\n" as *byte);
            codegen.indent_level = codegen.indent_level - 1;
            c99_emit(codegen, "}))" as *byte);
        } else {
            // 生成被调用函数名
            if callee != null && callee.type == ASTNodeType.AST_IDENTIFIER {
                const func_name: &byte = callee.identifier_name;
                const safe_name: &byte = get_safe_c_identifier(codegen, func_name);
                fprintf(codegen.output as *void, "%s(" as *byte, safe_name as *byte);
                // 单参数 printf 用字面量格式避免 -Wformat-security
                if callee_name != null && strcmp(callee_name as *byte, "printf" as *byte) == 0 && arg_count == 1 {
                    fputs("\"%s\", " as *byte, codegen.output as *void);
                }
            } else {
                fputs("unknown(" as *byte, codegen.output as *void);
            }
            
            // 生成参数
            var i: i32 = 0;
            while i < arg_count {
            if codegen.interp_arg_temp_names[i] != null {
                fputs("(uint8_t *)" as *byte, codegen.output as *void);
                fputs(codegen.interp_arg_temp_names[i] as *byte, codegen.output as *void);
            } else {
            // 检查参数是否是字符串常量，如果是则添加类型转换以消除 const 警告
            var is_string_arg: i32 = 0;
            if expr.call_expr_args[i] != null && expr.call_expr_args[i].type == ASTNodeType.AST_STRING {
                is_string_arg = 1;
            }
            if is_string_arg != 0 {
                fputs("(uint8_t *)" as *byte, codegen.output as *void);
            }
            
            // 检查是否是大结构体参数且函数期望指针
            // 对于 extern 函数，如果参数类型是大结构体（>16字节），则传递地址
            var need_address: i32 = 0;
            if fn_decl != null && fn_decl.type == ASTNodeType.AST_FN_DECL {
                const body: &ASTNode = fn_decl.fn_decl_body;
                var is_extern: i32 = 0;
                if body == null {
                    is_extern = 1;
                }
                
                if is_extern != 0 && expr.call_expr_args[i] != null && i < fn_decl.fn_decl_param_count {
                    const param: &ASTNode = fn_decl.fn_decl_params[i];
                    if param != null && param.type == ASTNodeType.AST_VAR_DECL {
                        const param_type: &ASTNode = param.var_decl_type;
                        if param_type != null && param_type.type == ASTNodeType.AST_TYPE_NAMED {
                            const struct_size: i32 = calculate_struct_size(codegen, param_type);
                            if struct_size > 16 {
                                // 函数期望指针，需要传递地址
                                need_address = 1;
                            }
                        }
                    }
                }
            }
            
            if need_address != 0 {
                fputc(38, codegen.output as *void);  // '&'
            }
            // 装箱：当形参是接口类型且实参是实现了该接口的结构体时，生成 vtable+data
            var did_box: i32 = 0;
            if fn_decl != null && fn_decl.type == ASTNodeType.AST_FN_DECL && i < fn_decl.fn_decl_param_count {
                const param: &ASTNode = fn_decl.fn_decl_params[i];
                if param != null && param.type == ASTNodeType.AST_VAR_DECL && param.var_decl_type != null &&
                    param.var_decl_type.type == ASTNodeType.AST_TYPE_NAMED {
                    const param_type_name: &byte = param.var_decl_type.type_named_name;
                    const iface: &ASTNode = find_interface_decl_c99(codegen, param_type_name);
                    if iface != null && expr.call_expr_args[i] != null {
                        var struct_name_for_check: &byte = null;
                        const arg: &ASTNode = expr.call_expr_args[i];
                        if arg.type == ASTNodeType.AST_IDENTIFIER {
                            const arg_type_c: &byte = get_identifier_type_c(codegen, arg.identifier_name);
                            if arg_type_c != null {
                                var atc: &byte = arg_type_c;
                                if strncmp(atc as *byte, "const " as *byte, 6) == 0 {
                                    atc = &arg_type_c[6] as &byte;
                                }
                                if strncmp(atc as *byte, "struct " as *byte, 7) == 0 &&
                                    strstr(atc as *byte, "uya_interface_" as *byte) == null {
                                    var snbuf: [byte: 64] = [];
                                    const start: &byte = &atc[7] as &byte;
                                    var pos: i32 = 0;
                                    while start[pos] != 0 && start[pos] != 32 && start[pos] != 42 && pos < 63 {
                                        snbuf[pos] = start[pos];
                                        pos = pos + 1;
                                    }
                                    snbuf[pos] = 0;
                                    if pos > 0 && struct_implements_interface_c99(codegen, &snbuf[0] as &byte, param_type_name) != 0 {
                                        struct_name_for_check = &snbuf[0] as &byte;
                                    }
                                }
                            }
                        } else if arg.type == ASTNodeType.AST_STRUCT_INIT {
                            const st_name: &byte = arg.struct_init_struct_name;
                            if st_name != null && struct_implements_interface_c99(codegen, st_name, param_type_name) != 0 {
                                struct_name_for_check = st_name;
                            }
                        }
                        if struct_name_for_check != null {
                            const safe_iface: &byte = get_safe_c_identifier(codegen, param_type_name);
                            const safe_struct: &byte = get_safe_c_identifier(codegen, struct_name_for_check);
                            fprintf(codegen.output as *void, "(struct uya_interface_%s){ .vtable = (void*)&uya_vtable_%s_%s, .data = (void*)&(" as *byte,
                                    safe_iface as *byte, safe_iface as *byte, safe_struct as *byte);
                            gen_expr(codegen, expr.call_expr_args[i]);
                            fputs(") }" as *byte, codegen.output as *void);
                            did_box = 1;
                        }
                    }
                }
            }
            if did_box == 0 {
            gen_expr(codegen, expr.call_expr_args[i]);
            }
            }
            if i < arg_count - 1 {
                fputs(", " as *byte, codegen.output as *void);
            }
            i = i + 1;
        }
        fputc(41, codegen.output as *void);  // ')'
        }
        }
    } else if expr.type == ASTNodeType.AST_ASSIGN {
        // 赋值表达式（右结合）：dest = src；dest 为 _ 时仅求值右侧
        const dest: &ASTNode = expr.assign_dest;
        const src: &ASTNode = expr.assign_src;
        
        fputc(40, codegen.output as *void);  // '('
        if dest.type == ASTNodeType.AST_UNDERSCORE {
            gen_expr(codegen, src);
        } else {
            gen_expr(codegen, dest);
            fputs(" = " as *byte, codegen.output as *void);
            gen_expr(codegen, src);
        }
        fputc(41, codegen.output as *void);  // ')'
    } else if expr.type == ASTNodeType.AST_MATCH_EXPR {
        // match expr { pat => result, ... } 作为表达式：GCC 语句表达式
        const match_expr: &ASTNode = expr.match_expr_expr;
        var m_type: &byte = get_c_type_of_expr(codegen, match_expr);
        if m_type == null {
            m_type = "int32_t" as &byte;
        }
        var res_type: &byte = "int32_t" as &byte;
        if expr.match_expr_arm_count > 0 {
            const t: &byte = get_c_type_of_expr(codegen, expr.match_expr_arms[0].result_expr);
            if t != null {
                res_type = t;
            }
        }
        fputs("({ " as *byte, codegen.output as *void);
        fprintf(codegen.output as *void, "%s _uya_m = " as *byte, m_type as *byte);
        gen_expr(codegen, match_expr);
        fputs("; " as *byte, codegen.output as *void);
        fprintf(codegen.output as *void, "%s _uya_r; " as *byte, res_type as *byte);
        var first: i32 = 1;
        var i: i32 = 0;
        while i < expr.match_expr_arm_count {
            var prefix: &byte = "else " as &byte;
            if first != 0 {
                prefix = "" as &byte;
                first = 0;
            }
            if expr.match_expr_arms[i].kind == MatchPatternKind.MATCH_PAT_LITERAL {
                if expr.match_expr_arms[i].literal_is_bool != 0 {
                    if expr.match_expr_arms[i].literal_int_value != 0 {
                        fprintf(codegen.output as *void, "%sif (_uya_m == 1) _uya_r = " as *byte, prefix as *byte);
                    } else {
                        fprintf(codegen.output as *void, "%sif (_uya_m == 0) _uya_r = " as *byte, prefix as *byte);
                    }
                } else {
                    fprintf(codegen.output as *void, "%sif (_uya_m == %d) _uya_r = " as *byte, prefix as *byte, expr.match_expr_arms[i].literal_int_value);
                }
                gen_expr(codegen, expr.match_expr_arms[i].result_expr);
                fputs("; " as *byte, codegen.output as *void);
            } else if expr.match_expr_arms[i].kind == MatchPatternKind.MATCH_PAT_UNION && expr.match_expr_arms[i].variant_name != null {
                const union_decl: &ASTNode = find_union_decl_by_variant_c99(codegen, expr.match_expr_arms[i].variant_name);
                if union_decl != null {
                    const idx: i32 = find_union_variant_index(union_decl, expr.match_expr_arms[i].variant_name);
                    const uname: &byte = get_safe_c_identifier(codegen, union_decl.union_decl_name);
                    const vname: &byte = get_safe_c_identifier(codegen, expr.match_expr_arms[i].variant_name);
                    if idx >= 0 && uname != null && vname != null {
                        const vnode: &ASTNode = union_decl.union_decl_variants[idx];
                        var vtype: &byte = "int" as &byte;
                        if vnode != null && vnode.type == ASTNodeType.AST_VAR_DECL && vnode.var_decl_type != null {
                            vtype = c99_type_to_c(codegen, vnode.var_decl_type);
                        }
                        var bind: &byte = null;
                        if expr.match_expr_arms[i].var_name != null && strcmp(expr.match_expr_arms[i].var_name as *byte, "_" as *byte) != 0 {
                            bind = get_safe_c_identifier(codegen, expr.match_expr_arms[i].var_name);
                        }
                        if bind != null {
                            fprintf(codegen.output as *void, "%sif (_uya_m._tag == %d) { %s %s = _uya_m.u.%s; _uya_r = " as *byte, prefix as *byte, idx, vtype as *byte, bind as *byte, vname as *byte);
                        } else {
                            fprintf(codegen.output as *void, "%sif (_uya_m._tag == %d) _uya_r = " as *byte, prefix as *byte, idx);
                        }
                        gen_expr(codegen, expr.match_expr_arms[i].result_expr);
                        if bind != null {
                            fputs("; } " as *byte, codegen.output as *void);
                        } else {
                            fputs("; " as *byte, codegen.output as *void);
                        }
                    }
                }
            } else if expr.match_expr_arms[i].kind == MatchPatternKind.MATCH_PAT_ENUM {
                const enum_decl: &ASTNode = find_enum_decl_c99(codegen, expr.match_expr_arms[i].enum_name);
                var ev: i32 = -1;
                if enum_decl != null {
                    ev = find_enum_variant_value(codegen, enum_decl, expr.match_expr_arms[i].variant_name);
                }
                if ev >= 0 {
                    fprintf(codegen.output as *void, "%sif (_uya_m == %d) _uya_r = " as *byte, prefix as *byte, ev);
                } else {
                    fprintf(codegen.output as *void, "%sif (0) _uya_r = " as *byte, prefix as *byte);
                }
                gen_expr(codegen, expr.match_expr_arms[i].result_expr);
                fputs("; " as *byte, codegen.output as *void);
            } else if expr.match_expr_arms[i].kind == MatchPatternKind.MATCH_PAT_BIND {
                const v: &byte = get_safe_c_identifier(codegen, expr.match_expr_arms[i].var_name);
                if v != null {
                    fprintf(codegen.output as *void, "%s{ %s %s = _uya_m; _uya_r = " as *byte, prefix as *byte, m_type as *byte, v as *byte);
                }
                gen_expr(codegen, expr.match_expr_arms[i].result_expr);
                if v != null {
                    fputs("; } " as *byte, codegen.output as *void);
                } else {
                    fputs("; " as *byte, codegen.output as *void);
                }
            } else if expr.match_expr_arms[i].kind == MatchPatternKind.MATCH_PAT_WILDCARD || expr.match_expr_arms[i].kind == MatchPatternKind.MATCH_PAT_ELSE {
                fprintf(codegen.output as *void, "%s{ _uya_r = " as *byte, prefix as *byte);
                gen_expr(codegen, expr.match_expr_arms[i].result_expr);
                fputs("; } " as *byte, codegen.output as *void);
            } else if expr.match_expr_arms[i].kind == MatchPatternKind.MATCH_PAT_ERROR {
                var id: i32 = c99_get_or_add_error_id(codegen, expr.match_expr_arms[i].error_name);
                if id == 0 {
                    id = 1;
                }
                fprintf(codegen.output as *void, "%sif (_uya_m.error_id == %uU) _uya_r = " as *byte, prefix as *byte, id as u32);
                gen_expr(codegen, expr.match_expr_arms[i].result_expr);
                fputs("; " as *byte, codegen.output as *void);
            }
            i = i + 1;
        }
        fputs("_uya_r; })" as *byte, codegen.output as *void);
    } else {
        fputs("0" as *byte, codegen.output as *void);
    }
}

