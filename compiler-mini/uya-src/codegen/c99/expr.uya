// expr.uya - C99 代码生成器表达式模块
// 提供表达式代码生成功能
//
// 注意：需要先包含 internal.uya（包含类型定义和函数声明）
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 外部函数声明 =====
// C 标准库函数（在 extern_decls.uya 中声明）

fn gen_expr(codegen: &C99CodeGenerator, expr: &ASTNode) void {
    if expr == null {
        return;
    }
    
    if expr.type == AST_NUMBER {
        fprintf(codegen.output as *void, "%d" as *byte, expr.number_value);
    } else if expr.type == AST_BOOL {
        if expr.bool_literal_value != 0 {
            fputs("true" as *byte, codegen.output as *void);
        } else {
            fputs("false" as *byte, codegen.output as *void);
        }
    } else if expr.type == AST_STRING {
        const str_const: &byte = add_string_constant(codegen, expr.string_literal_value);
        if str_const != null {
            fprintf(codegen.output as *void, "%s" as *byte, str_const as *byte);
        } else {
            fputs("\"\"" as *byte, codegen.output as *void);
        }
    } else if expr.type == AST_BINARY_EXPR {
        const left: &ASTNode = expr.binary_expr_left;
        const right: &ASTNode = expr.binary_expr_right;
        const op: i32 = expr.binary_expr_op;
        
        // 检查是否是结构体比较（== 或 !=）
        var is_struct_comparison: i32 = 0;
        if (op == TOKEN_EQUAL || op == TOKEN_NOT_EQUAL) && left != null && right != null {
            // 检查左操作数是否是结构体类型
            if left.type == AST_IDENTIFIER {
                if is_identifier_struct_type(codegen, left.identifier_name) != 0 {
                    is_struct_comparison = 1;
                }
            } else if left.type == AST_STRUCT_INIT {
                is_struct_comparison = 1;
            }
        }
        
        if is_struct_comparison != 0 {
            // 解析出结构体声明，空结构体直接输出 (1)/(0)
            var struct_decl: &ASTNode = null;
            if left.type == AST_IDENTIFIER {
                const type_c: &byte = get_identifier_type_c(codegen, left.identifier_name);
                if type_c != null {
                    const struct_prefix: *byte = strstr(type_c as *byte, "struct " as *byte);
                    if struct_prefix != null {
                        const name_start: &byte = (struct_prefix + 7) as &byte;
                        struct_decl = find_struct_decl_c99(codegen, name_start);
                    }
                }
            } else if left.type == AST_STRUCT_INIT {
                struct_decl = find_struct_decl_c99(codegen, left.struct_init_struct_name);
            }
            if struct_decl != null && struct_decl.struct_decl_field_count == 0 {
                if op == TOKEN_EQUAL {
                    fputs("(1)" as *byte, codegen.output as *void);
                } else if op == TOKEN_NOT_EQUAL {
                    fputs("(0)" as *byte, codegen.output as *void);
                }
            } else if struct_decl != null && struct_decl.type == AST_STRUCT_DECL && struct_decl.struct_decl_field_count > 0 {
                // 按字段比较，与 C 编译器一致，避免 padding 未初始化导致 memcmp 结果错误
                if op == TOKEN_NOT_EQUAL {
                    fputs("(!(" as *byte, codegen.output as *void);
                } else {
                    fputc(40, codegen.output as *void);  // '('
                }
                var i: i32 = 0;
                while i < struct_decl.struct_decl_field_count {
                    const field: &ASTNode = struct_decl.struct_decl_fields[i];
                    if field != null && field.type == AST_VAR_DECL {
                        const field_type: &ASTNode = field.var_decl_type;
                        const safe_field: &byte = get_safe_c_identifier(codegen, field.var_decl_name);
                        if safe_field != null {
                            var field_needs_memcmp: i32 = 0;
                            if field_type != null {
                                if field_type.type == AST_TYPE_NAMED {
                                    const type_name: &byte = field_type.type_named_name;
                                    if type_name != null && find_struct_decl_c99(codegen, type_name) != null {
                                        field_needs_memcmp = 1;
                                    }
                                } else if field_type.type == AST_TYPE_ARRAY {
                                    field_needs_memcmp = 1;
                                }
                            }
                            if field_needs_memcmp != 0 {
                                fputs("(memcmp(&(" as *byte, codegen.output as *void);
                                gen_expr(codegen, left);
                                fputs(")." as *byte, codegen.output as *void);
                                fputs(safe_field as *byte, codegen.output as *void);
                                fputs(", &(" as *byte, codegen.output as *void);
                                gen_expr(codegen, right);
                                fputs(")." as *byte, codegen.output as *void);
                                fputs(safe_field as *byte, codegen.output as *void);
                                fputs(", sizeof((" as *byte, codegen.output as *void);
                                gen_expr(codegen, left);
                                fputs(")." as *byte, codegen.output as *void);
                                fputs(safe_field as *byte, codegen.output as *void);
                                fputs(")) == 0)" as *byte, codegen.output as *void);
                            } else {
                                fputs("((" as *byte, codegen.output as *void);
                                gen_expr(codegen, left);
                                fputs(")." as *byte, codegen.output as *void);
                                fputs(safe_field as *byte, codegen.output as *void);
                                fputs(" == (" as *byte, codegen.output as *void);
                                gen_expr(codegen, right);
                                fputs(")." as *byte, codegen.output as *void);
                                fputs(safe_field as *byte, codegen.output as *void);
                                fputs(")" as *byte, codegen.output as *void);
                            }
                            if i < struct_decl.struct_decl_field_count - 1 {
                                fputs(" && " as *byte, codegen.output as *void);
                            }
                        }
                    }
                    i = i + 1;
                }
                fputc(41, codegen.output as *void);  // ')'
                if op == TOKEN_NOT_EQUAL {
                    fputc(41, codegen.output as *void);  // ')'
                }
            } else {
                // 回退：无法按字段比较时用 memcmp，与 C 编译器一致
                fputc(40, codegen.output as *void);  // '('
                if left.type == AST_IDENTIFIER {
                    fputs("memcmp(&" as *byte, codegen.output as *void);
                    gen_expr(codegen, left);
                    fputs(", &" as *byte, codegen.output as *void);
                    gen_expr(codegen, right);
                    fputs(", sizeof(" as *byte, codegen.output as *void);
                    gen_expr(codegen, left);
                    fputs("))" as *byte, codegen.output as *void);
                } else if left.type == AST_STRUCT_INIT {
                    const struct_name: &byte = left.struct_init_struct_name;
                    fputs("memcmp(&" as *byte, codegen.output as *void);
                    gen_expr(codegen, left);
                    fputs(", &" as *byte, codegen.output as *void);
                    gen_expr(codegen, right);
                    const safe_struct_name: &byte = get_safe_c_identifier(codegen, struct_name);
                    fprintf(codegen.output as *void, ", sizeof(struct %s))" as *byte, safe_struct_name as *byte);
                } else {
                    fputs("memcmp(&" as *byte, codegen.output as *void);
                    gen_expr(codegen, left);
                    fputs(", &" as *byte, codegen.output as *void);
                    gen_expr(codegen, right);
                    fputs(", sizeof(" as *byte, codegen.output as *void);
                    gen_expr(codegen, left);
                    fputs("))" as *byte, codegen.output as *void);
                }
                if op == TOKEN_EQUAL {
                    fputs(" == 0)" as *byte, codegen.output as *void);
                } else if op == TOKEN_NOT_EQUAL {
                    fputs(" != 0)" as *byte, codegen.output as *void);
                } else {
                    fputc(41, codegen.output as *void);  // ')'
                }
            }
        } else {
            // 普通二元表达式
            fputc(40, codegen.output as *void);  // '('
            gen_expr(codegen, left);
            // 操作符映射
            if op == TOKEN_PLUS {
                fputs(" + " as *byte, codegen.output as *void);
            } else if op == TOKEN_MINUS {
                fputs(" - " as *byte, codegen.output as *void);
            } else if op == TOKEN_ASTERISK {
                fputs(" * " as *byte, codegen.output as *void);
            } else if op == TOKEN_SLASH {
                fputs(" / " as *byte, codegen.output as *void);
            } else if op == TOKEN_PERCENT {
                fputs(" % " as *byte, codegen.output as *void);
            } else if op == TOKEN_EQUAL {
                fputs(" == " as *byte, codegen.output as *void);
            } else if op == TOKEN_NOT_EQUAL {
                fputs(" != " as *byte, codegen.output as *void);
            } else if op == TOKEN_LESS {
                fputs(" < " as *byte, codegen.output as *void);
            } else if op == TOKEN_GREATER {
                fputs(" > " as *byte, codegen.output as *void);
            } else if op == TOKEN_LESS_EQUAL {
                fputs(" <= " as *byte, codegen.output as *void);
            } else if op == TOKEN_GREATER_EQUAL {
                fputs(" >= " as *byte, codegen.output as *void);
            } else if op == TOKEN_LOGICAL_AND {
                fputs(" && " as *byte, codegen.output as *void);
            } else if op == TOKEN_LOGICAL_OR {
                fputs(" || " as *byte, codegen.output as *void);
            } else {
                fputs(" + " as *byte, codegen.output as *void); // 默认为加法
            }
            gen_expr(codegen, right);
            fputc(41, codegen.output as *void);  // ')'
        }
    } else if expr.type == AST_UNARY_EXPR {
        const op: i32 = expr.unary_expr_op;
        const operand: &ASTNode = expr.unary_expr_operand;
        fputc(40, codegen.output as *void);  // '('
        if op == TOKEN_ASTERISK {
            fputs("*" as *byte, codegen.output as *void);
        } else if op == TOKEN_AMPERSAND {
            fputs("&" as *byte, codegen.output as *void);
        } else if op == TOKEN_MINUS {
            fputs("-" as *byte, codegen.output as *void);
        } else if op == TOKEN_EXCLAMATION {
            fputs("!" as *byte, codegen.output as *void);
        } else if op == TOKEN_PLUS {
            fputs("+" as *byte, codegen.output as *void);
        } else {
            fputs("+" as *byte, codegen.output as *void); // 默认
        }
        gen_expr(codegen, operand);
        fputc(41, codegen.output as *void);  // ')'
    } else if expr.type == AST_MEMBER_ACCESS {
        const object: &ASTNode = expr.member_access_object;
        const field_name: &byte = expr.member_access_field_name;
        
        if object == null || field_name == null {
            return;
        }
        
        // 检查是否是枚举值访问（EnumName.Variant）
        if object.type == AST_IDENTIFIER {
            const enum_name: &byte = object.identifier_name;
            if enum_name != null {
                // 检查是否是枚举类型名称（不检查变量表，直接检查枚举声明）
                const enum_decl: &ASTNode = find_enum_decl_c99(codegen, enum_name);
                if enum_decl != null {
                    // 是枚举类型，查找变体值
                    const enum_value: i32 = find_enum_variant_value(codegen, enum_decl, field_name);
                    if enum_value >= 0 {
                        // 找到变体，直接输出枚举值名称（C中枚举值不需要前缀）
                        const safe_variant_name: &byte = get_safe_c_identifier(codegen, field_name);
                        fprintf(codegen.output as *void, "%s" as *byte, safe_variant_name as *byte);
                        return;
                    }
                }
            }
        }
        
        // 普通字段访问（结构体字段）
        const safe_field_name: &byte = get_safe_c_identifier(codegen, field_name);
        
        // 检查对象是否是指针类型（需要自动解引用）
        var is_pointer: i32 = 0;
        if object.type == AST_IDENTIFIER {
            // 标识符：检查变量类型是否是指针
            // 注意：需要使用 get_safe_c_identifier 转换名称，因为变量表中存储的是转换后的名称
            const var_name: &byte = object.identifier_name;
            if var_name != null {
                const safe_name: &byte = get_safe_c_identifier(codegen, var_name);
                is_pointer = is_identifier_pointer_type(codegen, safe_name);
            }
        } else if object.type == AST_MEMBER_ACCESS {
            // 嵌套成员访问：检查嵌套访问的结果类型是否是指针
            is_pointer = is_member_access_pointer_type(codegen, object);
        } else if object.type == AST_ARRAY_ACCESS {
            // 数组访问：检查数组元素类型是否是指针
            // 例如：programs[i] 如果 programs 的类型是 [&ASTNode: 64]，那么 programs[i] 是指针类型
            is_pointer = is_array_access_pointer_type(codegen, object);
        } else if object.type == AST_UNARY_EXPR {
            // 一元表达式：检查操作符
            const op2: i32 = object.unary_expr_op;
            if op2 == TOKEN_AMPERSAND {
                // &expr：取地址表达式的结果是指针，但这里访问的是 expr 的字段
                // 实际上不应该发生这种情况，因为 &expr.field 在语法上不合法
                // 但为了安全，我们假设不是指针
                is_pointer = 0;
            } else if op2 == TOKEN_ASTERISK {
                // *ptr：解引用表达式的结果是结构体本身，不是指针
                // 所以应该使用 . 而不是 ->
                is_pointer = 0;
            }
            // 其他一元操作符（!, -, +）不影响类型判断
        }
        
        gen_expr(codegen, object);
        if is_pointer != 0 {
            // 指针类型使用 -> 操作符
            fprintf(codegen.output as *void, "->%s" as *byte, safe_field_name as *byte);
        } else {
            // 非指针类型使用 . 操作符
            fprintf(codegen.output as *void, ".%s" as *byte, safe_field_name as *byte);
        }
    } else if expr.type == AST_ARRAY_ACCESS {
        const array: &ASTNode = expr.array_access_array;
        const index: &ASTNode = expr.array_access_index;
        
        // 检查数组表达式是否是指向数组的指针
        var is_ptr_to_array: i32 = 0;
        if array.type == AST_IDENTIFIER {
            const array_name: &byte = array.identifier_name;
            if array_name != null {
                is_ptr_to_array = is_identifier_pointer_to_array_type(codegen, array_name);
            }
        }
        
        if is_ptr_to_array != 0 {
            // 指向数组的指针需要先解引用：(*ptr)[index]
            fputc(40, codegen.output as *void);  // '('
            fputc(42, codegen.output as *void);  // '*'
            gen_expr(codegen, array);
            fputc(41, codegen.output as *void);  // ')'
        } else {
            gen_expr(codegen, array);
        }
        
        fputc(91, codegen.output as *void);  // '['
        gen_expr(codegen, index);
        fputc(93, codegen.output as *void);  // ']'
    } else if expr.type == AST_STRUCT_INIT {
        const struct_name: &byte = get_safe_c_identifier(codegen, expr.struct_init_struct_name);
        const field_count: i32 = expr.struct_init_field_count;
        fprintf(codegen.output as *void, "(struct %s){" as *byte, struct_name as *byte);
        var i: i32 = 0;
        while i < field_count {
            const safe_field_name: &byte = get_safe_c_identifier(codegen, expr.struct_init_field_names[i]);
            fprintf(codegen.output as *void, ".%s = " as *byte, safe_field_name as *byte);
            gen_expr(codegen, expr.struct_init_field_values[i]);
            if i < field_count - 1 {
                fputs(", " as *byte, codegen.output as *void);
            }
            i = i + 1;
        }
        fputc(125, codegen.output as *void);  // '}'
    } else if expr.type == AST_ARRAY_LITERAL {
        const element_count: i32 = expr.array_literal_element_count;
        fputc(123, codegen.output as *void);  // '{'
        var i: i32 = 0;
        while i < element_count {
            gen_expr(codegen, expr.array_literal_elements[i]);
            if i < element_count - 1 {
                fputs(", " as *byte, codegen.output as *void);
            }
            i = i + 1;
        }
        fputc(125, codegen.output as *void);  // '}'
    } else if expr.type == AST_SIZEOF {
        const target: &ASTNode = expr.sizeof_expr_target;
        const is_type: i32 = expr.sizeof_expr_is_type;
        fputs("sizeof(" as *byte, codegen.output as *void);
        if is_type != 0 {
            // 显式检查是否是结构体类型（即使在 c99_type_to_c 中查找失败）
            if target.type == AST_TYPE_NAMED {
                const name: &byte = target.type_named_name;
                if name != null && is_c_keyword(name) == 0 {
                    // 检查是否是结构体（检查是否在表中，不管是否已定义）
                    const safe_name: &byte = get_safe_c_identifier(codegen, name);
                    if is_struct_in_table(codegen, safe_name) != 0 {
                        fprintf(codegen.output as *void, "struct %s" as *byte, safe_name as *byte);
                    } else {
                        // 如果不在表中，尝试从程序节点中查找结构体声明
                        if codegen.program_node != null {
                            const decl_count: i32 = codegen.program_node.program_decl_count;
                            var found: i32 = 0;
                            var i: i32 = 0;
                            while i < decl_count {
                                const decl: &ASTNode = codegen.program_node.program_decls[i];
                                if decl != null && decl.type == AST_STRUCT_DECL {
                                    const struct_name: &byte = decl.struct_decl_name;
                                    if struct_name != null {
                                        const safe_struct_name: &byte = get_safe_c_identifier(codegen, struct_name);
                                        if strcmp(safe_struct_name as *byte, safe_name as *byte) == 0 {
                                            fprintf(codegen.output as *void, "struct %s" as *byte, safe_name as *byte);
                                            found = 1;
                                            break;
                                        }
                                    }
                                }
                                i = i + 1;
                            }
                            if found == 0 {
                                // 不是结构体，使用默认类型转换
                                const type_c: &byte = c99_type_to_c(codegen, target);
                                fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                            }
                        } else {
                            const type_c: &byte = c99_type_to_c(codegen, target);
                            fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                        }
                    }
                } else {
                    const type_c: &byte = c99_type_to_c(codegen, target);
                    fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                }
            } else {
                const type_c: &byte = c99_type_to_c(codegen, target);
                // 检查是否是数组指针类型（包含 [数字] *，且 * 在末尾）
                const bracket: *byte = strchr(type_c as *byte, 91);  // '['
                const asterisk: *byte = strrchr(type_c as *byte, 42);  // '*' 从后往前找最后一个 *
                if bracket != null && asterisk != null && bracket < asterisk {
                    // 检查 * 是否在末尾（后面只有空格或结束）
                    const asterisk_offset: i32 = ptr_diff(asterisk, type_c as *byte);
                    var after_asterisk_offset: i32 = asterisk_offset + 1;
                    const type_c_len: i32 = strlen(type_c as *byte);
                    while after_asterisk_offset < type_c_len && type_c[after_asterisk_offset] == 32 {  // ' '
                        after_asterisk_offset = after_asterisk_offset + 1;
                    }
                    if after_asterisk_offset >= type_c_len || type_c[after_asterisk_offset] == 0 {
                        // 数组指针类型：T[N] * -> T(*)[N]
                        // 找到 ']' 的位置
                        const close_bracket: *byte = strchr(bracket, 93);  // ']'
                        if close_bracket != null {
                            const base_len: i32 = ptr_diff(bracket, type_c as *byte);
                            const array_spec_len: i32 = ptr_diff(close_bracket, bracket) + 1;
                            // 注意：Uya Mini 不支持 %.*s，需要手动处理
                            var temp_buf: [byte: 256] = [];
                            var j: i32 = 0;
                            while j < base_len && j < 255 {
                                temp_buf[j] = type_c[j];
                                j = j + 1;
                            }
                            temp_buf[j] = 0;
                            fprintf(codegen.output as *void, "%s(*)" as *byte, &temp_buf[0] as *byte);
                            // 输出数组规格
                            j = 0;
                            while j < array_spec_len && j < 255 {
                                temp_buf[j] = bracket[j];
                                j = j + 1;
                            }
                            temp_buf[j] = 0;
                            fprintf(codegen.output as *void, "%s" as *byte, &temp_buf[0] as *byte);
                        } else {
                            fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                        }
                    } else {
                        fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                    }
                } else {
                    fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                }
            }
        } else {
            // 即使 is_type = 0，也检查是否是结构体标识符（如 sizeof(Point) 中的 Point）
            if target.type == AST_IDENTIFIER || target.type == AST_TYPE_NAMED {
                var name: &byte = null;
                if target.type == AST_IDENTIFIER {
                    name = target.identifier_name;
                } else {
                    name = target.type_named_name;
                }
                if name != null && is_c_keyword(name) == 0 {
                    const safe_name: &byte = get_safe_c_identifier(codegen, name);
                    if is_struct_in_table(codegen, safe_name) != 0 {
                        fprintf(codegen.output as *void, "struct %s" as *byte, safe_name as *byte);
                    } else {
                        var is_enum: i32 = is_enum_in_table(codegen, safe_name);
                        if is_enum == 0 && find_enum_decl_c99(codegen, safe_name) != null {
                            is_enum = 1;
                        }
                        if is_enum != 0 {
                            fprintf(codegen.output as *void, "enum %s" as *byte, safe_name as *byte);
                        } else {
                            gen_expr(codegen, target);
                        }
                    }
                } else {
                    gen_expr(codegen, target);
                }
            } else {
                gen_expr(codegen, target);
            }
        }
        fputc(41, codegen.output as *void);  // ')'
    } else if expr.type == AST_LEN {
        const array: &ASTNode = expr.len_expr_array;
        
        // 检查数组表达式是否是标识符（局部变量或参数）
        if array.type == AST_IDENTIFIER {
            const var_name: &byte = array.identifier_name;
            
            // 查找变量类型以确定数组大小
            var found: i32 = 0;
            var array_size: i32 = -1;
            
            // 检查局部变量
            var i: i32 = codegen.local_variable_count - 1;
            while i >= 0 {
                if strcmp(codegen.local_variables[i].name as *byte, var_name as *byte) == 0 {
                    const type_c: &byte = codegen.local_variables[i].type_c;
                    if type_c != null {
                        // 从类型字符串中提取数组大小，格式如 "int32_t[3]"
                        const bracket: *byte = strchr(type_c as *byte, 91);  // '['
                        if bracket != null {
                            const bracket_offset: i32 = ptr_diff(bracket, type_c as *byte);
                            const close_bracket: *byte = strchr(&type_c[bracket_offset + 1] as *byte, 93);  // ']'
                            if close_bracket != null {
                                // 提取数字部分
                                const num_len: i32 = ptr_diff(close_bracket, bracket) - 1;
                                var num_buf: [byte: 32] = [];
                                if num_len < 32 && num_len > 0 {
                                    memcpy(&num_buf[0] as *void, &type_c[bracket_offset + 1] as *void, num_len);
                                    num_buf[num_len] = 0;
                                    array_size = atoi(&num_buf[0] as *byte);
                                    if array_size > 0 {
                                        fprintf(codegen.output as *void, "%d" as *byte, array_size);
                                        found = 1;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    break;
                }
                i = i - 1;
            }
            
            // 如果找到数组大小，直接输出
            if found != 0 {
                return;
            }
        }
        
        // 备用方案：使用 sizeof 计算（适用于非参数数组）
        // 注意：这只适用于栈分配的数组，不适用于函数参数
        fputs("sizeof(" as *byte, codegen.output as *void);
        gen_expr(codegen, array);
        fputs(") / sizeof((" as *byte, codegen.output as *void);
        gen_expr(codegen, array);
        fputs(")[0])" as *byte, codegen.output as *void);
    } else if expr.type == AST_ALIGNOF {
        const target: &ASTNode = expr.alignof_expr_target;
        const is_type: i32 = expr.alignof_expr_is_type;
        
        // 获取类型字符串
        var type_c: &byte = null;
        if is_type != 0 {
            type_c = c99_type_to_c(codegen, target);
        } else {
            // 即使 is_type = 0，也检查是否是类型标识符（如 alignof(usize) 中的 usize）
            if target.type == AST_IDENTIFIER {
                const name: &byte = target.identifier_name;
                if name != null && is_c_keyword(name) == 0 {
                    const safe_name: &byte = get_safe_c_identifier(codegen, name);
                    if is_struct_in_table(codegen, safe_name) != 0 {
                        // 结构体类型
                        const str_len: i32 = strlen(safe_name as *byte) + 8;  // "struct " + name + '\0'
                        const buf: &byte = arena_alloc(codegen.arena, str_len) as &byte;
                        if buf != null {
                            snprintf(buf as *byte, str_len, "struct %s" as *byte, safe_name as *byte);
                            type_c = buf;
                        }
                    } else {
                        // 对于变量名，需要获取变量的类型（从局部/全局变量表查找）
                        type_c = get_identifier_type_c(codegen, safe_name);
                        if type_c == null {
                            // 如果找不到，可能是类型名（如 alignof(usize)）
                            type_c = c99_type_to_c(codegen, target);
                        }
                    }
                } else {
                    type_c = c99_type_to_c(codegen, target);
                }
            } else {
                // 其他表达式类型：尝试从变量表查找（如成员访问的基变量）
                type_c = c99_type_to_c(codegen, target);
            }
        }
        
        if type_c == null {
            type_c = ("void" as *byte) as &byte;
        }
        
        // void 类型不能用于 uya_alignof 宏（struct { char c; void t; } 非法），直接输出 1
        if strcmp(type_c as *byte, "void" as *byte) == 0 {
            fputs("1" as *byte, codegen.output as *void);
            return;
        }
        
        // 检查类型是否是数组类型（包含 '['）
        const bracket: *byte = strchr(type_c as *byte, 91);  // '['
        if bracket != null {
            // 数组类型：提取元素类型（数组的对齐值等于元素类型的对齐值）
            const elem_len: i32 = ptr_diff(bracket, type_c as *byte);
            const elem_type: &byte = arena_alloc(codegen.arena, elem_len + 1) as &byte;
            if elem_type != null {
                memcpy(elem_type as *void, type_c as *void, elem_len);
                elem_type[elem_len] = 0;
                // 移除可能的 const 限定符（如果存在）
                if strncmp(elem_type as *byte, "const " as *byte, 6) == 0 {
                    fputs("uya_alignof(" as *byte, codegen.output as *void);
                    fprintf(codegen.output as *void, "%s" as *byte, &elem_type[6] as *byte);
                    fputc(41, codegen.output as *void);  // ')'
                } else {
                    fputs("uya_alignof(" as *byte, codegen.output as *void);
                    fprintf(codegen.output as *void, "%s" as *byte, elem_type as *byte);
                    fputc(41, codegen.output as *void);  // ')'
                }
            } else {
                // 分配失败，回退到原始类型（会失败，但至少不会崩溃）
                fputs("uya_alignof(" as *byte, codegen.output as *void);
                fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
                fputc(41, codegen.output as *void);  // ')'
            }
        } else {
            // 非数组类型：直接使用
            fputs("uya_alignof(" as *byte, codegen.output as *void);
            fprintf(codegen.output as *void, "%s" as *byte, type_c as *byte);
            fputc(41, codegen.output as *void);  // ')'
        }
    } else if expr.type == AST_CAST_EXPR {
        const src_expr: &ASTNode = expr.cast_expr_expr;
        const target_type: &ASTNode = expr.cast_expr_target_type;
        const type_c: &byte = c99_type_to_c(codegen, target_type);
        fputc(40, codegen.output as *void);  // '('
        fprintf(codegen.output as *void, "%s)" as *byte, type_c as *byte);
        gen_expr(codegen, src_expr);
    } else if expr.type == AST_IDENTIFIER {
        const name: &byte = expr.identifier_name;
        if name != null && strcmp(name as *byte, "null" as *byte) == 0 {
            fputs("NULL" as *byte, codegen.output as *void);
        } else {
            const safe_name: &byte = get_safe_c_identifier(codegen, name);
            fprintf(codegen.output as *void, "%s" as *byte, safe_name as *byte);
        }
    } else if expr.type == AST_CALL_EXPR {
        const callee: &ASTNode = expr.call_expr_callee;
        const arg_count: i32 = expr.call_expr_arg_count;
        
        // 查找函数声明（用于检查参数类型）
        var fn_decl: &ASTNode = null;
        if callee != null && callee.type == AST_IDENTIFIER {
            const func_name: &byte = callee.identifier_name;
            fn_decl = find_function_decl_c99(codegen, func_name);
        }
        
        // 生成被调用函数名
        if callee != null && callee.type == AST_IDENTIFIER {
            const func_name: &byte = callee.identifier_name;
            const safe_name: &byte = get_safe_c_identifier(codegen, func_name);
            fprintf(codegen.output as *void, "%s(" as *byte, safe_name as *byte);
        } else {
            fputs("unknown(" as *byte, codegen.output as *void);
        }
        
        // 生成参数
        var i: i32 = 0;
        while i < arg_count {
            // 检查参数是否是字符串常量，如果是则添加类型转换以消除 const 警告
            var is_string_arg: i32 = 0;
            if expr.call_expr_args[i] != null && expr.call_expr_args[i].type == AST_STRING {
                is_string_arg = 1;
            }
            if is_string_arg != 0 {
                fputs("(uint8_t *)" as *byte, codegen.output as *void);
            }
            
            // 检查是否是大结构体参数且函数期望指针
            // 对于 extern 函数，如果参数类型是大结构体（>16字节），则传递地址
            var need_address: i32 = 0;
            if fn_decl != null && fn_decl.type == AST_FN_DECL {
                const body: &ASTNode = fn_decl.fn_decl_body;
                var is_extern: i32 = 0;
                if body == null {
                    is_extern = 1;
                }
                
                if is_extern != 0 && expr.call_expr_args[i] != null && i < fn_decl.fn_decl_param_count {
                    const param: &ASTNode = fn_decl.fn_decl_params[i];
                    if param != null && param.type == AST_VAR_DECL {
                        const param_type: &ASTNode = param.var_decl_type;
                        if param_type != null && param_type.type == AST_TYPE_NAMED {
                            const struct_size: i32 = calculate_struct_size(codegen, param_type);
                            if struct_size > 16 {
                                // 函数期望指针，需要传递地址
                                need_address = 1;
                            }
                        }
                    }
                }
            }
            
            if need_address != 0 {
                fputc(38, codegen.output as *void);  // '&'
            }
            gen_expr(codegen, expr.call_expr_args[i]);
            if i < arg_count - 1 {
                fputs(", " as *byte, codegen.output as *void);
            }
            i = i + 1;
        }
        fputc(41, codegen.output as *void);  // ')'
    } else if expr.type == AST_ASSIGN {
        // 赋值表达式（右结合）：dest = src
        // 在表达式中使用时，需要生成 (dest = src) 的形式
        const dest: &ASTNode = expr.assign_dest;
        const src: &ASTNode = expr.assign_src;
        
        fputc(40, codegen.output as *void);  // '('
        gen_expr(codegen, dest);
        fputs(" = " as *byte, codegen.output as *void);
        gen_expr(codegen, src);
        fputc(41, codegen.output as *void);  // ')'
    } else {
        fputs("0" as *byte, codegen.output as *void);
    }
}

