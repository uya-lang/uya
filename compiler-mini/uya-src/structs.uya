// structs.uya - 全局结构体定义
// 将所有结构体定义集中到全局级别，避免函数内部注册的复杂性

// ===== 基础类型 =====

// Arena 分配器
struct Arena {
    buffer: &byte,  // 静态缓冲区指针
    size: i32,      // 缓冲区总大小（字节）
    offset: i32,     // 当前分配位置（bump pointer）
}

// ===== 词法分析器相关 =====

// Token 结构
struct Token {
    type: TokenType,// Token 类型
    value: &byte,// Token 值（字符串，存储在 Arena 中，可为 null）
    line: i32,// 行号
    column: i32// 列号
}

// Lexer 结构
struct Lexer {
    buffer: &byte,// 源代码缓冲区指针
    buffer_size: i32,// 缓冲区实际大小（字节数）
    position: i32,// 当前读取位置
    line: i32,// 当前行号（从1开始）
    column: i32,// 当前列号（从1开始）
    input_file: &byte,// 输入文件名（存储在 Arena 中）
    arena: &Arena// Arena 分配器
}

// ===== 语法分析器相关 =====

// Parser 结构
struct Parser {
    lexer: &Lexer,// 词法分析器指针（由调用者提供，不分配）
    current_token: &Token,// 当前 Token（从 Arena 分配）
    arena: &Arena,// Arena 分配器（用于分配 Token 和 AST 节点）
    context: ParserContext// 当前解析上下文
}

// ===== AST 相关 =====

// EnumVariant 结构
struct EnumVariant {
    name: &byte,// 变体名称（字符串存储在 Arena 中）
    value: &byte// 显式值（字符串形式，如果指定了 = NUM，否则为 null，存储在 Arena 中）
}

// 注意：常量定义在其他文件中已存在

// ASTNode 结构（简化的定义，实际字段在代码中使用）
struct ASTNode {
    type: ASTNodeType,// 节点类型
    line: i32,// 行号
    column: i32,// 列号
    filename: &byte,// 文件名（从 Lexer 中获取，用于错误报告）

    // 简化的字段定义（实际使用中会访问更多字段）
    // 这里只定义必要的字段以通过编译
    enum_decl_variants: &EnumVariant,// 变体数组指针（从 Arena 分配）
    enum_decl_variant_count: i32// 变体数量
}

// ===== 类型检查器相关 =====

// Type 结构
struct Type {
    kind: TypeKind,// 类型种类

    // 枚举类型数据
    enum_name: &byte,// 枚举名称（仅当 kind == TYPE_ENUM 时有效）

    // 结构体类型数据
    struct_name: &byte,// 结构体名称（仅当 kind == TYPE_STRUCT 时有效）

    // 指针类型数据
    pointer_to: &Type,// 指向的类型（仅当 kind == TYPE_POINTER 时有效）

    // 数组类型数据
    element_type: &Type,// 数组元素类型（仅当 kind == TYPE_ARRAY 时有效）
    array_size: i32// 数组大小（仅当 kind == TYPE_ARRAY 时有效）
}

// Symbol 结构
struct Symbol {
    name: &byte,// 符号名称（存储在 Arena 中）
    type: Type,// 符号类型
    is_const: i32,// 1 表示 const，0 表示 var
    scope_level: i32,// 作用域级别
    line: i32,// 行号
    column: i32// 列号
}

// FunctionSignature 结构
struct FunctionSignature {
    name: &byte,// 函数名称（存储在 Arena 中）
    param_types: &Type,// 参数类型数组（从 Arena 分配）
    param_count: i32,// 参数数量（固定参数数量，不包括可变参数）
    return_type: Type,// 返回类型
    is_extern: i32,// 是否为 extern 函数
    line: i32,// 行号
    column: i32// 列号
}

// SymbolTable 结构
struct SymbolTable {
    slots: [&Symbol: SYMBOL_TABLE_SIZE],// 符号槽位数组（固定大小 256）
    count: i32// 当前符号数量
}

// FunctionTable 结构
struct FunctionTable {
    slots: [&FunctionSignature: FUNCTION_TABLE_SIZE],// 函数槽位数组（固定大小 64）
    count: i32// 当前函数数量
}

// TypeChecker 结构
struct TypeChecker {
    arena: &Arena,// Arena 分配器（用于分配类型、符号等）
    symbol_table: SymbolTable,// 符号表
    function_table: FunctionTable,// 函数表
    scope_level: i32,// 当前作用域级别
    loop_depth: i32,// 循环深度（用于检查 break/continue 是否在循环中）
    program_node: &ASTNode,// 程序节点（用于查找结构体声明等）
    error_count: i32,// 错误计数（简化版本，暂不存储错误消息）
    default_filename: &byte,// 默认文件名（用于错误报告，可为 null）
    current_return_type: Type,// 当前函数的返回类型（用于检查 return 语句）
    in_function: i32// 是否在函数中（1 表示是，0 表示否）
}

// ===== 代码生成器相关 =====

// 常量定义（与 codegen.uya 中的定义保持一致）
const STRUCT_TYPE_MAP_SIZE: i32 = 64;        // 结构体类型映射表大小
const VAR_MAP_SIZE: i32 = 256;                // 变量映射表大小
const FUNC_MAP_SIZE: i32 = 256;               // 函数映射表大小
const GLOBAL_VAR_MAP_SIZE: i32 = 128;         // 全局变量映射表大小
const LOOP_STACK_SIZE: i32 = 16;              // 循环栈大小

// StructTypeMap 结构
struct StructTypeMap {
    name: &byte,// 结构体名称（存储在 Arena 中）
    llvm_type: *void,// LLVM 结构体类型（LLVMTypeRef）
    ast_node: &ASTNode// AST 节点引用（用于查找结构体声明）
}

// VarMap 结构
struct VarMap {
    name: &byte,// 变量名称（存储在 Arena 中）
    value: *void,// LLVM 值（alloca 指令返回的指针，LLVMValueRef）
    type: *void,// 变量类型（用于 LLVMBuildLoad2，LLVMTypeRef）
    struct_name: &byte,// 结构体名称（仅当类型是结构体类型时有效，存储在 Arena 中）
    ast_type: &ASTNode// AST 类型节点（用于从 AST 重新构建类型，避免使用 LLVMGetElementType）
}

// FuncMap 结构
struct FuncMap {
    name: &byte,// 函数名称（存储在 Arena 中）
    func: *void,// LLVM 函数值（LLVMValueRef）
    func_type: *void// LLVM 函数类型（函数签名类型，用于 LLVMBuildCall2，LLVMTypeRef）
}

// GlobalVarMap 结构
struct GlobalVarMap {
    name: &byte,// 全局变量名称（存储在 Arena 中）
    global_var: *void,// LLVM 全局变量值（指针，LLVMValueRef）
    type: *void,// 全局变量类型（用于 LLVMBuildLoad2，LLVMTypeRef）
    struct_name: &byte// 结构体名称（仅当类型是结构体类型时有效，存储在 Arena 中）
}

// LoopInfo 结构
struct LoopInfo {
    cond_bb: *void,// 循环条件检查基本块（LLVMBasicBlockRef）
    end_bb: *void,// 循环结束基本块（用于 break，LLVMBasicBlockRef）
    inc_bb: *void// 循环递增基本块（用于 for 循环的 continue，while 循环为 null，LLVMBasicBlockRef）
}

// CodeGenerator 结构
struct CodeGenerator {
    arena: &Arena,// Arena 分配器（用于编译器自身内存分配）
    context: *void,// LLVM 上下文（LLVMContextRef）
    module: *void,// LLVM 模块（LLVMModuleRef）
    builder: *void,// IR 构建器（用于生成指令，LLVMBuilderRef）
    module_name: &byte,// 模块名称（存储在 Arena 中）
    struct_types: [StructTypeMap: STRUCT_TYPE_MAP_SIZE],// 结构体类型映射表（固定大小数组）
    struct_type_count: i32,// 当前注册的结构体类型数量
    var_maps: [VarMap: VAR_MAP_SIZE],// 变量映射表（局部变量，栈分配）
    var_map_count: i32,// 当前变量数量
    func_maps: [FuncMap: FUNC_MAP_SIZE],// 函数映射表
    func_map_count: i32,// 当前函数数量
    global_var_maps: [GlobalVarMap: GLOBAL_VAR_MAP_SIZE],// 全局变量映射表
    global_var_map_count: i32,// 当前全局变量数量
    loop_stack: [LoopInfo: LOOP_STACK_SIZE],// 循环栈（用于 break/continue）
    loop_stack_depth: i32// 循环栈深度
}
