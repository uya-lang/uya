// 自动生成的合并文件 - 2026年 01月 14日 星期三 17:12:53 CST
// 包含文件: uya-src/str_utils.uya uya-src/llvm_api.uya uya-src/arena.uya uya-src/ast.uya uya-src/lexer.uya uya-src/parser.uya uya-src/checker.uya uya-src/codegen.uya uya-src/main.uya

// ========== 来自文件: uya-src/str_utils.uya ==========
// str_utils.uya - 字符串辅助函数模块
// 封装 C 标准库字符串函数，简化 Uya Mini 代码中的字符串操作

// ===== C 标准库字符串函数声明 =====

// 字符串长度
extern fn strlen(s: *byte) i32;

// 字符串比较
extern fn strcmp(s1: *byte, s2: *byte) i32;
extern fn strncmp(s1: *byte, s2: *byte, n: i32) i32;

// 字符串复制
extern fn strcpy(dest: *byte, src: *byte) *byte;
extern fn strncpy(dest: *byte, src: *byte, n: i32) *byte;

// 字符串连接
extern fn strcat(dest: *byte, src: *byte) *byte;

// 字符串查找
extern fn strrchr(s: *byte, c: i32) *byte;  // 查找字符最后一次出现的位置

// 字符串格式化输出
// 注意：这些函数使用可变参数（...），需要确认 Uya Mini 是否支持可变参数函数
// 如果 Uya Mini 不支持可变参数，可能需要：
// 1. 使用固定参数版本（如 fprintf2, fprintf3 等）
// 2. 使用字符串拼接函数替代
// 3. 在实现阶段提供替代方案
extern fn sprintf(s: *byte, format: *byte, ...) i32;
extern fn fprintf(stream: *void, format: *byte, ...) i32;
extern fn snprintf(s: *byte, n: i32, format: *byte, ...) i32;

// 字符分类（ctype.h）
extern fn isalpha(c: i32) i32;
extern fn isdigit(c: i32) i32;
extern fn isalnum(c: i32) i32;
extern fn isspace(c: i32) i32;

// ===== 封装函数（可选，提供更友好的接口）=====

// 字符串相等判断
fn str_equals(s1: *byte, s2: *byte) bool {
    return strcmp(s1, s2) == 0;
}

// 字符串长度（类型为 i32）
fn str_length(s: *byte) i32 {
    return strlen(s);
}


// ========== 来自文件: uya-src/llvm_api.uya ==========
// llvm_api.uya - LLVM C API 外部函数声明文件
// 声明 CodeGen 模块需要的 LLVM C API 函数
// 注意：根据代码生成模块翻译时的需要逐步添加
// LLVM 版本：基于 LLVM 15+ C API（具体版本取决于编译时链接的 LLVM 库）

// ===== 类型定义 =====
// LLVM 类型在 Uya Mini 中使用 *void 或具体结构体指针类型表示
// LLVMContextRef, LLVMModuleRef, LLVMBuilderRef, LLVMValueRef, LLVMTypeRef 等都映射为 *void

// ===== 基础类型和上下文函数 =====

// 创建和销毁上下文
extern fn LLVMContextCreate() *void;
extern fn LLVMContextDispose(context: *void) void;

// 基础类型创建（全局函数，不依赖 context）
extern fn LLVMInt1Type() *void;   // bool
extern fn LLVMInt8Type() *void;  // byte
extern fn LLVMInt32Type() *void;  // i32
extern fn LLVMInt64Type() *void;  // usize (64位平台)
extern fn LLVMVoidType() *void;   // void

// ===== 模块和函数创建函数 =====

// 模块创建
extern fn LLVMModuleCreateWithNameInContext(name: *byte, context: *void) *void;
extern fn LLVMDisposeModule(module: *void) void;
extern fn LLVMSetTarget(module: *void, triple: *byte) void;
extern fn LLVMSetModuleDataLayout(module: *void, layout: *void) void;

// 函数创建和声明
extern fn LLVMAddFunction(module: *void, name: *byte, function_type: *void) *void;
extern fn LLVMGetParam(func: *void, index: i32) *void;
extern fn LLVMSetValueName(value: *void, name: *byte) void;
extern fn LLVMSetLinkage(value: *void, linkage: i32) void;

// ===== 基本块和指令构建函数 =====

// 构建器创建
extern fn LLVMCreateBuilderInContext(context: *void) *void;
extern fn LLVMDisposeBuilder(builder: *void) void;
extern fn LLVMPositionBuilderAtEnd(builder: *void, basic_block: *void) void;
extern fn LLVMGetInsertBlock(builder: *void) *void;
extern fn LLVMGetBasicBlockParent(basic_block: *void) *void;

// 基本块创建
extern fn LLVMAppendBasicBlock(func: *void, name: *byte) *void;

// 控制流指令
extern fn LLVMBuildBr(builder: *void, dest: *void) *void;
extern fn LLVMBuildCondBr(builder: *void, condition: *void, then_bb: *void, else_bb: *void) *void;
extern fn LLVMBuildRet(builder: *void, value: *void) *void;
extern fn LLVMBuildRetVoid(builder: *void) *void;

// 内存操作指令
extern fn LLVMBuildAlloca(builder: *void, type: *void, name: *byte) *void;
extern fn LLVMBuildLoad2(builder: *void, type: *void, pointer: *void, name: *byte) *void;
extern fn LLVMBuildStore(builder: *void, value: *void, pointer: *void) *void;

// 算术运算指令
extern fn LLVMBuildAdd(builder: *void, lhs: *void, rhs: *void, name: *byte) *void;
extern fn LLVMBuildSub(builder: *void, lhs: *void, rhs: *void, name: *byte) *void;
extern fn LLVMBuildMul(builder: *void, lhs: *void, rhs: *void, name: *byte) *void;
extern fn LLVMBuildUDiv(builder: *void, lhs: *void, rhs: *void, name: *byte) *void;  // 无符号除法
extern fn LLVMBuildSDiv(builder: *void, lhs: *void, rhs: *void, name: *byte) *void;  // 有符号除法
extern fn LLVMBuildURem(builder: *void, lhs: *void, rhs: *void, name: *byte) *void;  // 无符号取模
extern fn LLVMBuildSRem(builder: *void, lhs: *void, rhs: *void, name: *byte) *void;  // 有符号取模

// 逻辑运算指令
extern fn LLVMBuildAnd(builder: *void, lhs: *void, rhs: *void, name: *byte) *void;
extern fn LLVMBuildOr(builder: *void, lhs: *void, rhs: *void, name: *byte) *void;
extern fn LLVMBuildXor(builder: *void, lhs: *void, rhs: *void, name: *byte) *void;

// 比较指令
extern fn LLVMBuildICmp(builder: *void, predicate: i32, lhs: *void, rhs: *void, name: *byte) *void;

// 类型转换指令
extern fn LLVMBuildZExt(builder: *void, value: *void, dest_type: *void, name: *byte) *void;  // 零扩展
extern fn LLVMBuildSExt(builder: *void, value: *void, dest_type: *void, name: *byte) *void;  // 符号扩展
extern fn LLVMBuildTrunc(builder: *void, value: *void, dest_type: *void, name: *byte) *void;  // 截断
extern fn LLVMBuildPtrToInt(builder: *void, value: *void, dest_type: *void, name: *byte) *void;  // 指针转整数
extern fn LLVMBuildIntToPtr(builder: *void, value: *void, dest_type: *void, name: *byte) *void;  // 整数转指针

// 结构体和数组操作指令
extern fn LLVMBuildGEP2(builder: *void, type: *void, pointer: *void, indices: *void, num_indices: i32, name: *byte) *void;  // GetElementPtr
extern fn LLVMBuildExtractValue(builder: *void, aggregate_value: *void, index: i32, name: *byte) *void;
extern fn LLVMBuildInsertValue(builder: *void, aggregate_value: *void, element_value: *void, index: i32, name: *byte) *void;

// 函数调用指令
extern fn LLVMBuildCall2(builder: *void, function_type: *void, function: *void, args: *void, num_args: i32, name: *byte) *void;

// ===== 类型创建函数 =====

// 指针类型
extern fn LLVMPointerType(element_type: *void, address_space: i32) *void;

// 数组类型
extern fn LLVMArrayType(element_type: *void, element_count: i32) *void;

// 结构体类型
extern fn LLVMStructTypeInContext(context: *void, element_types: *void, element_count: i32, packed: i32) *void;

// 函数类型
extern fn LLVMFunctionType(return_type: *void, param_types: *void, param_count: i32, is_var_arg: i32) *void;

// 类型查询
extern fn LLVMTypeOf(value: *void) *void;
extern fn LLVMGetTypeKind(type: *void) i32;
extern fn LLVMGetElementType(type: *void) *void;
extern fn LLVMGetIntTypeWidth(type: *void) i32;
extern fn LLVMGetArrayLength(array_type: *void) i32;
extern fn LLVMGetFirstBasicBlock(func: *void) *void;
extern fn LLVMGetBasicBlockTerminator(basic_block: *void) *void;
extern fn LLVMCountStructElementTypes(struct_type: *void) i32;  // 获取结构体字段数量

// ===== 常量创建函数 =====

// 整数常量
extern fn LLVMConstInt(type: *void, value: i64, sign_extend: i32) *void;

// 空指针常量
extern fn LLVMConstNull(type: *void) *void;

// 字符串常量
extern fn LLVMConstStringInContext(context: *void, str: *byte, length: i32, dont_null_terminate: i32) *void;

// 数组常量
extern fn LLVMConstArray(element_type: *void, constant_values: *void, length: i32) *void;

// 结构体常量
extern fn LLVMConstStructInContext(context: *void, constant_values: *void, count: i32, packed: i32) *void;

// ===== 全局变量函数 =====

extern fn LLVMAddGlobal(module: *void, type: *void, name: *byte) *void;
extern fn LLVMSetInitializer(global_var: *void, constant: *void) void;
extern fn LLVMSetGlobalConstant(global_var: *void, is_constant: i32) void;

// ===== 目标数据布局函数 =====

extern fn LLVMGetModuleDataLayout(module: *void) *void;
extern fn LLVMPointerSize(target_data: *void) i32;
extern fn LLVMCreateTargetDataLayout(target_machine: *void) *void;
extern fn LLVMDisposeTargetData(target_data: *void) void;
extern fn LLVMStoreSizeOfType(target_data: *void, type: *void) i32;  // 获取类型的存储大小（字节数）
extern fn LLVMABIAlignmentOfType(target_data: *void, type: *void) i32;  // 获取类型的 ABI 对齐值（字节数）

// ===== 目标代码生成函数 =====

// 目标初始化
extern fn LLVMInitializeNativeTarget() void;
extern fn LLVMInitializeNativeAsmPrinter() void;
extern fn LLVMInitializeNativeAsmParser() void;

// 目标机器
extern fn LLVMGetDefaultTargetTriple() *byte;
extern fn LLVMGetTargetFromTriple(triple: *byte, target: *void, error_message: *void) i32;
extern fn LLVMCreateTargetMachine(target: *void, triple: *byte, cpu: *byte, features: *byte, level: i32, reloc: i32, code_model: i32) *void;
extern fn LLVMDisposeTargetMachine(target_machine: *void) void;

// 代码生成
extern fn LLVMTargetMachineEmitToFile(target_machine: *void, module: *void, filename: *byte, codegen: i32, error_message: *void) i32;

// IR 输出
extern fn LLVMPrintModuleToFile(module: *void, filename: *byte, error_message: *void) i32;

// 消息处理
extern fn LLVMDisposeMessage(message: *byte) void;

// ===== 枚举常量 =====
// 这些值在 C 代码中作为整数常量使用，在 Uya Mini 中使用 const 常量定义

// LLVMIntPredicate 枚举值（用于 LLVMBuildICmp）
const LLVMIntEQ: i32 = 32;
const LLVMIntNE: i32 = 33;
const LLVMIntUGT: i32 = 34;
const LLVMIntUGE: i32 = 35;
const LLVMIntULT: i32 = 36;
const LLVMIntULE: i32 = 37;
const LLVMIntSGT: i32 = 38;
const LLVMIntSGE: i32 = 39;
const LLVMIntSLT: i32 = 40;
const LLVMIntSLE: i32 = 41;

// LLVMTypeKind 枚举值（用于 LLVMGetTypeKind）
const LLVMIntegerTypeKind: i32 = 0;
const LLVMFloatTypeKind: i32 = 1;
const LLVMDoubleTypeKind: i32 = 2;
const LLVMX86_FP80TypeKind: i32 = 3;
const LLVMFP128TypeKind: i32 = 4;
const LLVMPPC_FP128TypeKind: i32 = 5;
const LLVMNullTypeKind: i32 = 6;
const LLVMStructTypeKind: i32 = 7;
const LLVMArrayTypeKind: i32 = 8;
const LLVMPointerTypeKind: i32 = 9;
const LLVMVectorTypeKind: i32 = 10;
const LLVMFunctionTypeKind: i32 = 11;

// LLVMLinkage 枚举值（用于 LLVMSetLinkage）
const LLVMExternalLinkage: i32 = 0;
const LLVMAvailableExternallyLinkage: i32 = 1;
const LLVMLinkOnceAnyLinkage: i32 = 2;
const LLVMLinkOnceODRLinkage: i32 = 3;
const LLVMWeakAnyLinkage: i32 = 4;
const LLVMWeakODRLinkage: i32 = 5;
const LLVMAppendingLinkage: i32 = 6;
const LLVMInternalLinkage: i32 = 7;
const LLVMPrivateLinkage: i32 = 8;
const LLVMDLLImportLinkage: i32 = 9;
const LLVMDLLExportLinkage: i32 = 10;
const LLVMExternalWeakLinkage: i32 = 11;
const LLVMGhostLinkage: i32 = 12;
const LLVMCommonLinkage: i32 = 13;
const LLVMLinkerPrivateLinkage: i32 = 14;
const LLVMLinkerPrivateWeakLinkage: i32 = 15;

// LLVMCodeGenOptLevel 枚举值（用于 LLVMCreateTargetMachine）
const LLVMCodeGenLevelNone: i32 = 0;
const LLVMCodeGenLevelLess: i32 = 1;
const LLVMCodeGenLevelDefault: i32 = 2;
const LLVMCodeGenLevelAggressive: i32 = 3;

// LLVMRelocMode 枚举值
const LLVMRelocDefault: i32 = 0;
const LLVMRelocStatic: i32 = 1;
const LLVMRelocPIC: i32 = 2;
const LLVMRelocDynamicNoPic: i32 = 3;
const LLVMRelocROPI: i32 = 4;
const LLVMRelocRWPI: i32 = 5;
const LLVMRelocROPI_RWPI: i32 = 6;

// LLVMCodeModel 枚举值
const LLVMCodeModelDefault: i32 = 0;
const LLVMCodeModelJITDefault: i32 = 1;
const LLVMCodeModelSmall: i32 = 2;
const LLVMCodeModelKernel: i32 = 3;
const LLVMCodeModelMedium: i32 = 4;
const LLVMCodeModelLarge: i32 = 5;

// LLVMCodeGenFileType 枚举值（用于 LLVMTargetMachineEmitToFile）
const LLVMAssemblyFile: i32 = 0;
const LLVMObjectFile: i32 = 1;


// ========== 来自文件: uya-src/arena.uya ==========
// arena.uya - Arena 分配器模块
// 使用静态缓冲区 + bump pointer 实现无堆分配的内存管理

// 内存对齐边界（字节）
const ARENA_ALIGNMENT: i32 = 8;

// Arena 分配器结构体
// 使用静态缓冲区 + bump pointer 实现无堆分配的内存管理
struct Arena {
    buffer: &byte,  // 静态缓冲区指针
    size: i32,      // 缓冲区总大小（字节）
    offset: i32,     // 当前分配位置（bump pointer）
}

// 对齐到指定边界
// 参数：size - 要对齐的大小（必须 >= 0），align - 对齐边界（必须 > 0）
// 返回：对齐后的大小
// 使用除法方式实现对齐（Uya Mini 不支持按位运算符）
// 公式：align_up(value, alignment) = ((value + alignment - 1) / alignment) * alignment
// 注意：调用者必须确保 size >= 0 且 align > 0，否则结果未定义
fn align_size(size: i32, align: i32) i32 {
    return ((size + align - 1) / align) * align;
}

// 初始化 Arena 分配器
// 参数：arena - Arena 结构体指针，buffer - 静态缓冲区，size - 缓冲区大小
// 注意：buffer 必须是一个静态缓冲区（栈上或全局），不能是堆分配的内存
// 注意：buffer 参数使用 &void 类型以支持任意类型的缓冲区指针
fn arena_init(arena: &Arena, buffer: &void, size: i32) void {
    if arena == null {
        return;
    }
    if buffer == null {
        return;
    }
    
    arena.buffer = buffer as &byte;
    arena.size = size;
    arena.offset = 0;
}

// 从 Arena 分配内存
// 参数：arena - Arena 分配器指针，size - 要分配的内存大小（字节）
// 返回：分配的内存指针，如果分配失败（空间不足）返回 null
// 注意：分配的内存会自动对齐到 8 字节边界
fn arena_alloc(arena: &Arena, size: i32) &void {
    if arena == null {
        return null;
    }
    if arena.buffer == null {
        return null;
    }
    
    // 对齐当前的 offset，确保返回的地址是 8 字节对齐的
    const aligned_offset: i32 = align_size(arena.offset, ARENA_ALIGNMENT);
    
    // 对齐请求的大小
    const aligned_size: i32 = align_size(size, ARENA_ALIGNMENT);
    
    // 检查是否有足够空间
    if aligned_offset + aligned_size > arena.size {
        return null;  // 空间不足
    }
    
    // 计算返回的地址（buffer + 对齐后的 offset）
    // 在 Uya Mini 中，使用数组索引访问：&buffer[offset] 来获取偏移后的地址
    // buffer 是 &byte 类型，buffer[aligned_offset] 访问元素，&buffer[aligned_offset] 获取地址
    // 将 &byte 转换为 &void 以支持任意类型的指针返回
    const result: &void = &arena.buffer[aligned_offset] as &void;
    
    // 更新 offset（移动到对齐后的位置 + 分配的大小）
    arena.offset = aligned_offset + aligned_size;
    
    return result;
}

// 重置 Arena 分配器
// 参数：arena - Arena 分配器指针
// 将 bump pointer 重置到开始位置，释放所有已分配的内存
// 注意：不会清除缓冲区内容，只是重置指针
fn arena_reset(arena: &Arena) void {
    if arena == null {
        return;
    }
    
    arena.offset = 0;
}

// ========== 来自文件: uya-src/ast.uya ==========
// ast.uya - AST 数据结构模块
// 定义抽象语法树（AST）的数据结构，用于表示 Uya Mini 程序的语法结构

// 注意：需要先包含 arena.uya 中的 Arena 定义
// 由于 Uya Mini 不支持模块系统，这里假设 Arena 类型已经定义

// ===== 数组容量常量定义 =====
// 用于固定大小数组的容量限制（替代动态指针数组）

const MAX_PROGRAM_DECLS: i32 = 256;        // 程序最大声明数量
const MAX_STRUCT_FIELDS: i32 = 64;          // 结构体最大字段数量
const MAX_FN_PARAMS: i32 = 32;              // 函数最大参数数量
const MAX_CALL_ARGS: i32 = 32;              // 函数调用最大参数数量
const MAX_STRUCT_INIT_FIELDS: i32 = 64;     // 结构体初始化最大字段数量
const MAX_ARRAY_LITERAL_ELEMENTS: i32 = 256;// 数组字面量最大元素数量
const MAX_BLOCK_STMTS: i32 = 512;            // 代码块最大语句数量
const MAX_STRUCT_INIT_FIELD_NAMES: i32 = 64;// 结构体初始化字段名称数组大小

// 枚举变体结构
struct EnumVariant {
    name: &byte,// 变体名称（字符串存储在 Arena 中）
    value: &byte// 显式值（字符串形式，如果指定了 = NUM，否则为 null，存储在 Arena 中）
}

// AST 节点类型枚举
// Uya Mini 仅包含最小子集所需的节点类型
enum ASTNodeType {
    // 声明节点
    AST_PROGRAM,        // 程序节点（根节点）
    AST_ENUM_DECL,      // 枚举声明
    AST_STRUCT_DECL,    // 结构体声明
    AST_FN_DECL,        // 函数声明
    AST_VAR_DECL,       // 变量声明（const/var）
    
    // 语句节点
    AST_IF_STMT,        // if 语句
    AST_WHILE_STMT,     // while 语句
    AST_FOR_STMT,       // for 语句（数组遍历）
    AST_BREAK_STMT,     // break 语句
    AST_CONTINUE_STMT,  // continue 语句
    AST_RETURN_STMT,    // return 语句
    AST_ASSIGN,         // 赋值语句
    AST_EXPR_STMT,      // 表达式语句
    AST_BLOCK,          // 代码块
    
    // 表达式节点
    AST_BINARY_EXPR,    // 二元表达式
    AST_UNARY_EXPR,     // 一元表达式
    AST_CALL_EXPR,      // 函数调用
    AST_MEMBER_ACCESS,  // 字段访问（obj.field）
    AST_ARRAY_ACCESS,   // 数组访问（arr[index]）
    AST_STRUCT_INIT,    // 结构体字面量（StructName{ field: value, ... }）
    AST_ARRAY_LITERAL,  // 数组字面量（[expr1, expr2, ..., exprN]）
    AST_SIZEOF,         // sizeof 表达式（sizeof(Type) 或 sizeof(expr)）
    AST_LEN,            // len 表达式（len(array)）
    AST_ALIGNOF,        // alignof 表达式（alignof(Type) 或 alignof(expr)）
    AST_CAST_EXPR,      // 类型转换表达式（expr as type）
    AST_IDENTIFIER,     // 标识符
    AST_NUMBER,         // 数字字面量
    AST_BOOL,           // 布尔字面量（true/false）
    AST_STRING,         // 字符串字面量
    
    // 类型节点
    AST_TYPE_NAMED,     // 命名类型（i32, bool, void, 或 struct Name）
    AST_TYPE_POINTER,   // 指针类型（&T 或 *T）
    AST_TYPE_ARRAY,     // 数组类型（[T: N]）
}

// 基础 AST 节点结构
// 注意：Uya Mini 不支持 union，因此将所有 union 字段都放在结构体中
// 虽然这会增加内存占用，但可以保持代码简单和类型安全
struct ASTNode {
    type: ASTNodeType,// 节点类型
    line: i32,// 行号
    column: i32,// 列号
    
    // 程序节点数据
    program_decls: [&ASTNode: MAX_PROGRAM_DECLS],// 声明数组（固定大小）
    program_decl_count: i32,// 声明数量
    
    // 枚举声明数据
    enum_decl_name: &byte,// 枚举名称（字符串存储在 Arena 中）
    enum_decl_variants: &EnumVariant,// 变体数组指针（从 Arena 分配）
    enum_decl_variant_count: i32,// 变体数量
    
    // 结构体声明数据
    struct_decl_name: &byte,// 结构体名称（字符串存储在 Arena 中）
    struct_decl_fields: [&ASTNode: MAX_STRUCT_FIELDS],// 字段数组（固定大小）
    struct_decl_field_count: i32,// 字段数量
    
    // 函数声明数据
    fn_decl_name: &byte,// 函数名称
    fn_decl_params: [&ASTNode: MAX_FN_PARAMS],// 参数数组（固定大小）
    fn_decl_param_count: i32,// 参数数量
    fn_decl_return_type: &ASTNode,// 返回类型（类型节点）
    fn_decl_body: &ASTNode,// 函数体（AST_BLOCK 节点）
    fn_decl_is_varargs: i32,// 是否为可变参数函数（1 表示是，0 表示否，仅用于 extern 函数）
    
    // 变量声明数据（用于变量声明、函数参数、结构体字段）
    var_decl_name: &byte,// 变量名称
    var_decl_type: &ASTNode,// 类型节点
    var_decl_init: &ASTNode,// 初始值表达式（可为 null）
    var_decl_is_const: i32,// 1 表示 const，0 表示 var
    
    // 二元表达式数据
    binary_expr_left: &ASTNode,// 左操作数
    binary_expr_op: i32,// 运算符（Token 类型，暂用 i32 表示）
    binary_expr_right: &ASTNode,// 右操作数
    
    // 一元表达式数据
    unary_expr_op: i32,// 运算符（Token 类型）
    unary_expr_operand: &ASTNode,// 操作数
    
    // 函数调用数据
    call_expr_callee: &ASTNode,// 被调用的函数（标识符节点）
    call_expr_args: [&ASTNode: MAX_CALL_ARGS],// 参数表达式数组（固定大小）
    call_expr_arg_count: i32,// 参数数量
    
    // 字段访问数据（obj.field）
    member_access_object: &ASTNode,// 对象表达式
    member_access_field_name: &byte,// 字段名称
    
    // 数组访问数据（arr[index]）
    array_access_array: &ASTNode,// 数组表达式
    array_access_index: &ASTNode,// 索引表达式
    
    // 结构体字面量数据（StructName{ field1: value1, field2: value2 }）
    struct_init_struct_name: &byte,// 结构体名称
    struct_init_field_names: [&byte: MAX_STRUCT_INIT_FIELD_NAMES],// 字段名称数组（固定大小）
    struct_init_field_values: [&ASTNode: MAX_STRUCT_INIT_FIELDS],// 字段值表达式数组（固定大小）
    struct_init_field_count: i32,// 字段数量
    
    // 数组字面量数据（[expr1, expr2, ..., exprN]）
    array_literal_elements: [&ASTNode: MAX_ARRAY_LITERAL_ELEMENTS],// 元素表达式数组（固定大小）
    array_literal_element_count: i32,// 元素数量
    
    // sizeof 表达式数据（sizeof(Type) 或 sizeof(expr)）
    sizeof_expr_target: &ASTNode,// 目标节点（类型节点或表达式节点）
    sizeof_expr_is_type: i32,// 1 表示 target 是类型节点，0 表示 target 是表达式节点
    
    // len 表达式数据（len(array)）
    len_expr_array: &ASTNode,// 数组表达式节点
    
    // alignof 表达式数据（alignof(Type) 或 alignof(expr)）
    alignof_expr_target: &ASTNode,// 目标节点（类型节点或表达式节点）
    alignof_expr_is_type: i32,// 1 表示 target 是类型节点，0 表示 target 是表达式节点
    
    // 类型转换表达式数据（expr as type）
    cast_expr_expr: &ASTNode,// 源表达式
    cast_expr_target_type: &ASTNode,// 目标类型节点
    
    // 标识符数据
    identifier_name: &byte,// 标识符名称
    
    // 数字字面量数据
    number_value: i32,// 数值（i32）
    
    // 布尔字面量数据
    bool_literal_value: i32,// 1 表示 true，0 表示 false
    
    // 字符串字面量数据
    string_literal_value: &byte,// 字符串内容（存储在 Arena 中，不包括引号，包括 null 终止符）
    
    // if 语句数据
    if_stmt_condition: &ASTNode,// 条件表达式
    if_stmt_then_branch: &ASTNode,// then 分支（AST_BLOCK 节点）
    if_stmt_else_branch: &ASTNode,// else 分支（AST_BLOCK 节点，可为 null）
    
    // while 语句数据
    while_stmt_condition: &ASTNode,// 条件表达式
    while_stmt_body: &ASTNode,// 循环体（AST_BLOCK 节点）
    
    // for 语句数据（数组遍历）
    for_stmt_array: &ASTNode,// 数组表达式
    for_stmt_var_name: &byte,// 循环变量名称（存储在 Arena 中）
    for_stmt_is_ref: i32,// 是否为引用迭代（1 表示引用迭代，0 表示值迭代）
    for_stmt_body: &ASTNode,// 循环体（AST_BLOCK 节点）
    
    // return 语句数据
    return_stmt_expr: &ASTNode,// 返回值表达式（可为 null，用于 void 函数）
    
    // 赋值语句数据
    assign_dest: &ASTNode,// 目标表达式（标识符节点）
    assign_src: &ASTNode,// 源表达式
    
    // 代码块数据
    block_stmts: [&ASTNode: MAX_BLOCK_STMTS],// 语句数组（固定大小）
    block_stmt_count: i32,// 语句数量
    
    // 类型节点数据（命名类型：i32, bool, void, struct Name）
    type_named_name: &byte,// 类型名称（"i32", "bool", "void", 或结构体名称）
    
    // 指针类型节点数据（&T 或 *T）
    type_pointer_pointed_type: &ASTNode,// 指向的类型节点（从 Arena 分配）
    type_pointer_is_ffi_pointer: i32,// 是否为 FFI 指针（1 表示 *T，0 表示 &T）
    
    // 数组类型节点数据（[T: N]）
    type_array_element_type: &ASTNode,// 元素类型节点（从 Arena 分配）
    type_array_size_expr: &ASTNode// 数组大小表达式节点（必须是编译期常量，从 Arena 分配）
}

// 创建新的 AST 节点
// 参数：type - 节点类型，line - 行号，column - 列号，arena - Arena 分配器
// 返回：新创建的 AST 节点指针，失败返回 null
fn ast_new_node(type: ASTNodeType, line: i32, column: i32, arena: &Arena) &ASTNode {
    if arena == null {
        return null;
    }
    
    // 从 Arena 分配器分配节点内存
    const node: &ASTNode = arena_alloc(arena, sizeof(ASTNode)) as &ASTNode;
    if node == null {
        return null;
    }
    
    // 初始化节点基本字段
    node.type = type;
    node.line = line;
    node.column = column;
    
    // 声明循环变量（在函数作用域内）
    var i: i32 = 0;
    
    // 根据节点类型初始化相应的数据字段
    // 注意：所有指针字段初始化为 null，数组字段初始化为空数组（所有元素为 null）和 0
    if type == AST_PROGRAM {
        // 初始化数组为全 null（空数组）
        i = 0;
        while i < MAX_PROGRAM_DECLS {
            node.program_decls[i] = null;
            i = i + 1;
        }
        node.program_decl_count = 0;
    } else if type == AST_ENUM_DECL {
        node.enum_decl_variant_count = 0;
    } else if type == AST_STRUCT_DECL {
        i = 0;
        while i < MAX_STRUCT_FIELDS {
            node.struct_decl_fields[i] = null;
            i = i + 1;
        }
        node.struct_decl_field_count = 0;
    } else if type == AST_FN_DECL {
        i = 0;
        while i < MAX_FN_PARAMS {
            node.fn_decl_params[i] = null;
            i = i + 1;
        }
        node.fn_decl_param_count = 0;
        node.fn_decl_return_type = null;
        node.fn_decl_body = null;
    } else if type == AST_VAR_DECL {
        node.var_decl_init = null;
        node.var_decl_is_const = 0;
    } else if type == AST_BINARY_EXPR {
        node.binary_expr_right = null;
    } else if type == AST_UNARY_EXPR {
    } else if type == AST_CALL_EXPR {
        i = 0;
        while i < MAX_CALL_ARGS {
            node.call_expr_args[i] = null;
            i = i + 1;
        }
        node.call_expr_arg_count = 0;
    } else if type == AST_MEMBER_ACCESS {
    } else if type == AST_ARRAY_ACCESS {
    } else if type == AST_STRUCT_INIT {
        i = 0;
        while i < MAX_STRUCT_INIT_FIELD_NAMES {
            node.struct_init_field_names[i] = null;
            i = i + 1;
        }
        i = 0;
        while i < MAX_STRUCT_INIT_FIELDS {
            node.struct_init_field_values[i] = null;
            i = i + 1;
        }
        node.struct_init_field_count = 0;
    } else if type == AST_ARRAY_LITERAL {
        while i < MAX_ARRAY_LITERAL_ELEMENTS {
            node.array_literal_elements[i] = null;
            i = i + 1;
        }
        node.array_literal_element_count = 0;
    } else if type == AST_SIZEOF {
    } else if type == AST_ALIGNOF {
    } else if type == AST_LEN {
    } else if type == AST_CAST_EXPR {
        node.cast_expr_target_type = null;
    } else if type == AST_IDENTIFIER {
    } else if type == AST_NUMBER {
    } else if type == AST_BOOL {
    } else if type == AST_STRING {
    } else if type == AST_IF_STMT {
        node.if_stmt_else_branch = null;
    } else if type == AST_WHILE_STMT {
    } else if type == AST_FOR_STMT {
        node.for_stmt_is_ref = 0;
        node.for_stmt_body = null;
    } else if type == AST_RETURN_STMT {
    } else if type == AST_BREAK_STMT {
    } else if type == AST_CONTINUE_STMT {
    } else if type == AST_ASSIGN {
        node.assign_src = null;
    } else if type == AST_EXPR_STMT {
    } else if type == AST_BLOCK {
        i = 0;
        while i < MAX_BLOCK_STMTS {
            node.block_stmts[i] = null;
            i = i + 1;
        }
        node.block_stmt_count = 0;
    } else if type == AST_TYPE_NAMED {
    } else if type == AST_TYPE_POINTER {
        node.type_pointer_is_ffi_pointer = 0;
    } else if type == AST_TYPE_ARRAY {
    }
    
    return node;
}

// ========== 来自文件: uya-src/lexer.uya ==========
// lexer.uya - 词法分析器模块
// 将源代码转换为 Token 序列，用于语法分析器

// 注意：需要先包含 arena.uya 和 str_utils.uya
// 由于 Uya Mini 不支持模块系统，这里假设 Arena 类型已经定义

// ===== Token 类型枚举 =====

// Token 类型枚举
// Uya Mini 仅包含最小子集需要的 Token 类型
enum TokenType {
    // 基础 Token
    TOKEN_EOF,          // 文件结束
    TOKEN_IDENTIFIER,   // 标识符
    TOKEN_NUMBER,       // 数字字面量
    TOKEN_STRING,       // 字符串字面量
    
    // 关键字
    TOKEN_ENUM,         // enum
    TOKEN_STRUCT,       // struct
    TOKEN_CONST,        // const
    TOKEN_VAR,          // var
    TOKEN_FN,           // fn
    TOKEN_EXTERN,       // extern
    TOKEN_RETURN,       // return
    TOKEN_IF,           // if
    TOKEN_ELSE,         // else
    TOKEN_WHILE,        // while
    TOKEN_FOR,          // for
    TOKEN_BREAK,        // break
    TOKEN_CONTINUE,     // continue
    TOKEN_TRUE,         // true
    TOKEN_FALSE,        // false
    TOKEN_NULL,         // null（空指针字面量）
    TOKEN_SIZEOF,       // sizeof
    TOKEN_LEN,          // len
    TOKEN_ALIGNOF,      // alignof
    TOKEN_AS,           // as（类型转换关键字）
    
    // 运算符
    TOKEN_PLUS,         // +
    TOKEN_MINUS,        // -
    TOKEN_ASTERISK,     // *
    TOKEN_SLASH,        // /
    TOKEN_PERCENT,      // %
    TOKEN_EQUAL,        // ==
    TOKEN_NOT_EQUAL,    // !=
    TOKEN_LESS,         // <
    TOKEN_GREATER,      // >
    TOKEN_LESS_EQUAL,   // <=
    TOKEN_GREATER_EQUAL,// >=
    TOKEN_LOGICAL_AND,  // &&
    TOKEN_LOGICAL_OR,   // ||
    TOKEN_EXCLAMATION,  // !
    TOKEN_AMPERSAND,    // &（取地址运算符）
    
    // 标点符号
    TOKEN_LEFT_PAREN,   // (
    TOKEN_RIGHT_PAREN,  // )
    TOKEN_LEFT_BRACE,   // {
    TOKEN_RIGHT_BRACE,  // }
    TOKEN_LEFT_BRACKET, // [
    TOKEN_RIGHT_BRACKET,// ]
    TOKEN_SEMICOLON,    // ;
    TOKEN_COMMA,        // ,
    TOKEN_ASSIGN,       // =
    TOKEN_DOT,          // .
    TOKEN_COLON,        // :
    TOKEN_PIPE,         // |（用于 for 循环）
    TOKEN_ELLIPSIS,     // ...（可变参数，用于 extern 函数声明）
}

// ===== Token 结构体 =====

// Token 结构体
// 字符串值存储在 Arena 中，不分配堆内存
struct Token {
    type: TokenType,// Token 类型
    value: &byte,// Token 值（字符串，存储在 Arena 中，可为 null）
    line: i32,// 行号
    column: i32// 列号
}

// ===== Lexer 结构体 =====

// 缓冲区大小常量（1MB）
const LEXER_BUFFER_SIZE: i32 = 1048576;  // 1024 * 1024

// Lexer 结构体
// 使用固定大小缓冲区，不分配堆内存
// 注意：buffer 使用指针，由调用者提供缓冲区
struct Lexer {
    buffer: &byte,// 源代码缓冲区指针
    buffer_size: i32,// 缓冲区实际大小（字节数）
    position: i32,// 当前读取位置
    line: i32,// 当前行号（从1开始）
    column: i32,// 当前列号（从1开始）
    filename: &byte// 文件名（存储在 Arena 中，可为 null）
}

// ===== 外部函数声明 =====

// 内存复制函数（string.h）
extern fn memcpy(dest: &byte, src: &byte, n: i32) &void;

// 字符串函数（来自 str_utils.uya）
extern fn strlen(s: *byte) i32;
extern fn strcmp(s1: *byte, s2: *byte) i32;
extern fn isalpha(c: i32) i32;
extern fn isdigit(c: i32) i32;
extern fn isalnum(c: i32) i32;

// Arena 函数（来自 arena.uya）
// 注意：假设 Arena 类型已定义
extern fn arena_alloc(arena: &Arena, size: i32) &void;

// ===== 辅助函数 =====

// 辅助函数：查看指定偏移的字符
// 参数：lexer - Lexer 指针，offset - 相对于当前位置的偏移
// 返回：字符（如果超出范围返回 0）
fn peek_char(lexer: &Lexer, offset: i32) i32 {
    if lexer == null {
        return 0;
    }
    
    const pos: i32 = lexer.position + offset;
    if pos >= lexer.buffer_size {
        return 0;
    }
    
    return lexer.buffer[pos] as i32;
}

// 辅助函数：前进一个字符，更新位置信息
// 参数：lexer - Lexer 指针
// 返回：当前字符（如果超出范围返回 0）
fn advance_char(lexer: &Lexer) i32 {
    if lexer == null {
        return 0;
    }
    if lexer.position >= lexer.buffer_size {
        return 0;
    }
    
    const c: i32 = lexer.buffer[lexer.position] as i32;
    lexer.position = lexer.position + 1;
    
    if c == 10 {  // '\n'
        lexer.line = lexer.line + 1;
        lexer.column = 1;
    } else {
        lexer.column = lexer.column + 1;
    }
    
    return c;
}

// 跳过空白字符和注释
// 参数：lexer - Lexer 指针
fn skip_whitespace_and_comments(lexer: &Lexer) void {
    if lexer == null {
        return;
    }
    
    while lexer.position < lexer.buffer_size {
        const c: i32 = peek_char(lexer, 0);
        if c == 32 || c == 9 || c == 13 || c == 10 {  // ' ', '\t', '\r', '\n'
            advance_char(lexer);
        } else if c == 47 && peek_char(lexer, 1) == 47 {  // '/' && '/'
            // 单行注释：跳过到行尾
            while lexer.position < lexer.buffer_size && peek_char(lexer, 0) != 10 {
                advance_char(lexer);
            }
        } else {
            break;
        }
    }
}

// 检查是否为关键字
// 参数：str - 字符串指针（*byte 类型用于 extern 函数）
// 返回：如果是关键字返回对应的 TokenType，否则返回 TOKEN_IDENTIFIER
fn is_keyword(str: *byte) TokenType {
    if strcmp(str, "enum") == 0 {
        return TOKEN_ENUM;
    }
    if strcmp(str, "struct") == 0 {
        return TOKEN_STRUCT;
    }
    if strcmp(str, "const") == 0 {
        return TOKEN_CONST;
    }
    if strcmp(str, "var") == 0 {
        return TOKEN_VAR;
    }
    if strcmp(str, "fn") == 0 {
        return TOKEN_FN;
    }
    if strcmp(str, "extern") == 0 {
        return TOKEN_EXTERN;
    }
    if strcmp(str, "return") == 0 {
        return TOKEN_RETURN;
    }
    if strcmp(str, "if") == 0 {
        return TOKEN_IF;
    }
    if strcmp(str, "else") == 0 {
        return TOKEN_ELSE;
    }
    if strcmp(str, "while") == 0 {
        return TOKEN_WHILE;
    }
    if strcmp(str, "for") == 0 {
        return TOKEN_FOR;
    }
    if strcmp(str, "break") == 0 {
        return TOKEN_BREAK;
    }
    if strcmp(str, "continue") == 0 {
        return TOKEN_CONTINUE;
    }
    if strcmp(str, "true") == 0 {
        return TOKEN_TRUE;
    }
    if strcmp(str, "false") == 0 {
        return TOKEN_FALSE;
    }
    if strcmp(str, "null") == 0 {
        return TOKEN_NULL;
    }
    if strcmp(str, "sizeof") == 0 {
        return TOKEN_SIZEOF;
    }
    if strcmp(str, "len") == 0 {
        return TOKEN_LEN;
    }
    if strcmp(str, "alignof") == 0 {
        return TOKEN_ALIGNOF;
    }
    if strcmp(str, "as") == 0 {
        return TOKEN_AS;
    }
    
    return TOKEN_IDENTIFIER;  // 不是关键字，是标识符
}

// 从字符串字面量（*byte）复制到 Arena
// 参数：arena - Arena 分配器，str - 字符串字面量（*byte 类型）
// 返回：复制后的字符串指针（存储在 Arena 中），失败返回 null
fn arena_strdup_from_literal(arena: &Arena, str: *byte) &byte {
    if arena == null || str == null {
        return null;
    }
    
    // 计算字符串长度
    const str_len: i32 = strlen(str);
    
    // 分配 str_len + 1 字节（包括 null 终止符）
    const result: &byte = arena_alloc(arena, str_len + 1) as &byte;
    if result == null {
        return null;
    }
    
    // 复制字符串内容
    var i: i32 = 0;
    while i < str_len {
        result[i] = (str as &byte)[i];
        i = i + 1;
    }
    result[str_len] = 0;  // null 终止符
    
    return result;
}

// 从 Arena 复制字符串
// 参数：arena - Arena 分配器，start - 字符串起始位置，str_len - 字符串长度
// 返回：复制后的字符串指针（存储在 Arena 中），失败返回 null
fn arena_strdup(arena: &Arena, start: &byte, str_len: i32) &byte {
    if arena == null {
        return null;
    }
    if start == null {
        return null;
    }
    
    // 分配 str_len + 1 字节（包括 null 终止符）
    const result: &byte = arena_alloc(arena, str_len + 1) as &byte;
    if result == null {
        return null;
    }
    
    // 复制字符串内容
    var i: i32 = 0;
    while i < str_len {
        result[i] = start[i];
        i = i + 1;
    }
    result[str_len] = 0;  // null 终止符
    
    return result;
}

// 创建 Token
// 参数：arena - Arena 分配器，type - Token 类型，value - Token 值（字符串，存储在 Arena 中，可为 null），line - 行号，column - 列号
// 返回：Token 指针（从 Arena 分配），失败返回 null
fn make_token(arena: &Arena, type: TokenType, value: &byte, line: i32, column: i32) &Token {
    if arena == null {
        return null;
    }
    
    const token: &Token = arena_alloc(arena, 16) as &Token;  // Token 结构体大小约为 16 字节
    if token == null {
        return null;
    }
    
    token.type = type;
    token.value = value;  // value 已经在 Arena 中
    token.line = line;
    token.column = column;
    
    return token;
}

// 读取标识符或关键字
// 参数：lexer - Lexer 指针，arena - Arena 分配器
// 返回：标识符或关键字 Token，失败返回 null
fn read_identifier_or_keyword(lexer: &Lexer, arena: &Arena) &Token {
    if lexer == null || arena == null {
        return null;
    }
    
    const start_pos: i32 = lexer.position;  // 保存开始位置
    const start: &byte = &lexer.buffer[start_pos];
    const line: i32 = lexer.line;
    const column: i32 = lexer.column;
    
    // 读取标识符字符
    while lexer.position < lexer.buffer_size {
        const c: i32 = peek_char(lexer, 0);
        if isalnum(c) != 0 || c == 95 {  // isalnum(c) || c == '_'
            advance_char(lexer);
        } else {
            break;
        }
    }
    
    const str_len: i32 = lexer.position - start_pos;  // 使用位置差计算长度
    const value: &byte = arena_strdup(arena, start, str_len);
    if value == null {
        return null;
    }
    
    // 检查是否为关键字
    const type: TokenType = is_keyword(value as *byte);
    
    return make_token(arena, type, value, line, column);
}

// 读取数字字面量
// 参数：lexer - Lexer 指针，arena - Arena 分配器
// 返回：数字字面量 Token，失败返回 null
fn read_number(lexer: &Lexer, arena: &Arena) &Token {
    if lexer == null || arena == null {
        return null;
    }
    
    const start_pos: i32 = lexer.position;  // 保存开始位置
    const start: &byte = &lexer.buffer[start_pos];
    const line: i32 = lexer.line;
    const column: i32 = lexer.column;
    
    // 读取数字（仅支持整数）
    while lexer.position < lexer.buffer_size {
        const c: i32 = peek_char(lexer, 0);
        if isdigit(c) != 0 {
            advance_char(lexer);
        } else {
            break;
        }
    }
    
    const str_len: i32 = lexer.position - start_pos;  // 使用位置差计算长度
    const value: &byte = arena_strdup(arena, start, str_len);
    if value == null {
        return null;
    }
    
    return make_token(arena, TOKEN_NUMBER, value, line, column);
}

// 读取字符串字面量
// 参数：lexer - Lexer 指针，arena - Arena 分配器
// 返回：字符串字面量 Token，失败返回 null
// 注意：Uya Mini 字符串字面量不支持转义序列，仅支持普通字符
fn read_string(lexer: &Lexer, arena: &Arena) &Token {
    if lexer == null || arena == null {
        return null;
    }
    
    const line: i32 = lexer.line;
    const column: i32 = lexer.column;
    
    // 消费开始的引号
    advance_char(lexer);
    
    const start_pos: i32 = lexer.position;  // 保存开始位置
    const start: &byte = &lexer.buffer[start_pos];
    
    // 读取字符串内容（直到遇到结束引号）
    while lexer.position < lexer.buffer_size {
        const c: i32 = peek_char(lexer, 0);
        if c == 0 {  // '\0'
            // 文件结束，字符串未闭合
            return null;
        }
        if c == 34 {  // '"'
            // 遇到结束引号
            break;
        }
        if c == 10 {  // '\n'
            // 字符串字面量不能跨行（Uya Mini 不支持转义序列）
            return null;
        }
        advance_char(lexer);
    }
    
    // 检查是否找到了结束引号
    if lexer.position >= lexer.buffer_size || peek_char(lexer, 0) != 34 {  // '"'
        // 字符串未闭合
        return null;
    }
    
    // 计算字符串长度（不包括引号）
    const str_len: i32 = lexer.position - start_pos;  // 使用位置差计算长度
    
    // 复制字符串内容到 Arena（包括 null 终止符）
    const value: &byte = arena_strdup(arena, start, str_len);
    if value == null {
        return null;
    }
    
    // 消费结束引号
    advance_char(lexer);
    
    return make_token(arena, TOKEN_STRING, value, line, column);
}

// ===== 主要函数 =====

// 初始化 Lexer
// 参数：lexer - Lexer 结构体指针（由调用者提供，栈上或静态分配），source - 源代码字符串（*byte 类型用于 extern 函数），source_len - 源代码长度，filename - 文件名（存储在 Arena 中），arena - Arena 分配器
// 返回：成功返回 0，失败返回 -1
// 注意：Lexer 结构体由调用者在栈上或静态分配，此函数只负责初始化
// 注意：buffer 需要由调用者提供，此函数只是设置指针
fn lexer_init(lexer: &Lexer, source: *byte, source_len: i32, filename: *byte, arena: &Arena) i32 {
    if lexer == null || source == null || arena == null {
        return -1;
    }
    
    // 检查源代码长度是否超过缓冲区大小
    if source_len >= LEXER_BUFFER_SIZE {
        return -1;  // 源代码太长
    }
    
    // 设置缓冲区指针（调用者需要确保 source 指向有效的缓冲区）
    lexer.buffer = source as &byte;
    lexer.buffer_size = source_len;
    
    // 初始化位置信息
    lexer.position = 0;
    lexer.line = 1;
    lexer.column = 1;
    
    // 复制文件名到 Arena
    if filename != null {
        const filename_len: i32 = strlen(filename) + 1;
        const filename_copy: &byte = arena_alloc(arena, filename_len) as &byte;
        if filename_copy == null {
            return -1;
        }
        // 复制文件名（使用循环）
        var i: i32 = 0;
        while i < filename_len {
            filename_copy[i] = (filename as &byte)[i];
            i = i + 1;
        }
        lexer.filename = filename_copy;
    } else {
        lexer.filename = null;
    }
    
    return 0;
}

// 获取下一个 Token
// 参数：lexer - Lexer 指针，arena - Arena 分配器（用于存储 Token 和字符串值）
// 返回：下一个 Token 指针（从 Arena 分配），文件结束返回 TOKEN_EOF 类型的 Token
fn lexer_next_token(lexer: &Lexer, arena: &Arena) &Token {
    if lexer == null || arena == null {
        return null;
    }
    
    // 跳过空白字符和注释
    skip_whitespace_and_comments(lexer);
    
    // 检查是否到达文件末尾
    if lexer.position >= lexer.buffer_size {
        return make_token(arena, TOKEN_EOF, null, lexer.line, lexer.column);
    }
    
    const c: i32 = peek_char(lexer, 0);
    const line: i32 = lexer.line;
    const column: i32 = lexer.column;
    
    // 根据第一个字符判断 Token 类型
    if c == 43 {  // '+'
        advance_char(lexer);
        return make_token(arena, TOKEN_PLUS, arena_strdup_from_literal(arena, "+"), line, column);
    } else if c == 45 {  // '-'
        advance_char(lexer);
        return make_token(arena, TOKEN_MINUS, arena_strdup_from_literal(arena, "-"), line, column);
    } else if c == 42 {  // '*'
        advance_char(lexer);
        return make_token(arena, TOKEN_ASTERISK, arena_strdup_from_literal(arena, "*"), line, column);
    } else if c == 47 {  // '/'
        advance_char(lexer);
        return make_token(arena, TOKEN_SLASH, arena_strdup_from_literal(arena, "/"), line, column);
    } else if c == 37 {  // '%'
        advance_char(lexer);
        return make_token(arena, TOKEN_PERCENT, arena_strdup_from_literal(arena, "%"), line, column);
    } else if c == 61 {  // '='
        advance_char(lexer);
        if peek_char(lexer, 0) == 61 {  // '=='
            advance_char(lexer);
            return make_token(arena, TOKEN_EQUAL, arena_strdup_from_literal(arena, "=="), line, column);
        }
        return make_token(arena, TOKEN_ASSIGN, arena_strdup_from_literal(arena, "="), line, column);
    } else if c == 33 {  // '!'
        advance_char(lexer);
        if peek_char(lexer, 0) == 61 {  // '!='
            advance_char(lexer);
            return make_token(arena, TOKEN_NOT_EQUAL, arena_strdup_from_literal(arena, "!="), line, column);
        }
        return make_token(arena, TOKEN_EXCLAMATION, arena_strdup_from_literal(arena, "!"), line, column);
    } else if c == 60 {  // '<'
        advance_char(lexer);
        if peek_char(lexer, 0) == 61 {  // '<='
            advance_char(lexer);
            return make_token(arena, TOKEN_LESS_EQUAL, arena_strdup_from_literal(arena, "<="), line, column);
        }
        return make_token(arena, TOKEN_LESS, arena_strdup_from_literal(arena, "<"), line, column);
    } else if c == 62 {  // '>'
        advance_char(lexer);
        if peek_char(lexer, 0) == 61 {  // '>='
            advance_char(lexer);
            return make_token(arena, TOKEN_GREATER_EQUAL, arena_strdup_from_literal(arena, ">="), line, column);
        }
        return make_token(arena, TOKEN_GREATER, arena_strdup_from_literal(arena, ">"), line, column);
    } else if c == 38 {  // '&'
        advance_char(lexer);
        if peek_char(lexer, 0) == 38 {  // '&&'
            advance_char(lexer);
            return make_token(arena, TOKEN_LOGICAL_AND, arena_strdup_from_literal(arena, "&&"), line, column);
        }
        // 单个 & 是取地址运算符
        return make_token(arena, TOKEN_AMPERSAND, arena_strdup_from_literal(arena, "&"), line, column);
    } else if c == 124 {  // '|'
        advance_char(lexer);
        if peek_char(lexer, 0) == 124 {  // '||'
            advance_char(lexer);
            return make_token(arena, TOKEN_LOGICAL_OR, arena_strdup_from_literal(arena, "||"), line, column);
        }
        // 单个 | 用于 for 循环（for expr | ID | { ... }）
        return make_token(arena, TOKEN_PIPE, arena_strdup_from_literal(arena, "|"), line, column);
    } else if c == 40 {  // '('
        advance_char(lexer);
        return make_token(arena, TOKEN_LEFT_PAREN, arena_strdup_from_literal(arena, "("), line, column);
    } else if c == 41 {  // ')'
        advance_char(lexer);
        return make_token(arena, TOKEN_RIGHT_PAREN, arena_strdup_from_literal(arena, ")"), line, column);
    } else if c == 123 {  // '{'
        advance_char(lexer);
        return make_token(arena, TOKEN_LEFT_BRACE, arena_strdup_from_literal(arena, "{"), line, column);
    } else if c == 125 {  // '}'
        advance_char(lexer);
        return make_token(arena, TOKEN_RIGHT_BRACE, arena_strdup_from_literal(arena, "}"), line, column);
    } else if c == 91 {  // '['
        advance_char(lexer);
        return make_token(arena, TOKEN_LEFT_BRACKET, arena_strdup_from_literal(arena, "["), line, column);
    } else if c == 93 {  // ']'
        advance_char(lexer);
        return make_token(arena, TOKEN_RIGHT_BRACKET, arena_strdup_from_literal(arena, "]"), line, column);
    } else if c == 59 {  // ';'
        advance_char(lexer);
        return make_token(arena, TOKEN_SEMICOLON, arena_strdup_from_literal(arena, ";"), line, column);
    } else if c == 44 {  // ','
        advance_char(lexer);
        return make_token(arena, TOKEN_COMMA, arena_strdup_from_literal(arena, ","), line, column);
    } else if c == 46 {  // '.'
        advance_char(lexer);
        // 检查是否为 ...（可变参数）
        if peek_char(lexer, 0) == 46 && peek_char(lexer, 1) == 46 {  // '.' && '.'
            advance_char(lexer);  // 消费第二个 .
            advance_char(lexer);  // 消费第三个 .
            return make_token(arena, TOKEN_ELLIPSIS, arena_strdup_from_literal(arena, "..."), line, column);
        }
        return make_token(arena, TOKEN_DOT, arena_strdup_from_literal(arena, "."), line, column);
    } else if c == 58 {  // ':'
        advance_char(lexer);
        return make_token(arena, TOKEN_COLON, arena_strdup_from_literal(arena, ":"), line, column);
    } else if c == 34 {  // '"'
        // 字符串字面量
        return read_string(lexer, arena);
    } else {
        if isalpha(c) != 0 || c == 95 {  // isalpha(c) || c == '_'
            return read_identifier_or_keyword(lexer, arena);
        } else if isdigit(c) != 0 {
            return read_number(lexer, arena);
        } else {
            // 未知字符，跳过并返回错误（这里返回 EOF 作为错误标记）
            advance_char(lexer);
            return make_token(arena, TOKEN_EOF, null, line, column);
        }
    }
}
// ========== 来自文件: uya-src/parser.uya ==========
// parser.uya - 语法分析器模块
// 将 Token 序列转换为抽象语法树（AST）
// 
// 注意：需要先包含 arena.uya、lexer.uya、ast.uya 和 str_utils.uya
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 数组容量常量定义 =====
// 用于解析过程中的临时数组（替代动态指针数组）
const PARSER_MAX_STMTS: i32 = 512;          // 代码块最大语句数量
const PARSER_MAX_FIELDS: i32 = 64;           // 结构体最大字段数量
const PARSER_MAX_PARAMS: i32 = 32;           // 函数最大参数数量
const PARSER_MAX_DECLS: i32 = 256;           // 程序最大声明数量
const PARSER_MAX_CALL_ARGS: i32 = 32;        // 函数调用最大参数数量
const PARSER_MAX_STRUCT_INIT_FIELDS: i32 = 64; // 结构体初始化最大字段数量
const PARSER_MAX_ARRAY_ELEMENTS: i32 = 256;   // 数组字面量最大元素数量

// ===== 外部函数声明 =====

// 字符串函数（来自 str_utils.uya）
extern fn strlen(s: *byte) i32;
extern fn strcmp(s1: *byte, s2: *byte) i32;
extern fn fprintf(stream: *void, format: *byte, ...) i32;

// 内存复制函数（string.h）
extern fn memcpy(dest: &byte, src: &byte, n: i32) &void;

// 字符串转整数函数（stdlib.h）
extern fn atoi(s: *byte) i32;

// Arena 函数（来自 arena.uya）
// 注意：假设 Arena 类型已定义
extern fn arena_alloc(arena: &Arena, size: i32) &void;

// AST 函数（来自 ast.uya）
// 注意：假设 ASTNode, ASTNodeType 类型已定义
extern fn ast_new_node(type: ASTNodeType, line: i32, column: i32, arena: &Arena) &ASTNode;

// Lexer 函数（来自 lexer.uya）
// 注意：假设 Lexer, Token, TokenType 类型已定义
extern fn lexer_next_token(lexer: &Lexer, arena: &Arena) &Token;

// 字符串辅助函数（来自 lexer.uya）
// 注意：这些函数在 lexer.uya 中定义，但这里可能需要使用
extern fn arena_strdup_from_literal(arena: &Arena, str: *byte) &byte;
extern fn arena_strdup(arena: &Arena, start: &byte, str_len: i32) &byte;

// 标准错误输出（stderr）
// 注意：在 C 中，stderr 是一个 FILE* 指针，在 Uya Mini 中使用 *void 表示
// 通常 stderr 的值是 2（文件描述符），但作为 FILE* 指针，这里使用 extern 声明
// 实际上，fprintf 的第一个参数是 *void，可以直接传递数值
// 在实现时，如果需要，可以使用 extern 声明，或者直接使用数值 2
// 为了简化，这里不声明 stderr，在代码中直接使用数值常量（通过注释说明）

// ===== Parser 结构体 =====

// 语法分析器结构体
// 使用 Lexer 读取 Token，构建 AST
// 注意：假设 Lexer, Token, Arena 类型已定义
struct Parser {
    lexer: &Lexer,// 词法分析器指针（由调用者提供，不分配）
    current_token: &Token,// 当前 Token（从 Arena 分配）
    arena: &Arena// Arena 分配器（用于分配 Token 和 AST 节点）
}

// ===== 基础函数 =====

// 初始化 Parser
// 参数：parser - Parser 结构体指针（由调用者提供），lexer - Lexer 指针，arena - Arena 分配器
// 返回：成功返回 0，失败返回 -1
// 注意：Parser 结构体由调用者在栈上或静态分配，此函数只负责初始化
fn parser_init(parser: &Parser, lexer: &Lexer, arena: &Arena) i32 {
    if parser == null || lexer == null || arena == null {
        return -1;
    }
    
    parser.lexer = lexer;
    parser.arena = arena;
    
    // 获取第一个 Token
    parser.current_token = lexer_next_token(lexer, arena);
    
    return 0;
}

// 辅助函数：检查当前 Token 类型是否匹配
// 参数：parser - Parser 指针，type - Token 类型
// 返回：匹配返回 1，不匹配返回 0
fn parser_match(parser: &Parser, type: TokenType) i32 {
    if parser == null || parser.current_token == null {
        return 0;
    }
    if parser.current_token.type == type {
        return 1;
    }
    return 0;
}

// 辅助函数：消费当前 Token 并获取下一个
// 参数：parser - Parser 指针
// 返回：当前 Token 指针，失败返回 null
fn parser_consume(parser: &Parser) &Token {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const current: &Token = parser.current_token;
    parser.current_token = lexer_next_token(parser.lexer, parser.arena);
    return current;
}

// 辅助函数：期望特定类型的 Token
// 参数：parser - Parser 指针，type - Token 类型
// 返回：匹配的 Token 指针，不匹配返回 null
fn parser_expect(parser: &Parser, type: TokenType) &Token {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    if parser.current_token.type != type {
        // 错误：期望的类型不匹配
        return null;
    }
    
    return parser_consume(parser);
}

// 辅助函数：检查当前 token（'{'）后面是否是结构体字段初始化列表的开始
// 结构体字段初始化列表格式：identifier: expr 或 }
// 注意：调用此函数时，parser.current_token 应该是 '{'
// 参数：parser - Parser 指针
// 返回：是结构体初始化返回 1，否则返回 0
fn parser_peek_is_struct_init(parser: &Parser) i32 {
    if parser == null || parser.lexer == null || parser.current_token == null {
        return 0;
    }
    
    if parser.current_token.type != TOKEN_LEFT_BRACE {
        return 0;
    }
    
    // 保存 lexer 状态（当前 lexer 的 position 已经在 '{' 之后）
    const lexer: &Lexer = parser.lexer;
    const saved_position: i32 = lexer.position;
    const saved_line: i32 = lexer.line;
    const saved_column: i32 = lexer.column;
    
    // 获取 '{' 后面的 token（lexer_next_token 会跳过空白字符和注释）
    const after_brace: &Token = lexer_next_token(lexer, parser.arena);
    
    if after_brace == null {
        // 恢复状态
        lexer.position = saved_position;
        lexer.line = saved_line;
        lexer.column = saved_column;
        return 0;
    }
    
    const token_type: TokenType = after_brace.type;
    var is_struct_init: i32 = 0;
    
    // 只检查 identifier: 模式，不检查空的 {}（因为空代码块 {} 和空结构体字面量 {} 无法区分）
    if token_type == TOKEN_IDENTIFIER {
        // 检查标识符后面是否有 ':'
        const saved_position2: i32 = lexer.position;
        const saved_line2: i32 = lexer.line;
        const saved_column2: i32 = lexer.column;
        
        const after_identifier: &Token = lexer_next_token(lexer, parser.arena);
        if after_identifier != null && after_identifier.type == TOKEN_COLON {
            is_struct_init = 1;
        }
        
        // 恢复状态到标识符之前
        lexer.position = saved_position2;
        lexer.line = saved_line2;
        lexer.column = saved_column2;
    }
    
    // 恢复 lexer 状态到 '{' 之后
    lexer.position = saved_position;
    lexer.line = saved_line;
    lexer.column = saved_column;
    
    return is_struct_init;
}

// 从 Arena 复制字符串
// 参数：arena - Arena 分配器，src - 源字符串（&byte 类型，存储在 Arena 中）
// 返回：复制后的字符串指针（存储在 Arena 中），失败返回 null
// 注意：此函数用于复制 token.value，使用 strlen 计算长度，然后使用 arena_strdup
fn arena_strdup_for_parser(arena: &Arena, src: &byte) &byte {
    if arena == null || src == null {
        return null;
    }
    
    // 计算字符串长度
    const str_len: i32 = strlen(src as *byte);
    
    // 使用 arena_strdup 复制字符串
    return arena_strdup(arena, src, str_len);
}

// ===== 类型解析函数 =====

// 解析类型（支持命名类型、指针类型和数组类型）
// type = named_type | pointer_type | array_type
// named_type = ID
// pointer_type = '&' type | '*' type
// array_type = '[' type ':' expr ']'
// 参数：parser - Parser 指针
// 返回：类型节点，失败返回 null
// 注意：此函数递归调用 parser_parse_type 和 parser_parse_expression
fn parser_parse_type(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 检查是否是指针类型（&Type 或 *Type）
    if parser.current_token.type == TOKEN_AMPERSAND {
        // 普通指针类型 &Type
        parser_consume(parser);  // 消费 '&'
        
        // 递归解析指向的类型
        const pointed_type: &ASTNode = parser_parse_type(parser);
        if pointed_type == null {
            return null;
        }
        
        // 创建指针类型节点
        const pointer_type: &ASTNode = ast_new_node(AST_TYPE_POINTER, line, column, parser.arena);
        if pointer_type == null {
            return null;
        }
        
        pointer_type.type_pointer_pointed_type = pointed_type;
        pointer_type.type_pointer_is_ffi_pointer = 0;  // 普通指针
        
        return pointer_type;
    } else if parser.current_token.type == TOKEN_ASTERISK {
        // FFI 指针类型 *Type（仅用于 extern 函数）
        parser_consume(parser);  // 消费 '*'
        
        // 递归解析指向的类型
        const pointed_type: &ASTNode = parser_parse_type(parser);
        if pointed_type == null {
            return null;
        }
        
        // 创建 FFI 指针类型节点
        const pointer_type: &ASTNode = ast_new_node(AST_TYPE_POINTER, line, column, parser.arena);
        if pointer_type == null {
            return null;
        }
        
        pointer_type.type_pointer_pointed_type = pointed_type;
        pointer_type.type_pointer_is_ffi_pointer = 1;  // FFI 指针
        
        return pointer_type;
    } else if parser.current_token.type == TOKEN_LEFT_BRACKET {
        // 数组类型 [Type: Size]
        parser_consume(parser);  // 消费 '['
        
        // 解析元素类型
        const element_type: &ASTNode = parser_parse_type(parser);
        if element_type == null {
            return null;
        }
        
        // 期望 ':'
        if parser_expect(parser, TOKEN_COLON) == null {
            return null;
        }
        
        // 解析数组大小表达式（必须是编译期常量，但解析阶段先解析为表达式）
        // 注意：这里解析为表达式节点，类型检查阶段会验证是否为编译期常量
        const size_expr: &ASTNode = parser_parse_expression(parser);
        if size_expr == null {
            return null;
        }
        
        // 期望 ']'
        if parser_expect(parser, TOKEN_RIGHT_BRACKET) == null {
            return null;
        }
        
        // 创建数组类型节点
        const array_type: &ASTNode = ast_new_node(AST_TYPE_ARRAY, line, column, parser.arena);
        if array_type == null {
            return null;
        }
        
        array_type.type_array_element_type = element_type;
        array_type.type_array_size_expr = size_expr;
        
        return array_type;
    } else if parser.current_token.type == TOKEN_IDENTIFIER {
        // 命名类型（i32, bool, void, 或结构体名称）
        const type_node: &ASTNode = ast_new_node(AST_TYPE_NAMED, line, column, parser.arena);
        if type_node == null {
            return null;
        }
        
        // 复制类型名称到 Arena
        const type_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if type_name == null {
            return null;
        }
        
        type_node.type_named_name = type_name;
        
        // 消费类型标识符
        parser_consume(parser);
        
        return type_node;
    }
    
    // 无法识别的类型语法
    return null;
}

// ===== 代码块解析函数 =====

// 解析代码块（完善版本，解析语句列表）
// 参数：parser - Parser 指针
// 返回：代码块节点（AST_BLOCK），失败返回 null
// 注意：此函数调用 parser_parse_statement（在后面定义）
fn parser_parse_block(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 '{'
    if parser_match(parser, TOKEN_LEFT_BRACE) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 创建代码块节点
    const block: &ASTNode = ast_new_node(AST_BLOCK, line, column, parser.arena);
    if block == null {
        return null;
    }
    
    // 初始化语句列表（使用固定大小数组）
    var stmts: [&ASTNode: PARSER_MAX_STMTS] = [];
    var stmt_count: i32 = 0;
    var i: i32 = 0;
    
    // 初始化数组为全 null
    i = 0;
    while i < PARSER_MAX_STMTS {
        stmts[i] = null;
        i = i + 1;
    }
    
    // 消费 '{'
    parser_consume(parser);
    
    // 解析语句列表
    while parser.current_token != null && 
          parser_match(parser, TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TOKEN_EOF) == 0 {
        
        // 检查容量
        if stmt_count >= PARSER_MAX_STMTS {
            // 超出容量，报错
            const filename: *byte = parser.lexer.filename;
            if filename == null {
                filename = "<unknown>" as *byte;
            }
            fprintf(2 as *void, "错误: 代码块语句数量超出限制 (%d)\n", PARSER_MAX_STMTS);
            return null;
        }
        
        // 解析语句
        const stmt: &ASTNode = parser_parse_statement(parser);
        if stmt == null {
            // 解析失败
            return null;
        }
        
        stmts[stmt_count] = stmt;
        stmt_count = stmt_count + 1;
    }
    
    // 期望 '}'
    if parser_expect(parser, TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    
    // 将语句列表复制到代码块节点的固定大小数组
    i = 0;
    while i < stmt_count {
        block.block_stmts[i] = stmts[i];
        i = i + 1;
    }
    // 剩余位置初始化为 null
    while i < MAX_BLOCK_STMTS {
        block.block_stmts[i] = null;
        i = i + 1;
    }
    block.block_stmt_count = stmt_count;
    
    return block;
}

// ===== 声明解析函数 =====

// 解析结构体声明：struct ID { field_list }
// field_list = field { ',' field }
// field = ID ':' type
// 参数：parser - Parser 指针
// 返回：AST_STRUCT_DECL 节点，失败返回 null
fn parser_parse_struct(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'struct'
    if parser_match(parser, TOKEN_STRUCT) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'struct'
    parser_consume(parser);
    
    // 期望结构体名称
    if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const struct_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
    if struct_name == null {
        return null;
    }
    
    // 消费结构体名称
    parser_consume(parser);
    
    // 创建结构体声明节点
    const struct_decl: &ASTNode = ast_new_node(AST_STRUCT_DECL, line, column, parser.arena);
    if struct_decl == null {
        return null;
    }
    
    struct_decl.struct_decl_name = struct_name;
    struct_decl.struct_decl_fields = null;
    struct_decl.struct_decl_field_count = 0;
    
    // 期望 '{'
    if parser_expect(parser, TOKEN_LEFT_BRACE) == null {
        return null;
    }
    
    // 解析字段列表
    // 字段列表：field { ',' field }
    // field = ID ':' type
    var fields: [&ASTNode: PARSER_MAX_FIELDS] = [];
    var field_count: i32 = 0;
    var i: i32 = 0;
    
    // 初始化数组为全 null
    i = 0;
    while i < PARSER_MAX_FIELDS {
        fields[i] = null;
        i = i + 1;
    }
    
    while parser.current_token != null && 
          parser_match(parser, TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TOKEN_EOF) == 0 {
        
        // 检查容量
        if field_count >= PARSER_MAX_FIELDS {
            fprintf(2 as *void, "错误: 结构体字段数量超出限制 (%d)\n", PARSER_MAX_FIELDS);
            return null;
        }
        
        // 解析字段名称
        if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const field_line: i32 = parser.current_token.line;
        const field_column: i32 = parser.current_token.column;
        const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if field_name == null {
            return null;
        }
        
        parser_consume(parser);
        
        // 期望 ':'
        if parser_expect(parser, TOKEN_COLON) == null {
            return null;
        }
        
        // 解析字段类型
        const field_type: &ASTNode = parser_parse_type(parser);
        if field_type == null {
            return null;
        }
        
        // 创建字段节点（使用 AST_VAR_DECL，is_const = 0）
        const field: &ASTNode = ast_new_node(AST_VAR_DECL, field_line, field_column, parser.arena);
        if field == null {
            return null;
        }
        
        field.var_decl_name = field_name;
        field.var_decl_type = field_type;
        field.var_decl_init = null;
        field.var_decl_is_const = 0;
        
        fields[field_count] = field;
        field_count = field_count + 1;
        
        // 检查是否有逗号（可选，最后一个字段后不需要逗号）
        if parser_match(parser, TOKEN_COMMA) != 0 {
            parser_consume(parser);
        }
    }
    
    // 期望 '}'
    if parser_expect(parser, TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    
    // 将字段列表复制到结构体节点的固定大小数组
    i = 0;
    while i < field_count {
        struct_decl.struct_decl_fields[i] = fields[i];
        i = i + 1;
    }
    // 剩余位置初始化为 null
    while i < MAX_STRUCT_FIELDS {
        struct_decl.struct_decl_fields[i] = null;
        i = i + 1;
    }
    struct_decl.struct_decl_field_count = field_count;
    
    return struct_decl;
}

// 解析枚举声明：enum ID '{' variant_list '}'
// variant_list = variant { ',' variant }
// variant = ID [ '=' NUM ]
// 参数：parser - Parser 指针
// 返回：AST_ENUM_DECL 节点，失败返回 null
fn parser_parse_enum(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'enum'
    if parser_match(parser, TOKEN_ENUM) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'enum'
    parser_consume(parser);
    
    // 期望枚举名称
    if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const enum_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
    if enum_name == null {
        return null;
    }
    
    // 消费枚举名称
    parser_consume(parser);
    
    // 创建枚举声明节点
    const enum_decl: &ASTNode = ast_new_node(AST_ENUM_DECL, line, column, parser.arena);
    if enum_decl == null {
        return null;
    }
    
    enum_decl.enum_decl_name = enum_name;
    enum_decl.enum_decl_variants = null;
    enum_decl.enum_decl_variant_count = 0;
    
    // 期望 '{'
    if parser_expect(parser, TOKEN_LEFT_BRACE) == null {
        return null;
    }
    
    // 解析变体列表
    // 变体列表：variant { ',' variant }
    // variant = ID
    var variants: &EnumVariant = null;
    var variant_count: i32 = 0;
    var variant_capacity: i32 = 0;
    
    while parser.current_token != null && 
          parser_match(parser, TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TOKEN_EOF) == 0 {
        
        // 解析变体名称
        if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const variant_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if variant_name == null {
            return null;
        }
        
        parser_consume(parser);
        
        // 扩展变体数组（使用 Arena 分配）
        // EnumVariant 包含两个指针（name 和 value），每个8字节，总共16字节
        if variant_count >= variant_capacity {
            var new_capacity: i32 = 0;
            if variant_capacity == 0 {
                new_capacity = 4;
            } else {
                new_capacity = variant_capacity * 2;
            }
            const new_variants: &EnumVariant = arena_alloc(parser.arena, 16 * new_capacity) as &EnumVariant;
            if new_variants == null {
                return null;
            }
            
            // 复制旧变体
            if variants != null {
                var i: i32 = 0;
                while i < variant_count {
                    new_variants[i].name = variants[i].name;
                    new_variants[i].value = variants[i].value;
                    i = i + 1;
                }
            }
            
            variants = new_variants;
            variant_capacity = new_capacity;
        }
        
        // 解析可选的显式值 (= NUM)
        var variant_value: &byte = null;
        if parser_match(parser, TOKEN_ASSIGN) != 0 {
            parser_consume(parser);  // 消费 '='
            
            // 期望数字字面量
            if parser_match(parser, TOKEN_NUMBER) == 0 {
                return null;
            }
            
            // 复制数字值字符串到 Arena
            variant_value = arena_strdup_for_parser(parser.arena, parser.current_token.value);
            if variant_value == null {
                return null;
            }
            
            parser_consume(parser);  // 消费数字值
        }
        
        // 添加变体
        variants[variant_count].name = variant_name;
        variants[variant_count].value = variant_value;  // null 表示没有显式赋值
        variant_count = variant_count + 1;
        
        // 检查是否有逗号（可选，最后一个变体后不需要逗号）
        if parser_match(parser, TOKEN_COMMA) != 0 {
            parser_consume(parser);
        }
    }
    
    // 期望 '}'
    if parser_expect(parser, TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    
    enum_decl.enum_decl_variants = variants;
    enum_decl.enum_decl_variant_count = variant_count;
    
    return enum_decl;
}

// 解析函数声明：fn ID '(' [ param_list ] ')' type '{' statements '}'
// param_list = param { ',' param }
// param = ID ':' type
// 参数：parser - Parser 指针
// 返回：AST_FN_DECL 节点，失败返回 null
fn parser_parse_function(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'fn'
    if parser_match(parser, TOKEN_FN) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'fn'
    parser_consume(parser);
    
    // 期望函数名称
    if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const fn_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
    if fn_name == null {
        return null;
    }
    
    // 消费函数名称
    parser_consume(parser);
    
    // 创建函数声明节点
    const fn_decl: &ASTNode = ast_new_node(AST_FN_DECL, line, column, parser.arena);
    if fn_decl == null {
        return null;
    }
    
    fn_decl.fn_decl_name = fn_name;
    fn_decl.fn_decl_params = null;
    fn_decl.fn_decl_param_count = 0;
    fn_decl.fn_decl_return_type = null;
    fn_decl.fn_decl_body = null;
    
    // 期望 '('
    if parser_expect(parser, TOKEN_LEFT_PAREN) == null {
        return null;
    }
    
    // 解析参数列表（可选）
    var params: [&ASTNode: PARSER_MAX_PARAMS] = [];
    var param_count: i32 = 0;
    var i: i32 = 0;
    
    // 初始化数组为全 null
    i = 0;
    while i < PARSER_MAX_PARAMS {
        params[i] = null;
        i = i + 1;
    }
    
    if parser_match(parser, TOKEN_RIGHT_PAREN) == 0 {
        // 有参数
        while parser.current_token != null && 
              parser_match(parser, TOKEN_RIGHT_PAREN) == 0 && 
              parser_match(parser, TOKEN_EOF) == 0 {
            
            // 检查容量
            if param_count >= PARSER_MAX_PARAMS {
                fprintf(2 as *void, "错误: 函数参数数量超出限制 (%d)\n", PARSER_MAX_PARAMS);
                return null;
            }
            
            // 解析参数名称
            if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
                return null;
            }
            
            const param_line: i32 = parser.current_token.line;
            const param_column: i32 = parser.current_token.column;
            const param_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
            if param_name == null {
                return null;
            }
            
            parser_consume(parser);
            
            // 期望 ':'
            if parser_expect(parser, TOKEN_COLON) == null {
                return null;
            }
            
            // 解析参数类型
            const param_type: &ASTNode = parser_parse_type(parser);
            if param_type == null {
                return null;
            }
            
            // 创建参数节点（使用 AST_VAR_DECL，is_const = 0）
            const param: &ASTNode = ast_new_node(AST_VAR_DECL, param_line, param_column, parser.arena);
            if param == null {
                return null;
            }
            
            param.var_decl_name = param_name;
            param.var_decl_type = param_type;
            param.var_decl_init = null;
            param.var_decl_is_const = 0;
            
            params[param_count] = param;
            param_count = param_count + 1;
            
            // 检查是否有逗号
            if parser_match(parser, TOKEN_COMMA) != 0 {
                parser_consume(parser);
            }
        }
    }
    
    // 期望 ')'
    if parser_expect(parser, TOKEN_RIGHT_PAREN) == null {
        return null;
    }
    
    // 解析返回类型
    const return_type: &ASTNode = parser_parse_type(parser);
    if return_type == null {
        return null;
    }
    
    // 解析函数体（代码块）
    const body: &ASTNode = parser_parse_block(parser);
    if body == null {
        return null;
    }
    
    // 将参数列表复制到函数节点的固定大小数组
    i = 0;
    while i < param_count {
        fn_decl.fn_decl_params[i] = params[i];
        i = i + 1;
    }
    // 剩余位置初始化为 null
    while i < MAX_FN_PARAMS {
        fn_decl.fn_decl_params[i] = null;
        i = i + 1;
    }
    fn_decl.fn_decl_param_count = param_count;
    fn_decl.fn_decl_return_type = return_type;
    fn_decl.fn_decl_body = body;
    
    return fn_decl;
}

// 解析 extern 函数声明
// extern_decl = 'extern' 'fn' ID '(' [ param_list ] ')' type ';'
// 参数：parser - Parser 指针
// 返回：AST_FN_DECL 节点（body 为 null），失败返回 null
fn parser_parse_extern_function(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'extern'
    if parser_match(parser, TOKEN_EXTERN) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'extern'
    parser_consume(parser);
    
    // 期望 'fn'
    if parser_expect(parser, TOKEN_FN) == null {
        return null;
    }
    
    // 期望函数名称
    if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const fn_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
    if fn_name == null {
        return null;
    }
    
    // 消费函数名称
    parser_consume(parser);
    
    // 创建函数声明节点
    const fn_decl: &ASTNode = ast_new_node(AST_FN_DECL, line, column, parser.arena);
    if fn_decl == null {
        return null;
    }
    
    fn_decl.fn_decl_name = fn_name;
    fn_decl.fn_decl_params = null;
    fn_decl.fn_decl_param_count = 0;
    fn_decl.fn_decl_return_type = null;
    fn_decl.fn_decl_body = null;  // extern 函数没有函数体
    fn_decl.fn_decl_is_varargs = 0;  // 默认不是可变参数函数
    
    // 期望 '('
    if parser_expect(parser, TOKEN_LEFT_PAREN) == null {
        return null;
    }
    
    // 解析参数列表（可选，支持可变参数）
    var params: [&ASTNode: PARSER_MAX_PARAMS] = [];
    var param_count: i32 = 0;
    var is_varargs: i32 = 0;
    var i: i32 = 0;
    
    // 初始化数组为全 null
    i = 0;
    while i < PARSER_MAX_PARAMS {
        params[i] = null;
        i = i + 1;
    }
    
    if parser_match(parser, TOKEN_RIGHT_PAREN) == 0 {
        // 有参数
        while parser.current_token != null && 
              parser_match(parser, TOKEN_RIGHT_PAREN) == 0 && 
              parser_match(parser, TOKEN_EOF) == 0 {
            
            // 检查是否为可变参数标记（...）
            if parser_match(parser, TOKEN_ELLIPSIS) != 0 {
                // 可变参数标记必须是参数列表的最后一个元素
                parser_consume(parser);  // 消费 '...'
                is_varargs = 1;
                break;  // 遇到 ... 后退出循环
            }
            
            // 检查容量
            if param_count >= PARSER_MAX_PARAMS {
                fprintf(2 as *void, "错误: extern 函数参数数量超出限制 (%d)\n", PARSER_MAX_PARAMS);
                return null;
            }
            
            // 解析参数名称
            if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
                return null;
            }
            
            const param_line: i32 = parser.current_token.line;
            const param_column: i32 = parser.current_token.column;
            const param_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
            if param_name == null {
                return null;
            }
            
            parser_consume(parser);
            
            // 期望 ':'
            if parser_expect(parser, TOKEN_COLON) == null {
                return null;
            }
            
            // 解析参数类型
            const param_type: &ASTNode = parser_parse_type(parser);
            if param_type == null {
                return null;
            }
            
            // 创建参数节点（使用 AST_VAR_DECL，is_const = 0）
            const param: &ASTNode = ast_new_node(AST_VAR_DECL, param_line, param_column, parser.arena);
            if param == null {
                return null;
            }
            
            param.var_decl_name = param_name;
            param.var_decl_type = param_type;
            param.var_decl_init = null;
            param.var_decl_is_const = 0;
            
            params[param_count] = param;
            param_count = param_count + 1;
            
            // 检查是否有逗号
            if parser_match(parser, TOKEN_COMMA) != 0 {
                parser_consume(parser);
            } else if parser_match(parser, TOKEN_ELLIPSIS) != 0 {
                // 逗号后紧跟 ...，也是合法的
                // 不消费逗号，让下次循环处理 ...
            }
        }
    }
    
    // 期望 ')'
    if parser_expect(parser, TOKEN_RIGHT_PAREN) == null {
        return null;
    }
    
    // 解析返回类型
    const return_type: &ASTNode = parser_parse_type(parser);
    if return_type == null {
        return null;
    }
    
    // extern 函数以分号结尾，没有函数体
    if parser_expect(parser, TOKEN_SEMICOLON) == null {
        return null;
    }
    
    // 将参数列表复制到函数节点的固定大小数组
    i = 0;
    while i < param_count {
        fn_decl.fn_decl_params[i] = params[i];
        i = i + 1;
    }
    // 剩余位置初始化为 null
    while i < MAX_FN_PARAMS {
        fn_decl.fn_decl_params[i] = null;
        i = i + 1;
    }
    fn_decl.fn_decl_param_count = param_count;
    fn_decl.fn_decl_return_type = return_type;
    fn_decl.fn_decl_body = null;  // extern 函数没有函数体
    fn_decl.fn_decl_is_varargs = is_varargs;
    
    return fn_decl;
}

// 解析声明（函数、结构体或变量声明）
// 参数：parser - Parser 指针
// 返回：声明节点（AST_FN_DECL, AST_STRUCT_DECL, AST_ENUM_DECL, 或 AST_VAR_DECL），失败返回 null
fn parser_parse_declaration(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 根据第一个 Token 判断声明类型
    if parser_match(parser, TOKEN_EXTERN) != 0 {
        // extern 函数声明
        return parser_parse_extern_function(parser);
    } else if parser_match(parser, TOKEN_FN) != 0 {
        return parser_parse_function(parser);
    } else if parser_match(parser, TOKEN_ENUM) != 0 {
        return parser_parse_enum(parser);
    } else if parser_match(parser, TOKEN_STRUCT) != 0 {
        return parser_parse_struct(parser);
    } else if parser_match(parser, TOKEN_CONST) != 0 || parser_match(parser, TOKEN_VAR) != 0 {
        // 变量声明
        return parser_parse_statement(parser);
    } else {
        // 无法识别的声明类型
        return null;
    }
}

// 解析程序（顶层声明列表）
// 参数：parser - Parser 指针
// 返回：AST_PROGRAM 节点，失败返回 null
fn parser_parse(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 创建程序节点
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    const program: &ASTNode = ast_new_node(AST_PROGRAM, line, column, parser.arena);
    if program == null {
        return null;
    }
    
    // 初始化声明列表
    program.program_decls = null;
    program.program_decl_count = 0;
    
    // 解析顶层声明列表
    var decls: [&ASTNode: PARSER_MAX_DECLS] = [];
    var decl_count: i32 = 0;
    var i: i32 = 0;
    
    // 初始化数组为全 null
    i = 0;
    while i < PARSER_MAX_DECLS {
        decls[i] = null;
        i = i + 1;
    }
    
    while parser.current_token != null && parser_match(parser, TOKEN_EOF) == 0 {
        // 检查容量
        if decl_count >= PARSER_MAX_DECLS {
            fprintf(2 as *void, "错误: 程序声明数量超出限制 (%d)\n", PARSER_MAX_DECLS);
            return null;
        }
        
        const decl: &ASTNode = parser_parse_declaration(parser);
        if decl == null {
            // 解析失败：检查是否因为到达文件末尾（EOF）还是真正的错误
            // 如果当前 token 不是 EOF，说明遇到了真正的解析错误
            if parser.current_token != null && parser_match(parser, TOKEN_EOF) == 0 {
                // 真正的解析错误：输出错误信息并返回 null
                // 注意：stderr 在 C 中通常是文件描述符 2，这里使用数值常量
                const stderr_fd: *void = 2 as *void;
                var filename: *byte = "<unknown>" as *byte;
                if parser.lexer.filename != null {
                    filename = parser.lexer.filename as *byte;
                }
                var token_value: *byte = "" as *byte;
                if parser.current_token.value != null {
                    token_value = parser.current_token.value as *byte;
                }
                fprintf(stderr_fd, "错误: 语法分析失败 (%s:%d:%d): 意外的 token", 
                        filename, parser.current_token.line, parser.current_token.column);
                // 检查 token_value 是否非空（如果指针不为 null，假设字符串非空）
                if token_value != null && strcmp(token_value, "" as *byte) != 0 {
                    fprintf(stderr_fd, " '%s'", token_value);
                }
                fprintf(stderr_fd, "\n");
                return null;
            }
            // 到达文件末尾，正常退出循环
            break;
        }
        
        decls[decl_count] = decl;
        decl_count = decl_count + 1;
    }
    
    // 将声明列表复制到程序节点的固定大小数组
    i = 0;
    while i < decl_count {
        program.program_decls[i] = decls[i];
        i = i + 1;
    }
    // 剩余位置初始化为 null
    while i < MAX_PROGRAM_DECLS {
        program.program_decls[i] = null;
        i = i + 1;
    }
    program.program_decl_count = decl_count;
    
    return program;
}

// ===== 表达式解析函数 =====

// 解析基础表达式
// 支持：数字、标识符、布尔字面量、括号表达式、函数调用、结构体字面量、字段访问
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_primary_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 解析数字字面量
    if parser.current_token.type == TOKEN_NUMBER {
        const node: &ASTNode = ast_new_node(AST_NUMBER, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        // 将字符串转换为整数
        const value: i32 = atoi(parser.current_token.value as *byte);
        node.number_value = value;
        
        parser_consume(parser);
        return node;
    }
    
    // 解析布尔字面量
    if parser.current_token.type == TOKEN_TRUE {
        const node: &ASTNode = ast_new_node(AST_BOOL, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        node.bool_literal_value = 1;  // true
        
        parser_consume(parser);
        return node;
    }
    
    if parser.current_token.type == TOKEN_FALSE {
        const node: &ASTNode = ast_new_node(AST_BOOL, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        node.bool_literal_value = 0;  // false
        
        parser_consume(parser);
        return node;
    }
    
    // 解析字符串字面量
    if parser.current_token.type == TOKEN_STRING {
        const node: &ASTNode = ast_new_node(AST_STRING, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        // 复制字符串内容到 Arena（token 的 value 已经在 Arena 中）
        const str_value: &byte = parser.current_token.value;
        if str_value == null {
            return null;
        }
        
        // 字符串内容已经在 token 中，直接使用（token 的 value 存储在 Arena 中）
        node.string_literal_value = str_value;
        
        parser_consume(parser);
        return node;
    }
    
    // 解析 null 字面量（null 被解析为标识符节点，在代码生成阶段通过字符串比较识别）
    if parser.current_token.type == TOKEN_NULL {
        const node: &ASTNode = ast_new_node(AST_IDENTIFIER, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        // 复制 "null" 字符串到 Arena（代码生成器会通过字符串比较识别）
        const null_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if null_name == null {
            return null;
        }
        node.identifier_name = null_name;
        
        parser_consume(parser);
        return node;
    }
    
    // 解析 sizeof 表达式：sizeof(Type) 或 sizeof(expr)
    if parser.current_token.type == TOKEN_SIZEOF {
        parser_consume(parser);  // 消费 'sizeof'
        
        // 期望 '('
        if parser_expect(parser, TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const sizeof_node: &ASTNode = ast_new_node(AST_SIZEOF, line, column, parser.arena);
        if sizeof_node == null {
            return null;
        }
        
        // 尝试解析类型，如果失败则解析表达式
        // 先检查是否是类型语法（基础类型或 struct 关键字）
        var is_type: i32 = 0;
        var target: &ASTNode = null;
        
        if parser.current_token != null {
            if parser.current_token.type == TOKEN_IDENTIFIER {
                const type_name: *byte = parser.current_token.value as *byte;
                // 检查是否是基础类型或 struct 关键字
                if strcmp(type_name, "i32" as *byte) == 0 || 
                   strcmp(type_name, "usize" as *byte) == 0 ||
                   strcmp(type_name, "bool" as *byte) == 0 || 
                   strcmp(type_name, "byte" as *byte) == 0 ||
                   strcmp(type_name, "void" as *byte) == 0 ||
                   strcmp(type_name, "struct" as *byte) == 0 {
                    // 尝试解析类型
                    target = parser_parse_type(parser);
                    if target != null {
                        is_type = 1;
                    }
                }
            } else if parser.current_token.type == TOKEN_AMPERSAND || 
                      parser.current_token.type == TOKEN_ASTERISK ||
                      parser.current_token.type == TOKEN_LEFT_BRACKET {
                // 指针类型或数组类型开始
                target = parser_parse_type(parser);
                if target != null {
                    is_type = 1;
                }
            }
        }
        
        // 如果不是类型，则解析表达式
        if target == null {
            target = parser_parse_expression(parser);
            if target == null {
                return null;
            }
            is_type = 0;
        }
        
        sizeof_node.sizeof_expr_target = target;
        sizeof_node.sizeof_expr_is_type = is_type;
        
        // 期望 ')'
        if parser_expect(parser, TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return sizeof_node;
    }
    
    // 解析 alignof 表达式：alignof(Type) 或 alignof(expr)
    if parser.current_token.type == TOKEN_ALIGNOF {
        parser_consume(parser);  // 消费 'alignof'
        
        // 期望 '('
        if parser_expect(parser, TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const alignof_node: &ASTNode = ast_new_node(AST_ALIGNOF, line, column, parser.arena);
        if alignof_node == null {
            return null;
        }
        
        // 尝试解析类型，如果失败则解析表达式
        // 先检查是否是类型语法（基础类型或 struct 关键字）
        var is_type: i32 = 0;
        var target: &ASTNode = null;
        
        if parser.current_token != null {
            if parser.current_token.type == TOKEN_IDENTIFIER {
                const type_name: *byte = parser.current_token.value as *byte;
                // 检查是否是基础类型或 struct 关键字
                if strcmp(type_name, "i32" as *byte) == 0 || 
                   strcmp(type_name, "usize" as *byte) == 0 ||
                   strcmp(type_name, "bool" as *byte) == 0 || 
                   strcmp(type_name, "byte" as *byte) == 0 ||
                   strcmp(type_name, "void" as *byte) == 0 ||
                   strcmp(type_name, "struct" as *byte) == 0 {
                    // 尝试解析类型
                    target = parser_parse_type(parser);
                    if target != null {
                        is_type = 1;
                    }
                }
            } else if parser.current_token.type == TOKEN_AMPERSAND || 
                      parser.current_token.type == TOKEN_ASTERISK ||
                      parser.current_token.type == TOKEN_LEFT_BRACKET {
                // 指针类型或数组类型开始
                target = parser_parse_type(parser);
                if target != null {
                    is_type = 1;
                }
            }
        }
        
        // 如果不是类型，则解析表达式
        if target == null {
            target = parser_parse_expression(parser);
            if target == null {
                return null;
            }
            is_type = 0;
        }
        
        alignof_node.alignof_expr_target = target;
        alignof_node.alignof_expr_is_type = is_type;
        
        // 期望 ')'
        if parser_expect(parser, TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return alignof_node;
    }
    
    // 解析 len 表达式：len(array)
    if parser.current_token.type == TOKEN_LEN {
        parser_consume(parser);  // 消费 'len'
        
        // 期望 '('
        if parser_expect(parser, TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const len_node: &ASTNode = ast_new_node(AST_LEN, line, column, parser.arena);
        if len_node == null {
            return null;
        }
        
        // 解析数组表达式
        const array_expr: &ASTNode = parser_parse_expression(parser);
        if array_expr == null {
            return null;
        }
        
        len_node.len_expr_array = array_expr;
        
        // 期望 ')'
        if parser_expect(parser, TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return len_node;
    }
    
    // 解析标识符（可能是普通标识符、函数调用、或结构体字面量的开始）
    if parser.current_token.type == TOKEN_IDENTIFIER {
        const name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if name == null {
            return null;
        }
        
        parser_consume(parser);  // 消费标识符
        
        // 检查下一个 token 类型
        if parser.current_token != null && parser.current_token.type == TOKEN_LEFT_PAREN {
            // 函数调用：ID '(' [ arg_list ] ')'
            const call: &ASTNode = ast_new_node(AST_CALL_EXPR, line, column, parser.arena);
            if call == null {
                return null;
            }
            
            // 创建标识符节点作为被调用的函数
            const callee: &ASTNode = ast_new_node(AST_IDENTIFIER, line, column, parser.arena);
            if callee == null {
                return null;
            }
            callee.identifier_name = name;
            call.call_expr_callee = callee;
            
            // 消费 '('
            parser_consume(parser);
            
            // 解析参数列表（可选）
            var args: [&ASTNode: PARSER_MAX_CALL_ARGS] = [];
            var arg_count: i32 = 0;
            var i: i32 = 0;
            
            // 初始化数组为全 null
            i = 0;
            while i < PARSER_MAX_CALL_ARGS {
                args[i] = null;
                i = i + 1;
            }
            
            if parser_match(parser, TOKEN_RIGHT_PAREN) == 0 {
                // 有参数
                while parser.current_token != null && 
                      parser_match(parser, TOKEN_RIGHT_PAREN) == 0 && 
                      parser_match(parser, TOKEN_EOF) == 0 {
                    
                    // 检查容量
                    if arg_count >= PARSER_MAX_CALL_ARGS {
                        fprintf(2 as *void, "错误: 函数调用参数数量超出限制 (%d)\n", PARSER_MAX_CALL_ARGS);
                        return null;
                    }
                    
                    // 解析参数表达式
                    const arg: &ASTNode = parser_parse_expression(parser);
                    if arg == null {
                        return null;
                    }
                    
                    args[arg_count] = arg;
                    arg_count = arg_count + 1;
                    
                    // 检查是否有逗号
                    if parser_match(parser, TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    }
                }
            }
            
            // 期望 ')'
            if parser_expect(parser, TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            
            // 将参数列表复制到调用节点的固定大小数组
            i = 0;
            while i < arg_count {
                call.call_expr_args[i] = args[i];
                i = i + 1;
            }
            // 剩余位置初始化为 null
            while i < MAX_CALL_ARGS {
                call.call_expr_args[i] = null;
                i = i + 1;
            }
            call.call_expr_arg_count = arg_count;
            
            // 字段访问和数组访问可能跟在函数调用后面（例如：f().field 或 f()[0]）
            var result: &ASTNode = call;
            
            // 处理字段访问和数组访问链
            while parser.current_token != null {
                if parser_match(parser, TOKEN_DOT) != 0 {
                    // 字段访问：.field
                    parser_consume(parser);  // 消费 '.'
                    
                    // 期望字段名称
                    if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
                        return null;
                    }
                    
                    const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费字段名称
                    
                    // 创建字段访问节点
                    const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena);
                    if member_access == null {
                        return null;
                    }
                    
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    
                    result = member_access;
                } else if parser_match(parser, TOKEN_LEFT_BRACKET) != 0 {
                    // 数组访问：[index]
                    const bracket_line: i32 = parser.current_token.line;
                    const bracket_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费 '['
                    
                    // 解析索引表达式
                    const index_expr: &ASTNode = parser_parse_expression(parser);
                    if index_expr == null {
                        return null;
                    }
                    
                    // 期望 ']'
                    if parser_expect(parser, TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    
                    // 创建数组访问节点
                    const array_access: &ASTNode = ast_new_node(AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena);
                    if array_access == null {
                        return null;
                    }
                    
                    array_access.array_access_array = result;
                    array_access.array_access_index = index_expr;
                    
                    result = array_access;
                } else {
                    // 既不是字段访问也不是数组访问，退出循环
                    break;
                }
            }
            
            return result;
        } else if parser.current_token != null && parser.current_token.type == TOKEN_LEFT_BRACE {
            // 使用 peek 机制检测是否是结构体字面量
            const is_struct_init: i32 = parser_peek_is_struct_init(parser);
            
            if is_struct_init == 0 {
                // 不是结构体字面量，创建普通标识符（后面的'{'是代码块的开始，不是表达式的一部分）
                const node: &ASTNode = ast_new_node(AST_IDENTIFIER, line, column, parser.arena);
                if node == null {
                    return null;
                }
                
                node.identifier_name = name;
                
                // 字段访问可能跟在标识符后面（例如：obj.field）
                var result: &ASTNode = node;
                
                // 处理字段访问链（左结合：a.b.c 解析为 (a.b).c）
                while parser.current_token != null && parser_match(parser, TOKEN_DOT) != 0 {
                    parser_consume(parser);  // 消费 '.'
                    
                    // 期望字段名称
                    if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
                        return null;
                    }
                    
                    const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费字段名称
                    
                    // 创建字段访问节点
                    const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena);
                    if member_access == null {
                        return null;
                    }
                    
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    
                    result = member_access;
                }
                
                return result;
            }
            
            // 结构体字面量：ID '{' field_init_list '}'
            const struct_init: &ASTNode = ast_new_node(AST_STRUCT_INIT, line, column, parser.arena);
            if struct_init == null {
                return null;
            }
            
            struct_init.struct_init_struct_name = name;
            
            // 消费 '{'
            parser_consume(parser);
            
            // 解析字段初始化列表
            var field_names: [&byte: PARSER_MAX_STRUCT_INIT_FIELDS] = [];
            var field_values: [&ASTNode: PARSER_MAX_STRUCT_INIT_FIELDS] = [];
            var field_count: i32 = 0;
            var i: i32 = 0;
            
            // 初始化数组为全 null
            i = 0;
            while i < PARSER_MAX_STRUCT_INIT_FIELDS {
                field_names[i] = null;
                field_values[i] = null;
                i = i + 1;
            }
            
            if parser_match(parser, TOKEN_RIGHT_BRACE) == 0 {
                // 有字段初始化
                while parser.current_token != null && 
                      parser_match(parser, TOKEN_RIGHT_BRACE) == 0 && 
                      parser_match(parser, TOKEN_EOF) == 0 {
                    
                    // 检查容量
                    if field_count >= PARSER_MAX_STRUCT_INIT_FIELDS {
                        fprintf(2 as *void, "错误: 结构体初始化字段数量超出限制 (%d)\n", PARSER_MAX_STRUCT_INIT_FIELDS);
                        return null;
                    }
                    
                    // 解析字段名称
                    if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
                        return null;
                    }
                    
                    const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    
                    parser_consume(parser);  // 消费字段名称
                    
                    // 期望 ':'
                    if parser_expect(parser, TOKEN_COLON) == null {
                        return null;
                    }
                    
                    // 解析字段值表达式
                    const field_value: &ASTNode = parser_parse_expression(parser);
                    if field_value == null {
                        return null;
                    }
                    
                    field_names[field_count] = field_name;
                    field_values[field_count] = field_value;
                    field_count = field_count + 1;
                    
                    // 检查是否有逗号
                    if parser_match(parser, TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    }
                }
            }
            
            // 期望 '}'
            if parser_expect(parser, TOKEN_RIGHT_BRACE) == null {
                return null;
            }
            
            // 将字段列表复制到结构体初始化节点的固定大小数组
            i = 0;
            while i < field_count {
                struct_init.struct_init_field_names[i] = field_names[i];
                struct_init.struct_init_field_values[i] = field_values[i];
                i = i + 1;
            }
            // 剩余位置初始化为 null
            while i < MAX_STRUCT_INIT_FIELD_NAMES {
                struct_init.struct_init_field_names[i] = null;
                i = i + 1;
            }
            i = field_count;
            while i < MAX_STRUCT_INIT_FIELDS {
                struct_init.struct_init_field_values[i] = null;
                i = i + 1;
            }
            struct_init.struct_init_field_count = field_count;
            
            // 字段访问可能跟在结构体字面量后面（例如：Point{x:1,y:2}.x）
            var result: &ASTNode = struct_init;
            
            // 处理字段访问链
            while parser.current_token != null && parser_match(parser, TOKEN_DOT) != 0 {
                parser_consume(parser);  // 消费 '.'
                
                // 期望字段名称
                if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
                    return null;
                }
                
                const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                if field_name == null {
                    return null;
                }
                
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费字段名称
                
                // 创建字段访问节点
                const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena);
                if member_access == null {
                    return null;
                }
                
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                
                result = member_access;
            }
            
            return result;
        } else {
            // 普通标识符
            const node: &ASTNode = ast_new_node(AST_IDENTIFIER, line, column, parser.arena);
            if node == null {
                return null;
            }
            
            node.identifier_name = name;
            
            // 字段访问和数组访问可能跟在标识符后面（例如：obj.field 或 arr[0]）
            var result: &ASTNode = node;
            
            // 处理字段访问和数组访问链（左结合：a.b.c 解析为 (a.b).c，arr[0][1] 解析为 (arr[0])[1]）
            while parser.current_token != null {
                if parser_match(parser, TOKEN_DOT) != 0 {
                    // 字段访问：.field
                    parser_consume(parser);  // 消费 '.'
                    
                    // 期望字段名称
                    if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
                        return null;
                    }
                    
                    const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费字段名称
                    
                    // 创建字段访问节点
                    const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena);
                    if member_access == null {
                        return null;
                    }
                    
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    
                    result = member_access;
                } else if parser_match(parser, TOKEN_LEFT_BRACKET) != 0 {
                    // 数组访问：[index]
                    const bracket_line: i32 = parser.current_token.line;
                    const bracket_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费 '['
                    
                    // 解析索引表达式
                    const index_expr: &ASTNode = parser_parse_expression(parser);
                    if index_expr == null {
                        return null;
                    }
                    
                    // 期望 ']'
                    if parser_expect(parser, TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    
                    // 创建数组访问节点
                    const array_access: &ASTNode = ast_new_node(AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena);
                    if array_access == null {
                        return null;
                    }
                    
                    array_access.array_access_array = result;
                    array_access.array_access_index = index_expr;
                    
                    result = array_access;
                } else {
                    // 既不是字段访问也不是数组访问，退出循环
                    break;
                }
            }
            
            return result;
        }
    }
    
    // 解析数组字面量：[expr1, expr2, ..., exprN] 或 []
    if parser.current_token.type == TOKEN_LEFT_BRACKET {
        const array_line: i32 = parser.current_token.line;
        const array_column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 '['
        
        // 创建数组字面量节点
        const array_literal: &ASTNode = ast_new_node(AST_ARRAY_LITERAL, array_line, array_column, parser.arena);
        if array_literal == null {
            return null;
        }
        
        // 初始化元素数组
        var elements: [&ASTNode: PARSER_MAX_ARRAY_ELEMENTS] = [];
        var element_count: i32 = 0;
        var i: i32 = 0;
        
        // 初始化数组为全 null
        i = 0;
        while i < PARSER_MAX_ARRAY_ELEMENTS {
            elements[i] = null;
            i = i + 1;
        }
        
        // 检查是否为空数组
        if parser_match(parser, TOKEN_RIGHT_BRACKET) == 0 {
            // 有元素，解析元素列表
            while parser.current_token != null && 
                  parser_match(parser, TOKEN_RIGHT_BRACKET) == 0 && 
                  parser_match(parser, TOKEN_EOF) == 0 {
                
                // 检查容量
                if element_count >= PARSER_MAX_ARRAY_ELEMENTS {
                    fprintf(2 as *void, "错误: 数组字面量元素数量超出限制 (%d)\n", PARSER_MAX_ARRAY_ELEMENTS);
                    return null;
                }
                
                // 解析元素表达式
                const element: &ASTNode = parser_parse_expression(parser);
                if element == null {
                    return null;
                }
                
                elements[element_count] = element;
                element_count = element_count + 1;
                
                // 检查是否有逗号
                if parser_match(parser, TOKEN_COMMA) != 0 {
                    parser_consume(parser);
                } else {
                    // 没有逗号，应该是最后一个元素
                    break;
                }
            }
        }
        
        // 期望 ']'
        if parser_expect(parser, TOKEN_RIGHT_BRACKET) == null {
            return null;
        }
        
        // 将元素列表复制到数组字面量节点的固定大小数组
        i = 0;
        while i < element_count {
            array_literal.array_literal_elements[i] = elements[i];
            i = i + 1;
        }
        // 剩余位置初始化为 null
        while i < MAX_ARRAY_LITERAL_ELEMENTS {
            array_literal.array_literal_elements[i] = null;
            i = i + 1;
        }
        array_literal.array_literal_element_count = element_count;
        
        // 字段访问和数组访问可能跟在数组字面量后面（例如：[1,2,3][0]）
        var result: &ASTNode = array_literal;
        
        // 处理字段访问和数组访问链
        while parser.current_token != null {
            if parser_match(parser, TOKEN_DOT) != 0 {
                // 字段访问：.field
                parser_consume(parser);  // 消费 '.'
                
                // 期望字段名称
                if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
                    return null;
                }
                
                const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                if field_name == null {
                    return null;
                }
                
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费字段名称
                
                // 创建字段访问节点
                const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena);
                if member_access == null {
                    return null;
                }
                
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                
                result = member_access;
            } else if parser_match(parser, TOKEN_LEFT_BRACKET) != 0 {
                // 数组访问：[index]
                const bracket_line: i32 = parser.current_token.line;
                const bracket_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费 '['
                
                // 解析索引表达式
                const index_expr: &ASTNode = parser_parse_expression(parser);
                if index_expr == null {
                    return null;
                }
                
                // 期望 ']'
                if parser_expect(parser, TOKEN_RIGHT_BRACKET) == null {
                    return null;
                }
                
                // 创建数组访问节点
                const array_access: &ASTNode = ast_new_node(AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena);
                if array_access == null {
                    return null;
                }
                
                array_access.array_access_array = result;
                array_access.array_access_index = index_expr;
                
                result = array_access;
            } else {
                // 既不是字段访问也不是数组访问，退出循环
                break;
            }
        }
        
        return result;
    }
    
    // 解析括号表达式
    if parser.current_token.type == TOKEN_LEFT_PAREN {
        parser_consume(parser);  // 消费 '('
        
        // 解析内部表达式（递归调用）
        const expr: &ASTNode = parser_parse_expression(parser);
        if expr == null {
            return null;
        }
        
        // 期望 ')'
        if parser_expect(parser, TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        // 字段访问和数组访问可能跟在括号表达式后面（例如：(expr).field 或 (expr)[0]）
        var result: &ASTNode = expr;
        
        // 处理字段访问和数组访问链
        while parser.current_token != null {
            if parser_match(parser, TOKEN_DOT) != 0 {
                // 字段访问：.field
                parser_consume(parser);  // 消费 '.'
                
                // 期望字段名称
                if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
                    return null;
                }
                
                const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                if field_name == null {
                    return null;
                }
                
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费字段名称
                
                // 创建字段访问节点
                const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena);
                if member_access == null {
                    return null;
                }
                
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                
                result = member_access;
            } else if parser_match(parser, TOKEN_LEFT_BRACKET) != 0 {
                // 数组访问：[index]
                const bracket_line: i32 = parser.current_token.line;
                const bracket_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费 '['
                
                // 解析索引表达式
                const index_expr: &ASTNode = parser_parse_expression(parser);
                if index_expr == null {
                    return null;
                }
                
                // 期望 ']'
                if parser_expect(parser, TOKEN_RIGHT_BRACKET) == null {
                    return null;
                }
                
                // 创建数组访问节点
                const array_access: &ASTNode = ast_new_node(AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena);
                if array_access == null {
                    return null;
                }
                
                array_access.array_access_array = result;
                array_access.array_access_index = index_expr;
                
                result = array_access;
            } else {
                // 既不是字段访问也不是数组访问，退出循环
                break;
            }
        }
        
        return result;
    }
    
    // 无法识别的基础表达式
    return null;
}

// 解析一元表达式（!, -, &, *，右结合）
// unary_expr = ('!' | '-' | '&' | '*') unary_expr | primary_expr
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_unary_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 检查一元运算符（!, -, &, *）
    if parser_match(parser, TOKEN_EXCLAMATION) != 0 || 
       parser_match(parser, TOKEN_MINUS) != 0 ||
       parser_match(parser, TOKEN_AMPERSAND) != 0 ||
       parser_match(parser, TOKEN_ASTERISK) != 0 {
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 递归解析一元表达式（右结合）
        const operand: &ASTNode = parser_parse_unary_expr(parser);
        if operand == null {
            return null;
        }
        
        // 创建一元表达式节点
        const node: &ASTNode = ast_new_node(AST_UNARY_EXPR, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        node.unary_expr_op = op as i32;
        node.unary_expr_operand = operand;
        
        return node;
    }
    
    // 不是一元运算符，解析基础表达式
    return parser_parse_primary_expr(parser);
}

// 解析类型转换表达式（右结合）
// cast_expr = unary_expr [ 'as' type ]
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_cast_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数（一元表达式）
    const expr: &ASTNode = parser_parse_unary_expr(parser);
    if expr == null {
        return null;
    }
    
    // 检查是否有 'as' 关键字（类型转换）
    if parser.current_token != null && parser.current_token.type == TOKEN_AS {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 'as'
        
        // 解析目标类型
        const target_type: &ASTNode = parser_parse_type(parser);
        if target_type == null {
            return null;
        }
        
        // 创建类型转换节点
        const node: &ASTNode = ast_new_node(AST_CAST_EXPR, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        node.cast_expr_expr = expr;
        node.cast_expr_target_type = target_type;
        
        return node;
    }
    
    // 没有类型转换，返回原表达式
    return expr;
}

// 解析乘除模表达式（左结合）
// mul_expr = cast_expr { ('*' | '/' | '%') cast_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_mul_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数（类型转换表达式）
    var left: &ASTNode = parser_parse_cast_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的乘除模运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TOKEN_ASTERISK) != 0 ||
        parser_match(parser, TOKEN_SLASH) != 0 ||
        parser_match(parser, TOKEN_PERCENT) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数（类型转换表达式）
        const right: &ASTNode = parser_parse_cast_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析加减表达式（左结合）
// add_expr = mul_expr { ('+' | '-') mul_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_add_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_mul_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的加减运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TOKEN_PLUS) != 0 ||
        parser_match(parser, TOKEN_MINUS) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_mul_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析比较表达式（左结合）
// rel_expr = add_expr { ('<' | '>' | '<=' | '>=') add_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_rel_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_add_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的比较运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TOKEN_LESS) != 0 ||
        parser_match(parser, TOKEN_GREATER) != 0 ||
        parser_match(parser, TOKEN_LESS_EQUAL) != 0 ||
        parser_match(parser, TOKEN_GREATER_EQUAL) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_add_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析相等性表达式（左结合）
// eq_expr = rel_expr { ('==' | '!=') rel_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_eq_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_rel_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的相等性运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TOKEN_EQUAL) != 0 ||
        parser_match(parser, TOKEN_NOT_EQUAL) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_rel_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析逻辑与表达式（左结合）
// and_expr = eq_expr { '&&' eq_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_and_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_eq_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的逻辑与运算符（左结合）
    while parser.current_token != null && parser_match(parser, TOKEN_LOGICAL_AND) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_eq_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析逻辑或表达式（左结合）
// or_expr = and_expr { '||' and_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_or_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_and_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的逻辑或运算符（左结合）
    while parser.current_token != null && parser_match(parser, TOKEN_LOGICAL_OR) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_and_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析赋值表达式（右结合）
// assign_expr = or_expr [ '=' assign_expr ]
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_assign_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    const left: &ASTNode = parser_parse_or_expr(parser);
    if left == null {
        return null;
    }
    
    // 检查是否有赋值运算符
    if parser.current_token != null && parser_match(parser, TOKEN_ASSIGN) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 '='
        
        // 递归解析赋值表达式（右结合）
        const right: &ASTNode = parser_parse_assign_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建赋值节点
        const node: &ASTNode = ast_new_node(AST_ASSIGN, line, column, parser.arena);
        if node == null {
            return null;
        }
        
        node.assign_dest = left;
        node.assign_src = right;
        
        return node;
    }
    
    // 没有赋值运算符，返回左操作数
    return left;
}

// 解析表达式（完整版本）
// expr = assign_expr
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_expression(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 从赋值表达式开始解析（最低优先级）
    return parser_parse_assign_expr(parser);
}

// ===== 语句解析函数 =====

// 解析语句
// 参数：parser - Parser 指针
// 返回：语句节点，失败返回 null
fn parser_parse_statement(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 根据第一个 Token 判断语句类型
    if parser.current_token.type == TOKEN_RETURN {
        // 解析 return 语句
        parser_consume(parser);  // 消费 'return'
        
        const stmt: &ASTNode = ast_new_node(AST_RETURN_STMT, line, column, parser.arena);
        if stmt == null {
            return null;
        }
        
        // 解析返回值表达式（可选，void 函数可以没有返回值）
        if parser_match(parser, TOKEN_SEMICOLON) != 0 {
            // 没有返回值（void 函数）
            stmt.return_stmt_expr = null;
            parser_consume(parser);  // 消费 ';'
        } else {
            // 有返回值表达式
            const expr: &ASTNode = parser_parse_expression(parser);
            if expr == null {
                return null;
            }
            stmt.return_stmt_expr = expr;
            
            // 期望 ';'
            if parser_expect(parser, TOKEN_SEMICOLON) == null {
                return null;
            }
        }
        
        return stmt;
    }
    
    if parser_match(parser, TOKEN_BREAK) != 0 {
        // 解析 break 语句
        parser_consume(parser);  // 消费 'break'
        
        const stmt: &ASTNode = ast_new_node(AST_BREAK_STMT, line, column, parser.arena);
        if stmt == null {
            return null;
        }
        
        // 期望 ';'
        if parser_expect(parser, TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TOKEN_CONTINUE) != 0 {
        // 解析 continue 语句
        parser_consume(parser);  // 消费 'continue'
        
        const stmt: &ASTNode = ast_new_node(AST_CONTINUE_STMT, line, column, parser.arena);
        if stmt == null {
            return null;
        }
        
        // 期望 ';'
        if parser_expect(parser, TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TOKEN_IF) != 0 {
        // 解析 if 语句
        parser_consume(parser);  // 消费 'if'
        
        const stmt: &ASTNode = ast_new_node(AST_IF_STMT, line, column, parser.arena);
        if stmt == null {
            return null;
        }
        
        // 解析条件表达式
        const condition: &ASTNode = parser_parse_expression(parser);
        if condition == null {
            return null;
        }
        stmt.if_stmt_condition = condition;
        
        // 解析 then 分支（代码块）
        const then_branch: &ASTNode = parser_parse_block(parser);
        if then_branch == null {
            return null;
        }
        stmt.if_stmt_then_branch = then_branch;
        
        // 解析 else 分支（可选）
        if parser_match(parser, TOKEN_ELSE) != 0 {
            parser_consume(parser);  // 消费 'else'
            
            const else_branch: &ASTNode = parser_parse_block(parser);
            if else_branch == null {
                return null;
            }
            stmt.if_stmt_else_branch = else_branch;
        } else {
            stmt.if_stmt_else_branch = null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TOKEN_WHILE) != 0 {
        // 解析 while 语句
        parser_consume(parser);  // 消费 'while'
        
        const stmt: &ASTNode = ast_new_node(AST_WHILE_STMT, line, column, parser.arena);
        if stmt == null {
            return null;
        }
        
        // 解析条件表达式
        const condition: &ASTNode = parser_parse_expression(parser);
        if condition == null {
            return null;
        }
        stmt.while_stmt_condition = condition;
        
        // 解析循环体（代码块）
        const body: &ASTNode = parser_parse_block(parser);
        if body == null {
            return null;
        }
        stmt.while_stmt_body = body;
        
        return stmt;
    }
    
    if parser_match(parser, TOKEN_FOR) != 0 {
        // 解析 for 语句（数组遍历）
        // 语法：for expr | ID | { statements } 或 for expr | &ID | { statements }
        parser_consume(parser);  // 消费 'for'
        
        const stmt: &ASTNode = ast_new_node(AST_FOR_STMT, line, column, parser.arena);
        if stmt == null {
            return null;
        }
        
        // 解析数组表达式
        const array_expr: &ASTNode = parser_parse_expression(parser);
        if array_expr == null {
            return null;
        }
        stmt.for_stmt_array = array_expr;
        
        // 期望 '|'
        if parser_expect(parser, TOKEN_PIPE) == null {
            return null;
        }
        
        // 检查是否为引用迭代（&ID）还是值迭代（ID）
        var is_ref: i32 = 0;
        if parser_match(parser, TOKEN_AMPERSAND) != 0 {
            // 引用迭代：for expr | &ID | { ... }
            parser_consume(parser);  // 消费 '&'
            is_ref = 1;
        }
        
        // 期望循环变量名称
        if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const var_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if var_name == null {
            return null;
        }
        stmt.for_stmt_var_name = var_name;
        parser_consume(parser);  // 消费变量名称
        
        // 期望 '|'
        if parser_expect(parser, TOKEN_PIPE) == null {
            return null;
        }
        
        stmt.for_stmt_is_ref = is_ref;
        
        // 解析循环体（代码块）
        const body: &ASTNode = parser_parse_block(parser);
        if body == null {
            return null;
        }
        stmt.for_stmt_body = body;
        
        return stmt;
    }
    
    if parser_match(parser, TOKEN_CONST) != 0 || parser_match(parser, TOKEN_VAR) != 0 {
        // 解析变量声明
        const is_const: i32 = if parser_match(parser, TOKEN_CONST) != 0 { 1 } else { 0 };
        parser_consume(parser);  // 消费 'const' 或 'var'
        
        // 期望变量名称
        if parser_match(parser, TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const var_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if var_name == null {
            return null;
        }
        
        parser_consume(parser);  // 消费变量名称
        
        const stmt: &ASTNode = ast_new_node(AST_VAR_DECL, line, column, parser.arena);
        if stmt == null {
            return null;
        }
        
        stmt.var_decl_name = var_name;
        stmt.var_decl_is_const = is_const;
        
        // 期望 ':'
        if parser_expect(parser, TOKEN_COLON) == null {
            return null;
        }
        
        // 解析类型
        const type: &ASTNode = parser_parse_type(parser);
        if type == null {
            return null;
        }
        stmt.var_decl_type = type;
        
        // 期望 '='
        if parser_expect(parser, TOKEN_ASSIGN) == null {
            return null;
        }
        
        // 解析初始值表达式
        const init: &ASTNode = parser_parse_expression(parser);
        if init == null {
            return null;
        }
        stmt.var_decl_init = init;
        
        // 期望 ';'
        if parser_expect(parser, TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TOKEN_LEFT_BRACE) != 0 {
        // 解析代码块语句
        return parser_parse_block(parser);
    }
    
    // 解析表达式语句（表达式后加分号）
    // 注意：AST_EXPR_STMT 节点在 union 中没有对应的数据结构
    // 根据 ast.c 的注释，表达式语句的数据存储在表达式的节点中
    // 所以这里直接返回表达式节点（表达式节点本身可以作为语句）
    const expr: &ASTNode = parser_parse_expression(parser);
    if expr == null {
        return null;
    }
    
    // 期望 ';'
    if parser_expect(parser, TOKEN_SEMICOLON) == null {
        return null;
    }
    
    // 直接返回表达式节点（表达式节点可以作为语句）
    return expr;
}

// ========== 来自文件: uya-src/checker.uya ==========
// checker.uya - 类型检查器模块
// 对 AST 进行类型检查，验证类型正确性，构建符号表
// 
// 注意：需要先包含 arena.uya、ast.uya、lexer.uya 和 str_utils.uya
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 外部函数声明 =====

// 字符串函数（来自 str_utils.uya）
extern fn strlen(s: *byte) i32;
extern fn strcmp(s1: *byte, s2: *byte) i32;
extern fn fprintf(stream: *void, format: *byte, ...) i32;

// Arena 函数（来自 arena.uya）
extern fn arena_alloc(arena: &Arena, size: i32) &void;

// AST 函数（来自 ast.uya）
// 注意：假设 ASTNode, ASTNodeType 类型已定义

// ===== 常量定义 =====

// 符号表大小（必须是2的幂）
const SYMBOL_TABLE_SIZE: i32 = 256;

// 函数表大小（必须是2的幂）
const FUNCTION_TABLE_SIZE: i32 = 64;

// ===== 类型定义 =====

// 类型枚举（Uya Mini 支持的类型）
enum TypeKind {
    TYPE_I32,      // 32位有符号整数
    TYPE_USIZE,    // 平台相关的无符号大小类型（32位平台=u32，64位平台=u64）
    TYPE_BOOL,     // 布尔类型
    TYPE_BYTE,     // 无符号字节（1 字节）
    TYPE_VOID,     // void 类型（仅用于函数返回类型）
    TYPE_ENUM,     // 枚举类型（通过名称引用）
    TYPE_STRUCT,   // 结构体类型（通过名称引用）
    TYPE_POINTER,  // 指针类型（&T 或 *T）
    TYPE_ARRAY,    // 数组类型（[T: N]）
}

// 类型结构
// 注意：Uya Mini 不支持 union，因此将所有 union 字段都放在结构体中
struct Type {
    kind: TypeKind,// 类型种类
    
    // 枚举类型数据
    enum_name: &byte,// 枚举名称（仅当 kind == TYPE_ENUM 时有效）
    
    // 结构体类型数据
    struct_name: &byte,// 结构体名称（仅当 kind == TYPE_STRUCT 时有效）
    
    // 指针类型数据
    pointer_to: &Type,// 指向的类型（仅当 kind == TYPE_POINTER 时有效，从 Arena 分配）
    is_ffi_pointer: i32,// 是否为 FFI 指针（1 表示 *T，0 表示 &T，仅当 kind == TYPE_POINTER 时有效）
    
    // 数组类型数据
    element_type: &Type,// 元素类型（仅当 kind == TYPE_ARRAY 时有效，从 Arena 分配）
    array_size: i32// 数组大小（编译期常量，仅当 kind == TYPE_ARRAY 时有效）
}

// 符号信息（变量、函数参数等）
struct Symbol {
    name: &byte,// 符号名称（存储在 Arena 中）
    type: Type,// 符号类型
    is_const: i32,// 1 表示 const，0 表示 var
    scope_level: i32,// 作用域级别
    line: i32,// 行号
    column: i32// 列号
}

// 函数签名信息
struct FunctionSignature {
    name: &byte,// 函数名称（存储在 Arena 中）
    param_types: &Type,// 参数类型数组（从 Arena 分配）
    param_count: i32,// 参数数量（固定参数数量，不包括可变参数）
    return_type: Type,// 返回类型
    is_extern: i32,// 是否为 extern 函数
    is_varargs: i32,// 是否为可变参数函数（1 表示是，0 表示否，仅用于 extern 函数）
    line: i32,// 行号
    column: i32// 列号
}

// 符号表（固定大小哈希表，使用开放寻址）
// 使用固定大小数组替代嵌套指针
struct SymbolTable {
    slots: [&Symbol: SYMBOL_TABLE_SIZE],// 符号槽位数组（固定大小 256）
    count: i32// 当前符号数量
}

// 函数表（固定大小哈希表，使用开放寻址）
struct FunctionTable {
    slots: [&FunctionSignature: FUNCTION_TABLE_SIZE],// 函数槽位数组（固定大小 64）
    count: i32// 当前函数数量
}

// 类型检查器结构
struct TypeChecker {
    arena: &Arena,// Arena 分配器（用于分配类型、符号等）
    symbol_table: SymbolTable,// 符号表
    function_table: FunctionTable,// 函数表
    scope_level: i32,// 当前作用域级别
    loop_depth: i32,// 循环深度（用于检查 break/continue 是否在循环中）
    program_node: &ASTNode,// 程序节点（用于查找结构体声明等）
    error_count: i32// 错误计数（简化版本，暂不存储错误消息）
}

// ===== 基础函数 =====

// 哈希函数（djb2算法，用于字符串哈希）
// 参数：str - 字符串指针
// 返回：哈希值（i32）
fn hash_string(str: *byte) i32 {
    if str == null {
        return 0;
    }
    
    var hash: i32 = 5381;
    var i: i32 = 0;
    while (str[i] as i32) != 0 {
        const c: i32 = str[i] as i32;
        hash = ((hash << 5) + hash) + c;  // hash * 33 + c
        i = i + 1;
    }
    
    return hash;
}

// 初始化 TypeChecker
// 参数：checker - TypeChecker 结构体指针（由调用者提供），arena - Arena 分配器
// 返回：成功返回 0，失败返回 -1
// 注意：TypeChecker 结构体由调用者在栈上或静态分配，此函数只负责初始化
fn checker_init(checker: &TypeChecker, arena: &Arena) i32 {
    if checker == null || arena == null {
        return -1;
    }
    
    checker.arena = arena;
    
    // 初始化符号表（所有槽位设为 null）
    var i: i32 = 0;
    while i < SYMBOL_TABLE_SIZE {
        checker.symbol_table.slots[i] = null;
        i = i + 1;
    }
    checker.symbol_table.count = 0;
    
    // 初始化函数表（所有槽位设为 null）
    i = 0;
    while i < FUNCTION_TABLE_SIZE {
        checker.function_table.slots[i] = null;
        i = i + 1;
    }
    checker.function_table.count = 0;
    
    checker.scope_level = 0;
    checker.loop_depth = 0;
    checker.program_node = null;
    checker.error_count = 0;
    
    return 0;
}

// 获取错误计数
// 参数：checker - TypeChecker 指针
// 返回：错误数量
fn checker_get_error_count(checker: &TypeChecker) i32 {
    if checker == null {
        return 0;
    }
    return checker.error_count;
}

// ===== 符号表操作函数 =====

// 符号表查找函数（支持作用域查找，返回最内层匹配的符号）
// 参数：checker - TypeChecker 指针，name - 符号名称
// 返回：找到的符号指针（最内层的匹配符号），未找到返回 null
// 注意：查找所有匹配的符号，返回作用域级别最高的（最内层的）
fn symbol_table_lookup(checker: &TypeChecker, name: *byte) &Symbol {
    if checker == null || name == null {
        return null;
    }
    
    var found: &Symbol = null;
    var found_scope: i32 = -1;
    
    // 遍历整个符号表，查找所有匹配的符号
    // 由于使用开放寻址，同名符号可能存储在不同的位置（由于哈希冲突）
    var i: i32 = 0;
    while i < SYMBOL_TABLE_SIZE {
        const symbol: &Symbol = checker.symbol_table.slots[i];
        
        if symbol != null {
            // 检查是否是目标符号
            if strcmp(symbol.name as *byte, name) == 0 {
                // 找到匹配的符号，选择作用域级别最高的（最内层的）
                if found == null || symbol.scope_level > found_scope {
                    found = symbol;
                    found_scope = symbol.scope_level;
                }
            }
        }
        
        i = i + 1;
    }
    
    return found;
}

// 符号表插入函数（使用开放寻址的哈希表）
// 参数：checker - TypeChecker 指针，symbol - 要插入的符号（从 Arena 分配）
// 返回：成功返回 0，失败返回 -1
// 注意：禁止变量遮蔽，内层作用域不能声明与外层作用域同名的变量（应在类型检查时验证）
//      如果符号已存在（相同名称和相同作用域级别），返回 -1
fn symbol_table_insert(checker: &TypeChecker, symbol: &Symbol) i32 {
    if checker == null || symbol == null || symbol.name == null {
        return -1;
    }
    
    // 首先检查是否已存在相同名称和相同作用域级别的符号
    const existing: &Symbol = symbol_table_lookup(checker, symbol.name as *byte);
    if existing != null && existing.scope_level == symbol.scope_level {
        return -1;  // 符号已存在（相同作用域级别）
    }
    
    // 计算哈希值
    const hash: i32 = hash_string(symbol.name as *byte);
    const index: i32 = hash & (SYMBOL_TABLE_SIZE - 1);  // 使用位与运算（表大小必须是2的幂）
    
    // 开放寻址：查找空槽位
    var i: i32 = 0;
    while i < SYMBOL_TABLE_SIZE {
        const slot: i32 = (index + i) & (SYMBOL_TABLE_SIZE - 1);
        
        if checker.symbol_table.slots[slot] == null {
            // 找到空槽位，插入符号
            checker.symbol_table.slots[slot] = symbol;
            checker.symbol_table.count = checker.symbol_table.count + 1;
            return 0;
        }
        
        i = i + 1;
    }
    
    // 哈希表已满（理论上不应该发生，因为我们有足够大的表）
    return -1;
}

// ===== 函数表操作函数 =====

// 函数表查找函数
// 参数：checker - TypeChecker 指针，name - 函数名称
// 返回：找到的函数签名指针，未找到返回 null
fn function_table_lookup(checker: &TypeChecker, name: *byte) &FunctionSignature {
    if checker == null || name == null {
        return null;
    }
    
    // 计算哈希值
    const hash: i32 = hash_string(name);
    const index: i32 = hash & (FUNCTION_TABLE_SIZE - 1);
    
    // 开放寻址：查找函数
    var i: i32 = 0;
    while i < FUNCTION_TABLE_SIZE {
        const slot: i32 = (index + i) & (FUNCTION_TABLE_SIZE - 1);
        const sig: &FunctionSignature = checker.function_table.slots[slot];
        
        if sig == null {
            // 空槽位，继续查找
            i = i + 1;
            continue;
        }
        
        // 检查是否是目标函数
        if strcmp(sig.name as *byte, name) == 0 {
            return sig;
        }
        
        i = i + 1;
    }
    
    return null;  // 未找到
}

// 函数表插入函数（使用开放寻址的哈希表）
// 参数：checker - TypeChecker 指针，sig - 要插入的函数签名（从 Arena 分配）
// 返回：成功返回 0，失败返回 -1
// 注意：如果函数已存在，返回 -1
fn function_table_insert(checker: &TypeChecker, sig: &FunctionSignature) i32 {
    if checker == null || sig == null || sig.name == null {
        return -1;
    }
    
    // 计算哈希值
    const hash: i32 = hash_string(sig.name as *byte);
    const index: i32 = hash & (FUNCTION_TABLE_SIZE - 1);
    
    // 开放寻址：查找空槽位或已存在的函数
    var i: i32 = 0;
    while i < FUNCTION_TABLE_SIZE {
        const slot: i32 = (index + i) & (FUNCTION_TABLE_SIZE - 1);
        const existing: &FunctionSignature = checker.function_table.slots[slot];
        
        if existing == null {
            // 找到空槽位，插入函数签名
            checker.function_table.slots[slot] = sig;
            checker.function_table.count = checker.function_table.count + 1;
            return 0;
        }
        
        // 检查是否是相同名称的函数
        if strcmp(existing.name as *byte, sig.name as *byte) == 0 {
            // 函数已存在，返回错误
            return -1;
        }
        
        i = i + 1;
    }
    
    // 哈希表已满（理论上不应该发生）
    return -1;
}

// ===== 作用域管理函数 =====

// 进入作用域（增加作用域级别）
// 参数：checker - TypeChecker 指针
fn checker_enter_scope(checker: &TypeChecker) {
    if checker != null {
        checker.scope_level = checker.scope_level + 1;
    }
}

// 退出作用域（减少作用域级别，并移除该作用域的符号）
// 参数：checker - TypeChecker 指针
// 注意：退出作用域时，移除当前作用域级别的所有符号
// 注意：在开放寻址哈希表中删除元素会导致查找链断裂，但我们的使用场景中，
//      退出作用域时删除符号是必要的，因此遍历整个表进行删除
fn checker_exit_scope(checker: &TypeChecker) {
    if checker == null || checker.scope_level <= 0 {
        return;
    }
    
    const current_scope: i32 = checker.scope_level;
    
    // 移除当前作用域级别的所有符号
    // 注意：在开放寻址哈希表中，删除元素会导致查找链断裂，但我们的使用场景中，
    //      符号表主要用于类型检查阶段，退出作用域后不会再查找已删除的符号
    var i: i32 = 0;
    while i < SYMBOL_TABLE_SIZE {
        const symbol: &Symbol = checker.symbol_table.slots[i];
        if symbol != null && symbol.scope_level == current_scope {
            checker.symbol_table.slots[i] = null;
            checker.symbol_table.count = checker.symbol_table.count - 1;
        }
        i = i + 1;
    }
    
    checker.scope_level = checker.scope_level - 1;
}

// ===== 类型系统函数 =====

// 类型比较函数（比较两个Type是否相等）
// 参数：t1, t2 - 要比较的两个类型
// 返回：1 表示相等，0 表示不相等
// 注意：结构体类型通过名称比较
fn type_equals(t1: Type, t2: Type) i32 {
    // 类型种类必须相同
    if (t1.kind as i32) != (t2.kind as i32) {
        return 0;
    }
    
    // 对于枚举类型，需要比较枚举名称
    if (t1.kind as i32) == (TYPE_ENUM as i32) {
        // 如果两个枚举名称都为 null，则相等
        if t1.enum_name == null && t2.enum_name == null {
            return 1;
        }
        // 如果只有一个为 null，则不相等
        if t1.enum_name == null || t2.enum_name == null {
            return 0;
        }
        // 比较枚举名称
        if strcmp(t1.enum_name as *byte, t2.enum_name as *byte) == 0 {
            return 1;
        } else {
            return 0;
        }
    }
    
    // 对于结构体类型，需要比较结构体名称
    if (t1.kind as i32) == (TYPE_STRUCT as i32) {
        // 如果两个结构体名称都为 null，则相等
        if t1.struct_name == null && t2.struct_name == null {
            return 1;
        }
        // 如果只有一个为 null，则不相等
        if t1.struct_name == null || t2.struct_name == null {
            return 0;
        }
        // 比较结构体名称
        if strcmp(t1.struct_name as *byte, t2.struct_name as *byte) == 0 {
            return 1;
        } else {
            return 0;
        }
    }
    
    // 对于指针类型，需要比较指向的类型和是否FFI指针
    if (t1.kind as i32) == (TYPE_POINTER as i32) {
        if t1.is_ffi_pointer != t2.is_ffi_pointer {
            return 0;
        }
        if t1.pointer_to == null && t2.pointer_to == null {
            return 1;
        }
        if t1.pointer_to == null || t2.pointer_to == null {
            return 0;
        }
        // 递归比较指向的类型
        return type_equals(t1.pointer_to[0], t2.pointer_to[0]);
    }
    
    // 对于数组类型，需要比较元素类型和大小
    if (t1.kind as i32) == (TYPE_ARRAY as i32) {
        if t1.array_size != t2.array_size {
            return 0;
        }
        if t1.element_type == null && t2.element_type == null {
            return 1;
        }
        if t1.element_type == null || t2.element_type == null {
            return 0;
        }
        // 递归比较元素类型
        return type_equals(t1.element_type[0], t2.element_type[0]);
    }
    
    // 对于其他类型（i32, bool, void），种类相同即相等
    return 1;
}

// 前向声明（用于 type_from_ast）
fn find_enum_decl_from_program(program_node: &ASTNode, enum_name: *byte) &ASTNode;
fn find_struct_decl_from_program(program_node: &ASTNode, struct_name: *byte) &ASTNode;

// 从AST类型节点创建Type结构
// 参数：checker - TypeChecker 指针，type_node - AST类型节点
// 返回：Type结构，如果类型节点无效返回TYPE_VOID类型
// 注意：结构体类型名称需要从program_node中查找结构体声明
//      指针和数组类型的子类型从Arena分配
fn type_from_ast(checker: &TypeChecker, type_node: &ASTNode) Type {
    var result: Type;
    
    // 初始化 result 的所有字段
    result.kind = TYPE_VOID as TypeKind;
    result.enum_name = null;
    result.struct_name = null;
    result.pointer_to = null;
    result.is_ffi_pointer = 0;
    result.element_type = null;
    result.array_size = 0;
    
    // 如果类型节点为 null，返回void类型
    if type_node == null {
        result.kind = TYPE_VOID as TypeKind;
        return result;
    }
    
    // 根据类型节点类型处理
    if (type_node.type as i32) == (AST_TYPE_POINTER as i32) {
        // 指针类型（&T 或 *T）
        // 递归解析指向的类型
        const pointed_type: Type = type_from_ast(checker, type_node.type_pointer_pointed_type);
        if (pointed_type.kind as i32) == (TYPE_VOID as i32) && type_node.type_pointer_pointed_type != null {
            // 指向的类型无效
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        
        // 分配指向的类型结构（从Arena分配）
        // sizeof(Type) 需要计算，假设为 48 字节（根据字段估算）
        const pointed_type_ptr: &Type = arena_alloc(checker.arena, 48) as &Type;
        if pointed_type_ptr == null {
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        pointed_type_ptr[0] = pointed_type;
        
        // 创建指针类型
        result.kind = TYPE_POINTER as TypeKind;
        result.pointer_to = pointed_type_ptr;
        result.is_ffi_pointer = type_node.type_pointer_is_ffi_pointer;
        
        return result;
    } else if (type_node.type as i32) == (AST_TYPE_ARRAY as i32) {
        // 数组类型（[T: N]）
        // 递归解析元素类型
        const element_type: Type = type_from_ast(checker, type_node.type_array_element_type);
        if (element_type.kind as i32) == (TYPE_VOID as i32) && type_node.type_array_element_type != null {
            // 元素类型无效
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        
        // 分配元素类型结构（从Arena分配）
        const element_type_ptr: &Type = arena_alloc(checker.arena, 48) as &Type;
        if element_type_ptr == null {
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        element_type_ptr[0] = element_type;
        
        // 解析数组大小（必须是编译期常量）
        // 注意：这里先简单验证，详细的编译期常量检查在类型检查阶段进行
        var array_size: i32 = 0;
        if type_node.type_array_size_expr != null &&
           (type_node.type_array_size_expr.type as i32) == (AST_NUMBER as i32) {
            array_size = type_node.type_array_size_expr.number_value;
            if array_size <= 0 {
                // 数组大小必须为正整数
                result.kind = TYPE_VOID as TypeKind;
                return result;
            }
        } else {
            // 数组大小不是数字字面量，暂时返回无效类型
            // 详细的编译期常量检查在类型检查阶段进行
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        
        // 创建数组类型
        result.kind = TYPE_ARRAY as TypeKind;
        result.element_type = element_type_ptr;
        result.array_size = array_size;
        
        return result;
    } else if (type_node.type as i32) == (AST_TYPE_NAMED as i32) {
        // 命名类型（i32, bool, byte, void, 或结构体名称）
        const type_name: &byte = type_node.type_named_name;
        if type_name == null {
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        
        // 根据类型名称确定类型种类
        if strcmp(type_name as *byte, "i32" as *byte) == 0 {
            result.kind = TYPE_I32 as TypeKind;
        } else if strcmp(type_name as *byte, "usize" as *byte) == 0 {
            result.kind = TYPE_USIZE as TypeKind;
        } else if strcmp(type_name as *byte, "bool" as *byte) == 0 {
            result.kind = TYPE_BOOL as TypeKind;
        } else if strcmp(type_name as *byte, "byte" as *byte) == 0 {
            result.kind = TYPE_BYTE as TypeKind;
        } else if strcmp(type_name as *byte, "void" as *byte) == 0 {
            result.kind = TYPE_VOID as TypeKind;
        } else {
            // 其他名称可能是枚举类型或结构体类型
            // 需要从program_node中查找枚举或结构体声明（在类型检查阶段验证）
            if checker != null && checker.program_node != null {
                // 先检查是否是枚举类型
                const enum_decl: &ASTNode = find_enum_decl_from_program(checker.program_node, type_name as *byte);
                if enum_decl != null {
                    result.kind = TYPE_ENUM as TypeKind;
                    result.enum_name = type_name;
                } else {
                    // 不是枚举类型，视为结构体类型
                    result.kind = TYPE_STRUCT as TypeKind;
                    result.struct_name = type_name;
                }
            } else {
                // 无法检查，暂时视为结构体类型（向后兼容）
                result.kind = TYPE_STRUCT as TypeKind;
                result.struct_name = type_name;
            }
        }
        
        return result;
    }
    
    // 无法识别的类型节点类型
    result.kind = TYPE_VOID as TypeKind;
    return result;
}

// ===== 辅助函数 =====

// 从程序节点中查找结构体声明
// 参数：program_node - 程序节点，struct_name - 结构体名称
// 返回：找到的结构体声明节点指针，未找到返回 null
fn find_struct_decl_from_program(program_node: &ASTNode, struct_name: *byte) &ASTNode {
    if program_node == null || (program_node.type as i32) != (AST_PROGRAM as i32) || struct_name == null {
        return null;
    }
    
    var i: i32 = 0;
    while i < program_node.program_decl_count {
        const decl: &ASTNode = program_node.program_decls[i];
        if decl != null && (decl.type as i32) == (AST_STRUCT_DECL as i32) {
            if decl.struct_decl_name != null && 
               strcmp(decl.struct_decl_name as *byte, struct_name) == 0 {
                return decl;
            }
        }
        i = i + 1;
    }
    
    return null;
}

// 从程序节点中查找枚举声明
// 参数：program_node - 程序节点，enum_name - 枚举名称
// 返回：找到的枚举声明节点指针，未找到返回 null
fn find_enum_decl_from_program(program_node: &ASTNode, enum_name: *byte) &ASTNode {
    if program_node == null || (program_node.type as i32) != (AST_PROGRAM as i32) || enum_name == null {
        return null;
    }
    
    var i: i32 = 0;
    while i < program_node.program_decl_count {
        const decl: &ASTNode = program_node.program_decls[i];
        if decl != null && (decl.type as i32) == (AST_ENUM_DECL as i32) {
            if decl.enum_decl_name != null && 
               strcmp(decl.enum_decl_name as *byte, enum_name) == 0 {
                return decl;
            }
        }
        i = i + 1;
    }
    
    return null;
}

// 查找结构体字段类型
// 参数：struct_decl - 结构体声明节点，field_name - 字段名称
// 返回：字段类型，如果字段不存在返回 TYPE_VOID 类型
fn find_struct_field_type(struct_decl: &ASTNode, field_name: *byte) Type {
    var result: Type;
    result.kind = TYPE_VOID as TypeKind;
    result.enum_name = null;
    result.struct_name = null;
    result.pointer_to = null;
    result.is_ffi_pointer = 0;
    result.element_type = null;
    result.array_size = 0;
    
    if struct_decl == null || (struct_decl.type as i32) != (AST_STRUCT_DECL as i32) || field_name == null {
        return result;
    }
    
    var i: i32 = 0;
    while i < struct_decl.struct_decl_field_count {
        const field: &ASTNode = struct_decl.struct_decl_fields[i];
        if field != null && (field.type as i32) == (AST_VAR_DECL as i32) {
            if field.var_decl_name != null && 
               strcmp(field.var_decl_name as *byte, field_name) == 0 {
                // 找到字段，返回字段类型
                // 注意：这里需要 TypeChecker 来调用 type_from_ast，但为了简化，我们直接使用 null
                // 实际上，find_struct_field_type 应该接受 TypeChecker 参数
                // 但为了保持与 C99 版本的兼容性，这里先使用简化版本
                // 在类型检查阶段，会使用正确的 TypeChecker
                var temp_checker: TypeChecker;
                temp_checker.arena = null;  // 临时使用，不会分配内存
                temp_checker.program_node = null;
                return type_from_ast(&temp_checker, field.var_decl_type);
            }
        }
        i = i + 1;
    }
    
    return result;
}

// 表达式类型推断函数（从表达式AST节点推断类型）
// 参数：checker - TypeChecker 指针，expr - 表达式AST节点
// 返回：Type结构，如果无法推断返回TYPE_VOID类型
// 注意：这是简化版本，完整的类型推断需要类型检查上下文
fn checker_infer_type(checker: &TypeChecker, expr: &ASTNode) Type {
    var result: Type;
    
    // 初始化 result
    result.kind = TYPE_VOID as TypeKind;
    result.enum_name = null;
    result.struct_name = null;
    result.pointer_to = null;
    result.is_ffi_pointer = 0;
    result.element_type = null;
    result.array_size = 0;
    
    if checker == null || expr == null {
        result.kind = TYPE_VOID as TypeKind;
        return result;
    }
    
    // 根据表达式类型处理（使用 if-else 替代 switch）
    if (expr.type as i32) == (AST_NUMBER as i32) {
        // 数字字面量类型为i32
        result.kind = TYPE_I32 as TypeKind;
        return result;
    } else if (expr.type as i32) == (AST_BOOL as i32) {
        // 布尔字面量类型为bool
        result.kind = TYPE_BOOL as TypeKind;
        return result;
    } else if (expr.type as i32) == (AST_STRING as i32) {
        // 字符串字面量类型为 *byte（FFI 指针类型）
        // 创建指向 byte 类型的指针类型
        var byte_type: Type;
        byte_type.kind = TYPE_BYTE as TypeKind;
        byte_type.enum_name = null;
        byte_type.struct_name = null;
        byte_type.pointer_to = null;
        byte_type.is_ffi_pointer = 0;
        byte_type.element_type = null;
        byte_type.array_size = 0;
        
        // 分配指向的类型结构（从Arena分配）
        const pointed_type_ptr: &Type = arena_alloc(checker.arena, 48) as &Type;
        if pointed_type_ptr == null {
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        pointed_type_ptr[0] = byte_type;
        
        // 创建 FFI 指针类型（*byte）
        result.kind = TYPE_POINTER as TypeKind;
        result.pointer_to = pointed_type_ptr;
        result.is_ffi_pointer = 1;  // FFI 指针类型
        return result;
    } else if (expr.type as i32) == (AST_IDENTIFIER as i32) {
        // 标识符类型需要从符号表中查找
        const symbol: &Symbol = symbol_table_lookup(checker, expr.identifier_name as *byte);
        if symbol != null {
            return symbol.type;
        }
        // 如果找不到符号，返回void类型（错误将在类型检查时报告）
        result.kind = TYPE_VOID as TypeKind;
        return result;
    } else if (expr.type as i32) == (AST_UNARY_EXPR as i32) {
        // 一元表达式：根据运算符推断类型
        const op: i32 = expr.unary_expr_op;
        const operand_type: Type = checker_infer_type(checker, expr.unary_expr_operand);
        
        if op == TOKEN_EXCLAMATION {
            // 逻辑非（!）返回bool类型
            result.kind = TYPE_BOOL as TypeKind;
            return result;
        } else if op == TOKEN_MINUS {
            // 一元负号（-）返回操作数类型（应为i32）
            return operand_type;
        } else if op == TOKEN_AMPERSAND {
            // 取地址（&expr）：返回指向操作数类型的指针类型
            if (operand_type.kind as i32) == (TYPE_VOID as i32) {
                // 操作数类型无效
                result.kind = TYPE_VOID as TypeKind;
                return result;
            }
            
            // 分配操作数类型结构（从Arena分配）
            const pointed_type_ptr: &Type = arena_alloc(checker.arena, 48) as &Type;
            if pointed_type_ptr == null {
                result.kind = TYPE_VOID as TypeKind;
                return result;
            }
            pointed_type_ptr[0] = operand_type;
            
            // 创建指针类型（普通指针）
            result.kind = TYPE_POINTER as TypeKind;
            result.pointer_to = pointed_type_ptr;
            result.is_ffi_pointer = 0;  // 普通指针
            return result;
        } else if op == TOKEN_ASTERISK {
            // 解引用（*expr）：操作数必须是指针类型，返回指针指向的类型
            if (operand_type.kind as i32) != (TYPE_POINTER as i32) {
                // 操作数不是指针类型
                result.kind = TYPE_VOID as TypeKind;
                return result;
            }
            
            if operand_type.pointer_to == null {
                // 指针类型无效
                result.kind = TYPE_VOID as TypeKind;
                return result;
            }
            
            // 返回指针指向的类型
            return operand_type.pointer_to[0];
        }
        
        // 其他一元运算符，返回操作数类型
        return operand_type;
    } else if (expr.type as i32) == (AST_BINARY_EXPR as i32) {
        // 二元表达式：根据运算符推断类型
        const op: i32 = expr.binary_expr_op;
        
        // 比较运算符和逻辑运算符返回bool类型
        if op == TOKEN_EQUAL || op == TOKEN_NOT_EQUAL ||
           op == TOKEN_LESS || op == TOKEN_GREATER ||
           op == TOKEN_LESS_EQUAL || op == TOKEN_GREATER_EQUAL ||
           op == TOKEN_LOGICAL_AND || op == TOKEN_LOGICAL_OR {
            result.kind = TYPE_BOOL as TypeKind;
            return result;
        }
        
        // 算术运算符返回左操作数的类型（假设左右操作数类型相同）
        const left_type: Type = checker_infer_type(checker, expr.binary_expr_left);
        return left_type;
    } else if (expr.type as i32) == (AST_CALL_EXPR as i32) {
        // 函数调用：返回函数的返回类型
        const callee: &ASTNode = expr.call_expr_callee;
        if callee == null || (callee.type as i32) != (AST_IDENTIFIER as i32) {
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        
        const sig: &FunctionSignature = function_table_lookup(checker, callee.identifier_name as *byte);
        if sig != null {
            return sig.return_type;
        }
        
        // 如果找不到函数，返回void类型（错误将在类型检查时报告）
        result.kind = TYPE_VOID as TypeKind;
        return result;
    } else if (expr.type as i32) == (AST_MEMBER_ACCESS as i32) {
        // 字段访问：推断对象类型，然后查找字段类型
        const object_type: Type = checker_infer_type(checker, expr.member_access_object);
        if (object_type.kind as i32) != (TYPE_STRUCT as i32) || object_type.struct_name == null {
            // 对象类型不是结构体，返回void类型
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        
        // 查找结构体声明
        const struct_decl: &ASTNode = find_struct_decl_from_program(checker.program_node, object_type.struct_name as *byte);
        if struct_decl == null {
            // 结构体声明未找到，返回void类型
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        
        // 查找字段类型
        const field_type: Type = find_struct_field_type(struct_decl, expr.member_access_field_name as *byte);
        return field_type;  // 如果字段不存在，field_type.kind 为 TYPE_VOID
    } else if (expr.type as i32) == (AST_ARRAY_ACCESS as i32) {
        // 数组访问：推断数组表达式类型，然后返回元素类型
        const array_type: Type = checker_infer_type(checker, expr.array_access_array);
        if (array_type.kind as i32) != (TYPE_ARRAY as i32) || array_type.element_type == null {
            // 数组表达式类型不是数组类型，返回void类型
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        
        // 返回数组的元素类型
        return array_type.element_type[0];
    } else if (expr.type as i32) == (AST_STRUCT_INIT as i32) {
        // 结构体字面量：返回结构体类型
        result.kind = TYPE_STRUCT as TypeKind;
        // 结构体名称需要存储在Arena中（从AST节点获取的名称已经在Arena中）
        result.struct_name = expr.struct_init_struct_name;
        return result;
    } else if (expr.type as i32) == (AST_ARRAY_LITERAL as i32) {
        // 数组字面量：从第一个元素推断元素类型，使用元素数量作为数组大小
        const element_count: i32 = expr.array_literal_element_count;
        
        if element_count == 0 {
            // 空数组：无法推断类型，返回void类型（错误将在类型检查时报告）
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        
        // 从第一个元素推断元素类型（直接访问固定大小数组）
        const element_type: Type = checker_infer_type(checker, expr.array_literal_elements[0]);
        if (element_type.kind as i32) == (TYPE_VOID as i32) {
            // 元素类型无效
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        
        // 分配元素类型结构（从Arena分配）
        const element_type_ptr: &Type = arena_alloc(checker.arena, 48) as &Type;
        if element_type_ptr == null {
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        element_type_ptr[0] = element_type;
        
        // 创建数组类型
        result.kind = TYPE_ARRAY as TypeKind;
        result.element_type = element_type_ptr;
        result.array_size = element_count;
        
        return result;
    } else if (expr.type as i32) == (AST_SIZEOF as i32) {
        // sizeof 表达式：返回 i32 类型（字节数）
        // 注意：这里不验证 target 是否有效，类型检查阶段会验证
        result.kind = TYPE_I32 as TypeKind;
        return result;
    } else if (expr.type as i32) == (AST_ALIGNOF as i32) {
        // alignof 表达式：返回 i32 类型（对齐字节数）
        // 注意：这里不验证 target 是否有效，类型检查阶段会验证
        result.kind = TYPE_I32 as TypeKind;
        return result;
    } else if (expr.type as i32) == (AST_LEN as i32) {
        // len 表达式：返回 i32 类型（元素个数）
        // 注意：这里不验证 array 是否是数组类型，类型检查阶段会验证
        result.kind = TYPE_I32 as TypeKind;
        return result;
    } else if (expr.type as i32) == (AST_CAST_EXPR as i32) {
        // 类型转换表达式：返回目标类型
        // 注意：这里不验证转换是否合法，类型检查阶段会验证
        const target_type_node: &ASTNode = expr.cast_expr_target_type;
        if target_type_node == null {
            result.kind = TYPE_VOID as TypeKind;
            return result;
        }
        return type_from_ast(checker, target_type_node);
    }
    
    // 其他表达式类型，返回void类型
    result.kind = TYPE_VOID as TypeKind;
    return result;
}

// ===== 类型检查函数 =====

// 报告类型错误（增加错误计数）
// 参数：checker - TypeChecker 指针
fn checker_report_error(checker: &TypeChecker) {
    if checker != null {
        checker.error_count = checker.error_count + 1;
    }
}

// 检查表达式类型是否匹配预期类型
// 参数：checker - TypeChecker 指针，expr - 表达式节点，expected_type - 预期类型
// 返回：1 表示类型匹配，0 表示类型不匹配
fn checker_check_expr_type(checker: &TypeChecker, expr: &ASTNode, expected_type: Type) i32 {
    if checker == null || expr == null {
        return 0;
    }
    
    const actual_type: Type = checker_infer_type(checker, expr);
    if type_equals(actual_type, expected_type) != 0 {
        return 1;
    }
    
    // 类型不匹配，报告错误
    checker_report_error(checker);
    return 0;
}

// 前向声明（用于递归调用）
fn checker_check_node(checker: &TypeChecker, node: &ASTNode) i32;

// 检查变量声明
// 参数：checker - TypeChecker 指针，node - 变量声明节点
// 返回：1 表示检查通过，0 表示检查失败
fn checker_check_var_decl(checker: &TypeChecker, node: &ASTNode) i32 {
    if checker == null || node == null || (node.type as i32) != (AST_VAR_DECL as i32) {
        return 0;
    }
    
    // 获取变量类型
    var var_type: Type = type_from_ast(checker, node.var_decl_type);
    if (var_type.kind as i32) == (TYPE_VOID as i32) && node.var_decl_type != null {
        // 结构体类型需要在程序节点中查找
        if (node.var_decl_type.type as i32) == (AST_TYPE_NAMED as i32) {
            const type_name: &byte = node.var_decl_type.type_named_name;
            if type_name != null && strcmp(type_name as *byte, "i32" as *byte) != 0 && 
               strcmp(type_name as *byte, "bool" as *byte) != 0 && 
               strcmp(type_name as *byte, "byte" as *byte) != 0 && 
               strcmp(type_name as *byte, "void" as *byte) != 0 {
                // 可能是结构体类型，检查是否存在
                const struct_decl: &ASTNode = find_struct_decl_from_program(checker.program_node, type_name as *byte);
                if struct_decl == null {
                    // 结构体类型未定义
                    checker_report_error(checker);
                    return 0;
                }
                var_type.kind = TYPE_STRUCT as TypeKind;
                var_type.struct_name = type_name;
            }
        }
    }
    
    // 检查初始化表达式类型
    if node.var_decl_init != null {
        // 特殊处理空数组字面量：如果变量类型是数组类型，空数组字面量表示未初始化
        if (node.var_decl_init.type as i32) == (AST_ARRAY_LITERAL as i32) &&
            node.var_decl_init.array_literal_element_count == 0 &&
            (var_type.kind as i32) == (TYPE_ARRAY as i32) {
            // 空数组字面量用于数组类型变量，允许（表示未初始化）
            // 不需要进一步检查，直接跳过类型比较
        } else {
            // 先递归检查初始化表达式本身（包括函数调用、运算符等的类型检查）
            checker_check_node(checker, node.var_decl_init);
            // 然后推断类型并比较
            const init_type: Type = checker_infer_type(checker, node.var_decl_init);
            if type_equals(init_type, var_type) == 0 {
                // 初始化表达式类型不匹配
                checker_report_error(checker);
                return 0;
            }
        }
    }
    
    // 将变量添加到符号表
    // sizeof(Symbol) 需要计算，假设为 32 字节（根据字段估算）
    const symbol: &Symbol = arena_alloc(checker.arena, 32) as &Symbol;
    if symbol == null {
        return 0;
    }
    symbol.name = node.var_decl_name;
    symbol.type = var_type;
    symbol.is_const = node.var_decl_is_const;
    symbol.scope_level = checker.scope_level;
    symbol.line = node.line;
    symbol.column = node.column;
    
    if symbol_table_insert(checker, symbol) != 0 {
        // 符号插入失败（可能是重复定义）
        checker_report_error(checker);
        return 0;
    }
    
    return 1;
}

// 注册函数声明（仅收集函数签名，不检查函数体）
// 参数：checker - TypeChecker 指针，node - 函数声明节点
// 返回：1 表示注册成功，0 表示注册失败
// 注意：此函数用于第一遍检查，只收集函数签名到函数表，不检查函数体
fn checker_register_fn_decl(checker: &TypeChecker, node: &ASTNode) i32 {
    if checker == null || node == null || (node.type as i32) != (AST_FN_DECL as i32) {
        return 0;
    }
    
    // 获取返回类型
    const return_type: Type = type_from_ast(checker, node.fn_decl_return_type);
    
    // 创建函数签名
    // sizeof(FunctionSignature) 需要计算，假设为 40 字节（根据字段估算）
    const sig: &FunctionSignature = arena_alloc(checker.arena, 40) as &FunctionSignature;
    if sig == null {
        return 0;
    }
    sig.name = node.fn_decl_name;
    sig.param_count = node.fn_decl_param_count;
    sig.return_type = return_type;
    sig.is_extern = if node.fn_decl_body == null then 1 else 0;  // 如果 body 为 null，则是 extern 函数
    sig.is_varargs = node.fn_decl_is_varargs;  // 是否为可变参数函数
    sig.line = node.line;
    sig.column = node.column;
    
    // 分配参数类型数组
    if sig.param_count > 0 {
        // sizeof(Type) 假设为 48 字节
        sig.param_types = arena_alloc(checker.arena, 48 * sig.param_count) as &Type;
        if sig.param_types == null {
            return 0;
        }
        
        // 填充参数类型（对所有函数都需要，包括extern函数）
        var i: i32 = 0;
        while i < node.fn_decl_param_count {
            const param: &ASTNode = node.fn_decl_params[i];
            if param != null && (param.type as i32) == (AST_VAR_DECL as i32) {
                const param_type: Type = type_from_ast(checker, param.var_decl_type);
                sig.param_types[i] = param_type;
            }
            i = i + 1;
        }
    } else {
        sig.param_types = null;
    }
    
    // 将函数添加到函数表
    if function_table_insert(checker, sig) != 0 {
        // 函数重复定义
        checker_report_error(checker);
        return 0;
    }
    
    return 1;
}

// 检查函数声明
// 参数：checker - TypeChecker 指针，node - 函数声明节点
// 返回：1 表示检查通过，0 表示检查失败
// 注意：此函数假设函数签名已经通过 checker_register_fn_decl 注册到函数表
fn checker_check_fn_decl(checker: &TypeChecker, node: &ASTNode) i32 {
    if checker == null || node == null || (node.type as i32) != (AST_FN_DECL as i32) {
        return 0;
    }
    
    // 检查函数体（如果有）
    if node.fn_decl_body != null {
        checker_enter_scope(checker);
        
        // 将参数添加到符号表（仅用于函数体内的类型检查）
        var i: i32 = 0;
        while i < node.fn_decl_param_count {
            const param: &ASTNode = node.fn_decl_params[i];
            if param != null && (param.type as i32) == (AST_VAR_DECL as i32) {
                const param_type: Type = type_from_ast(checker, param.var_decl_type);
                
                // 将参数添加到符号表
                const param_symbol: &Symbol = arena_alloc(checker.arena, 32) as &Symbol;
                if param_symbol != null {
                    param_symbol.name = param.var_decl_name;
                    param_symbol.type = param_type;
                    param_symbol.is_const = 1;  // 参数是只读的
                    param_symbol.scope_level = checker.scope_level;
                    param_symbol.line = param.line;
                    param_symbol.column = param.column;
                    symbol_table_insert(checker, param_symbol);
                }
            }
            i = i + 1;
        }
        
        // 检查函数体
        checker_check_node(checker, node.fn_decl_body);
        
        checker_exit_scope(checker);
    }
    
    return 1;
}

// 检查结构体声明
// 参数：checker - TypeChecker 指针，node - 结构体声明节点
// 返回：1 表示检查通过，0 表示检查失败
fn checker_check_struct_decl(checker: &TypeChecker, node: &ASTNode) i32 {
    if checker == null || node == null || (node.type as i32) != (AST_STRUCT_DECL as i32) {
        return 0;
    }
    
    // 检查字段
    var i: i32 = 0;
    while i < node.struct_decl_field_count {
        const field: &ASTNode = node.struct_decl_fields[i];
        if field != null && (field.type as i32) == (AST_VAR_DECL as i32) {
            // 检查字段类型
            const field_type: Type = type_from_ast(checker, field.var_decl_type);
            if (field_type.kind as i32) == (TYPE_VOID as i32) && field.var_decl_type != null {
                // 可能是结构体类型，检查是否存在（但结构体可能前向引用，这里暂时不检查）
                // TODO: 支持前向声明或两遍检查
            }
        }
        i = i + 1;
    }
    
    return 1;
}

// 检查函数调用表达式
// 参数：checker - TypeChecker 指针，node - 函数调用节点
// 返回：函数返回类型（如果检查失败返回TYPE_VOID）
fn checker_check_call_expr(checker: &TypeChecker, node: &ASTNode) Type {
    var result: Type;
    result.kind = TYPE_VOID as TypeKind;
    result.enum_name = null;
    result.struct_name = null;
    result.pointer_to = null;
    result.is_ffi_pointer = 0;
    result.element_type = null;
    result.array_size = 0;
    
    if checker == null || node == null || (node.type as i32) != (AST_CALL_EXPR as i32) {
        return result;
    }
    
    // 查找被调用的函数
    const callee: &ASTNode = node.call_expr_callee;
    if callee == null || (callee.type as i32) != (AST_IDENTIFIER as i32) {
        checker_report_error(checker);
        return result;
    }
    
    const sig: &FunctionSignature = function_table_lookup(checker, callee.identifier_name as *byte);
    if sig == null {
        // 函数未定义
        checker_report_error(checker);
        return result;
    }
    
    // 检查参数个数
    // 对于可变参数函数，参数个数必须 >= 固定参数数量
    // 对于普通函数，参数个数必须 == 固定参数数量
    if sig.is_varargs != 0 {
        // 可变参数函数：参数个数必须 >= 固定参数数量
        if node.call_expr_arg_count < sig.param_count {
            checker_report_error(checker);
            return result;
        }
    } else {
        // 普通函数：参数个数必须 == 固定参数数量
        if node.call_expr_arg_count != sig.param_count {
            checker_report_error(checker);
            return result;
        }
    }
    
    // 检查参数类型（只检查固定参数，不检查可变参数部分）
    const check_count: i32 = if sig.is_varargs != 0 then sig.param_count else node.call_expr_arg_count;
    var i: i32 = 0;
    while i < check_count {
        const arg: &ASTNode = node.call_expr_args[i];
        if arg != null && checker_check_expr_type(checker, arg, sig.param_types[i]) == 0 {
            // 参数类型不匹配
            return result;
        }
        i = i + 1;
    }
    
    return sig.return_type;
}

// 检查字段访问
// 参数：checker - TypeChecker 指针，node - 字段访问节点
// 返回：字段类型（如果检查失败返回TYPE_VOID）
fn checker_check_member_access(checker: &TypeChecker, node: &ASTNode) Type {
    var result: Type;
    result.kind = TYPE_VOID as TypeKind;
    result.enum_name = null;
    result.struct_name = null;
    result.pointer_to = null;
    result.is_ffi_pointer = 0;
    result.element_type = null;
    result.array_size = 0;
    
    if checker == null || node == null || (node.type as i32) != (AST_MEMBER_ACCESS as i32) {
        return result;
    }
    
    // 获取对象类型
    const object_type: Type = checker_infer_type(checker, node.member_access_object);
    if (object_type.kind as i32) != (TYPE_STRUCT as i32) || object_type.struct_name == null {
        // 对象类型不是结构体
        checker_report_error(checker);
        return result;
    }
    
    // 查找结构体声明
    const struct_decl: &ASTNode = find_struct_decl_from_program(checker.program_node, object_type.struct_name as *byte);
    if struct_decl == null {
        checker_report_error(checker);
        return result;
    }
    
    // 查找字段类型
    const field_type: Type = find_struct_field_type(struct_decl, node.member_access_field_name as *byte);
    if (field_type.kind as i32) == (TYPE_VOID as i32) {
        // 字段不存在
        checker_report_error(checker);
        return result;
    }
    
    return field_type;
}

// 检查数组访问
// 参数：checker - TypeChecker 指针，node - 数组访问节点
// 返回：元素类型（如果检查失败返回TYPE_VOID）
fn checker_check_array_access(checker: &TypeChecker, node: &ASTNode) Type {
    var result: Type;
    result.kind = TYPE_VOID as TypeKind;
    result.enum_name = null;
    result.struct_name = null;
    result.pointer_to = null;
    result.is_ffi_pointer = 0;
    result.element_type = null;
    result.array_size = 0;
    
    if checker == null || node == null || (node.type as i32) != (AST_ARRAY_ACCESS as i32) {
        return result;
    }
    
    // 获取数组表达式类型
    const array_type: Type = checker_infer_type(checker, node.array_access_array);
    if (array_type.kind as i32) != (TYPE_ARRAY as i32) || array_type.element_type == null {
        // 数组表达式类型不是数组类型
        checker_report_error(checker);
        return result;
    }
    
    // 检查索引表达式类型是 i32
    const index_type: Type = checker_infer_type(checker, node.array_access_index);
    if (index_type.kind as i32) != (TYPE_I32 as i32) {
        // 索引表达式类型不是 i32
        checker_report_error(checker);
        return result;
    }
    
    // 返回数组的元素类型
    return array_type.element_type[0];
}

// 检查 alignof 表达式
// 参数：checker - TypeChecker 指针，node - alignof 表达式节点
// 返回：i32 类型（如果检查失败返回TYPE_VOID）
fn checker_check_alignof(checker: &TypeChecker, node: &ASTNode) Type {
    var result: Type;
    result.kind = TYPE_VOID as TypeKind;
    result.enum_name = null;
    result.struct_name = null;
    result.pointer_to = null;
    result.is_ffi_pointer = 0;
    result.element_type = null;
    result.array_size = 0;
    
    if checker == null || node == null || (node.type as i32) != (AST_ALIGNOF as i32) {
        return result;
    }
    
    // alignof 可以接受类型或表达式
    // 如果 target 是类型节点，验证类型是否有效
    // 如果 target 是表达式节点，验证表达式类型是否有效
    const target: &ASTNode = node.alignof_expr_target;
    if target == null {
        checker_report_error(checker);
        return result;
    }
    
    if node.alignof_expr_is_type != 0 {
        // target 是类型节点，验证类型是否有效
        const target_type: Type = type_from_ast(checker, target);
        if (target_type.kind as i32) == (TYPE_VOID as i32) {
            checker_report_error(checker);
            return result;
        }
    } else {
        // target 是表达式节点，验证表达式类型是否有效
        const expr_type: Type = checker_infer_type(checker, target);
        if (expr_type.kind as i32) == (TYPE_VOID as i32) {
            checker_report_error(checker);
            return result;
        }
    }
    
    // alignof 返回 i32 类型（对齐字节数）
    result.kind = TYPE_I32 as TypeKind;
    return result;
}

// 检查 len 表达式
// 参数：checker - TypeChecker 指针，node - len 表达式节点
// 返回：i32 类型（如果检查失败返回TYPE_VOID）
fn checker_check_len(checker: &TypeChecker, node: &ASTNode) Type {
    var result: Type;
    result.kind = TYPE_VOID as TypeKind;
    result.enum_name = null;
    result.struct_name = null;
    result.pointer_to = null;
    result.is_ffi_pointer = 0;
    result.element_type = null;
    result.array_size = 0;
    
    if checker == null || node == null || (node.type as i32) != (AST_LEN as i32) {
        return result;
    }
    
    // 获取数组表达式类型
    const array_type: Type = checker_infer_type(checker, node.len_expr_array);
    if (array_type.kind as i32) != (TYPE_ARRAY as i32) || array_type.element_type == null {
        // 数组表达式类型不是数组类型
        checker_report_error(checker);
        return result;
    }
    
    // len 返回 i32 类型（元素个数）
    result.kind = TYPE_I32 as TypeKind;
    return result;
}

// 检查结构体字面量
// 参数：checker - TypeChecker 指针，node - 结构体字面量节点
// 返回：结构体类型（如果检查失败返回TYPE_VOID）
fn checker_check_struct_init(checker: &TypeChecker, node: &ASTNode) Type {
    var result: Type;
    result.kind = TYPE_VOID as TypeKind;
    result.enum_name = null;
    result.struct_name = null;
    result.pointer_to = null;
    result.is_ffi_pointer = 0;
    result.element_type = null;
    result.array_size = 0;
    
    if checker == null || node == null || (node.type as i32) != (AST_STRUCT_INIT as i32) {
        return result;
    }
    
    const struct_name: &byte = node.struct_init_struct_name;
    if struct_name == null {
        checker_report_error(checker);
        return result;
    }
    
    // 查找结构体声明
    const struct_decl: &ASTNode = find_struct_decl_from_program(checker.program_node, struct_name as *byte);
    if struct_decl == null {
        checker_report_error(checker);
        return result;
    }
    
    // 检查字段数量和类型
    if node.struct_init_field_count != struct_decl.struct_decl_field_count {
        checker_report_error(checker);
        return result;
    }
    
    // 检查每个字段的类型
    var i: i32 = 0;
    while i < node.struct_init_field_count {
        const field_name: &byte = node.struct_init_field_names[i];
        const field_value: &ASTNode = node.struct_init_field_values[i];
        
        const field_type: Type = find_struct_field_type(struct_decl, field_name as *byte);
        if (field_type.kind as i32) == (TYPE_VOID as i32) {
            checker_report_error(checker);
            return result;
        }
        
        if checker_check_expr_type(checker, field_value, field_type) == 0 {
            return result;
        }
        i = i + 1;
    }
    
    result.kind = TYPE_STRUCT as TypeKind;
    result.struct_name = struct_name;
    return result;
}

// 检查二元表达式
// 参数：checker - TypeChecker 指针，node - 二元表达式节点
// 返回：表达式类型（如果检查失败返回TYPE_VOID）
fn checker_check_binary_expr(checker: &TypeChecker, node: &ASTNode) Type {
    var result: Type;
    result.kind = TYPE_VOID as TypeKind;
    result.enum_name = null;
    result.struct_name = null;
    result.pointer_to = null;
    result.is_ffi_pointer = 0;
    result.element_type = null;
    result.array_size = 0;
    
    if checker == null || node == null || (node.type as i32) != (AST_BINARY_EXPR as i32) {
        return result;
    }
    
    const op: i32 = node.binary_expr_op;
    const left_type: Type = checker_infer_type(checker, node.binary_expr_left);
    const right_type: Type = checker_infer_type(checker, node.binary_expr_right);
    
    // 算术运算符：支持 i32 和 usize 混合运算
    // 规则：如果两个操作数都是 i32，结果为 i32
    //       如果至少有一个是 usize，结果为 usize
    if op == TOKEN_PLUS || op == TOKEN_MINUS || op == TOKEN_ASTERISK || 
       op == TOKEN_SLASH || op == TOKEN_PERCENT {
        // 验证操作数类型：必须是 i32 或 usize
        if ((left_type.kind as i32) != (TYPE_I32 as i32) && (left_type.kind as i32) != (TYPE_USIZE as i32) ||
            (right_type.kind as i32) != (TYPE_I32 as i32) && (right_type.kind as i32) != (TYPE_USIZE as i32)) {
            checker_report_error(checker);
            return result;
        }
        // 结果类型：如果至少有一个是 usize，结果为 usize，否则为 i32
        if (left_type.kind as i32) == (TYPE_USIZE as i32) || (right_type.kind as i32) == (TYPE_USIZE as i32) {
            result.kind = TYPE_USIZE as TypeKind;
        } else {
            result.kind = TYPE_I32 as TypeKind;
        }
        return result;
    }
    
    // 比较运算符：支持 i32 和 usize 比较（操作数可以是 i32 或 usize，但必须都是数值类型）
    if op == TOKEN_EQUAL || op == TOKEN_NOT_EQUAL || op == TOKEN_LESS || 
       op == TOKEN_GREATER || op == TOKEN_LESS_EQUAL || op == TOKEN_GREATER_EQUAL {
        // 允许相同类型比较，也允许 i32 和 usize 之间的比较
        if type_equals(left_type, right_type) != 0 {
            result.kind = TYPE_BOOL as TypeKind;
            return result;
        }
        // 允许 i32 和 usize 之间的比较
        if ((left_type.kind as i32) == (TYPE_I32 as i32) && (right_type.kind as i32) == (TYPE_USIZE as i32) ||
            (left_type.kind as i32) == (TYPE_USIZE as i32) && (right_type.kind as i32) == (TYPE_I32 as i32)) {
            result.kind = TYPE_BOOL as TypeKind;
            return result;
        }
        // 其他类型不匹配
        checker_report_error(checker);
        return result;
    }
    
    // 逻辑运算符：操作数必须是bool
    if op == TOKEN_LOGICAL_AND || op == TOKEN_LOGICAL_OR {
        if (left_type.kind as i32) != (TYPE_BOOL as i32) || (right_type.kind as i32) != (TYPE_BOOL as i32) {
            checker_report_error(checker);
            return result;
        }
        result.kind = TYPE_BOOL as TypeKind;
        return result;
    }
    
    return result;
}

// 检查类型转换表达式
// 参数：checker - TypeChecker 指针，node - 类型转换表达式节点
// 返回：无（通过 checker_report_error 报告错误）
fn checker_check_cast_expr(checker: &TypeChecker, node: &ASTNode) {
    if checker == null || node == null || (node.type as i32) != (AST_CAST_EXPR as i32) {
        return;
    }
    
    const expr: &ASTNode = node.cast_expr_expr;
    const target_type_node: &ASTNode = node.cast_expr_target_type;
    
    if expr == null || target_type_node == null {
        checker_report_error(checker);
        return;
    }
    
    // 推断源表达式类型和目标类型
    const source_type: Type = checker_infer_type(checker, expr);
    const target_type: Type = type_from_ast(checker, target_type_node);
    
    // 验证类型转换是否合法（支持 i32 ↔ byte、i32 ↔ bool、i32 ↔ usize）
    if (source_type.kind as i32) == (TYPE_I32 as i32) && (target_type.kind as i32) == (TYPE_BYTE as i32) {
        // i32 as byte：允许
        return;
    } else if (source_type.kind as i32) == (TYPE_BYTE as i32) && (target_type.kind as i32) == (TYPE_I32 as i32) {
        // byte as i32：允许
        return;
    } else if (source_type.kind as i32) == (TYPE_I32 as i32) && (target_type.kind as i32) == (TYPE_BOOL as i32) {
        // i32 as bool：允许
        return;
    } else if (source_type.kind as i32) == (TYPE_BOOL as i32) && (target_type.kind as i32) == (TYPE_I32 as i32) {
        // bool as i32：允许
        return;
    } else if (source_type.kind as i32) == (TYPE_I32 as i32) && (target_type.kind as i32) == (TYPE_USIZE as i32) {
        // i32 as usize：允许
        return;
    } else if (source_type.kind as i32) == (TYPE_USIZE as i32) && (target_type.kind as i32) == (TYPE_I32 as i32) {
        // usize as i32：允许
        return;
    } else {
        // 不支持的类型转换
        checker_report_error(checker);
        return;
    }
}

// 检查一元表达式
// 参数：checker - TypeChecker 指针，node - 一元表达式节点
// 返回：表达式类型（如果检查失败返回TYPE_VOID）
fn checker_check_unary_expr(checker: &TypeChecker, node: &ASTNode) Type {
    var result: Type;
    result.kind = TYPE_VOID as TypeKind;
    result.enum_name = null;
    result.struct_name = null;
    result.pointer_to = null;
    result.is_ffi_pointer = 0;
    result.element_type = null;
    result.array_size = 0;
    
    if checker == null || node == null || (node.type as i32) != (AST_UNARY_EXPR as i32) {
        return result;
    }
    
    const op: i32 = node.unary_expr_op;
    const operand_type: Type = checker_infer_type(checker, node.unary_expr_operand);
    
    if op == TOKEN_EXCLAMATION {
        // 逻辑非：操作数必须是bool
        if (operand_type.kind as i32) != (TYPE_BOOL as i32) {
            checker_report_error(checker);
            return result;
        }
        result.kind = TYPE_BOOL as TypeKind;
        return result;
    } else if op == TOKEN_MINUS {
        // 一元负号：操作数必须是i32
        if (operand_type.kind as i32) != (TYPE_I32 as i32) {
            checker_report_error(checker);
            return result;
        }
        result.kind = TYPE_I32 as TypeKind;
        return result;
    } else if op == TOKEN_AMPERSAND {
        // 取地址（&expr）：操作数必须是左值（变量、字段访问等）
        // 注意：这里简化处理，只要操作数类型有效就允许取地址
        // 完整的左值检查需要在更详细的语义分析阶段进行
        if (operand_type.kind as i32) == (TYPE_VOID as i32) {
            checker_report_error(checker);
            return result;
        }
        
        // 分配操作数类型结构（从Arena分配）
        const pointed_type_ptr: &Type = arena_alloc(checker.arena, 48) as &Type;
        if pointed_type_ptr == null {
            checker_report_error(checker);
            return result;
        }
        pointed_type_ptr[0] = operand_type;
        
        // 返回指向操作数类型的指针类型（普通指针）
        result.kind = TYPE_POINTER as TypeKind;
        result.pointer_to = pointed_type_ptr;
        result.is_ffi_pointer = 0;
        return result;
    } else if op == TOKEN_ASTERISK {
        // 解引用（*expr）：操作数必须是指针类型
        if (operand_type.kind as i32) != (TYPE_POINTER as i32) {
            checker_report_error(checker);
            return result;
        }
        
        if operand_type.pointer_to == null {
            checker_report_error(checker);
            return result;
        }
        
        // 返回指针指向的类型
        return operand_type.pointer_to[0];
    }
    
    return result;
}

// 递归类型检查节点函数
// 参数：checker - TypeChecker 指针，node - AST节点
// 返回：1 表示检查通过，0 表示检查失败
fn checker_check_node(checker: &TypeChecker, node: &ASTNode) i32 {
    if checker == null || node == null {
        return 0;
    }
    
    // 根据节点类型处理（使用 if-else 替代 switch）
    if (node.type as i32) == (AST_PROGRAM as i32) {
        // 检查所有声明
        var i: i32 = 0;
        while i < node.program_decl_count {
            const decl: &ASTNode = node.program_decls[i];
            if decl != null {
                checker_check_node(checker, decl);
            }
            i = i + 1;
        }
        return 1;
    } else if (node.type as i32) == (AST_STRUCT_DECL as i32) {
        return checker_check_struct_decl(checker, node);
    } else if (node.type as i32) == (AST_FN_DECL as i32) {
        return checker_check_fn_decl(checker, node);
    } else if (node.type as i32) == (AST_VAR_DECL as i32) {
        return checker_check_var_decl(checker, node);
    } else if (node.type as i32) == (AST_BLOCK as i32) {
        checker_enter_scope(checker);
        var i: i32 = 0;
        while i < node.block_stmt_count {
            const stmt: &ASTNode = node.block_stmts[i];
            if stmt != null {
                checker_check_node(checker, stmt);
            }
            i = i + 1;
        }
        checker_exit_scope(checker);
        return 1;
    } else if (node.type as i32) == (AST_IF_STMT as i32) {
        // 检查条件类型（必须是bool）
        const cond_type: Type = checker_infer_type(checker, node.if_stmt_condition);
        if (cond_type.kind as i32) != (TYPE_BOOL as i32) {
            checker_report_error(checker);
        }
        // 检查then分支
        if node.if_stmt_then_branch != null {
            checker_check_node(checker, node.if_stmt_then_branch);
        }
        // 检查else分支
        if node.if_stmt_else_branch != null {
            checker_check_node(checker, node.if_stmt_else_branch);
        }
        return 1;
    } else if (node.type as i32) == (AST_WHILE_STMT as i32) {
        // 检查条件类型（必须是bool）
        const cond_type: Type = checker_infer_type(checker, node.while_stmt_condition);
        if (cond_type.kind as i32) != (TYPE_BOOL as i32) {
            checker_report_error(checker);
        }
        // 进入循环（增加循环深度）
        checker.loop_depth = checker.loop_depth + 1;
        // 检查循环体
        if node.while_stmt_body != null {
            checker_check_node(checker, node.while_stmt_body);
        }
        // 退出循环（减少循环深度）
        checker.loop_depth = checker.loop_depth - 1;
        return 1;
    } else if (node.type as i32) == (AST_FOR_STMT as i32) {
        // for 循环类型检查
        // 1. 检查数组表达式类型（必须是数组类型）
        const array_type: Type = checker_infer_type(checker, node.for_stmt_array);
        if (array_type.kind as i32) != (TYPE_ARRAY as i32) || array_type.element_type == null {
            checker_report_error(checker);
            // 即使类型错误，也继续检查循环体（以便报告更多错误）
        } else {
            // 2. 如果引用迭代形式，检查数组是否为可变变量
            if node.for_stmt_is_ref != 0 {
                // 引用迭代形式只能用于可变数组（var arr）
                // 需要检查数组表达式是否是可变变量
                // 注意：这里简化处理，如果数组表达式是标识符，检查符号表
                if (node.for_stmt_array.type as i32) == (AST_IDENTIFIER as i32) {
                    const symbol: &Symbol = symbol_table_lookup(checker, node.for_stmt_array.identifier_name as *byte);
                    if symbol != null && symbol.is_const != 0 {
                        // 引用迭代形式不能用于 const 变量
                        checker_report_error(checker);
                    }
                }
                // 其他情况（如数组字面量）也允许引用迭代，但运行时可能出错
            }
            
            // 3. 进入循环作用域并添加循环变量
            checker_enter_scope(checker);
            checker.loop_depth = checker.loop_depth + 1;  // 进入循环（增加循环深度）
            
            // 创建循环变量类型
            var var_type: Type;
            if node.for_stmt_is_ref != 0 {
                // 引用迭代：变量类型为 &T（指向元素的指针）
                const element_type: Type = array_type.element_type[0];
                const element_type_ptr: &Type = arena_alloc(checker.arena, 48) as &Type;
                if element_type_ptr == null {
                    checker_report_error(checker);
                } else {
                    element_type_ptr[0] = element_type;
                    var_type.kind = TYPE_POINTER as TypeKind;
                    var_type.pointer_to = element_type_ptr;
                    var_type.is_ffi_pointer = 0;
                    var_type.enum_name = null;
                    var_type.struct_name = null;
                    var_type.element_type = null;
                    var_type.array_size = 0;
                }
            } else {
                // 值迭代：变量类型为数组元素类型 T
                var_type = array_type.element_type[0];
            }
            
            // 添加循环变量到符号表（var，可修改）
            const loop_var: &Symbol = arena_alloc(checker.arena, 32) as &Symbol;
            if loop_var == null {
                checker_report_error(checker);
            } else {
                loop_var.name = node.for_stmt_var_name;
                loop_var.type = var_type;
                loop_var.is_const = 0;  // for 循环变量是可修改的（即使是值迭代形式，在循环体内也可以使用）
                loop_var.scope_level = checker.scope_level;
                loop_var.line = node.line;
                loop_var.column = node.column;
                if symbol_table_insert(checker, loop_var) != 0 {
                    checker_report_error(checker);
                }
            }
            
            // 4. 检查循环体
            if node.for_stmt_body != null {
                checker_check_node(checker, node.for_stmt_body);
            }
            
            // 5. 退出循环作用域和循环深度
            checker.loop_depth = checker.loop_depth - 1;
            checker_exit_scope(checker);
        }
        return 1;
    } else if (node.type as i32) == (AST_BREAK_STMT as i32) {
        // 检查 break 是否在循环中
        if checker.loop_depth == 0 {
            checker_report_error(checker);
            return 0;
        }
        return 1;
    } else if (node.type as i32) == (AST_CONTINUE_STMT as i32) {
        // 检查 continue 是否在循环中
        if checker.loop_depth == 0 {
            checker_report_error(checker);
            return 0;
        }
        return 1;
    } else if (node.type as i32) == (AST_RETURN_STMT as i32) {
        // TODO: 检查返回值类型是否匹配函数返回类型
        // 这需要在函数上下文中检查，暂时跳过
        if node.return_stmt_expr != null {
            checker_infer_type(checker, node.return_stmt_expr);
        }
        return 1;
    } else if (node.type as i32) == (AST_ASSIGN as i32) {
        // 检查目标是否为var（不能是const）
        const dest: &ASTNode = node.assign_dest;
        if dest == null || (dest.type as i32) != (AST_IDENTIFIER as i32) {
            checker_report_error(checker);
            return 0;
        }
        
        const symbol: &Symbol = symbol_table_lookup(checker, dest.identifier_name as *byte);
        if symbol == null {
            checker_report_error(checker);
            return 0;
        }
        
        if symbol.is_const != 0 {
            // 不能给const变量赋值
            checker_report_error(checker);
            return 0;
        }
        
        // 检查赋值类型匹配
        if checker_check_expr_type(checker, node.assign_src, symbol.type) == 0 {
            return 0;
        }
        
        return 1;
    } else if (node.type as i32) == (AST_EXPR_STMT as i32) {
        // 表达式语句：表达式语句在解析时直接返回表达式节点
        // 所以AST_EXPR_STMT节点本身应该被当作表达式节点处理
        // 但由于AST_EXPR_STMT在union中没有对应的数据结构，这里直接跳过
        // 实际上，表达式语句在parser中已经作为表达式节点返回，不会到达这里
        return 1;
    } else if (node.type as i32) == (AST_BINARY_EXPR as i32) {
        checker_check_binary_expr(checker, node);
        return 1;
    } else if (node.type as i32) == (AST_UNARY_EXPR as i32) {
        checker_check_unary_expr(checker, node);
        return 1;
    } else if (node.type as i32) == (AST_CALL_EXPR as i32) {
        checker_check_call_expr(checker, node);
        return 1;
    } else if (node.type as i32) == (AST_MEMBER_ACCESS as i32) {
        checker_check_member_access(checker, node);
        return 1;
    } else if (node.type as i32) == (AST_ARRAY_ACCESS as i32) {
        checker_check_array_access(checker, node);
        return 1;
    } else if (node.type as i32) == (AST_STRUCT_INIT as i32) {
        checker_check_struct_init(checker, node);
        return 1;
    } else if (node.type as i32) == (AST_CAST_EXPR as i32) {
        checker_check_cast_expr(checker, node);
        return 1;
    } else if (node.type as i32) == (AST_ALIGNOF as i32) {
        checker_check_alignof(checker, node);
        return 1;
    } else if (node.type as i32) == (AST_LEN as i32) {
        checker_check_len(checker, node);
        return 1;
    } else if (node.type as i32) == (AST_IDENTIFIER as i32) ||
              (node.type as i32) == (AST_NUMBER as i32) ||
              (node.type as i32) == (AST_BOOL as i32) ||
              (node.type as i32) == (AST_TYPE_NAMED as i32) {
        // 这些节点类型不需要单独检查（在表达式中检查）
        return 1;
    }
    
    // 其他节点类型
    return 1;
}

// 类型检查主函数
// 实现两遍检查机制：
// 第一遍：收集所有函数声明（解决函数循环依赖问题）
// 第二遍：检查所有声明（包括函数体、结构体、变量等）
// 参数：checker - TypeChecker 指针，ast - AST 根节点
// 返回：成功返回 0，失败返回 -1
fn checker_check(checker: &TypeChecker, ast: &ASTNode) i32 {
    if checker == null || ast == null || (ast.type as i32) != (AST_PROGRAM as i32) {
        return -1;
    }
    
    checker.program_node = ast;
    checker.error_count = 0;
    
    // 第一遍：收集所有函数声明（只注册函数签名，不检查函数体）
    // 这样在第二遍检查函数体时，所有函数都已被注册，可以相互调用
    var i: i32 = 0;
    while i < ast.program_decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && (decl.type as i32) == (AST_FN_DECL as i32) {
            checker_register_fn_decl(checker, decl);
        }
        i = i + 1;
    }
    
    // 第二遍：检查所有声明（包括函数体、结构体、变量等）
    // 此时所有函数都已被注册，函数体中的函数调用可以正确解析
    checker_check_node(checker, ast);
    
    return 0;
}


// ========== 来自文件: uya-src/codegen.uya ==========
// codegen.uya - 代码生成器模块
// 使用 LLVM C API 生成 LLVM IR 并编译为二进制代码
//
// 注意：需要先包含 arena.uya、ast.uya、checker.uya、llvm_api.uya 和 str_utils.uya
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 外部函数声明 =====

// 字符串函数（来自 str_utils.uya）
extern fn strlen(s: *byte) i32;
extern fn strcmp(s1: *byte, s2: *byte) i32;
extern fn strcpy(dest: *byte, src: *byte) *byte;
extern fn memcpy(dest: *void, src: *void, n: i32) *void;
extern fn memset(s: *void, c: i32, n: i32) *void;
extern fn fprintf(stream: *void, format: *byte, ...) i32;
extern fn sprintf(s: *byte, format: *byte, ...) i32;
extern fn snprintf(s: *byte, n: i32, format: *byte, ...) i32;

// Arena 函数（来自 arena.uya）
extern fn arena_alloc(arena: &Arena, size: i32) &void;

// LLVM API 函数（来自 llvm_api.uya）
// 注意：假设所有需要的 LLVM API 函数已在 llvm_api.uya 中声明

// ===== 常量定义 =====

// 循环栈大小（最大嵌套深度）
const LOOP_STACK_SIZE: i32 = 16;

// 结构体类型映射表大小
const STRUCT_TYPE_MAP_SIZE: i32 = 64;

// 变量映射表大小
const VAR_MAP_SIZE: i32 = 256;

// 函数映射表大小
const FUNC_MAP_SIZE: i32 = 64;

// 全局变量映射表大小
const GLOBAL_VAR_MAP_SIZE: i32 = 64;

// 最大函数参数数量
const MAX_FUNC_PARAMS: i32 = 16;

// ===== 类型定义 =====

// 结构体类型映射表项
struct StructTypeMap {
    name: &byte,// 结构体名称（存储在 Arena 中）
    llvm_type: *void// LLVM 结构体类型（LLVMTypeRef）
}

// 变量映射表项（用于局部变量）
struct VarMap {
    name: &byte,// 变量名称（存储在 Arena 中）
    value: *void,// LLVM 值（alloca 指令返回的指针，LLVMValueRef）
    type: *void,// 变量类型（用于 LLVMBuildLoad2，LLVMTypeRef）
    struct_name: &byte,// 结构体名称（仅当类型是结构体类型时有效，存储在 Arena 中）
    ast_type: &ASTNode// AST 类型节点（用于从 AST 重新构建类型，避免使用 LLVMGetElementType）
}

// 函数映射表项
struct FuncMap {
    name: &byte,// 函数名称（存储在 Arena 中）
    func: *void,// LLVM 函数值（LLVMValueRef）
    func_type: *void// LLVM 函数类型（函数签名类型，用于 LLVMBuildCall2，LLVMTypeRef）
}

// 全局变量映射表项
struct GlobalVarMap {
    name: &byte,// 全局变量名称（存储在 Arena 中）
    global_var: *void,// LLVM 全局变量值（指针，LLVMValueRef）
    type: *void,// 全局变量类型（用于 LLVMBuildLoad2，LLVMTypeRef）
    struct_name: &byte// 结构体名称（仅当类型是结构体类型时有效，存储在 Arena 中）
}

// 循环基本块信息（用于 break/continue 语句）
struct LoopInfo {
    cond_bb: *void,// 循环条件检查基本块（LLVMBasicBlockRef）
    end_bb: *void,// 循环结束基本块（用于 break，LLVMBasicBlockRef）
    inc_bb: *void// 循环递增基本块（用于 for 循环的 continue，while 循环为 null，LLVMBasicBlockRef）
}

// 代码生成器结构
// 使用 LLVM C API 生成 LLVM IR 并编译为二进制代码
struct CodeGenerator {
    arena: &Arena,// Arena 分配器（用于编译器自身内存分配）
    context: *void,// LLVM 上下文（LLVMContextRef）
    module: *void,// LLVM 模块（LLVMModuleRef）
    builder: *void,// IR 构建器（用于生成指令，LLVMBuilderRef）
    module_name: &byte,// 模块名称（存储在 Arena 中）
    
    // 结构体类型映射表（固定大小数组，存储结构体名称到LLVM类型的映射）
    // 使用固定大小数组和线性查找（简单实现）
    struct_types: [StructTypeMap: STRUCT_TYPE_MAP_SIZE],// 固定大小（最多支持64个结构体类型）
    struct_type_count: i32,// 当前结构体类型数量
    
    // 当前函数的变量表（固定大小数组，存储变量名到LLVM值的映射）
    // 用于代码生成时查找局部变量（使用 alloca 分配的栈变量）
    var_map: [VarMap: VAR_MAP_SIZE],// 固定大小（最多支持256个局部变量）
    var_map_count: i32,// 当前变量数量
    
    // 函数映射表（固定大小数组，存储函数名到LLVM函数值和类型的映射）
    // 用于代码生成时查找函数引用
    func_map: [FuncMap: FUNC_MAP_SIZE],// 固定大小（最多支持64个函数）
    func_map_count: i32,// 当前函数数量
    
    // 全局变量映射表（固定大小数组，存储全局变量名到LLVM全局变量值和类型的映射）
    // 用于代码生成时查找全局变量引用
    global_var_map: [GlobalVarMap: GLOBAL_VAR_MAP_SIZE],// 固定大小（最多支持64个全局变量）
    global_var_map_count: i32,// 当前全局变量数量
    
    basic_block_counter: i32,// 基本块计数器（用于生成唯一的基本块名称）
    string_literal_counter: i32,// 字符串字面量计数器（用于生成唯一的字符串常量名称）
    
    // 循环基本块栈（用于 break/continue 语句）
    // 使用固定大小数组作为栈，支持嵌套循环
    loop_stack: [LoopInfo: LOOP_STACK_SIZE],
    loop_stack_depth: i32,// 当前循环栈深度（0 表示不在循环中）
    
    program_node: &ASTNode// 程序节点（用于查找结构体声明等）
}

// ===== 辅助函数声明 =====

// 查找变量（在变量表中查找）
// 参数：codegen - 代码生成器指针
//       name - 变量名称
// 返回：变量映射表项指针，未找到返回 null
fn lookup_var(codegen: &CodeGenerator, name: &byte) &VarMap;

// 查找函数（在函数表中查找）
// 参数：codegen - 代码生成器指针
//       name - 函数名称
//       func_type - 函数类型（可选，用于验证）
// 返回：函数映射表项指针，未找到返回 null
fn lookup_func(codegen: &CodeGenerator, name: &byte, func_type: *void) &FuncMap;

// 查找全局变量（在全局变量表中查找）
// 参数：codegen - 代码生成器指针
//       name - 全局变量名称
// 返回：全局变量映射表项指针，未找到返回 null
fn lookup_global_var(codegen: &CodeGenerator, name: &byte) &GlobalVarMap;

// 从 AST 类型节点获取 LLVM 类型
// 参数：codegen - 代码生成器指针
//       type_node - AST 类型节点
// 返回：LLVM 类型引用，失败返回 null
fn get_llvm_type_from_ast(codegen: &CodeGenerator, type_node: &ASTNode) *void;

// 声明函数（创建函数声明，不生成函数体）
// 参数：codegen - 代码生成器指针
//       fn_decl - 函数声明 AST 节点
// 返回：成功返回 0，失败返回非 0
fn codegen_declare_function(codegen: &CodeGenerator, fn_decl: &ASTNode) i32;

// ===== 公共函数实现 =====

// 创建代码生成器
// 参数：codegen - CodeGenerator 结构体指针（由调用者分配）
//       arena - Arena 分配器指针
//       module_name - 模块名称（字符串存储在 Arena 中）
// 返回：成功返回 0，失败返回非 0
fn codegen_new(codegen: &CodeGenerator, arena: &Arena, module_name: &byte) i32 {
    if codegen == null || arena == null || module_name == null {
        return -1;
    }
    
    // 初始化结构体（使用 memset 清零）
    const codegen_size: i32 = sizeof(CodeGenerator);
    memset(codegen as *void, 0, codegen_size);
    
    // 设置 Arena 分配器
    codegen.arena = arena;
    
    // 复制模块名称到 Arena
    const name_len: i32 = strlen(module_name);
    const name_copy: &byte = arena_alloc(arena, name_len + 1) as &byte;
    if name_copy == null {
        return -1;
    }
    memcpy(name_copy as *void, module_name as *void, name_len + 1);
    codegen.module_name = name_copy;
    
    // 创建 LLVM 上下文
    codegen.context = LLVMContextCreate();
    if codegen.context == null {
        return -1;
    }
    
    // 创建 LLVM 模块
    codegen.module = LLVMModuleCreateWithNameInContext(codegen.module_name, codegen.context);
    if codegen.module == null {
        LLVMContextDispose(codegen.context);
        return -1;
    }
    
    // 创建 IR 构建器
    codegen.builder = LLVMCreateBuilderInContext(codegen.context);
    if codegen.builder == null {
        LLVMDisposeModule(codegen.module);
        LLVMContextDispose(codegen.context);
        return -1;
    }
    
    // 初始化结构体类型映射表
    codegen.struct_type_count = 0;
    
    // 初始化变量表和函数表
    codegen.var_map_count = 0;
    codegen.func_map_count = 0;
    codegen.global_var_map_count = 0;
    codegen.basic_block_counter = 0;
    codegen.string_literal_counter = 0;
    codegen.loop_stack_depth = 0;
    codegen.program_node = null;
    
    return 0;
}

// 获取基础类型的LLVM类型
// 参数：codegen - 代码生成器指针
//       type_kind - 类型种类（TypeKind枚举：TYPE_I32, TYPE_USIZE, TYPE_BOOL, TYPE_BYTE, TYPE_VOID）
// 返回：LLVM类型引用，失败返回 null
// 注意：此函数仅支持基础类型，结构体类型需要使用其他函数
//       usize 类型大小根据目标平台确定（32位平台=u32，64位平台=u64）
fn codegen_get_base_type(codegen: &CodeGenerator, type_kind: TypeKind) *void {
    if codegen == null {
        return null;
    }
    
    if type_kind == TYPE_I32 {
        // i32 类型映射到 LLVM Int32 类型（全局类型，不依赖context）
        return LLVMInt32Type();
    } else if type_kind == TYPE_USIZE {
        // usize 类型：平台相关的无符号大小类型
        // 根据目标平台的指针大小确定 usize 的大小
        // 注意：Uya Mini 简化实现，默认使用 64 位（大多数现代平台）
        // 如果需要精确的平台检测，需要调用 LLVM API 获取目标平台信息
        // 这里简化处理，默认返回 64 位类型
        return LLVMInt64Type();
    } else if type_kind == TYPE_BOOL {
        // bool 类型映射到 LLVM Int1 类型（1位整数，更精确，全局类型）
        return LLVMInt1Type();
    } else if type_kind == TYPE_BYTE {
        // byte 类型映射到 LLVM Int8 类型（8位无符号整数，全局类型）
        return LLVMInt8Type();
    } else if type_kind == TYPE_VOID {
        // void 类型映射到 LLVM Void 类型（全局类型）
        return LLVMVoidType();
    } else {
        // 不支持的类型（如 TYPE_STRUCT）
        return null;
    }
}

// 获取结构体类型的LLVM类型
// 参数：codegen - 代码生成器指针
//       struct_name - 结构体名称
// 返回：LLVM类型引用，未找到返回 null
fn codegen_get_struct_type(codegen: &CodeGenerator, struct_name: &byte) *void {
    if codegen == null || struct_name == null {
        return null;
    }
    
    // 在结构体类型映射表中查找
    var i: i32 = 0;
    while i < codegen.struct_type_count {
        if strcmp(codegen.struct_types[i].name, struct_name) == 0 {
            return codegen.struct_types[i].llvm_type;
        }
        i = i + 1;
    }
    
    // 未找到
    return null;
}

// 前向声明辅助函数
fn find_enum_decl(codegen: &CodeGenerator, enum_name: &byte) &ASTNode;
fn get_enum_variant_value(enum_decl: &ASTNode, variant_index: i32) i32;
fn find_struct_decl(codegen: &CodeGenerator, struct_name: &byte) &ASTNode;
fn find_enum_variant_index(enum_decl: &ASTNode, variant_name: &byte) i32;
fn find_struct_field_index(struct_decl: &ASTNode, field_name: &byte) i32;
fn lookup_var_struct_name(codegen: &CodeGenerator, var_name: &byte) &byte;
fn lookup_var_type(codegen: &CodeGenerator, var_name: &byte) *void;
fn lookup_var_ast_type(codegen: &CodeGenerator, var_name: &byte) &ASTNode;
fn find_struct_name_from_type(codegen: &CodeGenerator, struct_type: *void) &byte;
fn codegen_gen_struct_comparison(codegen: &CodeGenerator, left_val: *void, right_val: *void, struct_decl: &ASTNode, is_equal: i32) *void;
fn gen_branch_with_terminator(codegen: &CodeGenerator, branch_bb: *void, branch_stmt: &ASTNode, target_bb: *void) i32;

// 辅助函数：从AST类型节点获取LLVM类型（支持基础类型、结构体类型、指针类型和数组类型）
// 参数：codegen - 代码生成器指针
//       type_node - AST类型节点（AST_TYPE_NAMED、AST_TYPE_POINTER 或 AST_TYPE_ARRAY）
// 返回：LLVM类型引用，失败返回 null
fn get_llvm_type_from_ast(codegen: &CodeGenerator, type_node: &ASTNode) *void {
    if codegen == null || type_node == null {
        return null;
    }
    
    if type_node.type == AST_TYPE_NAMED {
        // 命名类型（基础类型或结构体类型）
        const type_name: &byte = type_node.type_named_name;
        if type_name == null {
            return null;
        }
        
        // 基础类型
        if strcmp(type_name, "i32") == 0 {
            return codegen_get_base_type(codegen, TYPE_I32);
        } else if strcmp(type_name, "usize") == 0 {
            return codegen_get_base_type(codegen, TYPE_USIZE);
        } else if strcmp(type_name, "bool") == 0 {
            return codegen_get_base_type(codegen, TYPE_BOOL);
        } else if strcmp(type_name, "byte") == 0 {
            return codegen_get_base_type(codegen, TYPE_BYTE);
        } else if strcmp(type_name, "void") == 0 {
            return codegen_get_base_type(codegen, TYPE_VOID);
        }
        
        // 枚举类型或结构体类型
        // 先检查是否是枚举类型（枚举类型在LLVM中就是i32类型）
        const enum_decl: &ASTNode = find_enum_decl(codegen, type_name);
        if enum_decl != null {
            // 枚举类型，返回i32类型（默认底层类型）
            return codegen_get_base_type(codegen, TYPE_I32);
        }
        
        // 结构体类型（必须在注册表中查找）
        return codegen_get_struct_type(codegen, type_name);
    } else if type_node.type == AST_TYPE_POINTER {
        // 指针类型（&T 或 *T）
        // 普通指针和 FFI 指针在 LLVM 中都映射为指针类型
        const pointed_type: &ASTNode = type_node.type_pointer_pointed_type;
        if pointed_type == null {
            return null;
        }
        
        // 递归获取指向的类型的 LLVM 类型
        const pointed_llvm_type: *void = get_llvm_type_from_ast(codegen, pointed_type);
        if pointed_llvm_type == null {
            return null;
        }
        
        // 创建指针类型（地址空间 0，默认）
        return LLVMPointerType(pointed_llvm_type, 0);
    } else if type_node.type == AST_TYPE_ARRAY {
        // 数组类型（[T: N]）
        const element_type: &ASTNode = type_node.type_array_element_type;
        const size_expr: &ASTNode = type_node.type_array_size_expr;
        if element_type == null || size_expr == null {
            return null;
        }
        
        // 数组大小必须是编译期常量（数字字面量）
        if size_expr.type != AST_NUMBER {
            return null;  // 数组大小必须是编译期常量
        }
        
        const array_size: i32 = size_expr.number_value;
        if array_size < 0 {
            return null;  // 数组大小必须非负
        }
        
        // 递归获取元素类型的 LLVM 类型
        const element_llvm_type: *void = get_llvm_type_from_ast(codegen, element_type);
        if element_llvm_type == null {
            return null;
        }
        
        // 创建数组类型
        return LLVMArrayType(element_llvm_type, array_size);
    } else {
        // 不支持的类型
        return null;
    }
}

// 注册结构体类型（从AST结构体声明创建LLVM结构体类型并注册）
// 参数：codegen - 代码生成器指针
//       struct_decl - AST结构体声明节点
// 返回：成功返回 0，失败返回非 0
// 注意：如果结构体类型已注册，会返回成功（不重复注册）
fn codegen_register_struct_type(codegen: &CodeGenerator, struct_decl: &ASTNode) i32 {
    if codegen == null || struct_decl == null || struct_decl.type != AST_STRUCT_DECL {
        return -1;
    }
    
    const struct_name: &byte = struct_decl.struct_decl_name;
    if struct_name == null {
        return -1;
    }
    
    // 检查是否已经注册
    if codegen_get_struct_type(codegen, struct_name) != null {
        return 0;  // 已注册，返回成功
    }
    
    // 检查映射表是否已满
    if codegen.struct_type_count >= STRUCT_TYPE_MAP_SIZE {
        return -1;  // 映射表已满
    }
    
    const field_count: i32 = struct_decl.struct_decl_field_count;
    if field_count < 0 {
        return -1;
    }
    
    // 准备字段类型数组
    // 使用固定大小数组（栈分配，无堆分配）
    // 注意：最多支持16个字段（如果超过需要调整）
    if field_count > 16 {
        return -1;  // 字段数过多
    }
    
    var field_types: [*void: 16] = [];
    var i: i32 = 0;
    
    // 遍历字段，获取每个字段的LLVM类型
    while i < field_count {
        const field: &ASTNode = struct_decl.struct_decl_fields[i];
        if field == null || field.type != AST_VAR_DECL {
            return -1;
        }
        
        const field_type_node: &ASTNode = field.var_decl_type;
        const field_llvm_type: *void = get_llvm_type_from_ast(codegen, field_type_node);
        if field_llvm_type == null {
            return -1;  // 字段类型无效或未找到（结构体类型需要先注册）
        }
        
        field_types[i] = field_llvm_type;
        i = i + 1;
    }
    
    // 创建LLVM结构体类型
    const struct_type: *void;
    if field_count == 0 {
        // 空结构体
        struct_type = LLVMStructTypeInContext(codegen.context, null, 0, 0);
    } else {
        // 非空结构体（packed=0，使用默认对齐）
        // 注意：需要将数组转换为指针传递给 LLVM API
        struct_type = LLVMStructTypeInContext(codegen.context, &field_types[0] as *void, field_count, 0);
    }
    
    if struct_type == null {
        return -1;
    }
    
    // 注册到映射表
    const idx: i32 = codegen.struct_type_count;
    codegen.struct_types[idx].name = struct_name;  // 名称已经在Arena中
    codegen.struct_types[idx].llvm_type = struct_type;
    codegen.struct_type_count = codegen.struct_type_count + 1;
    
    return 0;
}

// 在变量表中查找变量（先查找局部变量，再查找全局变量）
// 参数：codegen - 代码生成器指针
//       var_name - 变量名称
// 返回：变量映射表项指针，未找到返回 null
fn lookup_var(codegen: &CodeGenerator, name: &byte) &VarMap {
    if codegen == null || name == null {
        return null;
    }
    
    // 先查找局部变量表（从后向前查找，由于禁止变量遮蔽，理论上只需要查找最后一个匹配项）
    var i: i32 = codegen.var_map_count - 1;
    while i >= 0 {
        if codegen.var_map[i].name != null && strcmp(codegen.var_map[i].name, name) == 0 {
            return &codegen.var_map[i];
        }
        i = i - 1;
    }
    
    // 如果局部变量表中未找到，查找全局变量表
    i = 0;
    while i < codegen.global_var_map_count {
        if codegen.global_var_map[i].name != null && strcmp(codegen.global_var_map[i].name, name) == 0 {
            // 返回全局变量的 VarMap（需要构造，但这里简化处理，返回 null 表示是全局变量）
            // 注意：实际实现中，全局变量和局部变量的处理方式不同
            return null;  // 全局变量需要特殊处理
        }
        i = i + 1;
    }
    
    return null;  // 未找到
}

// 查找函数（在函数表中查找）
// 参数：codegen - 代码生成器指针
//       name - 函数名称
//       func_type - 函数类型（可选，用于验证）
// 返回：函数映射表项指针，未找到返回 null
fn lookup_func(codegen: &CodeGenerator, name: &byte, func_type: *void) &FuncMap {
    if codegen == null || name == null {
        return null;
    }
    
    // 线性查找
    var i: i32 = 0;
    while i < codegen.func_map_count {
        if codegen.func_map[i].name != null && strcmp(codegen.func_map[i].name, name) == 0 {
            // 如果提供了 func_type，验证类型是否匹配
            if func_type != null && codegen.func_map[i].func_type != func_type {
                return null;  // 类型不匹配
            }
            return &codegen.func_map[i];
        }
        i = i + 1;
    }
    
    return null;  // 未找到
}

// 查找全局变量（在全局变量表中查找）
// 参数：codegen - 代码生成器指针
//       name - 全局变量名称
// 返回：全局变量映射表项指针，未找到返回 null
fn lookup_global_var(codegen: &CodeGenerator, name: &byte) &GlobalVarMap {
    if codegen == null || name == null {
        return null;
    }
    
    // 线性查找
    var i: i32 = 0;
    while i < codegen.global_var_map_count {
        if codegen.global_var_map[i].name != null && strcmp(codegen.global_var_map[i].name, name) == 0 {
            return &codegen.global_var_map[i];
        }
        i = i + 1;
    }
    
    return null;  // 未找到
}

// 从程序节点中查找结构体声明
// 参数：codegen - 代码生成器指针
//       struct_name - 结构体名称
// 返回：找到的结构体声明节点指针，未找到返回 null
fn find_struct_decl(codegen: &CodeGenerator, struct_name: &byte) &ASTNode {
    if codegen == null || codegen.program_node == null || struct_name == null {
        return null;
    }
    
    const program: &ASTNode = codegen.program_node;
    if program.type != AST_PROGRAM {
        return null;
    }
    
    var i: i32 = 0;
    while i < program.program_decl_count {
        const decl: &ASTNode = program.program_decls[i];
        if decl != null && decl.type == AST_STRUCT_DECL {
            if decl.struct_decl_name != null && strcmp(decl.struct_decl_name, struct_name) == 0 {
                return decl;
            }
        }
        i = i + 1;
    }
    
    return null;
}

// 从程序节点中查找枚举声明
// 参数：codegen - 代码生成器指针
//       enum_name - 枚举名称
// 返回：找到的枚举声明节点指针，未找到返回 null
fn find_enum_decl(codegen: &CodeGenerator, enum_name: &byte) &ASTNode {
    if codegen == null || codegen.program_node == null || enum_name == null {
        return null;
    }
    
    const program: &ASTNode = codegen.program_node;
    if program.type != AST_PROGRAM {
        return null;
    }
    
    var i: i32 = 0;
    while i < program.program_decl_count {
        const decl: &ASTNode = program.program_decls[i];
        if decl != null && decl.type == AST_ENUM_DECL {
            if decl.enum_decl_name != null && strcmp(decl.enum_decl_name, enum_name) == 0 {
                return decl;
            }
        }
        i = i + 1;
    }
    
    return null;
}

// 在枚举声明中查找变体索引
// 参数：enum_decl - 枚举声明节点
//       variant_name - 变体名称
// 返回：变体索引（>= 0），未找到返回 -1
fn find_enum_variant_index(enum_decl: &ASTNode, variant_name: &byte) i32 {
    if enum_decl == null || enum_decl.type != AST_ENUM_DECL || variant_name == null {
        return -1;
    }
    
    var i: i32 = 0;
    while i < enum_decl.enum_decl_variant_count {
        if enum_decl.enum_decl_variants != null && 
           enum_decl.enum_decl_variants[i].name != null && 
           strcmp(enum_decl.enum_decl_variants[i].name, variant_name) == 0 {
            return i;
        }
        i = i + 1;
    }
    
    return -1;
}

// 获取枚举变体的值（显式值或计算值）
// 参数：enum_decl - 枚举声明节点
//       variant_index - 变体索引
// 返回：枚举值（整数），失败返回 -1
// 注意：如果变体有显式值，使用显式值；否则使用变体索引（从0开始，或基于前一个变体的值）
fn get_enum_variant_value(enum_decl: &ASTNode, variant_index: i32) i32 {
    if enum_decl == null || enum_decl.type != AST_ENUM_DECL || variant_index < 0 {
        return -1;
    }
    
    if variant_index >= enum_decl.enum_decl_variant_count {
        return -1;
    }
    
    if enum_decl.enum_decl_variants == null {
        return -1;
    }
    const variant: &EnumVariant = &enum_decl.enum_decl_variants[variant_index];
    
    // 如果变体有显式值，使用显式值
    if variant.value != null {
        // 解析显式值（字符串形式的数字）
        // 简化实现：假设显式值是数字字符串，需要解析
        // 这里简化处理，返回变体索引
        // 实际实现中需要解析字符串为整数
        return variant_index;
    }
    
    // 如果没有显式值，使用变体索引（从0开始）
    // 注意：实际实现中可能需要考虑前一个变体的值
    return variant_index;
}

// 在结构体声明中查找字段索引
// 参数：struct_decl - 结构体声明节点
//       field_name - 字段名称
// 返回：字段索引（>= 0），未找到返回 -1
fn find_struct_field_index(struct_decl: &ASTNode, field_name: &byte) i32 {
    if struct_decl == null || struct_decl.type != AST_STRUCT_DECL || field_name == null {
        return -1;
    }
    
    var i: i32 = 0;
    while i < struct_decl.data.struct_decl.field_count {
        const field: &ASTNode = struct_decl.struct_decl_fields[i];
        if field != null && field.type == AST_VAR_DECL {
            if field.data.var_decl.name != null && 
               strcmp(field.data.var_decl.name, field_name) == 0 {
                return i;
            }
        }
        i = i + 1;
    }
    
    return -1;
}

// 从 LLVM 类型查找结构体名称
// 参数：codegen - 代码生成器指针
//       struct_type - LLVM 结构体类型
// 返回：结构体名称，未找到返回 null
fn find_struct_name_from_type(codegen: &CodeGenerator, struct_type: *void) &byte {
    if codegen == null || struct_type == null {
        return null;
    }
    
    // 在结构体类型映射表中查找匹配的类型
    var i: i32 = 0;
    while i < codegen.struct_type_count {
        if codegen.struct_types[i].llvm_type == struct_type {
            return codegen.struct_types[i].name;
        }
        i = i + 1;
    }
    
    return null;  // 未找到
}

// 在变量表中查找变量类型（先查找局部变量，再查找全局变量）
// 参数：codegen - 代码生成器指针
//       var_name - 变量名称
// 返回：LLVM类型引用，未找到返回 null
fn lookup_var_type(codegen: &CodeGenerator, var_name: &byte) *void {
    if codegen == null || var_name == null {
        return null;
    }
    
    // 先查找局部变量表（从后向前查找，由于禁止变量遮蔽，理论上只需要查找最后一个匹配项）
    var i: i32 = codegen.var_map_count - 1;
    while i >= 0 {
        if codegen.var_map[i].name != null && strcmp(codegen.var_map[i].name, var_name) == 0 {
            return codegen.var_map[i].type;
        }
        i = i - 1;
    }
    
    // 如果局部变量表中未找到，查找全局变量表
    i = 0;
    while i < codegen.global_var_map_count {
        if codegen.global_var_map[i].name != null && strcmp(codegen.global_var_map[i].name, var_name) == 0 {
            return codegen.global_var_map[i].type;
        }
        i = i + 1;
    }
    
    return null;  // 未找到
}

// 在变量表中查找变量 AST 类型节点（仅查找局部变量）
// 参数：codegen - 代码生成器指针
//       var_name - 变量名称
// 返回：AST类型节点，未找到返回 null
fn lookup_var_ast_type(codegen: &CodeGenerator, var_name: &byte) &ASTNode {
    if codegen == null || var_name == null {
        return null;
    }
    
    // 查找局部变量表（从后向前查找）
    var i: i32 = codegen.var_map_count - 1;
    while i >= 0 {
        if codegen.var_map[i].name != null && strcmp(codegen.var_map[i].name, var_name) == 0 {
            return codegen.var_map[i].ast_type;
        }
        i = i - 1;
    }
    
    return null;  // 未找到（全局变量暂不支持）
}

// 在变量表中查找变量结构体名称（先查找局部变量，再查找全局变量）
// 参数：codegen - 代码生成器指针
//       var_name - 变量名称
// 返回：结构体名称（如果变量是结构体类型），未找到返回 null
fn lookup_var_struct_name(codegen: &CodeGenerator, var_name: &byte) &byte {
    if codegen == null || var_name == null {
        return null;
    }
    
    // 先查找局部变量表（从后向前查找，由于禁止变量遮蔽，理论上只需要查找最后一个匹配项）
    var i: i32 = codegen.var_map_count - 1;
    while i >= 0 {
        if codegen.var_map[i].name != null && strcmp(codegen.var_map[i].name, var_name) == 0 {
            return codegen.var_map[i].struct_name;
        }
        i = i - 1;
    }
    
    // 如果局部变量表中未找到，查找全局变量表
    i = 0;
    while i < codegen.global_var_map_count {
        if codegen.global_var_map[i].name != null && strcmp(codegen.global_var_map[i].name, var_name) == 0 {
            return codegen.global_var_map[i].struct_name;
        }
        i = i + 1;
    }
    
    return null;  // 未找到
}

// 在变量表中添加变量
// 参数：codegen - 代码生成器指针
//       var_name - 变量名称（存储在 Arena 中）
//       value - LLVM值（变量指针）
//       type - 变量类型（用于 LLVMBuildLoad2）
//       struct_name - 结构体名称（仅当类型是结构体类型时有效，存储在 Arena 中，可为 null）
//       ast_type - AST 类型节点（用于从 AST 重新构建类型，可为 null）
// 返回：成功返回 0，失败返回非 0
fn add_var(codegen: &CodeGenerator, var_name: &byte, value: *void, type: *void, struct_name: &byte, ast_type: &ASTNode) i32 {
    if codegen == null || var_name == null || value == null || type == null {
        return -1;
    }
    
    // 检查映射表是否已满
    if codegen.var_map_count >= VAR_MAP_SIZE {
        return -1;  // 映射表已满
    }
    
    // 添加到映射表
    const idx: i32 = codegen.var_map_count;
    codegen.var_map[idx].name = var_name;
    codegen.var_map[idx].value = value;
    codegen.var_map[idx].type = type;
    codegen.var_map[idx].struct_name = struct_name;  // 结构体名称（可为 null）
    codegen.var_map[idx].ast_type = ast_type;  // AST 类型节点（可为 null）
    codegen.var_map_count = codegen.var_map_count + 1;
    
    return 0;
}

// 在全局变量表中添加全局变量
// 参数：codegen - 代码生成器指针
//       var_name - 全局变量名称（存储在 Arena 中）
//       global_var - LLVM全局变量值（指针）
//       type - 全局变量类型（用于 LLVMBuildLoad2）
//       struct_name - 结构体名称（仅当类型是结构体类型时有效，存储在 Arena 中，可为 null）
// 返回：成功返回 0，失败返回非 0
fn add_global_var(codegen: &CodeGenerator, var_name: &byte, global_var: *void, type: *void, struct_name: &byte) i32 {
    if codegen == null || var_name == null || global_var == null || type == null {
        return -1;
    }
    
    // 检查映射表是否已满
    if codegen.global_var_map_count >= GLOBAL_VAR_MAP_SIZE {
        return -1;  // 映射表已满
    }
    
    // 添加到映射表
    const idx: i32 = codegen.global_var_map_count;
    codegen.global_var_map[idx].name = var_name;
    codegen.global_var_map[idx].global_var = global_var;
    codegen.global_var_map[idx].type = type;
    codegen.global_var_map[idx].struct_name = struct_name;  // 结构体名称（可为 null）
    codegen.global_var_map_count = codegen.global_var_map_count + 1;
    
    return 0;
}

// 在函数表中添加函数
// 参数：codegen - 代码生成器指针
//       func_name - 函数名称（存储在 Arena 中）
//       func - LLVM函数值
//       func_type - LLVM函数类型（函数签名类型，用于 LLVMBuildCall2）
// 返回：成功返回 0，失败返回非 0
fn add_func(codegen: &CodeGenerator, func_name: &byte, func: *void, func_type: *void) i32 {
    if codegen == null || func_name == null || func == null || func_type == null {
        return -1;
    }
    
    // 检查映射表是否已满
    if codegen.func_map_count >= FUNC_MAP_SIZE {
        return -1;  // 映射表已满
    }
    
    // 添加到映射表
    const idx: i32 = codegen.func_map_count;
    codegen.func_map[idx].name = func_name;
    codegen.func_map[idx].func = func;
    codegen.func_map[idx].func_type = func_type;
    codegen.func_map_count = codegen.func_map_count + 1;
    
    return 0;
}

// 生成结构体比较代码（== 和 !=）
// 参数：codegen - 代码生成器指针
//       left_val - 左操作数值
//       right_val - 右操作数值
//       struct_decl - 结构体声明节点
//       is_equal - 1 表示 == 比较，0 表示 != 比较
// 返回：LLVM值引用（i1 布尔值），失败返回 null
fn codegen_gen_struct_comparison(codegen: &CodeGenerator, left_val: *void, right_val: *void, struct_decl: &ASTNode, is_equal: i32) *void {
    if codegen == null || left_val == null || right_val == null || struct_decl == null || 
       struct_decl.type != AST_STRUCT_DECL {
        return null;
    }
    
    const field_count: i32 = struct_decl.struct_decl_field_count;
    
    // 处理空结构体（0个字段）
    if field_count == 0 {
        // 空结构体总是相等
        const bool_type: *void = codegen_get_base_type(codegen, TYPE_BOOL);
        if bool_type == null {
            return null;
        }
        const bool_value: i64 = if is_equal != 0 { 1 } else { 0 };
        return LLVMConstInt(bool_type, bool_value, 0);
    }
    
    // 对于每个字段，提取并比较字段值
    // 最多支持16个字段
    if field_count > 16 {
        return null;  // 字段数过多
    }
    
    var field_comparisons: [*void: 16] = [];
    var valid_comparisons: i32 = 0;
    
    var i: i32 = 0;
    while i < field_count {
        const field: &ASTNode = struct_decl.struct_decl_fields[i];
        if field == null || field.type != AST_VAR_DECL {
            return null;
        }
        
        const field_type_node: &ASTNode = field.var_decl_type;
        if field_type_node == null || field_type_node.type != AST_TYPE_NAMED {
            return null;
        }
        
        const field_type_name: &byte = field_type_node.data.type_named.name;
        if field_type_name == null {
            return null;
        }
        
        // 提取字段值
        const left_field: *void = LLVMBuildExtractValue(codegen.builder, left_val, i, "");
        const right_field: *void = LLVMBuildExtractValue(codegen.builder, right_val, i, "");
        if left_field == null || right_field == null {
            return null;
        }
        
        // 根据字段类型进行比较
        var field_eq: *void = null;
        
        if strcmp(field_type_name, "i32") == 0 || strcmp(field_type_name, "bool") == 0 {
            // 基础类型（i32、bool）：使用整数比较
            field_eq = LLVMBuildICmp(codegen.builder, LLVMIntEQ, left_field, right_field, "");
        } else {
            // 嵌套结构体类型：递归调用结构体比较
            const field_type: *void = LLVMTypeOf(left_field);
            if field_type == null {
                return null;
            }
            const nested_struct_name: &byte = find_struct_name_from_type(codegen, field_type);
            if nested_struct_name == null {
                return null;
            }
            
            const nested_struct_decl: &ASTNode = find_struct_decl(codegen, nested_struct_name);
            if nested_struct_decl == null {
                return null;
            }
            
            // 递归调用结构体比较（使用 == 比较，然后根据 is_equal 决定是否取反）
            field_eq = codegen_gen_struct_comparison(
                codegen,
                left_field,
                right_field,
                nested_struct_decl,
                1  // 使用 == 比较
            );
        }
        
        if field_eq == null {
            return null;
        }
        
        field_comparisons[valid_comparisons] = field_eq;
        valid_comparisons = valid_comparisons + 1;
        i = i + 1;
    }
    
    // 组合所有字段比较结果（逻辑与）
    if valid_comparisons == 0 {
        return null;
    }
    
    var result: *void = field_comparisons[0];
    i = 1;
    while i < valid_comparisons {
        result = LLVMBuildAnd(codegen.builder, result, field_comparisons[i], "");
        if result == null {
            return null;
        }
        i = i + 1;
    }
    
    // 如果是 != 比较，对结果取反
    if is_equal == 0 {
        const bool_type: *void = codegen_get_base_type(codegen, TYPE_BOOL);
        if bool_type == null {
            return null;
        }
        const one: *void = LLVMConstInt(bool_type, 1, 0);
        result = LLVMBuildXor(codegen.builder, result, one, "");  // XOR 1 实现取反
    }
    
    return result;
}

// 生成表达式代码（从表达式AST节点生成LLVM值）
// 参数：codegen - 代码生成器指针
//       expr - 表达式AST节点
// 返回：LLVM值引用（LLVMValueRef），失败返回 null
// 注意：此函数需要在函数上下文中调用（builder需要在函数的基本块中）
//       标识符和函数调用使用变量表和函数表查找
fn codegen_gen_expr(codegen: &CodeGenerator, expr: &ASTNode) *void {
    if codegen == null || expr == null || codegen.builder == null {
        return null;
    }
    
    if expr.type == AST_NUMBER {
        // 数字字面量：创建 i32 常量
        const value: i32 = expr.data.number.value;
        const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32);
        if i32_type == null {
            return null;
        }
        return LLVMConstInt(i32_type, value as i64, 1);  // 1 表示有符号
    } else if expr.type == AST_BOOL {
        // 布尔字面量：创建 i1 常量（true=1, false=0）
        const value: i32 = expr.data.bool_literal.value;
        const bool_type: *void = codegen_get_base_type(codegen, TYPE_BOOL);
        if bool_type == null {
            return null;
        }
        const bool_value: i64 = if value != 0 { 1 } else { 0 };
        return LLVMConstInt(bool_type, bool_value, 0);  // 0 表示无符号（布尔值）
    } else if expr.type == AST_STRING {
        // 字符串字面量：创建全局字符串常量，返回指向它的指针（*byte 类型）
        const str_value: &byte = expr.data.string_literal.value;
        if str_value == null {
            return null;
        }
        
        // 计算字符串长度（不包括 null 终止符，LLVMConstStringInContext 会自动添加）
        const str_len: i32 = strlen(str_value);
        
        // 创建 i8 数组类型（字符串长度 + 1 个 null 终止符）
        const i8_type: *void = LLVMInt8Type();
        const array_type: *void = LLVMArrayType(i8_type, str_len + 1);
        
        // 创建字符串常量值（LLVMConstStringInContext 会自动添加 null 终止符）
        // 参数：context, string, length, dontNullTerminate
        // dontNullTerminate = 0 表示自动添加 null 终止符
        const str_const: *void = LLVMConstStringInContext(codegen.context, str_value, str_len, 0);
        if str_const == null {
            return null;
        }
        
        // 生成唯一的全局变量名称
        const str_id: i32 = codegen.string_literal_counter;
        codegen.string_literal_counter = codegen.string_literal_counter + 1;
        
        // 创建全局变量名称（使用固定大小数组）
        var global_name: [byte: 64] = [];
        snprintf(&global_name[0] as *byte, 64, "str.%d", str_id);
        
        // 将名称复制到 Arena
        const name_len: i32 = strlen(&global_name[0] as *byte);
        const name_copy: &byte = arena_alloc(codegen.arena, name_len + 1) as &byte;
        if name_copy == null {
            return null;
        }
        memcpy(name_copy as *void, &global_name[0] as *void, name_len + 1);
        
        // 创建全局变量（类型为数组）
        const global_var: *void = LLVMAddGlobal(codegen.module, array_type, name_copy);
        if global_var == null {
            return null;
        }
        
        // 设置初始值为字符串常量
        LLVMSetInitializer(global_var, str_const);
        
        // 设置为常量（不可变）
        LLVMSetGlobalConstant(global_var, 1);
        
        // 设置链接属性（内部链接）
        // 注意：LLVMInternalLinkage 已在 llvm_api.uya 中定义
        LLVMSetLinkage(global_var, LLVMInternalLinkage);
        
        // 全局变量本身就是一个指针，可以直接返回
        return global_var;
    } else if expr.type == AST_IDENTIFIER {
        // 标识符（变量）：从变量表查找并加载值
        const var_name: &byte = expr.data.identifier.name;
        if var_name == null {
            return null;
        }
        
        // 查找变量（先查找局部变量，再查找全局变量）
        const var_map: &VarMap = lookup_var(codegen, var_name);
        if var_map != null {
            // 局部变量：加载值
            return LLVMBuildLoad2(codegen.builder, var_map.type, var_map.value, var_name);
        }
        
        // 查找全局变量
        const global_var_map: &GlobalVarMap = lookup_global_var(codegen, var_name);
        if global_var_map != null {
            // 全局变量：加载值
            return LLVMBuildLoad2(codegen.builder, global_var_map.type, global_var_map.global_var, var_name);
        }
        
        // 检查是否是 null 标识符
        if strcmp(var_name, "null") == 0 {
            // null 标识符：返回 null 指针（类型需要从上下文推断）
            // 注意：这里简化处理，实际实现中需要从上下文获取类型
            // 对于 null，通常需要从比较操作的另一侧获取类型
            return null;  // 需要从上下文推断类型
        }
        
        return null;  // 变量未找到
    } else if expr.type == AST_UNARY_EXPR {
        // 一元表达式（!, -, &, *）
        const operand: &ASTNode = expr.data.unary_expr.operand;
        if operand == null {
            return null;
        }
        
        const op: i32 = expr.data.unary_expr.op;
        
        if op == TOKEN_AMPERSAND {
            // 取地址运算符：&expr
            // 操作数必须是左值（变量、字段访问等）
            // 对于标识符（变量），直接从变量表获取指针
            if operand.type == AST_IDENTIFIER {
                const var_name: &byte = operand.data.identifier.name;
                if var_name == null {
                    return null;
                }
                const var_map: &VarMap = lookup_var(codegen, var_name);
                if var_map == null {
                    // 尝试查找全局变量
                    const global_var_map: &GlobalVarMap = lookup_global_var(codegen, var_name);
                    if global_var_map != null {
                        return global_var_map.global_var;
                    }
                    return null;  // 变量未找到
                }
                // 变量指针已经是地址，直接返回
                return var_map.value;
            }
            // 对于其他表达式（如字段访问、数组访问），需要先计算表达式值
            // 然后分配临时空间存储值，返回临时空间的地址
            // 注意：这是一个简化实现，完整的左值检查应该在类型检查阶段完成
            const operand_val: *void = codegen_gen_expr(codegen, operand);
            if operand_val == null {
                return null;
            }
            const operand_type: *void = LLVMTypeOf(operand_val);
            if operand_type == null {
                return null;
            }
            // 使用 alloca 分配临时空间
            const temp_ptr: *void = LLVMBuildAlloca(codegen.builder, operand_type, "");
            if temp_ptr == null {
                return null;
            }
            // store 值到临时空间
            LLVMBuildStore(codegen.builder, operand_val, temp_ptr);
            // 返回临时空间的地址
            return temp_ptr;
        } else if op == TOKEN_ASTERISK {
            // 解引用运算符：*expr
            // 操作数必须是指针类型
            // 如果操作数是标识符，从 AST 类型节点获取指向的类型（避免使用 LLVMGetElementType）
            var operand_val: *void = null;
            var pointed_type: *void = null;
            
            if operand.type == AST_IDENTIFIER {
                // 优化：对于标识符，从变量表获取 AST 类型节点，然后从 AST 重新构建指向的类型
                const var_name: &byte = operand.data.identifier.name;
                if var_name != null {
                    const var_ast_type: &ASTNode = lookup_var_ast_type(codegen, var_name);
                    if var_ast_type != null && var_ast_type.type == AST_TYPE_POINTER {
                        // 从 AST 类型节点获取指向的类型节点
                        const pointed_ast_type: &ASTNode = var_ast_type.data.type_pointer.pointed_type;
                        if pointed_ast_type != null {
                            // 从 AST 类型节点重新构建指向类型的 LLVM 类型
                            pointed_type = get_llvm_type_from_ast(codegen, pointed_ast_type);
                            if pointed_type != null {
                                // 需要加载指针变量的值（指针变量本身存储的是指针值）
                                const var_map: &VarMap = lookup_var(codegen, var_name);
                                if var_map != null {
                                    // 加载指针变量的值（即指针值本身）
                                    operand_val = LLVMBuildLoad2(codegen.builder, var_map.type, var_map.value, var_name);
                                }
                            }
                        }
                    }
                }
            }
            
            // 如果优化路径失败，使用通用方法
            if operand_val == null || pointed_type == null {
                operand_val = codegen_gen_expr(codegen, operand);
                if operand_val == null {
                    return null;
                }
                const operand_type: *void = LLVMTypeOf(operand_val);
                if operand_type == null {
                    return null;
                }
                // 检查操作数类型是否为指针类型
                if LLVMGetTypeKind(operand_type) != LLVMPointerTypeKind {
                    return null;  // 操作数不是指针类型
                }
                // 获取指针指向的类型（通用方法仍然使用 LLVMGetElementType）
                pointed_type = LLVMGetElementType(operand_type);
                if pointed_type == null {
                    return null;
                }
            }
            
            // 使用 LLVMBuildLoad2 加载指针指向的值
            return LLVMBuildLoad2(codegen.builder, pointed_type, operand_val, "");
        }
        
        // 处理其他一元运算符（!, -）
        const operand_val: *void = codegen_gen_expr(codegen, operand);
        if operand_val == null {
            return null;
        }
        
        // 简化实现：假设操作数类型可以从operand_val获取
        const operand_type: *void = LLVMTypeOf(operand_val);
        if operand_type == null {
            return null;
        }
        
        if op == TOKEN_EXCLAMATION {
            // 逻辑非：!operand
            // 对于布尔值（i1），使用 XOR 1
            if LLVMGetTypeKind(operand_type) == LLVMIntegerTypeKind {
                const one: *void = LLVMConstInt(operand_type, 1, 0);
                return LLVMBuildXor(codegen.builder, operand_val, one, "");
            }
        } else if op == TOKEN_MINUS {
            // 一元负号：-operand
            // 对于整数，使用 sub 0, operand
            if LLVMGetTypeKind(operand_type) == LLVMIntegerTypeKind {
                const zero: *void = LLVMConstInt(operand_type, 0, 1);
                return LLVMBuildSub(codegen.builder, zero, operand_val, "");
            }
        }
        
        return null;
    } else if expr.type == AST_BINARY_EXPR {
        // 二元表达式（算术、比较、逻辑运算符）
        const left: &ASTNode = expr.data.binary_expr.left;
        const right: &ASTNode = expr.data.binary_expr.right;
        if left == null || right == null {
            return null;
        }
        
        const op: i32 = expr.data.binary_expr.op;
        
        // 特殊处理逻辑运算符（&&, ||）以实现短路求值
        if op == TOKEN_LOGICAL_AND || op == TOKEN_LOGICAL_OR {
            // 获取当前基本块
            const current_bb: *void = LLVMGetInsertBlock(codegen.builder);
            if current_bb == null {
                return null;
            }
            
            // 获取当前基本块所在的函数
            const func: *void = LLVMGetBasicBlockParent(current_bb);
            if func == null {
                return null;
            }
            
            // 生成左操作数
            var left_val: *void = codegen_gen_expr(codegen, left);
            if left_val == null {
                return null;
            }
            
            // 检查左操作数类型是否为i1（布尔类型）
            const left_type: *void = LLVMTypeOf(left_val);
            if left_type == null || LLVMGetTypeKind(left_type) != LLVMIntegerTypeKind || LLVMGetIntTypeWidth(left_type) != 1 {
                fprintf(2 as *void, "错误: 逻辑运算符左操作数必须是布尔类型 (i1)\n");
                return null;
            }
            
            // 创建临时变量来存储结果
            const result: *void = LLVMBuildAlloca(codegen.builder, left_type, "bool_result" as *byte);
            if result == null {
                return null;
            }
            
            // 创建基本块（使用计数器生成唯一名称）
            const bb_id: i32 = codegen.basic_block_counter;
            codegen.basic_block_counter = codegen.basic_block_counter + 1;
            
            var then_name: [byte: 32] = [];
            var else_name: [byte: 32] = [];
            var merge_name: [byte: 32] = [];
            snprintf(&then_name[0] as *byte, 32, "logical_then.%d", bb_id);
            snprintf(&else_name[0] as *byte, 32, "logical_else.%d", bb_id);
            snprintf(&merge_name[0] as *byte, 32, "logical_merge.%d", bb_id);
            const then_bb: *void = LLVMAppendBasicBlock(func, &then_name[0] as *byte);
            const else_bb: *void = LLVMAppendBasicBlock(func, &else_name[0] as *byte);
            const merge_bb: *void = LLVMAppendBasicBlock(func, &merge_name[0] as *byte);
            
            if op == TOKEN_LOGICAL_AND {
                // 短路与：if (left) then evaluate right else result = false
                LLVMBuildCondBr(codegen.builder, left_val, then_bb, else_bb);
                
                // then_bb：计算右操作数
                LLVMPositionBuilderAtEnd(codegen.builder, then_bb);
                const right_val: *void = codegen_gen_expr(codegen, right);
                if right_val == null {
                    return null;
                }
                // 检查右操作数类型是否为i1（布尔类型）
                const right_type: *void = LLVMTypeOf(right_val);
                if right_type == null || LLVMGetTypeKind(right_type) != LLVMIntegerTypeKind || LLVMGetIntTypeWidth(right_type) != 1 {
                    fprintf(2 as *void, "错误: 逻辑运算符右操作数必须是布尔类型 (i1)\n");
                    return null;
                }
                LLVMBuildStore(codegen.builder, right_val, result);
                LLVMBuildBr(codegen.builder, merge_bb);
                
                // else_bb：结果为false
                LLVMPositionBuilderAtEnd(codegen.builder, else_bb);
                LLVMBuildStore(codegen.builder, LLVMConstInt(left_type, 0, 0), result);
                LLVMBuildBr(codegen.builder, merge_bb);
            } else if op == TOKEN_LOGICAL_OR {
                // 短路或：if (left) then result = true else evaluate right
                LLVMBuildCondBr(codegen.builder, left_val, then_bb, else_bb);
                
                // then_bb：结果为true
                LLVMPositionBuilderAtEnd(codegen.builder, then_bb);
                LLVMBuildStore(codegen.builder, LLVMConstInt(left_type, 1, 0), result);
                LLVMBuildBr(codegen.builder, merge_bb);
                
                // else_bb：计算右操作数
                LLVMPositionBuilderAtEnd(codegen.builder, else_bb);
                const right_val: *void = codegen_gen_expr(codegen, right);
                if right_val == null {
                    return null;
                }
                // 检查右操作数类型是否为i1（布尔类型）
                const right_type: *void = LLVMTypeOf(right_val);
                if right_type == null || LLVMGetTypeKind(right_type) != LLVMIntegerTypeKind || LLVMGetIntTypeWidth(right_type) != 1 {
                    fprintf(2 as *void, "错误: 逻辑运算符右操作数必须是布尔类型 (i1)\n");
                    return null;
                }
                LLVMBuildStore(codegen.builder, right_val, result);
                LLVMBuildBr(codegen.builder, merge_bb);
            }
            
            // merge_bb：加载结果
            LLVMPositionBuilderAtEnd(codegen.builder, merge_bb);
            return LLVMBuildLoad2(codegen.builder, left_type, result, "");
        }
        
        // 处理其他二元表达式（算术、比较运算符）
        var left_val: *void = codegen_gen_expr(codegen, left);
        var right_val: *void = codegen_gen_expr(codegen, right);
        
        // 如果其中一个操作数生成失败，尝试处理 null 标识符
        if left_val == null && left.type == AST_IDENTIFIER {
            const left_name: &byte = left.data.identifier.name;
            if left_name != null && strcmp(left_name, "null") == 0 {
                // left 是 null 标识符，需要从 right 获取类型
                if right_val != null {
                    const right_type: *void = LLVMTypeOf(right_val);
                    if right_type != null && LLVMGetTypeKind(right_type) == LLVMPointerTypeKind {
                        left_val = LLVMConstNull(right_type);
                    }
                }
            }
        }
        if right_val == null && right.type == AST_IDENTIFIER {
            const right_name: &byte = right.data.identifier.name;
            if right_name != null && strcmp(right_name, "null") == 0 {
                // right 是 null 标识符，需要从 left 获取类型
                if left_val != null {
                    const left_type: *void = LLVMTypeOf(left_val);
                    if left_type != null && LLVMGetTypeKind(left_type) == LLVMPointerTypeKind {
                        right_val = LLVMConstNull(left_type);
                    }
                }
            }
        }
        
        if left_val == null || right_val == null {
            return null;
        }
        
        // 获取操作数类型
        const left_type: *void = LLVMTypeOf(left_val);
        const right_type: *void = LLVMTypeOf(right_val);
        if left_type == null || right_type == null {
            return null;
        }
        
        // 算术运算符和比较运算符（支持 i32 和 usize 混合运算）
        if LLVMGetTypeKind(left_type) == LLVMIntegerTypeKind && 
           LLVMGetTypeKind(right_type) == LLVMIntegerTypeKind {
            
            // 类型提升：如果操作数类型不同，将 i32 提升为 usize
            const left_width: i32 = LLVMGetIntTypeWidth(left_type);
            const right_width: i32 = LLVMGetIntTypeWidth(right_type);
            
            // 获取 usize 类型（用于类型提升）
            const usize_type: *void = codegen_get_base_type(codegen, TYPE_USIZE);
            if usize_type == null {
                return null;
            }
            const usize_width: i32 = LLVMGetIntTypeWidth(usize_type);
            
            // 标记是否至少有一个操作数是 usize（用于决定使用有符号还是无符号运算）
            var is_usize_op: i32 = 0;
            
            // 如果左操作数是 i32，右操作数是 usize，将左操作数提升为 usize
            if left_width == 32 && right_width == usize_width {
                left_val = LLVMBuildZExt(codegen.builder, left_val, usize_type, "");
                is_usize_op = 1;
            }
            // 如果左操作数是 usize，右操作数是 i32，将右操作数提升为 usize
            else if left_width == usize_width && right_width == 32 {
                right_val = LLVMBuildZExt(codegen.builder, right_val, usize_type, "");
                is_usize_op = 1;
            }
            // 如果两个操作数都是 usize
            else if left_width == usize_width && right_width == usize_width {
                is_usize_op = 1;
            }
            
            // 算术运算符（i32 或 usize）
            if op == TOKEN_PLUS {
                return LLVMBuildAdd(codegen.builder, left_val, right_val, "");
            } else if op == TOKEN_MINUS {
                return LLVMBuildSub(codegen.builder, left_val, right_val, "");
            } else if op == TOKEN_ASTERISK {
                return LLVMBuildMul(codegen.builder, left_val, right_val, "");
            } else if op == TOKEN_SLASH {
                // 除法：根据操作数类型选择有符号或无符号除法
                if is_usize_op != 0 {
                    return LLVMBuildUDiv(codegen.builder, left_val, right_val, "");
                } else {
                    return LLVMBuildSDiv(codegen.builder, left_val, right_val, "");
                }
            } else if op == TOKEN_PERCENT {
                // 取模：根据操作数类型选择有符号或无符号取模
                if is_usize_op != 0 {
                    return LLVMBuildURem(codegen.builder, left_val, right_val, "");
                } else {
                    return LLVMBuildSRem(codegen.builder, left_val, right_val, "");
                }
            }
            // 比较运算符（返回 i1 布尔值）
            else if op == TOKEN_EQUAL {
                // 相等比较：根据操作数类型选择有符号或无符号比较
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntEQ, left_val, right_val, "");
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntEQ, left_val, right_val, "");
                }
            } else if op == TOKEN_NOT_EQUAL {
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntNE, left_val, right_val, "");
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntNE, left_val, right_val, "");
                }
            } else if op == TOKEN_LESS {
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntULT, left_val, right_val, "");
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntSLT, left_val, right_val, "");
                }
            } else if op == TOKEN_GREATER {
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntUGT, left_val, right_val, "");
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntSGT, left_val, right_val, "");
                }
            } else if op == TOKEN_LESS_EQUAL {
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntULE, left_val, right_val, "");
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntSLE, left_val, right_val, "");
                }
            } else if op == TOKEN_GREATER_EQUAL {
                if is_usize_op != 0 {
                    return LLVMBuildICmp(codegen.builder, LLVMIntUGE, left_val, right_val, "");
                } else {
                    return LLVMBuildICmp(codegen.builder, LLVMIntSGE, left_val, right_val, "");
                }
            }
        }
        
        // 指针比较（==, !=）
        if LLVMGetTypeKind(left_type) == LLVMPointerTypeKind && 
           LLVMGetTypeKind(right_type) == LLVMPointerTypeKind {
            if op == TOKEN_EQUAL {
                return LLVMBuildICmp(codegen.builder, LLVMIntEQ, left_val, right_val, "");
            } else if op == TOKEN_NOT_EQUAL {
                return LLVMBuildICmp(codegen.builder, LLVMIntNE, left_val, right_val, "");
            }
            // 指针不支持其他比较运算符（<, >, <=, >=）
            return null;
        }
        
        // 结构体比较运算符（仅支持 == 和 !=）
        if LLVMGetTypeKind(left_type) == LLVMStructTypeKind &&
           LLVMGetTypeKind(right_type) == LLVMStructTypeKind {
            
            // 仅支持 == 和 != 运算符
            if op == TOKEN_EQUAL || op == TOKEN_NOT_EQUAL {
                // 从LLVM类型查找结构体名称
                const struct_name: &byte = find_struct_name_from_type(codegen, left_type);
                if struct_name == null {
                    return null;
                }
                
                // 查找结构体声明
                const struct_decl: &ASTNode = find_struct_decl(codegen, struct_name);
                if struct_decl == null {
                    return null;
                }
                
                // 调用结构体比较函数
                const is_equal: i32 = if op == TOKEN_EQUAL { 1 } else { 0 };
                return codegen_gen_struct_comparison(
                    codegen,
                    left_val,
                    right_val,
                    struct_decl,
                    is_equal
                );
            }
            // 结构体不支持其他比较运算符（<, >, <=, >=）
            return null;
        }
        
        return null;
    } else if expr.type == AST_CALL_EXPR {
        // 函数调用表达式
        const callee: &ASTNode = expr.data.call_expr_callee;
        if callee == null || callee.type != AST_IDENTIFIER {
            return null;
        }
        
        const func_name: &byte = callee.data.identifier.name;
        if func_name == null {
            return null;
        }
        
        // 查找函数
        var func_type: *void = null;
        const func_map: &FuncMap = lookup_func(codegen, func_name, func_type);
        if func_map == null {
            return null;  // 函数未找到
        }
        
        const func: *void = func_map.func;
        func_type = func_map.func_type;
        
        // 生成参数值
        const arg_count: i32 = expr.data.call_expr_arg_count;
        if arg_count > MAX_FUNC_PARAMS {
            return null;  // 参数过多
        }
        
        var arg_values: [*void: MAX_FUNC_PARAMS] = [];
        var i: i32 = 0;
        while i < arg_count {
            // 直接访问固定大小数组，不需要嵌套指针
            const arg_expr: &ASTNode = expr.call_expr_args[i];
            if arg_expr == null {
                return null;
            }
            arg_values[i] = codegen_gen_expr(codegen, arg_expr);
            if arg_values[i] == null {
                return null;
            }
            i = i + 1;
        }
        
        // 调用函数（LLVM 18 使用 LLVMBuildCall2）
        return LLVMBuildCall2(codegen.builder, func_type, func, &arg_values[0] as *void, arg_count, "");
    } else if expr.type == AST_MEMBER_ACCESS {
        // 字段访问或枚举值访问：使用 GEP + Load 获取字段值，或返回枚举值常量
        const object: &ASTNode = expr.data.member_access.object;
        const field_name: &byte = expr.data.member_access.field_name;
        
        if object == null || field_name == null {
            return null;
        }
        
        // 检查是否是枚举值访问（EnumName.Variant）
        // 如果对象是标识符且不是变量，可能是枚举类型名称
        if object.type == AST_IDENTIFIER {
            const enum_name: &byte = object.data.identifier.name;
            if enum_name != null {
                // 检查是否是枚举类型名称（先检查变量表，如果不是变量，可能是枚举类型）
                const var_map: &VarMap = lookup_var(codegen, enum_name);
                if var_map == null {
                    // 不是变量，可能是枚举类型名称
                    const enum_decl: &ASTNode = find_enum_decl(codegen, enum_name);
                    if enum_decl != null {
                        // 是枚举类型，查找变体索引
                        const variant_index: i32 = find_enum_variant_index(enum_decl, field_name);
                        if variant_index >= 0 {
                            // 获取枚举值（显式值或计算值）
                            const enum_value: i32 = get_enum_variant_value(enum_decl, variant_index);
                            if enum_value < 0 {
                                return null;
                            }
                            
                            // 找到变体，返回i32常量
                            const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32);
                            if i32_type == null {
                                return null;
                            }
                            return LLVMConstInt(i32_type, enum_value as i64, 0);
                        }
                        // 变体不存在
                        return null;
                    }
                }
            }
        }
        
        // 如果对象是标识符（变量），从变量表获取结构体名称
        var struct_name: &byte = null;
        var object_ptr: *void = null;
        
        if object.type == AST_IDENTIFIER {
            const var_name: &byte = object.data.identifier.name;
            if var_name != null {
                const var_map: &VarMap = lookup_var(codegen, var_name);
                if var_map != null {
                    object_ptr = var_map.value;
                    struct_name = lookup_var_struct_name(codegen, var_name);
                    
                    // 检查变量类型是否是指针类型（无论 struct_name 是否设置）
                    const var_ast_type: &ASTNode = lookup_var_ast_type(codegen, var_name);
                    if var_ast_type != null && var_ast_type.type == AST_TYPE_POINTER {
                        // 变量是指针类型，需要加载指针值
                        const var_type: *void = lookup_var_type(codegen, var_name);
                        if var_type != null && object_ptr != null {
                            // 加载指针变量的值（即指针值本身）
                            object_ptr = LLVMBuildLoad2(codegen.builder, var_type, object_ptr, var_name);
                            
                            // 从指针类型中获取指向的结构体类型名称
                            const pointed_type: &ASTNode = var_ast_type.data.type_pointer.pointed_type;
                            if pointed_type != null && pointed_type.type == AST_TYPE_NAMED {
                                struct_name = pointed_type.data.type_named.name;
                            }
                        }
                    }
                } else {
                    // 尝试查找全局变量
                    const global_var_map: &GlobalVarMap = lookup_global_var(codegen, var_name);
                    if global_var_map != null {
                        object_ptr = global_var_map.global_var;
                        struct_name = global_var_map.struct_name;
                    }
                }
            }
        }
        
        if object_ptr == null {
            // 对象不是标识符或变量未找到，生成对象表达式
            const object_val: *void = codegen_gen_expr(codegen, object);
            if object_val == null {
                return null;
            }
            
            // 对于非标识符对象（如结构体字面量、嵌套字段访问），需要先 store 到临时变量
            // 获取对象类型
            const object_type: *void = LLVMTypeOf(object_val);
            if object_type == null {
                return null;
            }
            
            // 使用 alloca 分配临时空间
            object_ptr = LLVMBuildAlloca(codegen.builder, object_type, "");
            if object_ptr == null {
                return null;
            }
            
            // store 对象值到临时变量
            LLVMBuildStore(codegen.builder, object_val, object_ptr);
            
            // 获取结构体名称
            if object.type == AST_STRUCT_INIT {
                // 对于结构体字面量，可以从 AST 获取结构体名称
                struct_name = object.data.struct_init.struct_name;
            }
        }
        
        if struct_name == null {
            return null;  // 无法确定结构体名称
        }
        
        // 查找结构体声明
        const struct_decl: &ASTNode = find_struct_decl(codegen, struct_name);
        if struct_decl == null {
            return null;
        }
        
        // 查找字段索引
        const field_index: i32 = find_struct_field_index(struct_decl, field_name);
        if field_index < 0 {
            return null;  // 字段不存在
        }
        
        // 获取结构体类型
        const struct_type: *void = codegen_get_struct_type(codegen, struct_name);
        if struct_type == null {
            return null;
        }
        
        // 使用 GEP 获取字段地址
        const i32_type: *void = LLVMInt32Type();
        const indices: [*void: 2] = [
            LLVMConstInt(i32_type, 0, 0),  // 结构体指针本身
            LLVMConstInt(i32_type, field_index as i64, 0)  // 字段索引
        ];
        
        const field_ptr: *void = LLVMBuildGEP2(codegen.builder, struct_type, object_ptr, &indices[0] as *void, 2, "");
        if field_ptr == null {
            return null;
        }
        
        // 获取字段类型（从结构体声明中）
        if field_index >= struct_decl.data.struct_decl.field_count {
            return null;
        }
        const field: &ASTNode = struct_decl.data.struct_decl.fields[field_index];
        if field == null || field.type != AST_VAR_DECL {
            return null;
        }
        const field_type_node: &ASTNode = field.var_decl_type;
        const field_type: *void = get_llvm_type_from_ast(codegen, field_type_node);
        if field_type == null {
            return null;
        }
        
        // load 字段值
        return LLVMBuildLoad2(codegen.builder, field_type, field_ptr, "");
    } else if expr.type == AST_ARRAY_ACCESS {
        // 数组访问：使用 GEP + Load 获取元素值
        const array_expr: &ASTNode = expr.data.array_access.array;
        const index_expr: &ASTNode = expr.data.array_access.index;
        
        if array_expr == null || index_expr == null {
            return null;
        }
        
        // 生成数组表达式值（可能是标识符、数组字面量等）
        var array_val: *void = codegen_gen_expr(codegen, array_expr);
        if array_val == null {
            return null;
        }
        
        var array_val_type: *void = LLVMTypeOf(array_val);
        if array_val_type == null {
            return null;
        }
        
        // 检查是否是数组类型
        const array_val_kind: i32 = LLVMGetTypeKind(array_val_type);
        var array_type: *void = null;
        var array_ptr: *void = null;
        
        if array_val_kind == LLVMArrayTypeKind {
            // 数组值类型，需要分配临时空间存储数组值
            array_type = array_val_type;
            array_ptr = LLVMBuildAlloca(codegen.builder, array_type, "");
            if array_ptr == null {
                return null;
            }
            // store 数组值到临时变量
            LLVMBuildStore(codegen.builder, array_val, array_ptr);
        } else if array_val_kind == LLVMPointerTypeKind {
            // 数组指针类型，直接使用
            array_ptr = array_val;
            // 获取指针指向的类型（数组类型）
            array_type = LLVMGetElementType(array_val_type);
        } else {
            return null;  // 不是数组类型
        }
        
        if array_type == null || array_ptr == null {
            return null;
        }
        
        // 生成索引表达式值
        const index_val: *void = codegen_gen_expr(codegen, index_expr);
        if index_val == null {
            return null;
        }
        
        // 获取元素类型
        const element_type: *void = LLVMGetElementType(array_type);
        if element_type == null {
            return null;
        }
        
        // 使用 GEP 获取元素地址
        const i32_type: *void = LLVMInt32Type();
        const indices: [*void: 2] = [
            LLVMConstInt(i32_type, 0, 0),  // 数组指针本身
            index_val  // 索引值
        ];
        
        const element_ptr: *void = LLVMBuildGEP2(codegen.builder, array_type, array_ptr, &indices[0] as *void, 2, "");
        if element_ptr == null {
            return null;
        }
        
        // load 元素值
        return LLVMBuildLoad2(codegen.builder, element_type, element_ptr, "");
    } else if expr.type == AST_STRUCT_INIT {
        // 结构体字面量：使用 alloca + store 创建结构体值
        const struct_name: &byte = expr.struct_init_struct_name;
        const field_count: i32 = expr.struct_init_field_count;
        // 直接访问固定大小数组，不需要嵌套指针变量
        
        if struct_name == null {
            return null;
        }
        
        // 获取结构体类型
        const struct_type: *void = codegen_get_struct_type(codegen, struct_name);
        if struct_type == null {
            return null;
        }
        
        // 查找结构体声明（用于字段索引映射）
        const struct_decl: &ASTNode = find_struct_decl(codegen, struct_name);
        if struct_decl == null {
            return null;
        }
        
        // 使用 alloca 分配栈空间
        const struct_ptr: *void = LLVMBuildAlloca(codegen.builder, struct_type, "" as *byte);
        if struct_ptr == null {
            return null;
        }
        
        // 生成每个字段的值并 store 到结构体中
        // 注意：字段值需要按照结构体声明中的字段顺序存储
        // 但 AST_STRUCT_INIT 中的字段可能是任意顺序的（使用字段名称）
        // 所以我们需要根据字段名称找到字段索引
        
        if field_count > 16 {
            return null;  // 字段数过多
        }
        
        // 为每个字段生成值并 store
        // 使用 GEP (GetElementPtr) 获取每个字段的地址，然后 store 字段值
        var i: i32 = 0;
        while i < field_count {
            const field_name: &byte = expr.struct_init_field_names[i];
            const field_value: &ASTNode = expr.struct_init_field_values[i];
            
            if field_name == null || field_value == null {
                return null;
            }
            
            // 查找字段索引
            const field_index: i32 = find_struct_field_index(struct_decl, field_name);
            if field_index < 0 {
                return null;  // 字段不存在
            }
            
            // 生成字段值
            const field_val: *void = codegen_gen_expr(codegen, field_value);
            if field_val == null {
                return null;
            }
            
            // 使用 GEP 获取字段地址（字段索引是 unsigned int）
            const i32_type: *void = LLVMInt32Type();
            const indices: [*void: 2] = [
                LLVMConstInt(i32_type, 0, 0),  // 结构体指针本身
                LLVMConstInt(i32_type, field_index as i64, 0)  // 字段索引
            ];
            
            const field_ptr: *void = LLVMBuildGEP2(codegen.builder, struct_type, struct_ptr, &indices[0] as *void, 2, "" as *byte);
            if field_ptr == null {
                return null;
            }
            
            // store 字段值到字段地址
            LLVMBuildStore(codegen.builder, field_val, field_ptr);
            
            i = i + 1;
        }
        
        // 返回结构体值（load 结构体指针）
        return LLVMBuildLoad2(codegen.builder, struct_type, struct_ptr, "" as *byte);
    } else if expr.type == AST_ARRAY_LITERAL {
        // 数组字面量：使用 alloca + store 创建数组值
        const element_count: i32 = expr.array_literal_element_count;
        // 直接访问固定大小数组，不需要嵌套指针变量
        
        if element_count == 0 {
            // 空数组：无法推断类型，返回null
            return null;
        }
        
        // 从第一个元素生成值以推断元素类型
        const first_element_val: *void = codegen_gen_expr(codegen, expr.array_literal_elements[0]);
        if first_element_val == null {
            return null;
        }
        
        const element_type: *void = LLVMTypeOf(first_element_val);
        if element_type == null {
            return null;
        }
        
        // 创建数组类型
        const array_type: *void = LLVMArrayType(element_type, element_count);
        if array_type == null {
            return null;
        }
        
        // 使用 alloca 分配数组空间
        const array_ptr: *void = LLVMBuildAlloca(codegen.builder, array_type, "" as *byte);
        if array_ptr == null {
            return null;
        }
        
        // 为每个元素生成值并 store 到数组中
        var i: i32 = 0;
        while i < element_count {
            const element: &ASTNode = expr.array_literal_elements[i];
            if element == null {
                return null;
            }
            
            // 生成元素值
            const element_val: *void = codegen_gen_expr(codegen, element);
            if element_val == null {
                return null;
            }
            
            // 使用 GEP 获取元素地址
            const i32_type: *void = LLVMInt32Type();
            const indices: [*void: 2] = [
                LLVMConstInt(i32_type, 0, 0),  // 数组指针本身
                LLVMConstInt(i32_type, i as i64, 0)  // 元素索引
            ];
            
            const element_ptr: *void = LLVMBuildGEP2(codegen.builder, array_type, array_ptr, &indices[0] as *void, 2, "" as *byte);
            if element_ptr == null {
                return null;
            }
            
            // store 元素值到元素地址
            LLVMBuildStore(codegen.builder, element_val, element_ptr);
            
            i = i + 1;
        }
        
        // 返回数组值（load 数组指针）
        return LLVMBuildLoad2(codegen.builder, array_type, array_ptr, "" as *byte);
    } else if expr.type == AST_SIZEOF {
        // sizeof 表达式：返回类型大小（i32 常量）
        const target: &ASTNode = expr.data.sizeof_expr.target;
        const is_type: i32 = expr.data.sizeof_expr.is_type;
        
        if target == null {
            return null;
        }
        
        var llvm_type: *void = null;
        
        if is_type != 0 {
            // target 是类型节点
            llvm_type = get_llvm_type_from_ast(codegen, target);
        } else {
            // target 是表达式节点，需要获取类型而不生成代码
            // 对于标识符（变量），直接从变量表获取类型
            if target.type == AST_IDENTIFIER {
                const var_name: &byte = target.data.identifier.name;
                if var_name == null {
                    return null;
                }
                llvm_type = lookup_var_type(codegen, var_name);
                // 如果变量表中找不到，可能是枚举类型或结构体类型名称（在 sizeof 中）
                // 尝试作为类型名称处理
                if llvm_type == null {
                    // 先检查是否是枚举类型（枚举类型在LLVM中就是i32类型）
                    const enum_decl: &ASTNode = find_enum_decl(codegen, var_name);
                    if enum_decl != null {
                        llvm_type = codegen_get_base_type(codegen, TYPE_I32);
                    } else {
                        // 检查是否是结构体类型
                        const struct_type: *void = codegen_get_struct_type(codegen, var_name);
                        if struct_type != null {
                            llvm_type = struct_type;
                        } else {
                            return null;
                        }
                    }
                }
            } else {
                // 对于其他表达式类型，生成代码以获取类型
                const target_val: *void = codegen_gen_expr(codegen, target);
                if target_val == null {
                    return null;
                }
                llvm_type = LLVMTypeOf(target_val);
            }
        }
        
        if llvm_type == null {
            return null;
        }
        
        // 获取类型大小（字节数）
        // 注意：这里使用简化实现，对于基础类型直接返回常量
        // 对于复杂类型（结构体、数组），需要使用 TargetData 获取准确大小
        var size: i64 = 0;
        
        const kind: i32 = LLVMGetTypeKind(llvm_type);
        if kind == LLVMIntegerTypeKind {
            // 整数类型：根据位宽计算字节数
            const width: i32 = LLVMGetIntTypeWidth(llvm_type);
            size = ((width + 7) / 8) as i64;  // 向上取整到字节
        } else if kind == LLVMPointerTypeKind {
            // 指针类型：使用 TargetData API 获取指针大小（平台相关）
            // 注意：DataLayout 应该在 codegen_generate() 的第零步就已经设置
            const target_data: *void = LLVMGetModuleDataLayout(codegen.module);
            if target_data == null {
                // 如果无法获取 TargetData，返回错误（不应该发生，因为 DataLayout 已设置）
                return null;
            }
            size = LLVMPointerSize(target_data) as i64;
        } else if kind == LLVMArrayTypeKind {
            // 数组类型：元素大小 * 元素数量
            const element_type: *void = LLVMGetElementType(llvm_type);
            const element_count: i32 = LLVMGetArrayLength(llvm_type);
            // 获取元素大小（递归计算）
            const element_kind: i32 = LLVMGetTypeKind(element_type);
            var element_size: i64 = 0;
            if element_kind == LLVMIntegerTypeKind {
                const width: i32 = LLVMGetIntTypeWidth(element_type);
                element_size = ((width + 7) / 8) as i64;
            } else if element_kind == LLVMPointerTypeKind {
                // 指针类型：使用 TargetData API 获取指针大小（平台相关）
                const target_data: *void = LLVMGetModuleDataLayout(codegen.module);
                if target_data == null {
                    return null;
                }
                element_size = LLVMPointerSize(target_data) as i64;
            } else if element_kind == LLVMStructTypeKind {
                // 结构体类型的数组：使用 TargetData 获取元素大小
                const target_data: *void = LLVMGetModuleDataLayout(codegen.module);
                if target_data == null {
                    return null;  // 模块的 DataLayout 未设置
                }
                element_size = LLVMStoreSizeOfType(target_data, element_type) as i64;
            } else {
                // 其他复杂类型，无法计算大小
                return null;
            }
            size = element_size * (element_count as i64);
        } else if kind == LLVMStructTypeKind {
            // 结构体类型：使用 TargetData 获取准确大小
            const target_data: *void = LLVMGetModuleDataLayout(codegen.module);
            if target_data == null {
                return null;  // 模块的 DataLayout 未设置
            }
            // 使用 LLVMStoreSizeOfType 获取结构体的存储大小（字节数）
            size = LLVMStoreSizeOfType(target_data, llvm_type) as i64;
            
            // 特殊处理：空结构体的大小应该是 1 字节（规范要求）
            // LLVM 对空结构体返回 0，但根据规范（2.3.6 节），空结构体大小为 1 字节
            if size == 0 {
                // 检查是否是空结构体（通过检查字段数）
                const element_count: i32 = LLVMCountStructElementTypes(llvm_type);
                if element_count == 0 {
                    size = 1;  // 空结构体大小为 1 字节
                }
            }
        } else {
            // 其他类型，无法计算大小
            return null;
        }
        
        // 创建 i32 常量
        const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32);
        if i32_type == null {
            return null;
        }
        return LLVMConstInt(i32_type, size, 0);  // 无符号整数
    } else if expr.type == AST_ALIGNOF {
        // alignof 表达式：返回类型对齐值（i32 常量）
        const target: &ASTNode = expr.data.alignof_expr.target;
        const is_type: i32 = expr.data.alignof_expr.is_type;
        
        if target == null {
            return null;
        }
        
        var llvm_type: *void = null;
        
        if is_type != 0 {
            // target 是类型节点
            llvm_type = get_llvm_type_from_ast(codegen, target);
        } else {
            // target 是表达式节点，需要获取类型而不生成代码
            // 对于标识符（变量），直接从变量表获取类型
            if target.type == AST_IDENTIFIER {
                const var_name: &byte = target.data.identifier.name;
                if var_name == null {
                    return null;
                }
                llvm_type = lookup_var_type(codegen, var_name);
                // 如果变量表中找不到，可能是枚举类型或结构体类型名称（在 alignof 中）
                // 尝试作为类型名称处理
                if llvm_type == null {
                    // 先检查是否是枚举类型（枚举类型在LLVM中就是i32类型）
                    const enum_decl: &ASTNode = find_enum_decl(codegen, var_name);
                    if enum_decl != null {
                        llvm_type = codegen_get_base_type(codegen, TYPE_I32);
                    } else {
                        // 检查是否是结构体类型
                        const struct_type: *void = codegen_get_struct_type(codegen, var_name);
                        if struct_type != null {
                            llvm_type = struct_type;
                        } else {
                            return null;
                        }
                    }
                }
            } else {
                // 对于其他表达式类型，生成代码以获取类型
                const target_val: *void = codegen_gen_expr(codegen, target);
                if target_val == null {
                    return null;
                }
                llvm_type = LLVMTypeOf(target_val);
            }
        }
        
        if llvm_type == null {
            return null;
        }
        
        // 获取类型对齐值（字节数）
        // 使用 TargetData 获取准确的对齐值
        const target_data: *void = LLVMGetModuleDataLayout(codegen.module);
        if target_data == null {
            return null;  // 模块的 DataLayout 未设置
        }
        
        var alignment: i64 = 0;
        
        const kind: i32 = LLVMGetTypeKind(llvm_type);
        if kind == LLVMIntegerTypeKind {
            // 整数类型：使用 TargetData 获取对齐值
            alignment = LLVMABIAlignmentOfType(target_data, llvm_type) as i64;
        } else if kind == LLVMPointerTypeKind {
            // 指针类型：使用 TargetData 获取对齐值（平台相关）
            alignment = LLVMABIAlignmentOfType(target_data, llvm_type) as i64;
        } else if kind == LLVMArrayTypeKind {
            // 数组类型：对齐值等于元素类型的对齐值
            const element_type: *void = LLVMGetElementType(llvm_type);
            if element_type == null {
                return null;
            }
            alignment = LLVMABIAlignmentOfType(target_data, element_type) as i64;
        } else if kind == LLVMStructTypeKind {
            // 结构体类型：使用 TargetData 获取对齐值（等于最大字段对齐值）
            alignment = LLVMABIAlignmentOfType(target_data, llvm_type) as i64;
        } else {
            // 其他类型，无法计算对齐值
            return null;
        }
        
        // 创建 i32 常量
        const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32);
        if i32_type == null {
            return null;
        }
        return LLVMConstInt(i32_type, alignment, 0);  // 无符号整数
    } else if expr.type == AST_LEN {
        // len 表达式：返回数组元素个数（i32 常量）
        const array_expr: &ASTNode = expr.data.len_expr.array;
        
        if array_expr == null {
            return null;
        }
        
        var array_type: *void = null;
        
        // 获取数组表达式的类型
        if array_expr.type == AST_IDENTIFIER {
            // 标识符（变量）：从变量表获取类型
            const var_name: &byte = array_expr.data.identifier.name;
            if var_name == null {
                return null;
            }
            array_type = lookup_var_type(codegen, var_name);
        } else {
            // 其他表达式类型：生成代码以获取类型
            const array_val: *void = codegen_gen_expr(codegen, array_expr);
            if array_val == null {
                return null;
            }
            array_type = LLVMTypeOf(array_val);
        }
        
        if array_type == null {
            return null;
        }
        
        // 验证是数组类型
        const kind: i32 = LLVMGetTypeKind(array_type);
        if kind != LLVMArrayTypeKind {
            return null;  // 不是数组类型
        }
        
        // 获取数组长度（元素个数）
        const element_count: i32 = LLVMGetArrayLength(array_type);
        
        // 创建 i32 常量
        const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32);
        if i32_type == null {
            return null;
        }
        return LLVMConstInt(i32_type, element_count as i64, 0);  // 无符号整数
    } else if expr.type == AST_CAST_EXPR {
        // 类型转换表达式（expr as type）
        const expr_node: &ASTNode = expr.data.cast_expr.expr;
        const target_type_node: &ASTNode = expr.data.cast_expr.target_type;
        
        if expr_node == null || target_type_node == null {
            return null;
        }
        
        // 生成源表达式代码
        const source_val: *void = codegen_gen_expr(codegen, expr_node);
        if source_val == null {
            return null;
        }
        
        // 获取目标类型
        const target_type: *void = get_llvm_type_from_ast(codegen, target_type_node);
        if target_type == null {
            return null;
        }
        
        const source_type: *void = LLVMTypeOf(source_val);
        if source_type == null {
            return null;
        }
        const source_kind: i32 = LLVMGetTypeKind(source_type);
        const target_kind: i32 = LLVMGetTypeKind(target_type);
        
        // 根据源类型和目标类型进行转换
        if source_kind == LLVMIntegerTypeKind && target_kind == LLVMIntegerTypeKind {
            const source_width: i32 = LLVMGetIntTypeWidth(source_type);
            const target_width: i32 = LLVMGetIntTypeWidth(target_type);
            
            // 获取 usize 类型宽度（用于判断 i32 ↔ usize 转换）
            const usize_type: *void = codegen_get_base_type(codegen, TYPE_USIZE);
            var usize_width: i32 = 0;
            if usize_type != null {
                usize_width = LLVMGetIntTypeWidth(usize_type);
            }
            
            if source_width == 32 && target_width == 8 {
                // i32 as byte：截断转换（保留低 8 位）
                return LLVMBuildTrunc(codegen.builder, source_val, target_type, "" as *byte);
            } else if source_width == 8 && target_width == 32 {
                // byte as i32：零扩展转换（无符号扩展）
                return LLVMBuildZExt(codegen.builder, source_val, target_type, "" as *byte);
            } else if source_width == 32 && target_width == 1 {
                // i32 as bool：非零值为 true，零值为 false
                const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32);
                if i32_type == null {
                    return null;
                }
                const zero: *void = LLVMConstInt(i32_type, 0, 1);  // 有符号零
                return LLVMBuildICmp(codegen.builder, LLVMIntNE, source_val, zero, "" as *byte);
            } else if source_width == 1 && target_width == 32 {
                // bool as i32：true 转换为 1，false 转换为 0（零扩展）
                return LLVMBuildZExt(codegen.builder, source_val, target_type, "" as *byte);
            } else if source_width == 32 && target_width == usize_width && usize_width > 0 {
                // i32 as usize：零扩展转换（如果 usize 是 64 位）或直接使用（如果 usize 是 32 位）
                if usize_width > 32 {
                    return LLVMBuildZExt(codegen.builder, source_val, target_type, "" as *byte);
                } else {
                    // 32位平台：usize 也是 32 位，使用零扩展（虽然是 no-op）
                    return LLVMBuildZExt(codegen.builder, source_val, target_type, "" as *byte);
                }
            } else if source_width == usize_width && target_width == 32 && usize_width > 0 {
                // usize as i32：截断转换（如果 usize 是 64 位）或直接使用（如果 usize 是 32 位）
                if usize_width > 32 {
                    return LLVMBuildTrunc(codegen.builder, source_val, target_type, "" as *byte);
                } else {
                    // 32位平台：usize 也是 32 位，使用截断（虽然是 no-op）
                    return LLVMBuildTrunc(codegen.builder, source_val, target_type, "" as *byte);
                }
            }
        }
        
        // 不支持的转换（类型检查阶段应该已经拒绝）
        return null;
    }
    
    // 其他未知表达式类型
    return null;
}

// 辅助函数：生成分支代码并确保控制流正确连接
// 参数：codegen - 代码生成器指针
//       branch_bb - 分支基本块（代码生成的位置）
//       branch_stmt - 分支语句AST节点（AST_BLOCK节点）
//       target_bb - 目标基本块（如果分支没有终止符，跳转到这里）
// 返回：成功返回 0，失败返回非 0
// 说明：此函数在branch_bb中生成分支代码，生成后检查当前构建器所在的基本块是否有终止符。
//       如果当前基本块没有终止符（说明控制流需要继续），添加跳转到target_bb。
//       这正确处理了嵌套控制流的情况（嵌套if、while等会创建自己的基本块）。
fn gen_branch_with_terminator(codegen: &CodeGenerator, branch_bb: *void, branch_stmt: &ASTNode, target_bb: *void) i32 {
    if codegen == null || branch_bb == null || branch_stmt == null || target_bb == null {
        return -1;
    }
    
    // 定位构建器到分支基本块
    LLVMPositionBuilderAtEnd(codegen.builder, branch_bb);
    
    // 生成分支代码（可能包含嵌套控制流，构建器可能被移动到其他基本块）
    if codegen_gen_stmt(codegen, branch_stmt) != 0 {
        return -1;
    }
    
    // 检查当前构建器所在的基本块是否有终止符
    // 如果分支包含嵌套控制流，构建器可能已经移动到其他基本块
    const current_bb: *void = LLVMGetInsertBlock(codegen.builder);
    if current_bb != null {
        const terminator: *void = LLVMGetBasicBlockTerminator(current_bb);
        if terminator == null {
            // 当前基本块没有终止符，添加跳转到目标基本块
            LLVMBuildBr(codegen.builder, target_bb);
        }
    }
    
    return 0;
}

// 辅助函数：生成左值表达式的地址
// 参数：codegen - 代码生成器指针
//       expr - 左值表达式节点
// 返回：LLVM值引用（地址），失败返回 null
fn codegen_gen_lvalue_address(codegen: &CodeGenerator, expr: &ASTNode) *void {
    if codegen == null || expr == null {
        return null;
    }
    
    if expr.type == AST_IDENTIFIER {
        // 标识符（变量）：从变量表查找指针
        const var_name: &byte = expr.data.identifier.name;
        if var_name == null {
            return null;
        }
        const var_map: &VarMap = lookup_var(codegen, var_name);
        if var_map != null {
            return var_map.value;
        }
        // 尝试查找全局变量
        const global_var_map: &GlobalVarMap = lookup_global_var(codegen, var_name);
        if global_var_map != null {
            return global_var_map.global_var;
        }
        return null;
    } else if expr.type == AST_UNARY_EXPR {
        // 解引用表达式：*expr
        // 对于赋值 *p = value，p 是指针，我们需要返回 p 的值（即指针本身）
        const op: i32 = expr.data.unary_expr.op;
        if op != TOKEN_ASTERISK {
            return null;  // 只有解引用表达式可以作为左值
        }
        
        const operand: &ASTNode = expr.data.unary_expr.operand;
        if operand == null {
            return null;
        }
        
        // 操作数应该是指针类型，直接返回操作数的值（指针值本身）
        const operand_val: *void = codegen_gen_expr(codegen, operand);
        if operand_val == null {
            return null;
        }
        
        // 验证操作数是指针类型
        const operand_type: *void = LLVMTypeOf(operand_val);
        if operand_type == null || LLVMGetTypeKind(operand_type) != LLVMPointerTypeKind {
            return null;  // 操作数不是指针类型
        }
        
        // 返回指针值本身（这是我们要存储的地址）
        return operand_val;
    } else if expr.type == AST_MEMBER_ACCESS {
        // 字段访问：使用 GEP 获取字段地址（用于赋值语句如 p.x = value）
        const object: &ASTNode = expr.data.member_access.object;
        const field_name: &byte = expr.data.member_access.field_name;
        
        if object == null || field_name == null {
            return null;
        }
        
        // 如果对象是标识符（变量），从变量表获取结构体名称和对象指针
        var struct_name: &byte = null;
        var object_ptr: *void = null;
        
        if object.type == AST_IDENTIFIER {
            const var_name: &byte = object.data.identifier.name;
            if var_name != null {
                const var_map: &VarMap = lookup_var(codegen, var_name);
                if var_map != null {
                    object_ptr = var_map.value;
                    struct_name = lookup_var_struct_name(codegen, var_name);
                    
                    // 检查变量类型是否是指针类型（无论 struct_name 是否设置）
                    const var_ast_type: &ASTNode = lookup_var_ast_type(codegen, var_name);
                    if var_ast_type != null && var_ast_type.type == AST_TYPE_POINTER {
                        // 变量是指针类型，需要加载指针值
                        const var_type: *void = lookup_var_type(codegen, var_name);
                        if var_type != null && object_ptr != null {
                            // 加载指针变量的值（即指针值本身）
                            object_ptr = LLVMBuildLoad2(codegen.builder, var_type, object_ptr, var_name);
                            
                            // 从指针类型中获取指向的结构体类型名称
                            const pointed_type: &ASTNode = var_ast_type.data.type_pointer.pointed_type;
                            if pointed_type != null && pointed_type.type == AST_TYPE_NAMED {
                                struct_name = pointed_type.data.type_named.name;
                            }
                        }
                    }
                } else {
                    // 尝试查找全局变量
                    const global_var_map: &GlobalVarMap = lookup_global_var(codegen, var_name);
                    if global_var_map != null {
                        object_ptr = global_var_map.global_var;
                        struct_name = global_var_map.struct_name;
                    }
                }
            }
        }
        
        if object_ptr == null || struct_name == null {
            // 对象不是标识符或变量未找到，需要生成对象表达式值
            // 对于字段访问作为左值，我们暂时不支持复杂表达式
            return null;
        }
        
        // 查找结构体声明
        const struct_decl: &ASTNode = find_struct_decl(codegen, struct_name);
        if struct_decl == null {
            return null;
        }
        
        // 查找字段索引
        const field_index: i32 = find_struct_field_index(struct_decl, field_name);
        if field_index < 0 {
            return null;  // 字段不存在
        }
        
        // 获取结构体类型
        const struct_type: *void = codegen_get_struct_type(codegen, struct_name);
        if struct_type == null {
            return null;
        }
        
        // 使用 GEP 获取字段地址
        const i32_type: *void = LLVMInt32Type();
        const indices: [*void: 2] = [
            LLVMConstInt(i32_type, 0, 0),  // 结构体指针本身
            LLVMConstInt(i32_type, field_index as i64, 0)  // 字段索引
        ];
        
        const field_ptr: *void = LLVMBuildGEP2(codegen.builder, struct_type, object_ptr, &indices[0] as *void, 2, "");
        if field_ptr == null {
            return null;
        }
        
        // 返回字段地址（不需要加载值）
        return field_ptr;
    }
    
    // 暂不支持其他类型的左值（如数组访问等）
    return null;
}

// 生成语句代码（从语句AST节点生成LLVM IR指令）
// 参数：codegen - 代码生成器指针
//       stmt - 语句AST节点
// 返回：成功返回 0，失败返回非 0
// 注意：此函数需要在函数上下文中调用（builder需要在函数的基本块中）
fn codegen_gen_stmt(codegen: &CodeGenerator, stmt: &ASTNode) i32 {
    if codegen == null || stmt == null || codegen.builder == null {
        return -1;
    }
    
    if stmt.type == AST_VAR_DECL {
        // 变量声明：使用 alloca 分配栈空间，如果有初始值则 store
        const var_name: &byte = stmt.data.var_decl.name;
        const var_type: &ASTNode = stmt.data.var_decl.type;
        const init_expr: &ASTNode = stmt.data.var_decl.init;
        
        if var_name == null || var_type == null {
            return -1;
        }
        
        // 获取变量类型
        const llvm_type: *void = get_llvm_type_from_ast(codegen, var_type);
        if llvm_type == null {
            return -1;
        }
        
        // 提取结构体名称（如果类型是结构体类型）
        var struct_name: &byte = null;
        if var_type.type == AST_TYPE_NAMED {
            const type_name: &byte = var_type.data.type_named.name;
            if type_name != null && strcmp(type_name, "i32") != 0 && 
               strcmp(type_name, "bool") != 0 && strcmp(type_name, "byte") != 0 && 
               strcmp(type_name, "void") != 0) {
                // 可能是结构体类型
                if codegen_get_struct_type(codegen, type_name) != null {
                    struct_name = type_name;  // 名称已经在 Arena 中
                }
            }
        }
        
        // 使用 alloca 分配栈空间
        const var_ptr: *void = LLVMBuildAlloca(codegen.builder, llvm_type, var_name);
        if var_ptr == null {
            return -1;
        }
        
        // 添加到变量表
        if add_var(codegen, var_name, var_ptr, llvm_type, struct_name, var_type) != 0 {
            return -1;
        }
        
        // 如果有初始值，生成初始值代码并 store
        if init_expr != null {
            var init_val: *void = null;
            
            // 特殊处理空数组字面量：如果变量类型是数组类型，空数组表示未初始化
            if init_expr.type == AST_ARRAY_LITERAL &&
               init_expr.data.array_literal.element_count == 0 &&
               LLVMGetTypeKind(llvm_type) == LLVMArrayTypeKind {
                // 空数组字面量用于数组类型变量，不进行初始化（变量已通过 alloca 分配，内容未定义）
                // 跳过初始化代码生成
                init_val = null;
            }
            // 特殊处理 null 标识符：检查是否是 null 字面量
            else if init_expr.type == AST_IDENTIFIER {
                const init_name: &byte = init_expr.data.identifier.name;
                if init_name != null && strcmp(init_name, "null") == 0 {
                    // null 字面量：检查变量类型是否为指针类型
                    if LLVMGetTypeKind(llvm_type) == LLVMPointerTypeKind {
                        init_val = LLVMConstNull(llvm_type);
                    } else {
                        fprintf(2 as *void, "错误: 变量 %s 的类型不是指针类型，不能初始化为 null\n", var_name);
                        return -1;
                    }
                }
            }
            
            // 如果不是特殊处理的情况，使用通用方法生成初始值
            if init_val == null && !(init_expr.type == AST_ARRAY_LITERAL &&
                                    init_expr.data.array_literal.element_count == 0 &&
                                    LLVMGetTypeKind(llvm_type) == LLVMArrayTypeKind) {
                init_val = codegen_gen_expr(codegen, init_expr);
                if init_val == null {
                    fprintf(2 as *void, "错误: 变量 %s 的初始值表达式生成失败\n", var_name);
                    return -1;
                }
            }
            
            // 如果有初始值（空数组字面量时 init_val 为 null，跳过 store）
            if init_val != null {
                // 检查类型是否匹配，如果不匹配则进行类型转换
                const init_type: *void = LLVMTypeOf(init_val);
                if init_type != llvm_type {
                    // 类型不匹配，需要进行类型转换
                    const var_type_kind: i32 = LLVMGetTypeKind(llvm_type);
                    const init_type_kind: i32 = LLVMGetTypeKind(init_type);
                    
                    if var_type_kind == LLVMIntegerTypeKind && init_type_kind == LLVMIntegerTypeKind {
                        // 整数类型之间的转换
                        const var_width: i32 = LLVMGetIntTypeWidth(llvm_type);
                        const init_width: i32 = LLVMGetIntTypeWidth(init_type);
                        
                        if var_width < init_width {
                            // 截断转换（例如 i32 -> i8）
                            init_val = LLVMBuildTrunc(codegen.builder, init_val, llvm_type, "");
                        } else if var_width > init_width {
                            // 零扩展转换（例如 i8 -> i32，byte 是无符号的，使用零扩展）
                            init_val = LLVMBuildZExt(codegen.builder, init_val, llvm_type, "");
                        }
                        // 如果宽度相同，类型应该相同，不需要转换
                    }
                    // 其他类型不匹配的情况会在类型检查阶段被拒绝
                }
                
                LLVMBuildStore(codegen.builder, init_val, var_ptr);
            }
        }
        
        return 0;
    } else if stmt.type == AST_RETURN_STMT {
        // return 语句：生成返回值并返回（void函数返回null）
        const return_expr: &ASTNode = stmt.data.return_stmt.expr;
        
        if return_expr != null {
            // 有返回值：生成返回值表达式并返回
            const return_val: *void = codegen_gen_expr(codegen, return_expr);
            if return_val == null {
                return -1;
            }
            LLVMBuildRet(codegen.builder, return_val);
        } else {
            // void 返回
            LLVMBuildRetVoid(codegen.builder);
        }
        
        return 0;
    } else if stmt.type == AST_ASSIGN {
        // 赋值语句：生成源表达式值，store 到目标左值表达式
        const dest: &ASTNode = stmt.data.assign.dest;
        const src: &ASTNode = stmt.data.assign.src;
        
        if dest == null || src == null {
            return -1;
        }
        
        // 生成目标左值表达式的地址
        const dest_ptr: *void = codegen_gen_lvalue_address(codegen, dest);
        if dest_ptr == null {
            return -1;  // 无法生成左值地址（不支持的类型或错误）
        }
        
        // 生成源表达式值
        const src_val: *void = codegen_gen_expr(codegen, src);
        if src_val == null {
            return -1;
        }
        
        // store 值到目标地址
        // LLVMBuildStore 会自动处理类型匹配
        LLVMBuildStore(codegen.builder, src_val, dest_ptr);
        
        return 0;
    } else if stmt.type == AST_EXPR_STMT {
        // 表达式语句：根据 parser 实现，表达式语句直接返回表达式节点
        // 而不是 AST_EXPR_STMT 节点，所以这里不应该被执行
        // 但为了完整性，如果遇到这种情况，尝试将其当作表达式处理
        const expr_val: *void = codegen_gen_expr(codegen, stmt);
        // 忽略返回值（即使失败也返回0，因为表达式语句的返回值不重要）
        return 0;
    } else if stmt.type == AST_BLOCK {
        // 代码块：递归处理语句列表
        const stmt_count: i32 = stmt.block_stmt_count;
        // 直接访问固定大小数组，不需要嵌套指针变量
        
        var i: i32 = 0;
        while i < stmt_count {
            const stmt_node: &ASTNode = stmt.block_stmts[i];
                if stmt_node != null {
                    if codegen_gen_stmt(codegen, stmt_node) != 0 {
                        return -1;
                    }
                }
            }
            i = i + 1;
        }
        
        return 0;
    } else if stmt.type == AST_IF_STMT {
        // if 语句：创建条件分支基本块
        const condition: &ASTNode = stmt.data.if_stmt.condition;
        const then_branch: &ASTNode = stmt.data.if_stmt.then_branch;
        const else_branch: &ASTNode = stmt.data.if_stmt.else_branch;
        
        if condition == null || then_branch == null {
            return -1;
        }
        
        // 生成条件表达式
        const cond_val: *void = codegen_gen_expr(codegen, condition);
        if cond_val == null {
            fprintf(2 as *void, "错误: 条件表达式生成失败\n");
            return -1;
        }
        
        // 获取当前函数
        const current_bb: *void = LLVMGetInsertBlock(codegen.builder);
        if current_bb == null {
            return -1;
        }
        const current_func: *void = LLVMGetBasicBlockParent(current_bb);
        if current_func == null {
            return -1;
        }
        
        // 创建基本块（使用计数器生成唯一名称）
        const bb_id: i32 = codegen.basic_block_counter;
        codegen.basic_block_counter = codegen.basic_block_counter + 1;
        
        var then_name: [byte: 32] = [];
        var end_name: [byte: 32] = [];
        snprintf(&then_name[0] as *byte, 32, "if.then.%d", bb_id);
        snprintf(&end_name[0] as *byte, 32, "if.end.%d", bb_id);
        const then_bb: *void = LLVMAppendBasicBlock(current_func, &then_name[0] as *byte);
        const end_bb: *void = LLVMAppendBasicBlock(current_func, &end_name[0] as *byte);
        
            // 生成条件分支指令
            if else_branch != null {
                // 有else分支
                var else_name: [byte: 32] = [];
                snprintf(&else_name[0] as *byte, 32, "if.else.%d", bb_id);
                const else_bb: *void = LLVMAppendBasicBlock(current_func, &else_name[0] as *byte);
                
                // 生成条件分支指令
                LLVMBuildCondBr(codegen.builder, cond_val, then_bb, else_bb);
                
                // 生成then分支代码（使用 gen_branch_with_terminator 确保控制流正确）
                if gen_branch_with_terminator(codegen, then_bb, then_branch, end_bb) != 0 {
                    return -1;
                }
                
                // 生成else分支代码（使用 gen_branch_with_terminator 确保控制流正确）
                if gen_branch_with_terminator(codegen, else_bb, else_branch, end_bb) != 0 {
                    return -1;
                }
            } else {
                // 没有else分支
                // 生成条件分支指令
                LLVMBuildCondBr(codegen.builder, cond_val, then_bb, end_bb);
                
                // 生成then分支代码（使用 gen_branch_with_terminator 确保控制流正确）
                if gen_branch_with_terminator(codegen, then_bb, then_branch, end_bb) != 0 {
                    return -1;
                }
            }
        
        // 最后设置构建器到end_bb
        LLVMPositionBuilderAtEnd(codegen.builder, end_bb);
        
        return 0;
    } else if stmt.type == AST_WHILE_STMT {
        // while 语句：创建循环基本块
        const condition: &ASTNode = stmt.data.while_stmt.condition;
        const body: &ASTNode = stmt.data.while_stmt.body;
        
        if condition == null || body == null {
            return -1;
        }
        
        // 获取当前函数
        const current_bb: *void = LLVMGetInsertBlock(codegen.builder);
        if current_bb == null {
            return -1;
        }
        const current_func: *void = LLVMGetBasicBlockParent(current_bb);
        if current_func == null {
            return -1;
        }
        
        // 创建基本块：cond（条件检查）、body（循环体）、end（结束）
        const bb_id: i32 = codegen.basic_block_counter;
        codegen.basic_block_counter = codegen.basic_block_counter + 1;
        
        var cond_name: [byte: 32] = [];
        var body_name: [byte: 32] = [];
        var end_name: [byte: 32] = [];
        snprintf(&cond_name[0] as *byte, 32, "while.cond.%d", bb_id);
        snprintf(&body_name[0] as *byte, 32, "while.body.%d", bb_id);
        snprintf(&end_name[0] as *byte, 32, "while.end.%d", bb_id);
        const cond_bb: *void = LLVMAppendBasicBlock(current_func, &cond_name[0] as *byte);
        const body_bb: *void = LLVMAppendBasicBlock(current_func, &body_name[0] as *byte);
        const end_bb: *void = LLVMAppendBasicBlock(current_func, &end_name[0] as *byte);
        
        // 将循环基本块推入栈（用于 break/continue）
        if codegen.loop_stack_depth >= LOOP_STACK_SIZE {
            return -1;  // 循环嵌套过深
        }
        codegen.loop_stack[codegen.loop_stack_depth].cond_bb = cond_bb;
        codegen.loop_stack[codegen.loop_stack_depth].end_bb = end_bb;
        codegen.loop_stack[codegen.loop_stack_depth].inc_bb = null;  // while 循环没有 inc_bb
        codegen.loop_stack_depth = codegen.loop_stack_depth + 1;
        
        // 跳转到条件检查
        LLVMBuildBr(codegen.builder, cond_bb);
        
        // 生成条件检查
        LLVMPositionBuilderAtEnd(codegen.builder, cond_bb);
        const cond_val: *void = codegen_gen_expr(codegen, condition);
        if cond_val == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;  // 错误恢复：弹出栈
            return -1;
        }
        LLVMBuildCondBr(codegen.builder, cond_val, body_bb, end_bb);
        
        // 生成循环体
        LLVMPositionBuilderAtEnd(codegen.builder, body_bb);
        if codegen_gen_stmt(codegen, body) != 0 {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;  // 错误恢复：弹出栈
            return -1;
        }
        
        // 检查循环体结束前是否需要跳转（如果已经有终止符，不需要再跳转）
        const current_bb_after: *void = LLVMGetInsertBlock(codegen.builder);
        if current_bb_after != null {
            // 循环体结束前跳转到条件检查（continue 会跳过这里）
            LLVMBuildBr(codegen.builder, cond_bb);
        }
        
        // 从栈中弹出循环信息
        codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
        
        // 设置构建器到 end 基本块
        LLVMPositionBuilderAtEnd(codegen.builder, end_bb);
        
        return 0;
    } else if stmt.type == AST_BREAK_STMT {
        // break 语句：跳转到循环结束基本块
        if codegen.loop_stack_depth == 0 {
            return -1;  // break 不在循环中（类型检查应该已经检查过了）
        }
        const end_bb: *void = codegen.loop_stack[codegen.loop_stack_depth - 1].end_bb;
        LLVMBuildBr(codegen.builder, end_bb);
        return 0;
    } else if stmt.type == AST_CONTINUE_STMT {
        // continue 语句：跳转到循环递增基本块（for 循环）或条件检查基本块（while 循环）
        if codegen.loop_stack_depth == 0 {
            return -1;  // continue 不在循环中（类型检查应该已经检查过了）
        }
        const inc_bb: *void = codegen.loop_stack[codegen.loop_stack_depth - 1].inc_bb;
        if inc_bb != null {
            // for 循环：跳转到递增基本块
            LLVMBuildBr(codegen.builder, inc_bb);
        } else {
            // while 循环：跳转到条件检查基本块
            const cond_bb: *void = codegen.loop_stack[codegen.loop_stack_depth - 1].cond_bb;
            LLVMBuildBr(codegen.builder, cond_bb);
        }
        return 0;
    }
    
    } else if stmt.type == AST_FOR_STMT {
        // for 语句：数组遍历循环
        const array_expr: &ASTNode = stmt.data.for_stmt.array;
        const var_name: &byte = stmt.data.for_stmt.var_name;
        const is_ref: i32 = stmt.data.for_stmt.is_ref;
        const body: &ASTNode = stmt.data.for_stmt.body;
        
        if array_expr == null || var_name == null || body == null {
            return -1;
        }
        
        // 获取当前函数
        const current_bb: *void = LLVMGetInsertBlock(codegen.builder);
        if current_bb == null {
            return -1;
        }
        const current_func: *void = LLVMGetBasicBlockParent(current_bb);
        if current_func == null {
            return -1;
        }
        
        // 创建基本块：init（初始化）、cond（条件检查）、body（循环体）、inc（递增）、end（结束）
        const bb_id: i32 = codegen.basic_block_counter;
        codegen.basic_block_counter = codegen.basic_block_counter + 1;
        
        var init_name: [byte: 32] = [];
        var cond_name: [byte: 32] = [];
        var body_name: [byte: 32] = [];
        var inc_name: [byte: 32] = [];
        var end_name: [byte: 32] = [];
        snprintf(&init_name[0] as *byte, 32, "for.init.%d", bb_id);
        snprintf(&cond_name[0] as *byte, 32, "for.cond.%d", bb_id);
        snprintf(&body_name[0] as *byte, 32, "for.body.%d", bb_id);
        snprintf(&inc_name[0] as *byte, 32, "for.inc.%d", bb_id);
        snprintf(&end_name[0] as *byte, 32, "for.end.%d", bb_id);
        const init_bb: *void = LLVMAppendBasicBlock(current_func, &init_name[0] as *byte);
        const cond_bb: *void = LLVMAppendBasicBlock(current_func, &cond_name[0] as *byte);
        const body_bb: *void = LLVMAppendBasicBlock(current_func, &body_name[0] as *byte);
        const inc_bb: *void = LLVMAppendBasicBlock(current_func, &inc_name[0] as *byte);
        const end_bb: *void = LLVMAppendBasicBlock(current_func, &end_name[0] as *byte);
        
        // 将循环基本块推入栈（用于 break/continue）
        if codegen.loop_stack_depth >= LOOP_STACK_SIZE {
            return -1;  // 循环嵌套过深
        }
        codegen.loop_stack[codegen.loop_stack_depth].cond_bb = cond_bb;
        codegen.loop_stack[codegen.loop_stack_depth].end_bb = end_bb;
        codegen.loop_stack[codegen.loop_stack_depth].inc_bb = inc_bb;  // for 循环有 inc_bb
        codegen.loop_stack_depth = codegen.loop_stack_depth + 1;
        
        // 在当前基本块分配循环索引变量 i（在所有基本块中使用）
        const i32_type: *void = codegen_get_base_type(codegen, TYPE_I32);
        if i32_type == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 分配循环索引变量 i（在当前基本块中分配，这样可以在所有后续基本块中使用）
        const index_ptr: *void = LLVMBuildAlloca(codegen.builder, i32_type, "");
        if index_ptr == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 获取数组变量的地址（指针）
        // 对于数组变量，我们使用 lvalue_address 获取其地址，而不是加载整个数组的值
        const array_ptr: *void = codegen_gen_lvalue_address(codegen, array_expr);
        if array_ptr == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 获取数组类型：如果 array_expr 是标识符，从变量表获取类型；否则从指针类型推导
        var array_type: *void = null;
        if array_expr.type == AST_IDENTIFIER {
            // 标识符：从变量表获取类型（变量表中存储的是数组类型，不是指针类型）
            const array_var_name: &byte = array_expr.data.identifier.name;
            array_type = lookup_var_type(codegen, array_var_name);
            if array_type == null {
                codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
                return -1;
            }
        } else {
            // 其他表达式：从指针类型推导数组类型
            const array_ptr_type: *void = LLVMTypeOf(array_ptr);
            if array_ptr_type == null || LLVMGetTypeKind(array_ptr_type) != LLVMPointerTypeKind {
                codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
                return -1;
            }
            array_type = LLVMGetElementType(array_ptr_type);
            if array_type == null {
                codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
                return -1;
            }
        }
        
        // 验证是数组类型
        if LLVMGetTypeKind(array_type) != LLVMArrayTypeKind {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;  // 不是数组类型
        }
        
        // 获取数组长度：从 AST 类型节点获取数组大小
        var array_length: i32 = 0;
        if array_expr.type == AST_IDENTIFIER {
            const array_var_name: &byte = array_expr.data.identifier.name;
            const array_ast_type: &ASTNode = lookup_var_ast_type(codegen, array_var_name);
            if array_ast_type != null && array_ast_type.type == AST_TYPE_ARRAY {
                const size_expr: &ASTNode = array_ast_type.data.type_array.size_expr;
                if size_expr != null && size_expr.type == AST_NUMBER {
                    array_length = size_expr.data.number.value;
                }
            }
        }
        if array_length <= 0 {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;  // 无法获取数组长度
        }
        const array_length_val: *void = LLVMConstInt(i32_type, array_length, 0);
        
        // 获取元素类型
        const element_type: *void = LLVMGetElementType(array_type);
        if element_type == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 确定循环变量类型
        var loop_var_type: *void = null;
        var loop_var_ast_type: &ASTNode = null;
        
        if is_ref != 0 {
            // 引用迭代：循环变量是指向元素的指针
            loop_var_type = LLVMPointerType(element_type, 0);
            // 简化处理：暂时不创建 AST 类型节点
        } else {
            // 值迭代：循环变量是元素值
            loop_var_type = element_type;
            // 简化处理：暂时不创建 AST 类型节点
        }
        
        // 分配循环变量空间（在当前基本块中分配，这样可以在所有后续基本块中使用）
        const loop_var_ptr: *void = LLVMBuildAlloca(codegen.builder, loop_var_type, "");
        if loop_var_ptr == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 添加循环变量到变量表（在循环开始前添加一次，而不是每次迭代都添加）
        if add_var(codegen, var_name, loop_var_ptr, loop_var_type, null, loop_var_ast_type) != 0 {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 跳转到初始化基本块
        LLVMBuildBr(codegen.builder, init_bb);
        
        // 生成初始化代码（初始化循环索引 i = 0）
        LLVMPositionBuilderAtEnd(codegen.builder, init_bb);
        LLVMBuildStore(codegen.builder, LLVMConstInt(i32_type, 0, 0), index_ptr);
        
        // 跳转到条件检查
        LLVMBuildBr(codegen.builder, cond_bb);
        
        // 生成条件检查（i < array_length）
        LLVMPositionBuilderAtEnd(codegen.builder, cond_bb);
        const index_val: *void = LLVMBuildLoad2(codegen.builder, i32_type, index_ptr, "");
        if index_val == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        const cond_val: *void = LLVMBuildICmp(codegen.builder, LLVMIntSLT, index_val, array_length_val, "");
        if cond_val == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        LLVMBuildCondBr(codegen.builder, cond_val, body_bb, end_bb);
        
        // 生成循环体
        LLVMPositionBuilderAtEnd(codegen.builder, body_bb);
        
        // 重新加载索引值（因为在不同的基本块中，index_val 不可用）
        const index_val_body: *void = LLVMBuildLoad2(codegen.builder, i32_type, index_ptr, "");
        if index_val_body == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 生成循环变量（值迭代：load array[i]，引用迭代：getelementptr array[i]）
        const i32_type_for_gep: *void = LLVMInt32Type();
        const indices: [*void: 2] = [
            LLVMConstInt(i32_type_for_gep, 0, 0),  // 数组指针本身
            index_val_body  // 元素索引（运行时值）
        ];
        
        const element_ptr: *void = LLVMBuildGEP2(codegen.builder, array_type, array_ptr, &indices[0] as *void, 2, "");
        if element_ptr == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        var loop_var_val: *void = null;
        
        if is_ref != 0 {
            // 引用迭代：循环变量是指向元素的指针
            loop_var_val = element_ptr;
        } else {
            // 值迭代：循环变量是元素值
            loop_var_val = LLVMBuildLoad2(codegen.builder, element_type, element_ptr, "");
            if loop_var_val == null {
                codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
                return -1;
            }
        }
        
        // 存储循环变量值（变量已经在循环开始前添加到变量表）
        LLVMBuildStore(codegen.builder, loop_var_val, loop_var_ptr);
        
        // 生成循环体代码
        if codegen_gen_stmt(codegen, body) != 0 {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        
        // 检查循环体结束前是否需要跳转（如果已经有终止符，不需要再跳转）
        const current_bb_after: *void = LLVMGetInsertBlock(codegen.builder);
        if current_bb_after != null {
            // 循环体结束前跳转到递增基本块（continue 会跳过这里）
            LLVMBuildBr(codegen.builder, inc_bb);
        }
        
        // 生成递增代码（i = i + 1）
        LLVMPositionBuilderAtEnd(codegen.builder, inc_bb);
        const index_val_inc: *void = LLVMBuildLoad2(codegen.builder, i32_type, index_ptr, "");
        if index_val_inc == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        const index_val_next: *void = LLVMBuildAdd(codegen.builder, index_val_inc, LLVMConstInt(i32_type, 1, 0), "");
        if index_val_next == null {
            codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
            return -1;
        }
        LLVMBuildStore(codegen.builder, index_val_next, index_ptr);
        
        // 跳转到条件检查
        LLVMBuildBr(codegen.builder, cond_bb);
        
        // 从栈中弹出循环信息
        codegen.loop_stack_depth = codegen.loop_stack_depth - 1;
        
        // 设置构建器到 end 基本块
        LLVMPositionBuilderAtEnd(codegen.builder, end_bb);
        
        return 0;
    }
    
    // 其他未知语句类型
    // 如果是表达式节点（表达式语句），尝试将其当作表达式处理
    const expr_val: *void = codegen_gen_expr(codegen, stmt);
    // 忽略返回值（即使失败也返回0，因为表达式语句的返回值不重要）
    return 0;
}

// 声明函数（创建函数声明并添加到函数表，但不生成函数体）
// 参数：codegen - 代码生成器指针
//       fn_decl - 函数声明AST节点
// 返回：成功返回 0，失败返回非 0
fn codegen_declare_function(codegen: &CodeGenerator, fn_decl: &ASTNode) i32 {
    if codegen == null || fn_decl == null || fn_decl.type != AST_FN_DECL {
        return -1;
    }
    
    const func_name: &byte = fn_decl.fn_decl_name;
    const return_type_node: &ASTNode = fn_decl.fn_decl_return_type;
    const param_count: i32 = fn_decl.fn_decl_param_count;
    // 直接访问固定大小数组，不需要嵌套指针变量
    
    if func_name == null || return_type_node == null {
        return -1;
    }
    
    // 检查函数是否已经声明（在函数表中查找）
    var func_type_check: *void = null;
    const func_map_check: &FuncMap = lookup_func(codegen, func_name, func_type_check);
    if func_map_check != null {
        return 0;  // 已在函数表中，跳过
    }
    
    // 获取返回类型
    const return_type: *void = get_llvm_type_from_ast(codegen, return_type_node);
    if return_type == null {
        return -1;
    }
    
    // 准备参数类型数组
    if param_count > MAX_FUNC_PARAMS {
        return -1;
    }
    
    var param_types: [*void: MAX_FUNC_PARAMS] = [];
    var i: i32 = 0;
    while i < param_count {
        if params == null {
            return -1;
        }
        const param: &ASTNode = params[i];
        if param == null || param.type != AST_VAR_DECL {
            return -1;
        }
        
        const param_type_node: &ASTNode = param.data.var_decl.type;
        const param_type: *void = get_llvm_type_from_ast(codegen, param_type_node);
        if param_type == null {
            return -1;
        }
        
        param_types[i] = param_type;
        i = i + 1;
    }
    
    // 创建函数类型（最后一个参数 isVarArg 表示是否为可变参数函数）
    const is_varargs: i32 = fn_decl.fn_decl_is_varargs;
    const func_type: *void = LLVMFunctionType(return_type, &param_types[0] as *void, param_count, is_varargs);
    if func_type == null {
        return -1;
    }
    
    // 创建函数声明（添加到模块）
    const func: *void = LLVMAddFunction(codegen.module, func_name, func_type);
    if func == null {
        return -1;
    }
    
    // 添加到函数表
    if add_func(codegen, func_name, func, func_type) != 0 {
        return -1;
    }
    
    return 0;
}

// 生成全局变量代码（从变量声明AST节点生成LLVM全局变量）
// 参数：codegen - 代码生成器指针
//       var_decl - 变量声明AST节点（必须是顶层变量声明）
// 返回：成功返回 0，失败返回非 0
fn codegen_gen_global_var(codegen: &CodeGenerator, var_decl: &ASTNode) i32 {
    if codegen == null || var_decl == null || var_decl.type != AST_VAR_DECL {
        return -1;
    }
    
    const var_name: &byte = var_decl.data.var_decl.name;
    const var_type_node: &ASTNode = var_decl.data.var_decl.type;
    const init_expr: &ASTNode = var_decl.data.var_decl.init;
    
    if var_name == null || var_type_node == null {
        return -1;
    }
    
    // 获取变量类型
    const llvm_type: *void = get_llvm_type_from_ast(codegen, var_type_node);
    if llvm_type == null {
        return -1;
    }
    
    // 提取结构体名称（如果类型是结构体类型）
    var struct_name: &byte = null;
    if var_type_node.type == AST_TYPE_NAMED {
        const type_name: &byte = var_type_node.data.type_named.name;
        if type_name != null && strcmp(type_name, "i32") != 0 && 
           strcmp(type_name, "bool") != 0 && strcmp(type_name, "byte") != 0 && 
           strcmp(type_name, "void") != 0 {
            // 可能是结构体类型
            if codegen_get_struct_type(codegen, type_name) != null {
                struct_name = type_name;  // 名称已经在 Arena 中
            }
        }
    }
    
    // 创建全局变量（使用内部链接，因为没有导出机制）
    const global_var: *void = LLVMAddGlobal(codegen.module, llvm_type, var_name);
    if global_var == null {
        return -1;
    }
    
    // 设置链接属性（内部链接，全局变量在当前模块内可见）
    LLVMSetLinkage(global_var, LLVMInternalLinkage);
    
    // 设置初始值
    var init_val: *void = null;
    if init_expr != null {
        // 对于常量表达式（数字字面量、布尔字面量），可以直接使用
        // 注意：这里简化处理，只支持常量字面量，不支持复杂表达式
        if init_expr.type == AST_NUMBER {
            const value: i32 = init_expr.data.number.value;
            if LLVMGetTypeKind(llvm_type) == LLVMIntegerTypeKind {
                init_val = LLVMConstInt(llvm_type, value as i64, 1);  // 1 表示有符号
            }
        } else if init_expr.type == AST_BOOL {
            const value: i32 = init_expr.data.bool_literal.value;
            if LLVMGetTypeKind(llvm_type) == LLVMIntegerTypeKind {
                const bool_value: i64 = if value != 0 { 1 } else { 0 };
                init_val = LLVMConstInt(llvm_type, bool_value, 0);  // 0 表示无符号（布尔值）
            }
        }
        // TODO: 支持其他常量表达式（如结构体字面量、数组字面量等）
    }
    
    // 如果没有初始值或初始值不是常量，使用零初始化
    if init_val == null {
        init_val = LLVMConstNull(llvm_type);
    }
    
    // 设置全局变量的初始值
    LLVMSetInitializer(global_var, init_val);
    
    // 添加到全局变量映射表
    if add_global_var(codegen, var_name, global_var, llvm_type, struct_name) != 0 {
        return -1;
    }
    
    return 0;
}

// 生成函数代码（从函数声明AST节点生成LLVM函数）
// 参数：codegen - 代码生成器指针
//       fn_decl - 函数声明AST节点
// 返回：成功返回 0，失败返回非 0
fn codegen_gen_function(codegen: &CodeGenerator, fn_decl: &ASTNode) i32 {
    if codegen == null || fn_decl == null || fn_decl.type != AST_FN_DECL {
        fprintf(2 as *void, "错误: codegen_gen_function 参数检查失败\n");
        return -1;
    }
    
    const func_name: &byte = fn_decl.fn_decl_name;
    const return_type_node: &ASTNode = fn_decl.fn_decl_return_type;
    const body: &ASTNode = fn_decl.fn_decl_body;
    const param_count: i32 = fn_decl.fn_decl_param_count;
    // 直接访问固定大小数组，不需要嵌套指针变量
    
    if func_name == null || return_type_node == null {
        fprintf(2 as *void, "错误: codegen_gen_function 函数名或返回类型为空: %s\n", if func_name != null { func_name } else { "(null)" as &byte });
        return -1;
    }
    
    // extern 函数没有函数体，只生成声明
    const is_extern: i32 = if body == null { 1 } else { 0 };
    
    // 获取返回类型
    const return_type: *void = get_llvm_type_from_ast(codegen, return_type_node);
    if return_type == null {
        return -1;
    }
    
    // 准备参数类型数组
    if param_count > MAX_FUNC_PARAMS {
        return -1;  // 参数过多
    }
    
    var param_types: [*void: MAX_FUNC_PARAMS] = [];
    var i: i32 = 0;
    while i < param_count {
        const param: &ASTNode = fn_decl.fn_decl_params[i];
        if param == null || param.type != AST_VAR_DECL {
            return -1;
        }
        
        const param_type_node: &ASTNode = param.var_decl_type;
        const param_type: *void = get_llvm_type_from_ast(codegen, param_type_node);
        if param_type == null {
            return -1;
        }
        
        param_types[i] = param_type;
        i = i + 1;
    }
    
    // 获取函数（应该已经在声明阶段创建）
    const func_map: &FuncMap = lookup_func(codegen, func_name, null);
    if func_map == null {
        fprintf(2 as *void, "错误: codegen_gen_function 函数未声明: %s\n", func_name);
        return -1;
    }
    const func: *void = func_map.func;
    
    // 检查函数体是否已经定义
    if LLVMGetFirstBasicBlock(func) != null {
        // 函数体已存在，跳过函数体生成
        return 0;
    }
    
    // extern 函数只生成声明，不生成函数体
    if is_extern != 0 {
        return 0;  // extern 函数处理完成
    }
    
    // 普通函数需要生成函数体
    // 确保函数体不为 null
    if body == null {
        fprintf(2 as *void, "错误: codegen_gen_function 非 extern 函数但函数体为 null: %s\n", func_name);
        return -1;
    }
    
    // 创建函数体的基本块
    const entry_bb: *void = LLVMAppendBasicBlock(func, "entry");
    if entry_bb == null {
        return -1;
    }
    
    // 设置构建器位置到入口基本块
    LLVMPositionBuilderAtEnd(codegen.builder, entry_bb);
    
    // 保存当前变量表状态（用于函数结束后恢复）
    const saved_var_map_count: i32 = codegen.var_map_count;
    
    // 处理函数参数：将参数值 store 到 alloca 分配的栈变量
    i = 0;
    while i < param_count {
        const param: &ASTNode = fn_decl.fn_decl_params[i];
        if param == null || param.type != AST_VAR_DECL {
            return -1;
        }
        
        const param_name: &byte = param.var_decl_name;
        const param_type_node: &ASTNode = param.var_decl_type;
        if param_name == null || param_type_node == null {
            return -1;
        }
        
        // 获取参数类型
        const param_type: *void = get_llvm_type_from_ast(codegen, param_type_node);
        if param_type == null {
            return -1;
        }
        
        // 提取结构体名称（如果类型是结构体类型或指针指向结构体类型）
        var struct_name: &byte = null;
        if param_type_node.type == AST_TYPE_NAMED {
            const type_name: &byte = param_type_node.data.type_named.name;
            if type_name != null && strcmp(type_name, "i32") != 0 && 
               strcmp(type_name, "bool") != 0 && strcmp(type_name, "void") != 0 {
                // 可能是结构体类型
                if codegen_get_struct_type(codegen, type_name) != null {
                    struct_name = type_name;  // 名称已经在 Arena 中
                }
            }
        } else if param_type_node.type == AST_TYPE_POINTER {
            // 指针类型：检查指向的类型是否为结构体类型
            const pointed_type: &ASTNode = param_type_node.data.type_pointer.pointed_type;
            if pointed_type != null && pointed_type.type == AST_TYPE_NAMED {
                const type_name: &byte = pointed_type.data.type_named.name;
                if type_name != null && strcmp(type_name, "i32") != 0 && 
                   strcmp(type_name, "bool") != 0 && strcmp(type_name, "byte") != 0 && 
                   strcmp(type_name, "void") != 0 {
                    // 可能是结构体类型
                    if codegen_get_struct_type(codegen, type_name) != null {
                        struct_name = type_name;  // 名称已经在 Arena 中
                    }
                }
            }
        }
        
        // 使用 alloca 分配栈空间（存储参数值）
        const param_ptr: *void = LLVMBuildAlloca(codegen.builder, param_type, param_name);
        if param_ptr == null {
            return -1;
        }
        
        // 获取函数参数值（LLVMGetParam）
        const param_val: *void = LLVMGetParam(func, i);
        if param_val == null {
            return -1;
        }
        
        // store 参数值到栈变量
        LLVMBuildStore(codegen.builder, param_val, param_ptr);
        
        // 添加到变量表
        if add_var(codegen, param_name, param_ptr, param_type, struct_name, param_type_node) != 0 {
            return -1;
        }
        
        i = i + 1;
    }
    
    // 生成函数体代码
    const stmt_result: i32 = codegen_gen_stmt(codegen, body);
    if stmt_result != 0 {
        fprintf(2 as *void, "错误: 函数体生成失败: %s (返回值: %d)\n", func_name, stmt_result);
        // 恢复变量表状态（如果失败）
        codegen.var_map_count = saved_var_map_count;
        return -1;
    }
    
    // 检查函数是否已经有返回语句
    // 如果当前基本块没有终止符（return），需要添加默认返回
    const current_bb: *void = LLVMGetInsertBlock(codegen.builder);
    if current_bb != null {
        const terminator: *void = LLVMGetBasicBlockTerminator(current_bb);
        if terminator == null {
            // 没有终止符，添加默认返回
            // 检查返回类型是否为 void（通过比较类型）
            const void_type: *void = LLVMVoidType();
            if return_type == void_type {
                // void 返回
                LLVMBuildRetVoid(codegen.builder);
            } else {
                // 非 void 返回，生成默认返回值（0）
                // 注意：这应该不会发生，因为类型检查应该确保所有非 void 函数都有返回值
                // 但为了安全，我们生成一个默认值
                var default_val: *void = null;
                if LLVMGetTypeKind(return_type) == LLVMIntegerTypeKind {
                    default_val = LLVMConstInt(return_type, 0, 0);
                }
                if default_val != null {
                    LLVMBuildRet(codegen.builder, default_val);
                } else {
                    return -1;  // 无法生成默认返回值
                }
            }
        }
    }
    
    // 恢复变量表状态（函数结束）
    codegen.var_map_count = saved_var_map_count;
    
    return 0;
}

// 从AST生成代码
// 参数：codegen - 代码生成器指针
//       ast - AST 根节点（程序节点）
//       output_file - 输出文件路径
// 返回：成功返回 0，失败返回非 0
fn codegen_generate(codegen: &CodeGenerator, ast: &ASTNode, output_file: &byte) i32 {
    if codegen == null || ast == null || output_file == null {
        return -1;
    }
    
    // 检查是否是程序节点
    if ast.type != AST_PROGRAM {
        return -1;
    }
    
    // 保存程序节点（用于查找结构体声明）
    codegen.program_node = ast;
    
    const decl_count: i32 = ast.data.program.decl_count;
    // 直接访问固定大小数组，不需要嵌套指针变量
    
    // 检查声明数组（固定大小数组不会为 null，但可以检查 count）
    if decl_count > 0 && decl_count > MAX_PROGRAM_DECLS {
        return -1;  // 声明数量超出限制
    }
    
    // 第零步：初始化目标并设置模块的 DataLayout（需要在生成函数体之前设置，以便 sizeof 可以使用）
    // 初始化LLVM目标（只需要初始化一次，但重复初始化是安全的）
    LLVMInitializeNativeTarget();
    LLVMInitializeNativeAsmPrinter();
    LLVMInitializeNativeAsmParser();
    
    // 获取默认目标三元组（例如："x86_64-pc-linux-gnu"）
    const init_target_triple: &byte = LLVMGetDefaultTargetTriple();
    if init_target_triple == null {
        return -1;
    }
    
    // 查找目标
    var init_error_msg: &byte = null;
    var init_target: *void = null;
    if LLVMGetTargetFromTriple(init_target_triple, &init_target as *void, &init_error_msg as *void) != 0 {
        // 错误处理：释放错误消息
        if init_error_msg != null {
            LLVMDisposeMessage(init_error_msg);
        }
        LLVMDisposeMessage(init_target_triple);
        return -1;
    }
    
    // 创建目标机器（使用默认的CPU和特性）
    const init_opt_level: i32 = LLVMCodeGenLevelDefault;
    const init_reloc_mode: i32 = LLVMRelocDefault;
    const init_code_model: i32 = LLVMCodeModelDefault;
    
    const init_target_machine: *void = LLVMCreateTargetMachine(
        init_target,
        init_target_triple,
        "" as &byte,  // CPU（空字符串表示默认）
        "" as &byte,  // Features（空字符串表示默认）
        init_opt_level,
        init_reloc_mode,
        init_code_model
    );
    
    if init_target_machine == null {
        LLVMDisposeMessage(init_target_triple);
        return -1;
    }
    
    // 配置模块的目标数据布局（需要在生成函数体之前设置）
    LLVMSetTarget(codegen.module, init_target_triple);
    const init_target_data: *void = LLVMCreateTargetDataLayout(init_target_machine);
    if init_target_data != null {
        // LLVM 18中，LLVMSetModuleDataLayout 直接接受 LLVMTargetDataRef 类型
        LLVMSetModuleDataLayout(codegen.module, init_target_data);
        LLVMDisposeTargetData(init_target_data);
    }
    
    // 释放资源（第零步创建的 target_machine 和 target_triple）
    LLVMDisposeTargetMachine(init_target_machine);
    LLVMDisposeMessage(init_target_triple);
    
    // 第一步：注册所有结构体类型
    // 使用多次遍历的方式处理结构体依赖关系（如果结构体字段是其他结构体类型）
    // 每次遍历注册所有可以注册的结构体，直到所有结构体都注册或无法继续注册
    const max_iterations: i32 = decl_count + 1;  // 最多迭代 decl_count + 1 次
    var iteration: i32 = 0;
    
    while iteration < max_iterations {
        var registered_this_iteration: i32 = 0;
        
        // 遍历所有声明，尝试注册结构体类型
        var i: i32 = 0;
        while i < decl_count {
            const decl: &ASTNode = ast.program_decls[i];
            if decl != null && decl.type == AST_STRUCT_DECL {
                // 尝试注册结构体类型（如果已经注册，会返回成功）
                if codegen_register_struct_type(codegen, decl) == 0 {
                    registered_this_iteration = 1;
                }
            }
            i = i + 1;
        }
        
        // 如果这一轮没有注册任何结构体，说明所有可以注册的结构体都已注册
        if registered_this_iteration == 0 {
            break;
        }
        
        iteration = iteration + 1;
    }
    
    // 第二步：生成所有全局变量（在函数声明之前，这样函数可以访问全局变量）
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == AST_VAR_DECL {
            // 生成全局变量
            const var_name: &byte = decl.var_decl_name;
                const result: i32 = codegen_gen_global_var(codegen, decl);
                if result != 0 {
                    fprintf(2 as *void, "错误: 全局变量生成失败: %s\n", if var_name != null { var_name } else { "(null)" as &byte });
                    return -1;
                }
            }
        }
        i = i + 1;
    }
    
    // 第三步：声明所有函数（创建函数声明并添加到函数表，但不生成函数体）
    // 这样在生成函数体时，所有函数都已被声明，可以相互调用
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == AST_FN_DECL {
            // 声明函数（不生成函数体）
            const func_name: &byte = decl.fn_decl_name;
                const result: i32 = codegen_declare_function(codegen, decl);
                if result != 0 {
                    fprintf(2 as *void, "错误: 函数声明失败: %s\n", if func_name != null { func_name } else { "(null)" as &byte });
                    return -1;
                }
            }
        }
        i = i + 1;
    }
    
    // 第四步：生成所有函数的函数体
    // 此时所有函数都已被声明，可以相互调用
    i = 0;
    while i < decl_count {
        const decl: &ASTNode = ast.program_decls[i];
        if decl != null && decl.type == AST_FN_DECL {
            // extern 函数没有函数体，跳过
            if decl.fn_decl_body == null {
                i = i + 1;
                continue;
            }
            
            // 生成函数体
            const func_name: &byte = decl.fn_decl_name;
                const result: i32 = codegen_gen_function(codegen, decl);
                if result != 0 {
                    fprintf(2 as *void, "错误: 函数代码生成失败: %s\n", if func_name != null { func_name } else { "(null)" as &byte });
                    return -1;  // 函数代码生成失败
                }
            }
        }
        i = i + 1;
    }
    
    // 第五步：生成目标代码
    // 初始化LLVM目标（只需要初始化一次，但重复初始化是安全的）
    LLVMInitializeNativeTarget();
    LLVMInitializeNativeAsmPrinter();
    LLVMInitializeNativeAsmParser();
    
    // 获取默认目标三元组（例如："x86_64-pc-linux-gnu"）
    const target_triple: &byte = LLVMGetDefaultTargetTriple();
    if target_triple == null {
        return -1;
    }
    
    // 查找目标
    var error_msg: &byte = null;
    var target: *void = null;
    if LLVMGetTargetFromTriple(target_triple, &target as *void, &error_msg as *void) != 0 {
        // 错误处理：释放错误消息
        if error_msg != null {
            LLVMDisposeMessage(error_msg);
        }
        LLVMDisposeMessage(target_triple);
        return -1;
    }
    
    // 创建目标机器（使用默认的CPU和特性）
    // 优化级别：0 = 无优化，1 = 少量优化，2 = 默认优化，3 = 激进优化
    const opt_level: i32 = LLVMCodeGenLevelDefault;
    const reloc_mode: i32 = LLVMRelocDefault;
    const code_model: i32 = LLVMCodeModelDefault;
    
    const target_machine: *void = LLVMCreateTargetMachine(
        target,
        target_triple,
        "" as &byte,  // CPU（空字符串表示默认）
        "" as &byte,  // Features（空字符串表示默认）
        opt_level,
        reloc_mode,
        code_model
    );
    
    if target_machine == null {
        LLVMDisposeMessage(target_triple);
        return -1;
    }
    
    // 配置模块的目标数据布局（如果还没有设置）
    // 注意：在第零步可能已经设置了 DataLayout，但重复设置是安全的
    LLVMSetTarget(codegen.module, target_triple);
    const layout_data: *void = LLVMCreateTargetDataLayout(target_machine);
    if layout_data != null {
        // LLVM 18中，LLVMSetModuleDataLayout 直接接受 LLVMTargetDataRef 类型
        LLVMSetModuleDataLayout(codegen.module, layout_data);
        LLVMDisposeTargetData(layout_data);
    }
    
    // 生成LLVM IR文本到文件，用于调试
    // 基于输出文件名生成 .ll 文件路径（将 .o 替换为 .ll）
    // 简化处理：直接追加 .ll
    var ir_file: [byte: 512] = [];
    const output_len: i32 = strlen(output_file);
    if output_len > 511 {
        LLVMDisposeTargetMachine(target_machine);
        LLVMDisposeMessage(target_triple);
        return -1;
    }
    strncpy(&ir_file[0] as *byte, output_file, output_len);
    ir_file[output_len] = 0;
    
    // 查找最后一个点号，如果以 .o 结尾则替换，否则追加 .ll
    var last_dot: *byte = null;
    var i: i32 = output_len - 1;
    while i >= 0 {
        if ir_file[i] == 46 {  // 46 是 '.' 的 ASCII 码
            last_dot = &ir_file[i] as *byte;
            break;
        }
        i = i - 1;
    }
    
    if last_dot != null && strcmp(last_dot, ".o" as *byte) == 0 {
        // 替换 .o 为 .ll
        last_dot[0] = 46;  // '.'
        last_dot[1] = 108;  // 'l'
        last_dot[2] = 108;  // 'l'
        last_dot[3] = 0;  // '\0'
    } else {
        // 追加 .ll
        strcat(&ir_file[0] as *byte, ".ll" as *byte);
    }
    
    var ir_error: &byte = null;
    LLVMPrintModuleToFile(codegen.module, &ir_file[0] as *byte, &ir_error as *void);
    if ir_error != null {
        LLVMDisposeMessage(ir_error);
    }
    
    // 生成目标代码到文件
    var error: &byte = null;
    if LLVMTargetMachineEmitToFile(target_machine, codegen.module, output_file, LLVMObjectFile, &error as *void) != 0 {
        // 生成失败
        if error != null {
            fprintf(2 as *void, "错误: LLVM 代码生成失败: %s\n", error);
            LLVMDisposeMessage(error);
        } else {
            fprintf(2 as *void, "错误: LLVM 代码生成失败（未知错误）\n");
        }
        LLVMDisposeTargetMachine(target_machine);
        LLVMDisposeMessage(target_triple);
        return -1;
    }
    
    // 清理资源
    LLVMDisposeTargetMachine(target_machine);
    LLVMDisposeMessage(target_triple);
    
    return 0;
}

// ========== 来自文件: uya-src/main.uya ==========
// main.uya - 主程序模块
// 编译器的入口点，协调所有编译阶段：词法分析 → 语法分析 → 类型检查 → 代码生成
//
// 注意：需要先包含 arena.uya、lexer.uya、parser.uya、checker.uya、codegen.uya 和 str_utils.uya
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 外部函数声明 =====

// 字符串函数（来自 str_utils.uya）
extern fn strlen(s: *byte) i32;
extern fn strcmp(s1: *byte, s2: *byte) i32;
extern fn fprintf(stream: *void, format: *byte, ...) i32;

// 文件 I/O 函数（stdio.h）
extern fn fopen(filename: *byte, mode: *byte) *void;  // FILE* 在 Uya Mini 中使用 *void 表示
extern fn fread(ptr: *void, size: i32, nmemb: i32, stream: *void) i32;
extern fn fclose(stream: *void) i32;
extern fn fgetc(stream: *void) i32;  // 返回 int，EOF 为 -1

// 命令行参数获取函数（C 运行时）
// 注意：在 Uya Mini 中，main 函数签名是 fn main() i32，不支持 argc 和 argv
// 因此需要使用 extern 函数来获取命令行参数
// 这些函数由 C 运行时提供，或者由编译器特殊处理
extern fn get_argc() i32;  // 获取命令行参数数量
extern fn get_argv(index: i32) *byte;  // 获取第 index 个命令行参数（字符串指针）

// Arena 函数（来自 arena.uya）
extern fn arena_init(arena: &Arena, buffer: &void, size: i32) void;

// Lexer 函数（来自 lexer.uya）
extern fn lexer_init(lexer: &Lexer, source: *byte, source_len: i32, filename: *byte, arena: &Arena) i32;

// Parser 函数（来自 parser.uya）
extern fn parser_init(parser: &Parser, lexer: &Lexer, arena: &Arena) i32;
extern fn parser_parse(parser: &Parser) &ASTNode;

// Checker 函数（来自 checker.uya）
extern fn checker_init(checker: &TypeChecker, arena: &Arena) i32;
extern fn checker_check(checker: &TypeChecker, ast: &ASTNode) i32;
extern fn checker_get_error_count(checker: &TypeChecker) i32;

// CodeGen 函数（来自 codegen.uya）
extern fn codegen_new(codegen: &CodeGenerator, arena: &Arena, module_name: *byte) i32;
extern fn codegen_generate(codegen: &CodeGenerator, ast: &ASTNode, output_file: *byte) i32;

// ===== 常量定义 =====

// 文件读取缓冲区大小（与 Lexer 的缓冲区大小相同）
const FILE_BUFFER_SIZE: i32 = 1024 * 1024;  // 1MB

// Arena 分配器缓冲区大小
const ARENA_BUFFER_SIZE: i32 = 1024 * 1024;  // 1MB

// EOF 常量（文件结束符）
const EOF: i32 = -1;

// ===== 辅助函数 =====

// 读取文件内容到缓冲区
// 参数：filename - 文件名
//       buffer - 缓冲区（固定大小数组）
//       buffer_size - 缓冲区大小
// 返回：成功返回读取的字节数，失败返回 -1
// 注意：文件大小不能超过缓冲区大小
fn read_file_content(filename: *byte, buffer: &byte, buffer_size: i32) i32 {
    if filename == null || buffer == null || buffer_size <= 0 {
        return -1;
    }
    
    const file: *void = fopen(filename, "rb" as *byte);  // 二进制模式读取
    if file == null {
        return -1;
    }
    
    // 读取文件内容（保留一个字节用于 '\0'）
    const bytes_read: i32 = fread(buffer as *void, 1, buffer_size - 1, file);
    
    // 检查是否还有更多数据（文件太大）
    if bytes_read >= buffer_size - 1 {
        const c: i32 = fgetc(file);
        fclose(file);
        if c != EOF {
            // 文件还有更多数据，文件太大
            return -1;
        }
    } else {
        fclose(file);
    }
    
    // 添加字符串结束符
    buffer[bytes_read] = 0;
    
    return bytes_read;
}

// 打印使用说明
// 参数：program_name - 程序名称
fn print_usage(program_name: *byte) void {
    if program_name == null {
        return;
    }
    fprintf(2 as *void, "用法: %s <输入文件> -o <输出文件>\n", program_name);
    fprintf(2 as *void, "示例: %s program.uya -o program\n", program_name);
}

// 解析命令行参数
// 参数：input_file - 输出参数：输入文件名（&(*byte) 表示指向 *byte 的指针）
//       output_file - 输出参数：输出文件名
// 返回：成功返回 0，失败返回 -1
// 注意：在 Uya Mini 中，使用 extern 函数获取命令行参数
fn parse_args(input_file: &(*byte), output_file: &(*byte)) i32 {
    const argc: i32 = get_argc();
    if argc < 4 {
        if argc > 0 {
            const program_name: *byte = get_argv(0);
            if program_name != null {
                print_usage(program_name);
            }
        }
        return -1;
    }
    
    // 简单的参数解析：程序名 <输入文件> -o <输出文件>
    input_file[0] = null;
    output_file[0] = null;
    
    var i: i32 = 1;
    while i < argc {
        const arg: *byte = get_argv(i);
        if arg == null {
            i = i + 1;
            continue;
        }
        
        // 检查是否是 -o 选项
        if strcmp(arg, "-o" as *byte) == 0 {
            if i + 1 < argc {
                output_file[0] = get_argv(i + 1);
                i = i + 2;  // 跳过 -o 和输出文件名
            } else {
                fprintf(2 as *void, "错误: -o 选项需要指定输出文件名\n");
                return -1;
            }
        } else {
            // 检查是否是选项（以 - 开头）
            if arg[0] != 45 {  // 45 是 '-' 的 ASCII 码
                // 非选项参数，应该是输入文件
                if input_file[0] == null {
                    input_file[0] = arg;
                } else {
                    fprintf(2 as *void, "错误: 只能指定一个输入文件\n");
                    return -1;
                }
            }
            i = i + 1;
        }
    }
    
    if input_file[0] == null {
        fprintf(2 as *void, "错误: 未指定输入文件\n");
        if argc > 0 {
            const program_name: *byte = get_argv(0);
            if program_name != null {
                print_usage(program_name);
            }
        }
        return -1;
    }
    
    if output_file[0] == null {
        fprintf(2 as *void, "错误: 未指定输出文件（使用 -o 选项）\n");
        if argc > 0 {
            const program_name: *byte = get_argv(0);
            if program_name != null {
                print_usage(program_name);
            }
        }
        return -1;
    }
    
    return 0;
}

// 主编译函数
// 协调所有编译阶段：词法分析 → 语法分析 → 类型检查 → 代码生成
// 参数：input_file - 输入文件名
//       output_file - 输出文件名
// 返回：成功返回 0，失败返回非 0
fn compile_file(input_file: *byte, output_file: *byte) i32 {
    if input_file == null || output_file == null {
        return 1;
    }
    
    // 文件读取缓冲区（栈上分配）
    var file_buffer: [byte: FILE_BUFFER_SIZE] = [];
    const file_size: i32 = read_file_content(input_file, &file_buffer[0], FILE_BUFFER_SIZE);
    if file_size < 0 {
        fprintf(2 as *void, "错误: 无法读取文件 '%s'\n", input_file);
        return 1;
    }
    
    // Arena 分配器缓冲区（栈上分配）
    var arena_buffer: [byte: ARENA_BUFFER_SIZE] = [];
    
    // 初始化所有结构体（栈上分配，自动初始化为零值）
    var arena: Arena;
    var lexer: Lexer;
    var parser: Parser;
    var checker: TypeChecker;
    var codegen: CodeGenerator;
    
    // 初始化 Arena 分配器
    arena_init(&arena, &arena_buffer[0] as &void, ARENA_BUFFER_SIZE);
    
    // 1. 词法分析
    if lexer_init(&lexer, &file_buffer[0], file_size, input_file, &arena) != 0 {
        fprintf(2 as *void, "错误: Lexer 初始化失败\n");
        return 1;
    }
    
    // 2. 语法分析
    if parser_init(&parser, &lexer, &arena) != 0 {
        fprintf(2 as *void, "错误: Parser 初始化失败\n");
        return 1;
    }
    
    const ast: &ASTNode = parser_parse(&parser);
    if ast == null {
        // 错误信息已在 parser_parse 中输出
        return 1;
    }
    
    // 3. 类型检查
    if checker_init(&checker, &arena) != 0 {
        fprintf(2 as *void, "错误: TypeChecker 初始化失败\n");
        return 1;
    }
    
    if checker_check(&checker, ast) != 0 {
        const error_count: i32 = checker_get_error_count(&checker);
        fprintf(2 as *void, "错误: 类型检查失败（错误数量: %d）\n", error_count);
        return 1;
    }
    
    // 4. 代码生成
    // 使用输入文件名（去掉扩展名）作为模块名
    const module_name: *byte = input_file;  // 简化：直接使用输入文件名
    
    if codegen_new(&codegen, &arena, module_name) != 0 {
        fprintf(2 as *void, "错误: CodeGenerator 初始化失败\n");
        return 1;
    }
    
    if codegen_generate(&codegen, ast, output_file) != 0 {
        fprintf(2 as *void, "错误: 代码生成失败\n");
        return 1;
    }
    
    return 0;
}

// 主函数
// 返回：成功返回 0，失败返回非 0
// 注意：在 Uya Mini 中，main 函数签名是 fn main() i32，不支持 argc 和 argv
//       使用 extern 函数 get_argc() 和 get_argv() 获取命令行参数
fn main() i32 {
    var input_file: *byte = null;
    var output_file: *byte = null;
    
    // 解析命令行参数
    if parse_args(&input_file, &output_file) != 0 {
        return 1;
    }
    
    // 编译文件
    const result: i32 = compile_file(input_file, output_file);
    
    return result;
}

