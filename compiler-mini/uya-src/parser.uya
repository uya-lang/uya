// parser.uya - 语法分析器模块
// 将 Token 序列转换为抽象语法树（AST）
// 
// 注意：需要先包含 arena.uya、lexer.uya、ast.uya 和 str_utils.uya
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 外部函数声明 =====

// 字符串函数（来自 str_utils.uya）
extern fn strlen(s: *byte) i32;
extern fn strcmp(s1: *byte, s2: *byte) i32;
extern fn fprintf(stream: *void, format: *byte, ...) i32;

// 内存复制函数（string.h）
extern fn memcpy(dest: &byte, src: &byte, n: i32) &void;

// 字符串转整数函数（stdlib.h）
extern fn atoi(s: *byte) i32;

// Arena 函数（来自 arena.uya）
// 注意：假设 Arena 类型已定义
extern fn arena_alloc(arena: &Arena, size: i32) &void;

// AST 函数（来自 ast.uya）
// 注意：假设 ASTNode, ASTNodeType 类型已定义
extern fn ast_new_node(type: ASTNodeType, line: i32, column: i32, arena: &Arena) &ASTNode;

// Lexer 函数（来自 lexer.uya）
// 注意：假设 Lexer, Token, TokenType 类型已定义
extern fn lexer_next_token(lexer: &Lexer, arena: &Arena) &Token;

// 字符串辅助函数（来自 lexer.uya）
// 注意：这些函数在 lexer.uya 中定义，但这里可能需要使用
extern fn arena_strdup_from_literal(arena: &Arena, str: *byte) &byte;
extern fn arena_strdup(arena: &Arena, start: &byte, len: i32) &byte;

// 标准错误输出（stderr）
// 注意：在 C 中，stderr 是一个 FILE* 指针，在 Uya Mini 中使用 *void 表示
// 通常 stderr 的值是 2（文件描述符），但作为 FILE* 指针，这里使用 extern 声明
// 实际上，fprintf 的第一个参数是 *void，可以直接传递数值
// 在实现时，如果需要，可以使用 extern 声明，或者直接使用数值 2
// 为了简化，这里不声明 stderr，在代码中直接使用数值常量（通过注释说明）

// ===== Parser 结构体 =====

// 语法分析器结构体
// 使用 Lexer 读取 Token，构建 AST
// 注意：假设 Lexer, Token, Arena 类型已定义
struct Parser {
    lexer: &Lexer;          // 词法分析器指针（由调用者提供，不分配）
    current_token: &Token;  // 当前 Token（从 Arena 分配）
    arena: &Arena;          // Arena 分配器（用于分配 Token 和 AST 节点）
}

// ===== 基础函数 =====

// 初始化 Parser
// 参数：parser - Parser 结构体指针（由调用者提供），lexer - Lexer 指针，arena - Arena 分配器
// 返回：成功返回 0，失败返回 -1
// 注意：Parser 结构体由调用者在栈上或静态分配，此函数只负责初始化
fn parser_init(parser: &Parser, lexer: &Lexer, arena: &Arena) i32 {
    if parser == null || lexer == null || arena == null {
        return -1;
    }
    
    parser.lexer = lexer;
    parser.arena = arena;
    
    // 获取第一个 Token
    parser.current_token = lexer_next_token(lexer, arena);
    
    return 0;
}

// 辅助函数：检查当前 Token 类型是否匹配
// 参数：parser - Parser 指针，type - Token 类型
// 返回：匹配返回 1，不匹配返回 0
fn parser_match(parser: &Parser, type: TokenType) i32 {
    if parser == null || parser.current_token == null {
        return 0;
    }
    if parser.current_token.type == type {
        return 1;
    }
    return 0;
}

// 辅助函数：消费当前 Token 并获取下一个
// 参数：parser - Parser 指针
// 返回：当前 Token 指针，失败返回 null
fn parser_consume(parser: &Parser) &Token {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const current: &Token = parser.current_token;
    parser.current_token = lexer_next_token(parser.lexer, parser.arena);
    return current;
}

// 辅助函数：期望特定类型的 Token
// 参数：parser - Parser 指针，type - Token 类型
// 返回：匹配的 Token 指针，不匹配返回 null
fn parser_expect(parser: &Parser, type: TokenType) &Token {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    if parser.current_token.type != type {
        // 错误：期望的类型不匹配
        return null;
    }
    
    return parser_consume(parser);
}

// 辅助函数：检查当前 token（'{'）后面是否是结构体字段初始化列表的开始
// 结构体字段初始化列表格式：identifier: expr 或 }
// 注意：调用此函数时，parser.current_token 应该是 '{'
// 参数：parser - Parser 指针
// 返回：是结构体初始化返回 1，否则返回 0
fn parser_peek_is_struct_init(parser: &Parser) i32 {
    if parser == null || parser.lexer == null || parser.current_token == null {
        return 0;
    }
    
    if parser.current_token.type != TOKEN_LEFT_BRACE {
        return 0;
    }
    
    // 保存 lexer 状态（当前 lexer 的 position 已经在 '{' 之后）
    const lexer: &Lexer = parser.lexer;
    const saved_position: i32 = lexer.position;
    const saved_line: i32 = lexer.line;
    const saved_column: i32 = lexer.column;
    
    // 获取 '{' 后面的 token（lexer_next_token 会跳过空白字符和注释）
    const after_brace: &Token = lexer_next_token(lexer, parser.arena);
    
    if after_brace == null {
        // 恢复状态
        lexer.position = saved_position;
        lexer.line = saved_line;
        lexer.column = saved_column;
        return 0;
    }
    
    const token_type: TokenType = after_brace.type;
    var is_struct_init: i32 = 0;
    
    // 只检查 identifier: 模式，不检查空的 {}（因为空代码块 {} 和空结构体字面量 {} 无法区分）
    if token_type == TOKEN_IDENTIFIER {
        // 检查标识符后面是否有 ':'
        const saved_position2: i32 = lexer.position;
        const saved_line2: i32 = lexer.line;
        const saved_column2: i32 = lexer.column;
        
        const after_identifier: &Token = lexer_next_token(lexer, parser.arena);
        if after_identifier != null && after_identifier.type == TOKEN_COLON {
            is_struct_init = 1;
        }
        
        // 恢复状态到标识符之前
        lexer.position = saved_position2;
        lexer.line = saved_line2;
        lexer.column = saved_column2;
    }
    
    // 恢复 lexer 状态到 '{' 之后
    lexer.position = saved_position;
    lexer.line = saved_line;
    lexer.column = saved_column;
    
    return is_struct_init;
}

// 从 Arena 复制字符串
// 参数：arena - Arena 分配器，src - 源字符串（&byte 类型，存储在 Arena 中）
// 返回：复制后的字符串指针（存储在 Arena 中），失败返回 null
// 注意：此函数用于复制 token.value，使用 strlen 计算长度，然后使用 arena_strdup
fn arena_strdup_for_parser(arena: &Arena, src: &byte) &byte {
    if arena == null || src == null {
        return null;
    }
    
    // 计算字符串长度
    const len: i32 = strlen(src as *byte);
    
    // 使用 arena_strdup 复制字符串
    return arena_strdup(arena, src, len);
}

// ===== 类型解析函数 =====

// 解析类型（支持命名类型、指针类型和数组类型）
// type = named_type | pointer_type | array_type
// named_type = ID
// pointer_type = '&' type | '*' type
// array_type = '[' type ':' expr ']'
// 参数：parser - Parser 指针
// 返回：类型节点，失败返回 null
// 注意：此函数递归调用 parser_parse_type 和 parser_parse_expression
fn parser_parse_type(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 检查是否是指针类型（&Type 或 *Type）
    if parser.current_token.type == TOKEN_AMPERSAND {
        // 普通指针类型 &Type
        parser_consume(parser);  // 消费 '&'
        
        // 递归解析指向的类型
        const pointed_type: &ASTNode = parser_parse_type(parser);
        if pointed_type == null {
            return null;
        }
        
        // 创建指针类型节点
        const pointer_type: &ASTNode = ast_new_node(AST_TYPE_POINTER, line, column, parser.arena);
        if pointer_type == null {
            return null;
        }
        
        pointer_type.type_pointer_pointed_type = pointed_type;
        pointer_type.type_pointer_is_ffi_pointer = 0;  // 普通指针
        
        return pointer_type;
    } else if parser.current_token.type == TOKEN_ASTERISK {
        // FFI 指针类型 *Type（仅用于 extern 函数）
        parser_consume(parser);  // 消费 '*'
        
        // 递归解析指向的类型
        const pointed_type: &ASTNode = parser_parse_type(parser);
        if pointed_type == null {
            return null;
        }
        
        // 创建 FFI 指针类型节点
        const pointer_type: &ASTNode = ast_new_node(AST_TYPE_POINTER, line, column, parser.arena);
        if pointer_type == null {
            return null;
        }
        
        pointer_type.type_pointer_pointed_type = pointed_type;
        pointer_type.type_pointer_is_ffi_pointer = 1;  // FFI 指针
        
        return pointer_type;
    } else if parser.current_token.type == TOKEN_LEFT_BRACKET {
        // 数组类型 [Type: Size]
        parser_consume(parser);  // 消费 '['
        
        // 解析元素类型
        const element_type: &ASTNode = parser_parse_type(parser);
        if element_type == null {
            return null;
        }
        
        // 期望 ':'
        if parser_expect(parser, TOKEN_COLON) == null {
            return null;
        }
        
        // 解析数组大小表达式（必须是编译期常量，但解析阶段先解析为表达式）
        // 注意：这里解析为表达式节点，类型检查阶段会验证是否为编译期常量
        const size_expr: &ASTNode = parser_parse_expression(parser);
        if size_expr == null {
            return null;
        }
        
        // 期望 ']'
        if parser_expect(parser, TOKEN_RIGHT_BRACKET) == null {
            return null;
        }
        
        // 创建数组类型节点
        const array_type: &ASTNode = ast_new_node(AST_TYPE_ARRAY, line, column, parser.arena);
        if array_type == null {
            return null;
        }
        
        array_type.type_array_element_type = element_type;
        array_type.type_array_size_expr = size_expr;
        
        return array_type;
    } else if parser.current_token.type == TOKEN_IDENTIFIER {
        // 命名类型（i32, bool, void, 或结构体名称）
        const type_node: &ASTNode = ast_new_node(AST_TYPE_NAMED, line, column, parser.arena);
        if type_node == null {
            return null;
        }
        
        // 复制类型名称到 Arena
        const type_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if type_name == null {
            return null;
        }
        
        type_node.type_named_name = type_name;
        
        // 消费类型标识符
        parser_consume(parser);
        
        return type_node;
    }
    
    // 无法识别的类型语法
    return null;
}

// ===== 代码块解析函数 =====

// 解析代码块（完善版本，解析语句列表）
// 参数：parser - Parser 指针
// 返回：代码块节点（AST_BLOCK），失败返回 null
// 注意：此函数调用 parser_parse_statement（在后面定义）
fn parser_parse_block(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 '{'
    if parser_match(parser, TOKEN_LEFT_BRACE) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 创建代码块节点
    const block: &ASTNode = ast_new_node(AST_BLOCK, line, column, parser.arena);
    if block == null {
        return null;
    }
    
    // 初始化语句列表
    var stmts: &(&ASTNode) = null;
    var stmt_count: i32 = 0;
    var stmt_capacity: i32 = 0;
    
    // 消费 '{'
    parser_consume(parser);
    
    // 解析语句列表
    while parser.current_token != null && 
          parser_match(parser, TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TOKEN_EOF) == 0 {
        
        // 解析语句
        const stmt: &ASTNode = parser_parse_statement(parser);
        if stmt == null {
            // 解析失败
            return null;
        }
        
        // 扩展语句数组（使用 Arena 分配）
        if stmt_count >= stmt_capacity {
            var new_capacity: i32 = 0;
            if stmt_capacity == 0 {
                new_capacity = 4;
            } else {
                new_capacity = stmt_capacity * 2;
            }
            const new_stmts: &(&ASTNode) = arena_alloc(parser.arena, 8 * new_capacity) as &(&ASTNode);
            if new_stmts == null {
                return null;
            }
            
            // 复制旧语句
            if stmts != null {
                var i: i32 = 0;
                while i < stmt_count {
                    new_stmts[i] = stmts[i];
                    i = i + 1;
                }
            }
            
            stmts = new_stmts;
            stmt_capacity = new_capacity;
        }
        
        stmts[stmt_count] = stmt;
        stmt_count = stmt_count + 1;
    }
    
    // 期望 '}'
    if parser_expect(parser, TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    
    block.block_stmts = stmts;
    block.block_stmt_count = stmt_count;
    
    return block;
}
