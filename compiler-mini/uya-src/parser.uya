// parser.uya - 语法分析器
// 从 compiler-mini/src/parser.c 重新覆盖式翻译
//
// 注意：Uya 没有 union，所有 union 字段都转换为结构体的独立字段
// 注意：Uya 不支持指针运算，ptr + i 必须转换为 &ptr[i]
// 注意：Uya 不支持函数前向声明，函数必须在使用前定义

// Lexer 函数前向声明（确保生成的 C 中在 parser_init 之前有声明，避免隐式声明）
extern fn lexer_next_token(lexer: &Lexer, arena: &Arena) &Token;
extern fn lexer_init(lexer: &Lexer, source: &byte, source_len: usize, filename: &byte, arena: &Arena) i32;

// 解析上下文类型
enum ParserContext {
    PARSER_CONTEXT_NORMAL,          // 普通表达式上下文
    PARSER_CONTEXT_VAR_INIT,        // 变量初始化上下文（var/const 声明中的 = 后面的表达式）
    PARSER_CONTEXT_CONDITION        // 条件表达式上下文（if/while 后面的表达式）
}

// 语法分析器结构体
// 使用 Lexer 读取 Token，构建 AST
struct Parser {
    lexer: &Lexer,           // 词法分析器指针（由调用者提供，不分配）
    current_token: &Token,    // 当前 Token（从 Arena 分配）
    arena: &Arena,            // Arena 分配器（用于分配 Token 和 AST 节点）
    context: ParserContext,  // 当前解析上下文
}

// 初始化 Parser
// 参数：parser - Parser 结构体指针（由调用者提供），lexer - Lexer 指针，arena - Arena 分配器
// 返回：成功返回 0，失败返回 -1
// 注意：Parser 结构体由调用者在栈上或静态分配，此函数只负责初始化
fn parser_init(parser: &Parser, lexer: &Lexer, arena: &Arena) i32 {
    if parser == null || lexer == null || arena == null {
        return -1;
    }
    
    parser.lexer = lexer;
    parser.arena = arena;
    parser.context = ParserContext.PARSER_CONTEXT_NORMAL;  // 默认上下文
    
    // 获取第一个 Token
    parser.current_token = lexer_next_token(lexer, arena);
    
    return 0;
}

// 辅助函数：检查当前 Token 类型是否匹配
fn parser_match(parser: &Parser, type: TokenType) i32 {
    if parser == null || parser.current_token == null {
        return 0;
    }
    if parser.current_token.type == type {
        return 1;
    } else {
        return 0;
    }
}

// 辅助函数：消费当前 Token 并获取下一个
fn parser_consume(parser: &Parser) &Token {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const current: &Token = parser.current_token;
    parser.current_token = lexer_next_token(parser.lexer, parser.arena);
    return current;
}

// 辅助函数：期望特定类型的 Token
fn parser_expect(parser: &Parser, type: TokenType) &Token {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    if parser.current_token.type != type {
        // 错误：期望的类型不匹配
        // 注意：Uya 版本简化错误报告，不使用 fprintf（需要 extern 函数）
        return null;
    }
    
    return parser_consume(parser);
}

// 从 Arena 复制字符串
// 注意：需要 extern 函数 strlen 和 memcpy
extern fn strlen(s: *byte) usize;
extern fn memcpy(dest: *byte, src: *byte, n: usize) *byte;

fn arena_strdup(arena: &Arena, src: &byte) &byte {
    if arena == null || src == null {
        return null;
    }
    
    const str_len: usize = strlen(src as *byte) + 1;
    const result: &byte = arena_alloc(arena, str_len) as &byte;
    if result == null {
        return null;
    }
    
    memcpy(result as *byte, src as *byte, str_len);
    return result;
}

// 辅助函数：检查当前 token（'{'）后面是否是结构体字段初始化列表的开始
// 结构体字段初始化列表格式：identifier: expr 或 }
// 注意：调用此函数时，parser.current_token 应该是 '{'
fn parser_peek_is_struct_init(parser: &Parser) i32 {
    if parser == null || parser.lexer == null || parser.current_token == null {
        return 0;
    }
    const lexer: &Lexer = parser.lexer;
    if lexer.string_mode != 0 || lexer.interp_depth > 0 {
        return 0;
    }
    if parser.current_token.type != TokenType.TOKEN_LEFT_BRACE {
        return 0;
    }
    
    // 保存 lexer 状态（当前 lexer 的 position 已经在 '{' 之后）
    var saved_position: usize = lexer.position;
    var saved_line: i32 = lexer.line;
    var saved_column: i32 = lexer.column;
    
    // 获取 '{' 后面的 token（lexer_next_token 会跳过空白字符和注释）
    const after_brace: &Token = lexer_next_token(lexer, parser.arena);
    
    if after_brace == null {
        // 恢复状态
        lexer.position = saved_position;
        lexer.line = saved_line;
        lexer.column = saved_column;
        return 0;
    }
    
    const token_type: TokenType = after_brace.type;
    var is_struct_init: i32 = 0;
    
    // 检查 identifier: 模式或空的 {}
    if token_type == TokenType.TOKEN_RIGHT_BRACE {
        // 空的 {}：在表达式上下文中，可能是结构体字面量，也可能是代码块
        // 采用保守策略：空的 `{}` 在表达式上下文中，优先认为是结构体字面量
        is_struct_init = 1;
    } else if token_type == TokenType.TOKEN_IDENTIFIER {
        // 检查标识符后面是否有 ':'
        var saved_position2: usize = lexer.position;
        var saved_line2: i32 = lexer.line;
        var saved_column2: i32 = lexer.column;
        
        const after_identifier: &Token = lexer_next_token(lexer, parser.arena);
        if after_identifier != null && after_identifier.type == TokenType.TOKEN_COLON {
            is_struct_init = 1;
        }
        
        // 恢复状态到标识符之前（after_brace 之后）
        lexer.position = saved_position2;
        lexer.line = saved_line2;
        lexer.column = saved_column2;
    }
    
    // 恢复 lexer 状态到 '{' 之后（原始位置）
    lexer.position = saved_position;
    lexer.line = saved_line;
    lexer.column = saved_column;
    
    return is_struct_init;
}

// 前向声明（Uya 不支持，需要重新组织函数顺序）
// 注意：这些函数会在后面定义，但需要先声明以便递归调用
// 由于 Uya 不支持前向声明，我们需要重新组织函数顺序
// 这里先定义基础表达式解析函数，然后定义更复杂的表达式解析函数

// 辅助函数：获取文件名（用于 ast_new_node）
fn parser_get_filename(parser: &Parser) &byte {
    if parser != null && parser.lexer != null {
        return parser.lexer.filename;
    }
    return null;
}

// 解析类型（支持命名类型、指针类型和数组类型）
// type = named_type | pointer_type | array_type
// named_type = ID
// pointer_type = '&' type | '*' type
// array_type = '[' type ':' expr ']'
// 注意：此函数会递归调用 parser_parse_expression，所以需要先定义基础表达式解析函数
fn parser_parse_type(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 错误联合类型 !T
    if parser.current_token.type == TokenType.TOKEN_EXCLAMATION {
        parser_consume(parser);
        const payload: &ASTNode = parser_parse_type(parser);
        if payload == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_ERROR_UNION, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.type_error_union_payload_type = payload;
        return node;
    }
    
    // 检查是否是元组类型（(T1, T2, ...)）
    if parser.current_token.type == TokenType.TOKEN_LEFT_PAREN {
        parser_consume(parser);  // 消费 '('
        
        const first: &ASTNode = parser_parse_type(parser);
        if first == null {
            return null;
        }
        
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COMMA {
            // 元组类型：(T1, T2, ...)
            var elements: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * 16) as & & ASTNode;
            if elements == null {
                return null;
            }
            var cap: i32 = 16;
            var count: i32 = 0;
            elements[count] = first;
            count = count + 1;
            
            while parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COMMA {
                parser_consume(parser);  // 消费 ','
                const elem: &ASTNode = parser_parse_type(parser);
                if elem == null {
                    return null;
                }
                if count >= cap {
                    const new_cap: i32 = cap * 2;
                    const new_elements: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * new_cap) as & & ASTNode;
                    if new_elements == null {
                        return null;
                    }
                    var i: i32 = 0;
                    while i < count {
                        new_elements[i] = elements[i];
                        i = i + 1;
                    }
                    elements = new_elements;
                    cap = new_cap;
                }
                elements[count] = elem;
                count = count + 1;
            }
            
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            
            const tuple_type: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_TUPLE, line, column, parser.arena, parser_get_filename(parser));
            if tuple_type == null {
                return null;
            }
            tuple_type.type_tuple_element_types = elements;
            tuple_type.type_tuple_element_count = count;
            return tuple_type;
        }
        
        // 单类型括号 (T) => 等价于 T
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        return first;
    }
    
    // 检查是否是指针类型（&Type 或 *Type）或切片类型（&[T] / &[T: N]）
    if parser.current_token.type == TokenType.TOKEN_AMPERSAND {
        parser_consume(parser);  // 消费 '&'
        
        // 切片类型 &[T] 或 &[T: N]：& 后紧跟 [
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
            parser_consume(parser);  // 消费 '['
            const element_type: &ASTNode = parser_parse_type(parser);
            if element_type == null {
                return null;
            }
            var size_expr: &ASTNode = null;
            if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                parser_consume(parser);  // 消费 ':'
                size_expr = parser_parse_expression(parser);
                if size_expr == null {
                    return null;
                }
            }
            if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                return null;
            }
            const slice_type: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_SLICE, line, column, parser.arena, parser_get_filename(parser));
            if slice_type == null {
                return null;
            }
            slice_type.type_slice_element_type = element_type;
            slice_type.type_slice_size_expr = size_expr;
            return slice_type;
        }
        
        // 普通指针类型 &Type
        const pointed_type: &ASTNode = parser_parse_type(parser);
        if pointed_type == null {
            return null;
        }
        
        // 创建指针类型节点
        const filename: &byte = parser_get_filename(parser);
        const pointer_type: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_POINTER, line, column, parser.arena, filename);
        if pointer_type == null {
            return null;
        }
        
        pointer_type.type_pointer_pointed_type = pointed_type;
        pointer_type.type_pointer_is_ffi_pointer = 0;  // 普通指针
        
        return pointer_type;
    } else if parser.current_token.type == TokenType.TOKEN_ASTERISK {
        // FFI 指针类型 *Type（仅用于 extern 函数）
        parser_consume(parser);  // 消费 '*'
        
        // 递归解析指向的类型
        const pointed_type: &ASTNode = parser_parse_type(parser);
        if pointed_type == null {
            return null;
        }
        
        // 创建 FFI 指针类型节点
        const pointer_type: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_POINTER, line, column, parser.arena, parser_get_filename(parser));
        if pointer_type == null {
            return null;
        }
        
        pointer_type.type_pointer_pointed_type = pointed_type;
        pointer_type.type_pointer_is_ffi_pointer = 1;  // FFI 指针
        
        return pointer_type;
    } else if parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
        // 数组类型 [Type: Size]
        parser_consume(parser);  // 消费 '['
        
        // 解析元素类型
        const element_type: &ASTNode = parser_parse_type(parser);
        if element_type == null {
            return null;
        }
        
        // 期望 ':'
        if parser_expect(parser, TokenType.TOKEN_COLON) == null {
            return null;
        }
        
        // 解析数组大小表达式（必须是编译期常量，但解析阶段先解析为表达式）
        // 注意：这里解析为表达式节点，类型检查阶段会验证是否为编译期常量
        // 注意：这里需要调用 parser_parse_expression，该函数会在后面定义
        const size_expr: &ASTNode = parser_parse_expression(parser);
        if size_expr == null {
            return null;
        }
        
        // 期望 ']'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
            return null;
        }
        
        // 创建数组类型节点
        const array_type: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_ARRAY, line, column, parser.arena, parser_get_filename(parser));
        if array_type == null {
            return null;
        }
        
        array_type.type_array_element_type = element_type;
        array_type.type_array_size_expr = size_expr;
        
        return array_type;
    } else if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
        // 命名类型（i32, bool, void, 或结构体名称）
        const type_node: &ASTNode = ast_new_node(ASTNodeType.AST_TYPE_NAMED, line, column, parser.arena, parser_get_filename(parser));
        if type_node == null {
            return null;
        }
        
        // 复制类型名称到 Arena
        const type_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if type_name == null {
            return null;
        }
        
        type_node.type_named_name = type_name;
        
        // 消费类型标识符
        parser_consume(parser);
        
        return type_node;
    }
    
    // 无法识别的类型语法
    return null;
}

// 字符串转整数/浮点辅助函数
extern fn atoi(s: *byte) i32;
extern fn strtod(nptr: *byte, endptr: * *byte) f64;

// 解析基础表达式
// 支持：数字、标识符、布尔字面量、括号表达式、函数调用、结构体字面量、字段访问
fn parser_parse_primary_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 解析整数字面量
    if parser.current_token.type == TokenType.TOKEN_NUMBER {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_NUMBER, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        const value: i32 = atoi(parser.current_token.value as *byte);
        node.number_value = value;
        parser_consume(parser);
        return node;
    }
    
    // 解析浮点字面量
    if parser.current_token.type == TokenType.TOKEN_FLOAT {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_FLOAT, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        const value: f64 = strtod(parser.current_token.value as *byte, null as * *byte);
        node.float_literal_value = value;
        parser_consume(parser);
        return node;
    }
    
    // 解析布尔字面量
    if parser.current_token.type == TokenType.TOKEN_TRUE {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BOOL, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.bool_literal_value = 1;  // true
        
        parser_consume(parser);
        return node;
    }
    
    if parser.current_token.type == TokenType.TOKEN_FALSE {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BOOL, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.bool_literal_value = 0;  // false
        
        parser_consume(parser);
        return node;
    }
    
    // 解析字符串插值（"text${expr}text" 或 "text${expr:spec}text"），以 TOKEN_INTERP_TEXT 或 TOKEN_INTERP_OPEN 开始
    if parser.current_token.type == TokenType.TOKEN_INTERP_TEXT || parser.current_token.type == TokenType.TOKEN_INTERP_OPEN {
        const MAX_INTERP_SEGMENTS: i32 = 64;
        var seg_is_text: [i32: 64] = [];
        var seg_text: [&byte: 64] = [];
        var seg_expr: [&ASTNode: 64] = [];
        var seg_format_spec: [&byte: 64] = [];
        var seg_count: i32 = 0;
        var saw_end: i32 = 0;
        while seg_count < MAX_INTERP_SEGMENTS && parser.current_token != null {
            if parser.current_token.type == TokenType.TOKEN_INTERP_TEXT {
                seg_is_text[seg_count] = 1;
                seg_text[seg_count] = parser.current_token.value;
                seg_expr[seg_count] = null;
                seg_format_spec[seg_count] = null;
                seg_count = seg_count + 1;
                parser_consume(parser);
            } else if parser.current_token.type == TokenType.TOKEN_INTERP_OPEN {
                parser_consume(parser);
                const expr: &ASTNode = parser_parse_expression(parser);
                if expr == null {
                    return null;
                }
                var spec: &byte = null;
                if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_INTERP_SPEC {
                    spec = parser.current_token.value;
                    parser_consume(parser);
                } else {
                    if parser.current_token == null || parser.current_token.type != TokenType.TOKEN_INTERP_CLOSE {
                        return null;
                    }
                    parser_consume(parser);
                }
                seg_is_text[seg_count] = 0;
                seg_text[seg_count] = null;
                seg_expr[seg_count] = expr;
                seg_format_spec[seg_count] = spec;
                seg_count = seg_count + 1;
            } else if parser.current_token.type == TokenType.TOKEN_INTERP_END {
                parser_consume(parser);
                saw_end = 1;
                break;
            } else if parser.current_token.type == TokenType.TOKEN_INTERP_SPEC && seg_count > 0 &&
                seg_is_text[seg_count - 1] == 0 && seg_expr[seg_count - 1] != null && seg_format_spec[seg_count - 1] == null {
                seg_format_spec[seg_count - 1] = parser.current_token.value;
                parser_consume(parser);
            } else {
                return null;
            }
        }
        if saw_end == 0 || seg_count == 0 || seg_count >= MAX_INTERP_SEGMENTS {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_STRING_INTERP, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        const segs: &ASTStringInterpSegment = arena_alloc(parser.arena, (seg_count as usize) * @sizeof(ASTStringInterpSegment)) as &ASTStringInterpSegment;
        if segs == null {
            return null;
        }
        var i: i32 = 0;
        while i < seg_count {
            segs[i].is_text = seg_is_text[i];
            segs[i].text = seg_text[i];
            segs[i].expr = seg_expr[i];
            segs[i].format_spec = seg_format_spec[i];
            i = i + 1;
        }
        node.string_interp_segments = segs;
        node.string_interp_segment_count = seg_count;
        return node;
    }
    
    // 解析字符串字面量
    if parser.current_token.type == TokenType.TOKEN_STRING {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_STRING, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        // 复制字符串内容到 Arena（token 的 value 已经在 Arena 中）
        const str_value: &byte = parser.current_token.value;
        if str_value == null {
            return null;
        }
        
        // 字符串内容已经在 token 中，直接使用（token 的 value 存储在 Arena 中）
        node.string_literal_value = str_value;
        
        parser_consume(parser);
        return node;
    }
    
    // 解析 error.Name（错误值，用于 return error.X）
    if parser.current_token.type == TokenType.TOKEN_ERROR {
        parser_consume(parser);
        if parser_match(parser, TokenType.TOKEN_DOT) == 0 {
            return null;
        }
        parser_consume(parser);
        if parser.current_token == null || parser.current_token.type != TokenType.TOKEN_IDENTIFIER {
            return null;
        }
        const err_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if err_name == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_ERROR_VALUE, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.error_value_name = err_name;
        parser_consume(parser);
        return node;
    }
    
    // 解析 null 字面量（null 被解析为标识符节点，在代码生成阶段通过字符串比较识别）
    if parser.current_token.type == TokenType.TOKEN_NULL {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        // 复制 "null" 字符串到 Arena（代码生成器会通过字符串比较识别）
        const null_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if null_name == null {
            return null;
        }
        node.identifier_name = null_name;
        
        parser_consume(parser);
        return node;
    }
    
    // 解析 @params（函数体内参数元组），支持 @params.0、@params.1 等后缀
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "params" as &byte) != 0 {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_PARAMS, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        parser_consume(parser);
        var result: &ASTNode = node;
        while parser.current_token != null && parser_match(parser, TokenType.TOKEN_DOT) != 0 {
            parser_consume(parser);
            if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER) {
                return null;
            }
            const field_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
            if field_name == null {
                return null;
            }
            const field_line: i32 = parser.current_token.line;
            const field_column: i32 = parser.current_token.column;
            parser_consume(parser);
            const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
            if member_access == null {
                return null;
            }
            member_access.member_access_object = result;
            member_access.member_access_field_name = field_name;
            result = member_access;
        }
        return result;
    }
    
    // 解析 @max/@min 整数极值字面量（类型由 Checker 从上下文推断）
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "max" as &byte) != 0 {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_INT_LIMIT, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.int_limit_is_max = 1;
        node.int_limit_resolved_kind = 0;
        parser_consume(parser);
        return node;
    }
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "min" as &byte) != 0 {
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_INT_LIMIT, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.int_limit_is_max = 0;
        node.int_limit_resolved_kind = 0;
        parser_consume(parser);
        return node;
    }
    
    // 解析 @sizeof 表达式：@sizeof(Type) 或 @sizeof(expr)
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "sizeof" as &byte) != 0 {
        parser_consume(parser);  // 消费 'sizeof'
        
        // 期望 '('
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const sizeof_node: &ASTNode = ast_new_node(ASTNodeType.AST_SIZEOF, line, column, parser.arena, parser_get_filename(parser));
        if sizeof_node == null {
            return null;
        }
        
        // 尝试解析类型，如果失败则解析表达式
        // 先检查是否是类型语法（基础类型或 struct 关键字）
        var is_type: i32 = 0;
        var target: &ASTNode = null;
        
        if parser.current_token != null {
            if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
                const type_name: &byte = parser.current_token.value;
                // 检查是否是基础类型或 struct 关键字
                if str_equals(type_name, "i32" as *byte) != 0 || 
                    str_equals(type_name, "usize" as *byte) != 0 ||
                    str_equals(type_name, "bool" as *byte) != 0 || 
                    str_equals(type_name, "byte" as *byte) != 0 ||
                    str_equals(type_name, "f32" as *byte) != 0 ||
                    str_equals(type_name, "f64" as *byte) != 0 ||
                    str_equals(type_name, "void" as *byte) != 0 ||
                    str_equals(type_name, "struct" as *byte) != 0 {
                    target = parser_parse_type(parser);
                    if target != null {
                        is_type = 1;
                    }
                }
            } else if parser.current_token.type == TokenType.TOKEN_AMPERSAND || 
                      parser.current_token.type == TokenType.TOKEN_ASTERISK ||
                      parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
                target = parser_parse_type(parser);
                if target != null {
                    is_type = 1;
                }
            }
        }
        if target == null {
            target = parser_parse_expression(parser);
            if target == null {
                return null;
            }
            is_type = 0;
        }
        sizeof_node.sizeof_expr_target = target;
        sizeof_node.sizeof_expr_is_type = is_type;
        
        // 期望 ')'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return sizeof_node;
    }
    
    // 解析 @alignof 表达式：@alignof(Type) 或 @alignof(expr)
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "alignof" as &byte) != 0 {
        parser_consume(parser);  // 消费 'alignof'
        
        // 期望 '('
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const alignof_node: &ASTNode = ast_new_node(ASTNodeType.AST_ALIGNOF, line, column, parser.arena, parser_get_filename(parser));
        if alignof_node == null {
            return null;
        }
        
        // 尝试解析类型，如果失败则解析表达式
        // 先检查是否是类型语法（基础类型或 struct 关键字）
        var is_type: i32 = 0;
        var target: &ASTNode = null;
        
        if parser.current_token != null {
            if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
                const type_name: &byte = parser.current_token.value;
                // 检查是否是基础类型或 struct 关键字
                if str_equals(type_name, "i32" as *byte) != 0 || 
                    str_equals(type_name, "usize" as *byte) != 0 ||
                    str_equals(type_name, "bool" as *byte) != 0 || 
                    str_equals(type_name, "byte" as *byte) != 0 ||
                    str_equals(type_name, "f32" as *byte) != 0 ||
                    str_equals(type_name, "f64" as *byte) != 0 ||
                    str_equals(type_name, "void" as *byte) != 0 ||
                    str_equals(type_name, "struct" as *byte) != 0 {
                    target = parser_parse_type(parser);
                    if target != null {
                        is_type = 1;
                    }
                }
            } else if parser.current_token.type == TokenType.TOKEN_AMPERSAND || 
                      parser.current_token.type == TokenType.TOKEN_ASTERISK ||
                      parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
                target = parser_parse_type(parser);
                if target != null {
                    is_type = 1;
                }
            }
        }
        if target == null {
            target = parser_parse_expression(parser);
            if target == null {
                return null;
            }
            is_type = 0;
        }
        alignof_node.alignof_expr_target = target;
        alignof_node.alignof_expr_is_type = is_type;
        
        // 期望 ')'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return alignof_node;
    }
    
    // 解析 @len 表达式：@len(array)
    if parser.current_token.type == TokenType.TOKEN_AT_IDENTIFIER && parser.current_token.value != null &&
        str_equals_lexer(parser.current_token.value, "len" as &byte) != 0 {
        parser_consume(parser);  // 消费 'len'
        
        // 期望 '('
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const len_node: &ASTNode = ast_new_node(ASTNodeType.AST_LEN, line, column, parser.arena, parser_get_filename(parser));
        if len_node == null {
            return null;
        }
        
        // 解析数组表达式
        const array_expr: &ASTNode = parser_parse_expression(parser);
        if array_expr == null {
            return null;
        }
        
        len_node.len_expr_array = array_expr;
        
        // 期望 ')'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return len_node;
    }
    
    // 解析标识符（可能是普通标识符、函数调用、或结构体字面量的开始）
    // 忽略占位 _：仅允许在赋值左侧、解构中使用，生成 AST_UNDERSCORE
    if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
        if parser.current_token.value != null && str_equals_lexer(parser.current_token.value, "_" as &byte) != 0 {
            const node: &ASTNode = ast_new_node(ASTNodeType.AST_UNDERSCORE, line, column, parser.arena, parser_get_filename(parser));
            if node == null {
                return null;
            }
            parser_consume(parser);
            return node;
        }
        const name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if name == null {
            return null;
        }
        
        parser_consume(parser);  // 消费标识符
        
        // 检查下一个 token 类型
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LEFT_PAREN {
            // 函数调用：ID '(' [ arg_list ] ')'
            const call: &ASTNode = ast_new_node(ASTNodeType.AST_CALL_EXPR, line, column, parser.arena, parser_get_filename(parser));
            if call == null {
                return null;
            }
            
            // 创建标识符节点作为被调用的函数
            const callee: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
            if callee == null {
                return null;
            }
            callee.identifier_name = name;
            call.call_expr_callee = callee;
            call.call_expr_has_ellipsis_forward = 0;
            
            // 消费 '('（与 C 版 parser.c 第 1636-1637 行一致）
            parser_consume(parser);
            
            // 解析参数列表（可选），末尾允许 ... 表示转发可变参数
            var args: & & ASTNode = null;
            var arg_count: i32 = 0;
            var arg_capacity: i32 = 0;
            
            if parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
                // 有参数
                while parser.current_token != null && 
                      parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 && 
                      parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                    
                    // 检查是否为末尾的 ...（转发可变参数）
                    if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                        parser_consume(parser);
                        call.call_expr_has_ellipsis_forward = 1;
                        break;
                    }
                    
                    // 解析参数表达式
                    const arg: &ASTNode = parser_parse_expression(parser);
                    if arg == null {
                        return null;
                    }
                    
                    // 扩展参数数组
                    if arg_count >= arg_capacity {
                        var new_capacity: i32 = 0;
                        if arg_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = arg_capacity * 2;
                        }
                        const new_args: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * new_capacity) as & & ASTNode;
                        if new_args == null {
                            return null;
                        }
                        
                        // 复制旧参数
                        if args != null {
                            var i: i32 = 0;
                            while i < arg_count {
                                new_args[i] = args[i];
                                i = i + 1;
                            }
                        }
                        
                        args = new_args;
                        arg_capacity = new_capacity;
                    }
                    
                    args[arg_count] = arg;
                    arg_count = arg_count + 1;
                    
                    // 检查是否有逗号或逗号后 ...
                    if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    }
                }
            }
            
            // 期望 ')'
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            
            call.call_expr_args = args;
            call.call_expr_arg_count = arg_count;
            
            // 字段访问和数组访问可能跟在函数调用后面（例如：f().field、f().0 或 f()[0]）
            var result: &ASTNode = call;
            
            // 处理字段访问和数组访问链（.field 或元组 .0/.1）
            while parser.current_token != null {
                if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                    parser_consume(parser);  // 消费 '.'
                    if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER) {
                        return null;
                    }
                    const field_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费字段名称
                    
                    // 创建字段访问节点
                    const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                    if member_access == null {
                        return null;
                    }
                    
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    
                    result = member_access;
                } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                    const bracket_line: i32 = parser.current_token.line;
                    const bracket_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费 '['
                    const first_expr: &ASTNode = parser_parse_expression(parser);
                    if first_expr == null {
                        return null;
                    }
                    if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                        parser_consume(parser);
                        const len_expr: &ASTNode = parser_parse_expression(parser);
                        if len_expr == null {
                            return null;
                        }
                        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                            return null;
                        }
                        const slice_expr: &ASTNode = ast_new_node(ASTNodeType.AST_SLICE_EXPR, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                        if slice_expr == null {
                            return null;
                        }
                        slice_expr.slice_expr_base = result;
                        slice_expr.slice_expr_start_expr = first_expr;
                        slice_expr.slice_expr_len_expr = len_expr;
                        result = slice_expr;
                    } else {
                        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                            return null;
                        }
                        const array_access: &ASTNode = ast_new_node(ASTNodeType.AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                        if array_access == null {
                            return null;
                        }
                        array_access.array_access_array = result;
                        array_access.array_access_index = first_expr;
                        result = array_access;
                    }
                } else {
                    break;
                }
            }
            
            return result;
        } else if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LEFT_BRACE {
            // 使用 peek 机制检测是否是结构体字面量
            var is_struct_init: i32 = parser_peek_is_struct_init(parser);
            
            // 特殊情况：如果 '{' 后面是 '}'（空块），且这是在条件表达式上下文中，
            // 我们需要检查这是否是在比较表达式之后（如 `p1 == p2 {`）
            if is_struct_init != 0 {
                const lexer: &Lexer = parser.lexer;
                var saved_position: usize = lexer.position;
                var saved_line: i32 = lexer.line;
                var saved_column: i32 = lexer.column;
                
                // Peek '{' 后面的 token
                const after_brace: &Token = lexer_next_token(lexer, parser.arena);
                if after_brace != null && after_brace.type == TokenType.TOKEN_RIGHT_BRACE {
                    // '{' 后面是 '}'（空块）
                    // 恢复 lexer 状态
                    lexer.position = saved_position;
                    lexer.line = saved_line;
                    lexer.column = saved_column;
                    
                    // 根据上下文判断
                    if parser.context == ParserContext.PARSER_CONTEXT_CONDITION {
                        // 在条件表达式上下文中，`{}` 应该是代码块的开始
                        // 返回标识符，让调用者处理 '{' 作为代码块
                        const node: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
                        if node == null {
                            return null;
                        }
                        
                        node.identifier_name = name;
                        return node;
                    }
                    // 在变量初始化上下文或普通上下文中，`{}` 应该是结构体字面量
                    // 继续解析结构体字面量
                } else {
                    // 恢复 lexer 状态
                    lexer.position = saved_position;
                    lexer.line = saved_line;
                    lexer.column = saved_column;
                }
            }
            
            if is_struct_init == 0 {
                // 不是结构体字面量，创建普通标识符（后面的'{'是代码块的开始，不是表达式的一部分）
                const node: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
                if node == null {
                    return null;
                }
                
                node.identifier_name = name;
                
                // 字段访问可能跟在标识符后面（例如：obj.field）
                var result: &ASTNode = node;
                
                // 处理字段访问链（左结合：a.b.c 或元组 .0/.1）
                while parser.current_token != null && parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                    parser_consume(parser);  // 消费 '.'
                    if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER) {
                        return null;
                    }
                    const field_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);
                    const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                    if member_access == null {
                        return null;
                    }
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    result = member_access;
                }
                
                return result;
            }
            
            // 结构体字面量：ID '{' field_init_list '}'
            const struct_init: &ASTNode = ast_new_node(ASTNodeType.AST_STRUCT_INIT, line, column, parser.arena, parser_get_filename(parser));
            if struct_init == null {
                return null;
            }
            
            struct_init.struct_init_struct_name = name;
            
            // 消费 '{'
            parser_consume(parser);
            
            // 解析字段初始化列表
            var field_names: & & byte = null;
            var field_values: & & ASTNode = null;
            var field_count: i32 = 0;
            var field_capacity: i32 = 0;
            
            if parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 {
                // 有字段初始化
                while parser.current_token != null && 
                      parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
                      parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                    
                    // 解析字段名称
                    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                        return null;
                    }
                    
                    const field_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    
                    parser_consume(parser);  // 消费字段名称
                    
                    // 期望 ':'
                    if parser_expect(parser, TokenType.TOKEN_COLON) == null {
                        return null;
                    }
                    
                    // 解析字段值表达式
                    const field_value: &ASTNode = parser_parse_expression(parser);
                    if field_value == null {
                        return null;
                    }
                    
                    // 扩展字段数组
                    if field_count >= field_capacity {
                        var new_capacity: i32 = 0;
                        if field_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = field_capacity * 2;
                        }
                        const new_field_names: & & byte = arena_alloc(parser.arena, @sizeof(&byte) * new_capacity) as & & byte;
                        const new_field_values: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * new_capacity) as & & ASTNode;
                        if new_field_names == null || new_field_values == null {
                            return null;
                        }
                        
                        // 复制旧字段
                        if field_names != null && field_values != null {
                            var i: i32 = 0;
                            while i < field_count {
                                new_field_names[i] = field_names[i];
                                new_field_values[i] = field_values[i];
                                i = i + 1;
                            }
                        }
                        
                        field_names = new_field_names;
                        field_values = new_field_values;
                        field_capacity = new_capacity;
                    }
                    
                    field_names[field_count] = field_name;
                    field_values[field_count] = field_value;
                    field_count = field_count + 1;
                    
                    // 检查是否有逗号
                    if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    }
                }
            }
            
            // 期望 '}'
            if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
                return null;
            }
            
            struct_init.struct_init_field_names = field_names;
            struct_init.struct_init_field_values = field_values;
            struct_init.struct_init_field_count = field_count;
            
            // 字段访问可能跟在结构体字面量后面（例如：Point{x:1,y:2}.x）
            var result: &ASTNode = struct_init;
            
            // 处理字段访问链（.field 或元组 .0/.1）
            while parser.current_token != null && parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                parser_consume(parser);  // 消费 '.'
                if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER) {
                    return null;
                }
                const field_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
                if field_name == null {
                    return null;
                }
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);
                const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                if member_access == null {
                    return null;
                }
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                result = member_access;
            }
            
            return result;
        } else {
            // 普通标识符
            const node: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, line, column, parser.arena, parser_get_filename(parser));
            if node == null {
                return null;
            }
            
            node.identifier_name = name;
            
            // 字段访问和数组访问可能跟在标识符后面（例如：obj.field 或 arr[0]）
            var result: &ASTNode = node;
            
            // 处理字段访问和数组访问链（.field 或元组 .0/.1、[index]）
            while parser.current_token != null {
                if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                    parser_consume(parser);  // 消费 '.'
                    if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER) {
                        return null;
                    }
                    const field_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);
                    const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                    if member_access == null {
                        return null;
                    }
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    result = member_access;
                } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                    const bracket_line: i32 = parser.current_token.line;
                    const bracket_column: i32 = parser.current_token.column;
                    parser_consume(parser);
                    const first_expr: &ASTNode = parser_parse_expression(parser);
                    if first_expr == null {
                        return null;
                    }
                    if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                        parser_consume(parser);
                        const len_expr: &ASTNode = parser_parse_expression(parser);
                        if len_expr == null {
                            return null;
                        }
                        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                            return null;
                        }
                        const slice_expr: &ASTNode = ast_new_node(ASTNodeType.AST_SLICE_EXPR, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                        if slice_expr == null {
                            return null;
                        }
                        slice_expr.slice_expr_base = result;
                        slice_expr.slice_expr_start_expr = first_expr;
                        slice_expr.slice_expr_len_expr = len_expr;
                        result = slice_expr;
                    } else {
                        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                            return null;
                        }
                        const array_access: &ASTNode = ast_new_node(ASTNodeType.AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                        if array_access == null {
                            return null;
                        }
                        array_access.array_access_array = result;
                        array_access.array_access_index = first_expr;
                        result = array_access;
                    }
                } else {
                    break;
                }
            }
            
            return result;
        }
    }
    
    // 解析数组字面量：[expr1, expr2, ..., exprN]、[value: N] 或 []
    if parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
        const array_line: i32 = parser.current_token.line;
        const array_column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 '['
        
        const array_literal: &ASTNode = ast_new_node(ASTNodeType.AST_ARRAY_LITERAL, array_line, array_column, parser.arena, parser_get_filename(parser));
        if array_literal == null {
            return null;
        }
        
        if parser_match(parser, TokenType.TOKEN_RIGHT_BRACKET) != 0 {
            parser_consume(parser);
            array_literal.array_literal_elements = null;
            array_literal.array_literal_element_count = 0;
            array_literal.array_literal_repeat_count_expr = null;
        } else {
            const first: &ASTNode = parser_parse_expression(parser);
            if first == null {
                return null;
            }
            if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                parser_consume(parser);
                const count_expr: &ASTNode = parser_parse_expression(parser);
                if count_expr == null {
                    return null;
                }
                if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                    return null;
                }
                const elements: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode)) as & & ASTNode;
                if elements == null {
                    return null;
                }
                elements[0] = first;
                array_literal.array_literal_elements = elements;
                array_literal.array_literal_element_count = 1;
                array_literal.array_literal_repeat_count_expr = count_expr;
            } else {
                var elements: & & ASTNode = null;
                var element_count: i32 = 0;
                var element_capacity: i32 = 0;
                if element_count >= element_capacity {
                    var new_capacity: i32 = 0;
                    if element_capacity == 0 {
                        new_capacity = 4;
                    } else {
                        new_capacity = element_capacity * 2;
                    }
                    const new_elements: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * new_capacity) as & & ASTNode;
                    if new_elements == null {
                        return null;
                    }
                    if elements != null {
                        var i: i32 = 0;
                        while i < element_count {
                            new_elements[i] = elements[i];
                            i = i + 1;
                        }
                    }
                    elements = new_elements;
                    element_capacity = new_capacity;
                }
                elements[element_count] = first;
                element_count = element_count + 1;
                while parser.current_token != null &&
                      parser_match(parser, TokenType.TOKEN_RIGHT_BRACKET) == 0 &&
                      parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                    if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    }
                    if parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_BRACKET) != 0 {
                        break;
                    }
                    const element: &ASTNode = parser_parse_expression(parser);
                    if element == null {
                        return null;
                    }
                    if element_count >= element_capacity {
                        var new_capacity: i32 = 0;
                        if element_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = element_capacity * 2;
                        }
                        const new_elements: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * new_capacity) as & & ASTNode;
                        if new_elements == null {
                            return null;
                        }
                        var i: i32 = 0;
                        while i < element_count {
                            new_elements[i] = elements[i];
                            i = i + 1;
                        }
                        elements = new_elements;
                        element_capacity = new_capacity;
                    }
                    elements[element_count] = element;
                    element_count = element_count + 1;
                }
                if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                    return null;
                }
                array_literal.array_literal_elements = elements;
                array_literal.array_literal_element_count = element_count;
                array_literal.array_literal_repeat_count_expr = null;
            }
        }
        
        // 字段访问和数组访问可能跟在数组字面量后面（例如：[1,2,3][0]）
        var result: &ASTNode = array_literal;
        
        // 处理字段访问和数组访问链（.field 或元组 .0/.1、[index]）
        while parser.current_token != null {
            if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                parser_consume(parser);  // 消费 '.'
                if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER) {
                    return null;
                }
                const field_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
                if field_name == null {
                    return null;
                }
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);
                const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                if member_access == null {
                    return null;
                }
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                result = member_access;
            } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                const bracket_line: i32 = parser.current_token.line;
                const bracket_column: i32 = parser.current_token.column;
                parser_consume(parser);
                const first_expr: &ASTNode = parser_parse_expression(parser);
                if first_expr == null {
                    return null;
                }
                if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                    parser_consume(parser);
                    const len_expr: &ASTNode = parser_parse_expression(parser);
                    if len_expr == null {
                        return null;
                    }
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    const slice_expr: &ASTNode = ast_new_node(ASTNodeType.AST_SLICE_EXPR, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                    if slice_expr == null {
                        return null;
                    }
                    slice_expr.slice_expr_base = result;
                    slice_expr.slice_expr_start_expr = first_expr;
                    slice_expr.slice_expr_len_expr = len_expr;
                    result = slice_expr;
                } else {
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    const array_access: &ASTNode = ast_new_node(ASTNodeType.AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                    if array_access == null {
                        return null;
                    }
                    array_access.array_access_array = result;
                    array_access.array_access_index = first_expr;
                    result = array_access;
                }
            } else {
                break;
            }
        }
        
        return result;
    }
    
    // 解析括号表达式或元组字面量
    if parser.current_token.type == TokenType.TOKEN_LEFT_PAREN {
        const paren_line: i32 = parser.current_token.line;
        const paren_column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 '('
        
        const first: &ASTNode = parser_parse_expression(parser);
        if first == null {
            return null;
        }
        
        var result: &ASTNode = null;
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COMMA {
            // 元组字面量：(expr1, expr2, ...)
            var elements: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * 16) as & & ASTNode;
            if elements == null {
                return null;
            }
            var cap: i32 = 16;
            var count: i32 = 0;
            elements[count] = first;
            count = count + 1;
            
            while parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COMMA {
                parser_consume(parser);  // 消费 ','
                const elem: &ASTNode = parser_parse_expression(parser);
                if elem == null {
                    return null;
                }
                if count >= cap {
                    const new_cap: i32 = cap * 2;
                    const new_elements: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * new_cap) as & & ASTNode;
                    if new_elements == null {
                        return null;
                    }
                    var i: i32 = 0;
                    while i < count {
                        new_elements[i] = elements[i];
                        i = i + 1;
                    }
                    elements = new_elements;
                    cap = new_cap;
                }
                elements[count] = elem;
                count = count + 1;
            }
            
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            
            const tuple_lit: &ASTNode = ast_new_node(ASTNodeType.AST_TUPLE_LITERAL, paren_line, paren_column, parser.arena, parser_get_filename(parser));
            if tuple_lit == null {
                return null;
            }
            tuple_lit.tuple_literal_elements = elements;
            tuple_lit.tuple_literal_element_count = count;
            result = tuple_lit;
        } else {
            // 单表达式括号 (expr) => expr
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            result = first;
        }
        
        // 处理字段访问和数组访问链（.field 或元组下标 .0/.1、[index]）
        while parser.current_token != null {
            if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                // 字段访问：.field 或元组下标 .0, .1, ...
                parser_consume(parser);  // 消费 '.'
                
                // 期望字段名称或元组下标（.0, .1, ... 为 NUMBER）
                if parser.current_token == null || (parser.current_token.type != TokenType.TOKEN_IDENTIFIER && parser.current_token.type != TokenType.TOKEN_NUMBER) {
                    return null;
                }
                
                const field_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
                if field_name == null {
                    return null;
                }
                
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费字段名称或元组下标
                
                // 创建字段访问节点
                const member_access: &ASTNode = ast_new_node(ASTNodeType.AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser_get_filename(parser));
                if member_access == null {
                    return null;
                }
                
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                
                result = member_access;
            } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                const bracket_line: i32 = parser.current_token.line;
                const bracket_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费 '['
                const first_expr: &ASTNode = parser_parse_expression(parser);
                if first_expr == null {
                    return null;
                }
                if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_COLON {
                    parser_consume(parser);
                    const len_expr: &ASTNode = parser_parse_expression(parser);
                    if len_expr == null {
                        return null;
                    }
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    const slice_expr: &ASTNode = ast_new_node(ASTNodeType.AST_SLICE_EXPR, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                    if slice_expr == null {
                        return null;
                    }
                    slice_expr.slice_expr_base = result;
                    slice_expr.slice_expr_start_expr = first_expr;
                    slice_expr.slice_expr_len_expr = len_expr;
                    result = slice_expr;
                } else {
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    const array_access: &ASTNode = ast_new_node(ASTNodeType.AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser_get_filename(parser));
                    if array_access == null {
                        return null;
                    }
                    array_access.array_access_array = result;
                    array_access.array_access_index = first_expr;
                    result = array_access;
                }
            } else {
                break;
            }
        }
        
        return result;
    }
    
    // 无法识别的基础表达式
    return null;
}

// 解析一元表达式（!, -, &, *, try，右结合）
// unary_expr = ('!' | '-' | '&' | '*' | 'try') unary_expr | primary_expr
fn parser_parse_unary_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // try expr（错误传播）
    if parser_match(parser, TokenType.TOKEN_TRY) != 0 {
        parser_consume(parser);
        const operand: &ASTNode = parser_parse_unary_expr(parser);
        if operand == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_TRY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.try_expr_operand = operand;
        return node;
    }
    
    // 检查一元运算符（!, -, ~, &, *）
    if parser_match(parser, TokenType.TOKEN_EXCLAMATION) != 0 || 
       parser_match(parser, TokenType.TOKEN_MINUS) != 0 ||
       parser_match(parser, TokenType.TOKEN_TILDE) != 0 ||
       parser_match(parser, TokenType.TOKEN_AMPERSAND) != 0 ||
       parser_match(parser, TokenType.TOKEN_ASTERISK) != 0 {
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 递归解析一元表达式（右结合）
        const operand: &ASTNode = parser_parse_unary_expr(parser);
        if operand == null {
            return null;
        }
        
        // 创建一元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_UNARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.unary_expr_op = op;
        node.unary_expr_operand = operand;
        
        return node;
    }
    
    // 不是一元运算符，解析基础表达式
    return parser_parse_primary_expr(parser);
}

// 解析类型转换表达式（右结合），支持后缀 catch
// cast_expr = unary_expr [ 'as' type ] { 'catch' [ '|' ID '|' ] '{' statements '}' }
fn parser_parse_cast_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数（一元表达式）
    var expr: &ASTNode = parser_parse_unary_expr(parser);
    if expr == null {
        return null;
    }
    
    // 检查是否有 'as' 关键字（类型转换）
    if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_AS {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 'as'
        
        // 解析目标类型
        const target_type: &ASTNode = parser_parse_type(parser);
        if target_type == null {
            return null;
        }
        
        // 创建类型转换节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_CAST_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.cast_expr_expr = expr;
        node.cast_expr_target_type = target_type;
        
        expr = node;
    }
    
    // 后缀 catch：expr catch [ |err| ] { stmts }（可多个，左结合）
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_CATCH) != 0 {
        const catch_line: i32 = parser.current_token.line;
        const catch_column: i32 = parser.current_token.column;
        parser_consume(parser);
        var err_name: &byte = null;
        if parser.current_token != null && parser_match(parser, TokenType.TOKEN_PIPE) != 0 {
            parser_consume(parser);
            if parser.current_token == null || parser.current_token.type != TokenType.TOKEN_IDENTIFIER {
                return null;
            }
            err_name = arena_strdup(parser.arena, parser.current_token.value);
            if err_name == null {
                return null;
            }
            parser_consume(parser);
            if parser_expect(parser, TokenType.TOKEN_PIPE) == null {
                return null;
            }
        }
        const catch_block: &ASTNode = parser_parse_block(parser);
        if catch_block == null {
            return null;
        }
        const catch_node: &ASTNode = ast_new_node(ASTNodeType.AST_CATCH_EXPR, catch_line, catch_column, parser.arena, parser_get_filename(parser));
        if catch_node == null {
            return null;
        }
        catch_node.catch_expr_operand = expr;
        catch_node.catch_expr_err_name = err_name;
        catch_node.catch_expr_catch_block = catch_block;
        expr = catch_node;
    }
    
    return expr;
}

// 解析乘除模表达式（左结合）
// mul_expr = cast_expr { ('*' | '/' | '%') cast_expr }
fn parser_parse_mul_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数（类型转换表达式）
    var left: &ASTNode = parser_parse_cast_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的乘除模运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_ASTERISK) != 0 ||
        parser_match(parser, TokenType.TOKEN_SLASH) != 0 ||
        parser_match(parser, TokenType.TOKEN_PERCENT) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数（类型转换表达式）
        const right: &ASTNode = parser_parse_cast_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析加减表达式（左结合）
// add_expr = mul_expr { ('+' | '-') mul_expr }
fn parser_parse_add_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_mul_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的加减运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_PLUS) != 0 ||
        parser_match(parser, TokenType.TOKEN_MINUS) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_mul_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析位移表达式（左结合）
// shift_expr = add_expr { ('<<' | '>>') add_expr }
fn parser_parse_shift_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    var left: &ASTNode = parser_parse_add_expr(parser);
    if left == null {
        return null;
    }
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_LSHIFT) != 0 ||
        parser_match(parser, TokenType.TOKEN_RSHIFT) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);
        const right: &ASTNode = parser_parse_add_expr(parser);
        if right == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        left = node;
    }
    return left;
}

// 解析比较表达式（左结合）
// rel_expr = shift_expr { ('<' | '>' | '<=' | '>=') shift_expr }
fn parser_parse_rel_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_shift_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的比较运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_LESS) != 0 ||
        parser_match(parser, TokenType.TOKEN_GREATER) != 0 ||
        parser_match(parser, TokenType.TOKEN_LESS_EQUAL) != 0 ||
        parser_match(parser, TokenType.TOKEN_GREATER_EQUAL) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_shift_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析按位与表达式（左结合）
// bitand_expr = eq_expr { '&' eq_expr }
fn parser_parse_bitand_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    var left: &ASTNode = parser_parse_eq_expr(parser);
    if left == null {
        return null;
    }
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_AMPERSAND) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);
        const right: &ASTNode = parser_parse_eq_expr(parser);
        if right == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        left = node;
    }
    return left;
}

// 解析相等性表达式（左结合）
// eq_expr = rel_expr { ('==' | '!=') rel_expr }
fn parser_parse_eq_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_rel_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的相等性运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_EQUAL) != 0 ||
        parser_match(parser, TokenType.TOKEN_NOT_EQUAL) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        var right: &ASTNode = parser_parse_rel_expr(parser);
        if right == null {
            return null;
        }
        
        // 特殊情况：如果右操作数是结构体初始化，且当前 token 是 '{'，且 '{' 后面是 '}'（空块），
        // 这可能是代码块的开始（如 `if p1 == p2 {`），而不是结构体字面量的一部分
        // 为了区分，我们检查当前 token 是否是 '{'
        // 如果是，我们 peek 一下 '{' 后面的内容，如果是 '}'（空块），我们假设这是代码块的开始
        // 在这种情况下，我们需要回退：如果 right 是结构体初始化，我们需要将其替换为标识符
        if parser.current_token != null && 
           parser.current_token.type == TokenType.TOKEN_LEFT_BRACE {
            // 保存 lexer 状态
            const lexer: &Lexer = parser.lexer;
            var saved_position: usize = lexer.position;
            var saved_line: i32 = lexer.line;
            var saved_column: i32 = lexer.column;
            
            // Peek '{' 后面的 token
            const after_brace: &Token = lexer_next_token(lexer, parser.arena);
            if after_brace != null && after_brace.type == TokenType.TOKEN_RIGHT_BRACE {
                // '{' 后面是 '}'（空块），这可能是代码块的开始
                // 恢复 lexer 状态
                lexer.position = saved_position;
                lexer.line = saved_line;
                lexer.column = saved_column;
                
                // 如果 right 是结构体初始化，我们需要将其替换为标识符
                // 因为 '{' 应该是代码块的开始，而不是结构体字面量的一部分
                if right.type == ASTNodeType.AST_STRUCT_INIT {
                    // 获取结构体名称
                    const struct_name: &byte = right.struct_init_struct_name;
                    if struct_name != null {
                        // 创建标识符节点
                        const identifier: &ASTNode = ast_new_node(ASTNodeType.AST_IDENTIFIER, right.line, right.column, parser.arena, parser_get_filename(parser));
                        if identifier != null {
                            identifier.identifier_name = struct_name;
                            right = identifier;
                        }
                    }
                }
                
                // 停止表达式解析，返回完整的比较表达式（不包含 '{'）
                // 调用者（如 if 语句解析）会处理 '{' 作为代码块
                const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
                if node == null {
                    return null;
                }
                
                node.binary_expr_left = left;
                node.binary_expr_op = op;
                node.binary_expr_right = right;
                
                return node;
            }
            
            // 恢复 lexer 状态
            lexer.position = saved_position;
            lexer.line = saved_line;
            lexer.column = saved_column;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析按位异或表达式（左结合）
// xor_expr = and_expr { '^' and_expr }
fn parser_parse_xor_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    var left: &ASTNode = parser_parse_and_expr(parser);
    if left == null {
        return null;
    }
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_CARET) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);
        const right: &ASTNode = parser_parse_and_expr(parser);
        if right == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        left = node;
    }
    return left;
}

// 解析按位或表达式（左结合）
// bitor_expr = xor_expr { '|' xor_expr }
fn parser_parse_bitor_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    var left: &ASTNode = parser_parse_xor_expr(parser);
    if left == null {
        return null;
    }
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_PIPE) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);
        const right: &ASTNode = parser_parse_xor_expr(parser);
        if right == null {
            return null;
        }
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        left = node;
    }
    return left;
}

// 解析逻辑与表达式（左结合）
// and_expr = bitand_expr { '&&' bitand_expr }
fn parser_parse_and_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_bitand_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的逻辑与运算符（左结合）
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_LOGICAL_AND) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_bitand_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析逻辑或表达式（左结合）
// or_expr = bitor_expr { '||' bitor_expr }
fn parser_parse_or_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_bitor_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的逻辑或运算符（左结合）
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_LOGICAL_OR) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_bitor_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_BINARY_EXPR, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析赋值表达式（右结合）
// assign_expr = or_expr [ '=' assign_expr ]
fn parser_parse_assign_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    const left: &ASTNode = parser_parse_or_expr(parser);
    if left == null {
        return null;
    }
    
    // 检查是否有赋值运算符
    if parser.current_token != null && parser_match(parser, TokenType.TOKEN_ASSIGN) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 '='
        
        // 递归解析赋值表达式（右结合）
        const right: &ASTNode = parser_parse_assign_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建赋值节点
        const node: &ASTNode = ast_new_node(ASTNodeType.AST_ASSIGN, line, column, parser.arena, parser_get_filename(parser));
        if node == null {
            return null;
        }
        
        node.assign_dest = left;
        node.assign_src = right;
        
        return node;
    }
    
    // 没有赋值运算符，返回左操作数
    return left;
}

// 解析表达式（完整版本）
// expression = assign_expr
fn parser_parse_expression(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 表达式就是赋值表达式
    return parser_parse_assign_expr(parser);
}

// 解析代码块（完善版本，解析语句列表）
fn parser_parse_block(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 '{'
    if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 创建代码块节点
    const block: &ASTNode = ast_new_node(ASTNodeType.AST_BLOCK, line, column, parser.arena, parser_get_filename(parser));
    if block == null {
        return null;
    }
    
    // 初始化语句列表
    var stmts: & & ASTNode = null;
    var stmt_count: i32 = 0;
    var stmt_capacity: i32 = 0;
    
    // 消费 '{'
    parser_consume(parser);
    
    // 解析语句列表
    while parser.current_token != null && 
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        
        // 如果当前token是右大括号，说明是空块，直接退出循环
        if parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) != 0 {
            break;
        }
        
        // 解析语句
        const stmt: &ASTNode = parser_parse_statement(parser);
        if stmt == null {
            // 解析失败：检查是否是因为遇到了右大括号（空块的情况）
            if parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) != 0 {
                // 空块，正常退出循环
                break;
            }
            // 检查是否是 EOF（TokenType.TOKEN_EOF = 0）
            if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_EOF {
                // 遇到文件末尾，正常退出循环（可能是函数体不完整，但这是语法错误，会在其他地方报告）
                break;
            }
            // 否则是真正的解析错误
            // 注意：Uya 版本简化错误报告，不使用 fprintf
            return null;
        }
        
        // 扩展语句数组（使用 Arena 分配）
        if stmt_count >= stmt_capacity {
            var new_capacity: i32 = 0;
                        if stmt_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = stmt_capacity * 2;
                        }
            const new_stmts: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * new_capacity) as & & ASTNode;
            if new_stmts == null {
                // 注意：Uya 版本简化错误报告
                return null;
            }
            
            // 复制旧语句
            if stmts != null {
                var i: i32 = 0;
                while i < stmt_count {
                    new_stmts[i] = stmts[i];
                    i = i + 1;
                }
            }
            
            stmts = new_stmts;
            stmt_capacity = new_capacity;
        }
        
        stmts[stmt_count] = stmt;
        stmt_count = stmt_count + 1;
    }
    
    // 期望 '}'
    // 注意：如果当前 token 是 'else'，说明可能是 if 语句的 else 分支
    // 但 block 必须以 '}' 结束，所以这里仍然期望 '}'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        // 注意：Uya 版本简化错误报告
        return null;
    }
    
    block.block_stmts = stmts;
    block.block_stmt_count = stmt_count;
    
    return block;
}

// 解析语句
fn parser_parse_statement(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 根据第一个 Token 判断语句类型
    if parser.current_token.type == TokenType.TOKEN_RETURN {
        // 解析 return 语句
        parser_consume(parser);  // 消费 'return'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_RETURN_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 解析返回值表达式（可选，void 函数可以没有返回值）
        if parser_match(parser, TokenType.TOKEN_SEMICOLON) != 0 {
            // 没有返回值（void 函数）
            stmt.return_stmt_expr = null;
            parser_consume(parser);  // 消费 ';'
        } else {
            // 有返回值表达式
            const expr: &ASTNode = parser_parse_expression(parser);
            if expr == null {
                return null;
            }
            stmt.return_stmt_expr = expr;
            
            // 期望 ';'
            if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
                return null;
            }
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_DEFER) != 0 {
        parser_consume(parser);
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_DEFER_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
            stmt.defer_stmt_body = parser_parse_block(parser);
        } else {
            stmt.defer_stmt_body = parser_parse_statement(parser);
        }
        if stmt.defer_stmt_body == null {
            return null;
        }
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_ERRDEFER) != 0 {
        parser_consume(parser);
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_ERRDEFER_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
            stmt.errdefer_stmt_body = parser_parse_block(parser);
        } else {
            stmt.errdefer_stmt_body = parser_parse_statement(parser);
        }
        if stmt.errdefer_stmt_body == null {
            return null;
        }
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_BREAK) != 0 {
        // 解析 break 语句
        parser_consume(parser);  // 消费 'break'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_BREAK_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 期望 ';'
        if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_CONTINUE) != 0 {
        // 解析 continue 语句
        parser_consume(parser);  // 消费 'continue'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_CONTINUE_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 期望 ';'
        if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_IF) != 0 {
        // 解析 if 语句
        parser_consume(parser);  // 消费 'if'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_IF_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 解析条件表达式
        // 设置上下文为条件表达式上下文，以便在解析表达式时正确区分结构体字面量和代码块
        const saved_context: ParserContext = parser.context;
        parser.context = ParserContext.PARSER_CONTEXT_CONDITION;
        const condition: &ASTNode = parser_parse_expression(parser);
        parser.context = saved_context;  // 恢复上下文
        if condition == null {
            return null;
        }
        stmt.if_stmt_condition = condition;
        
        // 解析 then 分支：允许 { block } 或单条语句（如 if (x) return 2;）
        var then_branch: &ASTNode = null;
        if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
            then_branch = parser_parse_block(parser);
        } else {
            const single: &ASTNode = parser_parse_statement(parser);
            if single == null {
                return null;
            }
            const block: &ASTNode = ast_new_node(ASTNodeType.AST_BLOCK, single.line, single.column, parser.arena, parser_get_filename(parser));
            if block == null {
                return null;
            }
            const stmts: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode)) as & & ASTNode;
            if stmts == null {
                return null;
            }
            stmts[0] = single;
            block.block_stmts = stmts;
            block.block_stmt_count = 1;
            then_branch = block;
        }
        if then_branch == null {
            return null;
        }
        stmt.if_stmt_then_branch = then_branch;
        
        // 解析 else 分支（可选）
        // 支持 else if、else { block }、else 单条语句
        if parser_match(parser, TokenType.TOKEN_ELSE) != 0 {
            parser_consume(parser);  // 消费 'else'
            if parser_match(parser, TokenType.TOKEN_IF) != 0 {
                const else_if_stmt: &ASTNode = parser_parse_statement(parser);
                if else_if_stmt == null {
                    return null;
                }
                stmt.if_stmt_else_branch = else_if_stmt;
            } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
                const else_branch: &ASTNode = parser_parse_block(parser);
                if else_branch == null {
                    return null;
                }
                stmt.if_stmt_else_branch = else_branch;
            } else {
                const single: &ASTNode = parser_parse_statement(parser);
                if single == null {
                    return null;
                }
                const block: &ASTNode = ast_new_node(ASTNodeType.AST_BLOCK, single.line, single.column, parser.arena, parser_get_filename(parser));
                if block == null {
                    return null;
                }
                const stmts: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode)) as & & ASTNode;
                if stmts == null {
                    return null;
                }
                stmts[0] = single;
                block.block_stmts = stmts;
                block.block_stmt_count = 1;
                stmt.if_stmt_else_branch = block;
            }
        } else {
            stmt.if_stmt_else_branch = null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_WHILE) != 0 {
        // 解析 while 语句
        parser_consume(parser);  // 消费 'while'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_WHILE_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 解析条件表达式
        // 设置上下文为条件表达式上下文，以便在解析表达式时正确区分结构体字面量和代码块
        const saved_context: ParserContext = parser.context;
        parser.context = ParserContext.PARSER_CONTEXT_CONDITION;
        const condition: &ASTNode = parser_parse_expression(parser);
        parser.context = saved_context;  // 恢复上下文
        if condition == null {
            return null;
        }
        stmt.while_stmt_condition = condition;
        
        // 解析循环体（代码块）
        const body: &ASTNode = parser_parse_block(parser);
        if body == null {
            return null;
        }
        stmt.while_stmt_body = body;
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_FOR) != 0 {
        // 解析 for 语句（数组遍历）
        // 语法：for expr | ID | { statements } 或 for expr | &ID | { statements }
        // 仅解析到 xor_expr，不包含 |，以便 for expr | id | 中的 | 作为分隔符
        parser_consume(parser);  // 消费 'for'
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_FOR_STMT, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        // 解析数组表达式（不包含 |，避免与 for 的 | 分隔符冲突）
        const array_expr: &ASTNode = parser_parse_xor_expr(parser);
        if array_expr == null {
            return null;
        }
        stmt.for_stmt_array = array_expr;
        
        // 期望 '|'
        if parser_expect(parser, TokenType.TOKEN_PIPE) == null {
            return null;
        }
        
        // 检查是否为引用迭代（&ID）还是值迭代（ID）
        var is_ref: i32 = 0;
        if parser_match(parser, TokenType.TOKEN_AMPERSAND) != 0 {
            // 引用迭代：for expr | &ID | { ... }
            parser_consume(parser);  // 消费 '&'
            is_ref = 1;
        }
        
        // 期望循环变量名称
        const for_var_val: &byte = parser.current_token.value;
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const var_name: &byte = arena_strdup(parser.arena, for_var_val);
        if var_name == null {
            return null;
        }
        stmt.for_stmt_var_name = var_name;
        parser_consume(parser);  // 消费变量名称
        
        // 期望 '|'
        if parser_expect(parser, TokenType.TOKEN_PIPE) == null {
            return null;
        }
        
        stmt.for_stmt_is_ref = is_ref;
        
        // 解析循环体（代码块）
        const body: &ASTNode = parser_parse_block(parser);
        if body == null {
            return null;
        }
        stmt.for_stmt_body = body;
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_CONST) != 0 || parser_match(parser, TokenType.TOKEN_VAR) != 0 {
        // 解析变量声明
        var is_const: i32 = 0;
        if parser_match(parser, TokenType.TOKEN_CONST) != 0 {
            is_const = 1;
        } else {
            is_const = 0;
        }
        parser_consume(parser);  // 消费 'const' 或 'var'
        
        // 解构声明：const (x, y) = expr; 或 var (x, _) = expr;
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LEFT_PAREN {
            parser_consume(parser);  // 消费 '('
            
            var names: & & byte = arena_alloc(parser.arena, @sizeof(&byte) * 16) as & & byte;
            if names == null {
                return null;
            }
            var cap: i32 = 16;
            var count: i32 = 0;
            
            while parser.current_token != null && parser.current_token.type != TokenType.TOKEN_RIGHT_PAREN {
                if count > 0 {
                    if parser_expect(parser, TokenType.TOKEN_COMMA) == null {
                        return null;
                    }
                }
                const name_val: &byte = parser.current_token.value;
                if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                    return null;
                }
                const name: &byte = arena_strdup(parser.arena, name_val);
                if name == null {
                    return null;
                }
                parser_consume(parser);  // 消费标识符
                if count >= cap {
                    const new_cap: i32 = cap * 2;
                    const new_names: & & byte = arena_alloc(parser.arena, @sizeof(&byte) * new_cap) as & & byte;
                    if new_names == null {
                        return null;
                    }
                    var i: i32 = 0;
                    while i < count {
                        new_names[i] = names[i];
                        i = i + 1;
                    }
                    names = new_names;
                    cap = new_cap;
                }
                names[count] = name;
                count = count + 1;
            }
            
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            if parser_expect(parser, TokenType.TOKEN_ASSIGN) == null {
                return null;
            }
            
            const saved_context: ParserContext = parser.context;
            parser.context = ParserContext.PARSER_CONTEXT_VAR_INIT;
            const init: &ASTNode = parser_parse_expression(parser);
            parser.context = saved_context;
            if init == null {
                return null;
            }
            if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
                return null;
            }
            
            const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_DESTRUCTURE_DECL, line, column, parser.arena, parser_get_filename(parser));
            if stmt == null {
                return null;
            }
            stmt.destructure_decl_names = names;
            stmt.destructure_decl_name_count = count;
            stmt.destructure_decl_is_const = is_const;
            stmt.destructure_decl_init = init;
            return stmt;
        }
        
        // 期望变量名称（立即复制到 arena，避免 token 缓冲区被后续 lexer 调用覆盖）
        const name_val: &byte = parser.current_token.value;
        const var_name: &byte = arena_strdup(parser.arena, name_val);
        if var_name == null {
            return null;
        }
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        parser_consume(parser);  // 消费变量名称
        
        const stmt: &ASTNode = ast_new_node(ASTNodeType.AST_VAR_DECL, line, column, parser.arena, parser_get_filename(parser));
        if stmt == null {
            return null;
        }
        
        stmt.var_decl_name = var_name;
        stmt.var_decl_is_const = is_const;
        
        // 期望 ':'
        if parser_expect(parser, TokenType.TOKEN_COLON) == null {
            return null;
        }
        
        // 解析类型
        const type: &ASTNode = parser_parse_type(parser);
        if type == null {
            return null;
        }
        stmt.var_decl_type = type;
        
        // 期望 '='
        if parser_expect(parser, TokenType.TOKEN_ASSIGN) == null {
            // 变量未初始化：注意：Uya 版本简化错误报告
            return null;
        }
        
        // 解析初始值表达式
        // 设置上下文为变量初始化上下文，以便在解析表达式时正确区分结构体字面量和代码块
        const saved_context: ParserContext = parser.context;
        parser.context = ParserContext.PARSER_CONTEXT_VAR_INIT;
        const init: &ASTNode = parser_parse_expression(parser);
        parser.context = saved_context;  // 恢复上下文
        if init == null {
            return null;
        }
        stmt.var_decl_init = init;
        
        // 期望 ';'
        if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    // 注意：根据规范，enum 和 struct 只能在顶层定义，不能在函数内部或其他局部作用域内定义
    // 因此这里不处理 TokenType.TOKEN_STRUCT 和 TokenType.TOKEN_ENUM
    // 函数内部也不允许定义函数（嵌套函数不支持）
    
    if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
        // 解析代码块语句
        return parser_parse_block(parser);
    }
    
    // 解析表达式语句（表达式后加分号）
    // 注意：ASTNodeType.AST_EXPR_STMT 节点在 union 中没有对应的数据结构
    // 根据 ast.c 的注释，表达式语句的数据存储在表达式的节点中
    // 所以这里直接返回表达式节点（表达式节点本身可以作为语句）
    
    // 如果当前token是右大括号，说明是空块，返回NULL（由调用者处理）
    if parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) != 0 {
        return null;
    }
    
    const expr: &ASTNode = parser_parse_expression(parser);
    if expr == null {
        // 如果当前token是右大括号，说明是空块，返回NULL（由调用者处理）
        if parser.current_token != null && parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) != 0 {
            return null;
        }
        return null;
    }
    
    // 期望 ';'
    if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
        return null;
    }
    
    // 直接返回表达式节点（表达式节点可以作为语句）
    return expr;
}

// 解析结构体声明：struct ID { field_list }
// field_list = field { ',' field }
// field = ID ':' type
fn parser_parse_struct(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'struct'
    if parser_match(parser, TokenType.TOKEN_STRUCT) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'struct'
    parser_consume(parser);
    
    // 期望结构体名称
    const struct_name_val: &byte = parser.current_token.value;
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    const struct_name: &byte = arena_strdup(parser.arena, struct_name_val);
    if struct_name == null {
        return null;
    }
    
    // 消费结构体名称
    parser_consume(parser);
    
    // 创建结构体声明节点
    const struct_decl: &ASTNode = ast_new_node(ASTNodeType.AST_STRUCT_DECL, line, column, parser.arena, parser_get_filename(parser));
    if struct_decl == null {
        return null;
    }
    
    struct_decl.struct_decl_name = struct_name;
    struct_decl.struct_decl_fields = null;
    struct_decl.struct_decl_field_count = 0;
    
    // 期望 '{'
    if parser_expect(parser, TokenType.TOKEN_LEFT_BRACE) == null {
        return null;
    }
    
    // 解析字段列表
    // 字段列表：field { ',' field }
    // field = ID ':' type
    var fields: & & ASTNode = null;
    var field_count: i32 = 0;
    var field_capacity: i32 = 0;
    
    while parser.current_token != null && 
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        
        // 解析字段名称
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const field_line: i32 = parser.current_token.line;
        const field_column: i32 = parser.current_token.column;
        const field_name: &byte = arena_strdup(parser.arena, parser.current_token.value);
        if field_name == null {
            return null;
        }
        
        parser_consume(parser);
        
        // 期望 ':'
        if parser_expect(parser, TokenType.TOKEN_COLON) == null {
            return null;
        }
        
        // 解析字段类型
        const field_type: &ASTNode = parser_parse_type(parser);
        if field_type == null {
            return null;
        }
        
        // 创建字段节点（使用 ASTNodeType.AST_VAR_DECL，is_const = 0）
        const field: &ASTNode = ast_new_node(ASTNodeType.AST_VAR_DECL, field_line, field_column, parser.arena, parser_get_filename(parser));
        if field == null {
            return null;
        }
        
        field.var_decl_name = field_name;
        field.var_decl_type = field_type;
        field.var_decl_init = null;
        field.var_decl_is_const = 0;
        
        // 扩展字段数组（使用 Arena 分配）
        if field_count >= field_capacity {
            var new_capacity: i32 = 0;
                        if field_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = field_capacity * 2;
                        }
            const new_fields: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * new_capacity) as & & ASTNode;
            if new_fields == null {
                // 注意：Uya 版本简化错误报告
                return null;
            }
            
            // 复制旧字段
            if fields != null {
                var i: i32 = 0;
                while i < field_count {
                    new_fields[i] = fields[i];
                    i = i + 1;
                }
            }
            
            fields = new_fields;
            field_capacity = new_capacity;
        }
        
        fields[field_count] = field;
        field_count = field_count + 1;
        
        // 检查是否有逗号（可选，最后一个字段后不需要逗号）
        if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
            parser_consume(parser);
        }
    }
    
    // 期望 '}'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    
    struct_decl.struct_decl_fields = fields;
    struct_decl.struct_decl_field_count = field_count;
    
    return struct_decl;
}

// 解析枚举声明：enum ID '{' variant_list '}'
// variant_list = variant { ',' variant }
// variant = ID [ '=' NUM ]
fn parser_parse_enum(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'enum'
    if parser_match(parser, TokenType.TOKEN_ENUM) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'enum'
    parser_consume(parser);
    
    // 期望枚举名称
    const enum_name_val: &byte = parser.current_token.value;
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const enum_name: &byte = arena_strdup(parser.arena, enum_name_val);
    if enum_name == null {
        return null;
    }
    
    // 消费枚举名称
    parser_consume(parser);
    
    // 创建枚举声明节点
    const enum_decl: &ASTNode = ast_new_node(ASTNodeType.AST_ENUM_DECL, line, column, parser.arena, parser_get_filename(parser));
    if enum_decl == null {
        return null;
    }
    
    enum_decl.enum_decl_name = enum_name;
    enum_decl.enum_decl_variants = null;
    enum_decl.enum_decl_variant_count = 0;
    
    // 期望 '{'
    if parser_expect(parser, TokenType.TOKEN_LEFT_BRACE) == null {
        return null;
    }
    
    // 解析变体列表
    // 变体列表：variant { ',' variant }
    // variant = ID
    var variants: &EnumVariant = null;
    var variant_count: i32 = 0;
    var variant_capacity: i32 = 0;
    
    while parser.current_token != null && 
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        
        // 解析变体名称
        const variant_name_val: &byte = parser.current_token.value;
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const variant_name: &byte = arena_strdup(parser.arena, variant_name_val);
        if variant_name == null {
            return null;
        }
        
        parser_consume(parser);
        
        // 扩展变体数组（使用 Arena 分配）
        if variant_count >= variant_capacity {
            var new_capacity: i32 = 0;
                        if variant_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = variant_capacity * 2;
                        }
            const new_variants: &EnumVariant = arena_alloc(parser.arena, @sizeof(EnumVariant) * new_capacity) as &EnumVariant;
            if new_variants == null {
                return null;
            }
            
            // 复制旧变体
            if variants != null {
                var i: i32 = 0;
                while i < variant_count {
                    new_variants[i] = variants[i];
                    i = i + 1;
                }
            }
            
            variants = new_variants;
            variant_capacity = new_capacity;
        }
        
        // 解析可选的显式值 (= NUM)
        var variant_value: &byte = null;
        if parser_match(parser, TokenType.TOKEN_ASSIGN) != 0 {
            parser_consume(parser);  // 消费 '='
            
            // 期望数字字面量
            if parser_match(parser, TokenType.TOKEN_NUMBER) == 0 {
                return null;
            }
            
            // 复制数字值字符串到 Arena
            variant_value = arena_strdup(parser.arena, parser.current_token.value);
            if variant_value == null {
                return null;
            }
            
            parser_consume(parser);  // 消费数字值
        }
        
        // 添加变体（确保数组索引有效）
        if variant_count < variant_capacity {
            variants[variant_count].name = variant_name;
            variants[variant_count].value = variant_value;  // null 表示没有显式赋值
            variant_count = variant_count + 1;
        } else {
            // 注意：Uya 版本简化错误报告
            return null;
        }
        
        // 检查是否有逗号（可选，最后一个变体后不需要逗号）
        if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
            parser_consume(parser);
        }
    }
    
    // 期望 '}'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    
    enum_decl.enum_decl_variants = variants;
    enum_decl.enum_decl_variant_count = variant_count;
    
    return enum_decl;
}

// 解析预定义错误声明：error ID ';'
fn parser_parse_error_decl(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    if parser_match(parser, TokenType.TOKEN_ERROR) == 0 {
        return null;
    }
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    parser_consume(parser);
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    const name: &byte = arena_strdup(parser.arena, parser.current_token.value);
    if name == null {
        return null;
    }
    parser_consume(parser);
    if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
        return null;
    }
    const node: &ASTNode = ast_new_node(ASTNodeType.AST_ERROR_DECL, line, column, parser.arena, parser_get_filename(parser));
    if node == null {
        return null;
    }
    node.error_decl_name = name;
    return node;
}

// 解析函数声明：fn ID '(' [ param_list ] ')' type '{' statements '}'
// param_list = param { ',' param }
// param = ID ':' type
fn parser_parse_function(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'fn'
    if parser_match(parser, TokenType.TOKEN_FN) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'fn'
    parser_consume(parser);
    
    // 期望函数名称
    const fn_name_val: &byte = parser.current_token.value;
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const fn_name: &byte = arena_strdup(parser.arena, fn_name_val);
    if fn_name == null {
        return null;
    }
    
    // 消费函数名称
    parser_consume(parser);
    
    // 创建函数声明节点
    const fn_decl: &ASTNode = ast_new_node(ASTNodeType.AST_FN_DECL, line, column, parser.arena, parser_get_filename(parser));
    if fn_decl == null {
        return null;
    }
    
    fn_decl.fn_decl_name = fn_name;
    fn_decl.fn_decl_params = null;
    fn_decl.fn_decl_param_count = 0;
    fn_decl.fn_decl_return_type = null;
    fn_decl.fn_decl_body = null;
    
    // 期望 '('
    if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
        return null;
    }
    
    // 解析参数列表（可选，支持可变参数 ...）
    var params: & & ASTNode = null;
    var param_count: i32 = 0;
    var param_capacity: i32 = 0;
    var is_varargs: i32 = 0;
    
    if parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
        // 有参数
        while parser.current_token != null && 
              parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 && 
              parser_match(parser, TokenType.TOKEN_EOF) == 0 {
            
            // 检查是否为可变参数标记（...）
            if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                parser_consume(parser);
                is_varargs = 1;
                break;
            }
            
            // 解析参数名称
            const param_name_val: &byte = parser.current_token.value;
            const param_line: i32 = parser.current_token.line;
            const param_column: i32 = parser.current_token.column;
            if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                return null;
            }
            
            const param_name: &byte = arena_strdup(parser.arena, param_name_val);
            if param_name == null {
                return null;
            }
            
            parser_consume(parser);
            
            // 期望 ':'
            if parser_expect(parser, TokenType.TOKEN_COLON) == null {
                return null;
            }
            
            // 解析参数类型
            const param_type: &ASTNode = parser_parse_type(parser);
            if param_type == null {
                return null;
            }
            
            // 创建参数节点（使用 ASTNodeType.AST_VAR_DECL，is_const = 0）
            const param: &ASTNode = ast_new_node(ASTNodeType.AST_VAR_DECL, param_line, param_column, parser.arena, parser_get_filename(parser));
            if param == null {
                return null;
            }
            
            param.var_decl_name = param_name;
            param.var_decl_type = param_type;
            param.var_decl_init = null;
            param.var_decl_is_const = 0;
            
            // 扩展参数数组（使用 Arena 分配）
            if param_count >= param_capacity {
                var new_capacity: i32 = 0;
                        if param_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = param_capacity * 2;
                        }
                const new_params: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * new_capacity) as & & ASTNode;
                if new_params == null {
                    // 注意：Uya 版本简化错误报告
                    return null;
                }
                
                // 复制旧参数
                if params != null {
                    var i: i32 = 0;
                    while i < param_count {
                        new_params[i] = params[i];
                        i = i + 1;
                    }
                }
                
                params = new_params;
                param_capacity = new_capacity;
            }
            
            params[param_count] = param;
            param_count = param_count + 1;
            
            // 检查是否有逗号或逗号后 ...
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            } else if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                // 逗号后紧跟 ...，下次循环处理
            }
        }
    }
    
    // 期望 ')'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
        return null;
    }
    
    // 解析返回类型
    const return_type: &ASTNode = parser_parse_type(parser);
    if return_type == null {
        return null;
    }
    
    // 解析函数体（代码块）
    const body: &ASTNode = parser_parse_block(parser);
    if body == null {
        // 注意：Uya 版本简化错误报告
        return null;
    }
    
    fn_decl.fn_decl_params = params;
    fn_decl.fn_decl_param_count = param_count;
    fn_decl.fn_decl_return_type = return_type;
    fn_decl.fn_decl_body = body;
    fn_decl.fn_decl_is_varargs = is_varargs;
    
    return fn_decl;
}

// 解析 extern 函数声明
// extern_decl = 'extern' 'fn' ID '(' [ param_list ] ')' type ';'
fn parser_parse_extern_function(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'extern'
    if parser_match(parser, TokenType.TOKEN_EXTERN) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'extern'
    parser_consume(parser);
    
    // 期望 'fn'
    if parser_expect(parser, TokenType.TOKEN_FN) == null {
        return null;
    }
    
    // 期望函数名称
    const extern_fn_name_val: &byte = parser.current_token.value;
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const fn_name: &byte = arena_strdup(parser.arena, extern_fn_name_val);
    if fn_name == null {
        return null;
    }
    
    // 消费函数名称
    parser_consume(parser);
    
    // 创建函数声明节点
    const fn_decl: &ASTNode = ast_new_node(ASTNodeType.AST_FN_DECL, line, column, parser.arena, parser_get_filename(parser));
    if fn_decl == null {
        return null;
    }
    
    fn_decl.fn_decl_name = fn_name;
    fn_decl.fn_decl_params = null;
    fn_decl.fn_decl_param_count = 0;
    fn_decl.fn_decl_return_type = null;
    fn_decl.fn_decl_body = null;  // extern 函数没有函数体
    fn_decl.fn_decl_is_varargs = 0;  // 默认不是可变参数函数
    
    // 期望 '('
    if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
        return null;
    }
    
    // 解析参数列表（可选，支持可变参数）
    var params: & & ASTNode = null;
    var param_count: i32 = 0;
    var param_capacity: i32 = 0;
    var is_varargs: i32 = 0;
    
    if parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
        // 有参数
        while parser.current_token != null && 
              parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 && 
              parser_match(parser, TokenType.TOKEN_EOF) == 0 {
            
            // 检查是否为可变参数标记（...）
            if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                // 可变参数标记必须是参数列表的最后一个元素
                parser_consume(parser);  // 消费 '...'
                is_varargs = 1;
                break;  // 遇到 ... 后退出循环
            }
            
            // 解析参数名称
            const param_name_val: &byte = parser.current_token.value;
            const param_line: i32 = parser.current_token.line;
            const param_column: i32 = parser.current_token.column;
            if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                return null;
            }
            
            const param_name: &byte = arena_strdup(parser.arena, param_name_val);
            if param_name == null {
                return null;
            }
            
            parser_consume(parser);
            
            // 期望 ':'
            if parser_expect(parser, TokenType.TOKEN_COLON) == null {
                return null;
            }
            
            // 解析参数类型
            const param_type: &ASTNode = parser_parse_type(parser);
            if param_type == null {
                return null;
            }
            
            // 创建参数节点（使用 ASTNodeType.AST_VAR_DECL，is_const = 0）
            const param: &ASTNode = ast_new_node(ASTNodeType.AST_VAR_DECL, param_line, param_column, parser.arena, parser_get_filename(parser));
            if param == null {
                return null;
            }
            
            param.var_decl_name = param_name;
            param.var_decl_type = param_type;
            param.var_decl_init = null;
            param.var_decl_is_const = 0;
            
            // 扩展参数数组（使用 Arena 分配）
            if param_count >= param_capacity {
                var new_capacity: i32 = 0;
                        if param_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = param_capacity * 2;
                        }
                const new_params: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * new_capacity) as & & ASTNode;
                if new_params == null {
                    return null;
                }
                
                // 复制旧参数
                if params != null {
                    var i: i32 = 0;
                    while i < param_count {
                        new_params[i] = params[i];
                        i = i + 1;
                    }
                }
                
                params = new_params;
                param_capacity = new_capacity;
            }
            
            params[param_count] = param;
            param_count = param_count + 1;
            
            // 检查是否有逗号
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            } else if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                // 逗号后紧跟 ...，也是合法的
                // 不消费逗号，让下次循环处理 ...
            }
        }
    }
    
    // 期望 ')'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
        return null;
    }
    
    // 解析返回类型
    const return_type: &ASTNode = parser_parse_type(parser);
    if return_type == null {
        return null;
    }
    
    // extern 函数以分号结尾，没有函数体
    if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
        return null;
    }
    
    fn_decl.fn_decl_params = params;
    fn_decl.fn_decl_param_count = param_count;
    fn_decl.fn_decl_return_type = return_type;
    fn_decl.fn_decl_body = null;  // extern 函数没有函数体
    fn_decl.fn_decl_is_varargs = is_varargs;
    
    return fn_decl;
}

// 解析声明（函数、结构体或变量声明）
fn parser_parse_declaration(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 根据第一个 Token 判断声明类型
    if parser_match(parser, TokenType.TOKEN_EXTERN) != 0 {
        // extern 函数声明
        return parser_parse_extern_function(parser);
    } else if parser_match(parser, TokenType.TOKEN_FN) != 0 {
        return parser_parse_function(parser);
    } else if parser_match(parser, TokenType.TOKEN_ERROR) != 0 {
        return parser_parse_error_decl(parser);
    } else if parser_match(parser, TokenType.TOKEN_ENUM) != 0 {
        return parser_parse_enum(parser);
    } else if parser_match(parser, TokenType.TOKEN_STRUCT) != 0 {
        return parser_parse_struct(parser);
    } else if parser_match(parser, TokenType.TOKEN_CONST) != 0 || parser_match(parser, TokenType.TOKEN_VAR) != 0 {
        // 变量声明
        return parser_parse_statement(parser);
    } else {
        // 无法识别的声明类型
        return null;
    }
}

// 解析程序（顶层声明列表）
fn parser_parse(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 创建程序节点
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    const program: &ASTNode = ast_new_node(ASTNodeType.AST_PROGRAM, line, column, parser.arena, parser_get_filename(parser));
    if program == null {
        return null;
    }
    
    // 初始化声明列表
    program.program_decls = null;
    program.program_decl_count = 0;
    
    // 解析顶层声明列表
    var decls: & & ASTNode = null;
    var decl_count: i32 = 0;
    var decl_capacity: i32 = 0;
    const stderr: *void = get_stderr();
    
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        const decl: &ASTNode = parser_parse_declaration(parser);
        if decl == null {
            // 解析失败：检查是否因为到达文件末尾（EOF）还是真正的错误
            // 如果当前 token 不是 EOF，说明遇到了真正的解析错误
            if parser.current_token != null && parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                // 真正的解析错误：输出错误信息并返回 null（与 C 版一致）
                var filename: &byte = "(unknown)" as *byte;
                if parser.lexer != null && parser.lexer.filename != null {
                    filename = parser.lexer.filename;
                }
                fprintf(stderr, "错误: 语法分析失败 (%s:%d:%d): 意外的 token" as *byte, filename, parser.current_token.line, parser.current_token.column);
                if parser.current_token.value != null {
                    fprintf(stderr, " '%s'" as *byte, parser.current_token.value);
                }
                fprintf(stderr, "\n" as *byte);
                return null;
            }
            if parser.current_token == null {
                // current_token 为 null 时也报告，便于排查自举失败
                var filename: &byte = "(unknown)" as *byte;
                if parser.lexer != null && parser.lexer.filename != null {
                    filename = parser.lexer.filename;
                }
                fprintf(stderr, "错误: 语法分析失败 (%s): 当前 token 为 null\n" as *byte, filename);
                return null;
            }
            // 到达文件末尾，正常退出循环
            break;
        }
        
        // 扩展声明数组（使用 Arena 分配）
        if decl_count >= decl_capacity {
            var new_capacity: i32 = 0;
                        if decl_capacity == 0 {
                            new_capacity = 4;
                        } else {
                            new_capacity = decl_capacity * 2;
                        }
            const new_decls: & & ASTNode = arena_alloc(parser.arena, @sizeof(&ASTNode) * new_capacity) as & & ASTNode;
            if new_decls == null {
                return null;
            }
            
            // 复制旧声明
            if decls != null {
                var i: i32 = 0;
                while i < decl_count {
                    new_decls[i] = decls[i];
                    i = i + 1;
                }
            }
            
            decls = new_decls;
            decl_capacity = new_capacity;
        }
        
        decls[decl_count] = decl;
        decl_count = decl_count + 1;
    }
    
    program.program_decls = decls;
    program.program_decl_count = decl_count;
    
    return program;
}

// parser_parse_program 是 parser_parse 的别名（为了兼容性）
fn parser_parse_program(parser: &Parser) &ASTNode {
    return parser_parse(parser);
}

