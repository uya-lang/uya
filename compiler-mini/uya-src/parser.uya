// parser.uya - 语法分析器模块
// 将 Token 序列转换为抽象语法树（AST）
// 
// 注意：需要先包含 arena.uya、lexer.uya、ast.uya 和 str_utils.uya
// 由于 Uya Mini 不支持模块系统，这里假设相关类型已经定义

// ===== 数组容量常量定义 =====
// 用于解析过程中的临时数组（替代动态指针数组）
const PARSER_MAX_STMTS: i32 = 512;          // 代码块最大语句数量
const PARSER_MAX_FIELDS: i32 = 64;           // 结构体最大字段数量
const PARSER_MAX_PARAMS: i32 = 32;           // 函数最大参数数量
const PARSER_MAX_DECLS: i32 = 256;           // 程序最大声明数量
const PARSER_MAX_CALL_ARGS: i32 = 32;        // 函数调用最大参数数量
const PARSER_MAX_STRUCT_INIT_FIELDS: i32 = 64; // 结构体初始化最大字段数量
const PARSER_MAX_ARRAY_ELEMENTS: i32 = 256;   // 数组字面量最大元素数量

// ===== 外部函数声明 =====
// 注意：C 标准库函数（strlen, strcmp, fprintf, memcpy, atoi 等）在 extern_decls.uya 中声明
// 编译时需要包含 extern_decls.uya 文件

// Arena 函数（来自 arena.uya）
// 注意：假设 Arena 类型已定义
extern fn arena_alloc(arena: &Arena, size: i32) &void;

// AST 函数（来自 ast.uya）
// 注意：假设 ASTNode, ASTNodeType 类型已定义
extern fn ast_new_node(type: ASTNodeType, line: i32, column: i32, arena: &Arena, filename: &byte) &ASTNode;

// Lexer 函数（来自 lexer.uya）
// 注意：假设 Lexer, Token, TokenType 类型已定义
extern fn lexer_next_token(lexer: &Lexer, arena: &Arena) &Token;

// 字符串辅助函数（来自 lexer.uya）
// 注意：这些函数在 lexer.uya 中定义，但这里可能需要使用
extern fn arena_strdup_from_literal(arena: &Arena, str: *byte) &byte;
extern fn arena_strdup(arena: &Arena, start: &byte, str_len: i32) &byte;

// 标准错误输出（stderr）
// 注意：在 C 中，stderr 是一个 FILE* 指针，在 Uya Mini 中使用 *void 表示
// 通常 stderr 的值是 2（文件描述符），但作为 FILE* 指针，这里使用 extern 声明
// 实际上，fprintf 的第一个参数是 *void，可以直接传递数值
// 在实现时，如果需要，可以使用 extern 声明，或者直接使用数值 2
// 为了简化，这里不声明 stderr，在代码中直接使用数值常量（通过注释说明）

// ===== Parser 结构体 =====

// 语法分析器结构体
// 使用 Lexer 读取 Token，构建 AST
// 注意：假设 Lexer, Token, Arena 类型已定义
struct Parser {
    lexer: &Lexer,// 词法分析器指针（由调用者提供，不分配）
    current_token: &Token,// 当前 Token（从 Arena 分配）
    arena: &Arena// Arena 分配器（用于分配 Token 和 AST 节点）
}

// ===== 基础函数 =====

// 初始化 Parser
// 参数：parser - Parser 结构体指针（由调用者提供），lexer - Lexer 指针，arena - Arena 分配器
// 返回：成功返回 0，失败返回 -1
// 注意：Parser 结构体由调用者在栈上或静态分配，此函数只负责初始化
fn parser_init(parser: &Parser, lexer: &Lexer, arena: &Arena) i32 {
    if parser == null || lexer == null || arena == null {
        return -1;
    }
    
    parser.lexer = lexer;
    parser.arena = arena;
    
    // 获取第一个 Token
    parser.current_token = lexer_next_token(lexer, arena);
    
    return 0;
}

// 辅助函数：检查当前 Token 类型是否匹配
// 参数：parser - Parser 指针，type - Token 类型
// 返回：匹配返回 1，不匹配返回 0
fn parser_match(parser: &Parser, type: TokenType) i32 {
    if parser == null || parser.current_token == null {
        return 0;
    }
    if parser.current_token.type == type {
        return 1;
    }
    return 0;
}

// 辅助函数：消费当前 Token 并获取下一个
// 参数：parser - Parser 指针
// 返回：当前 Token 指针，失败返回 null
fn parser_consume(parser: &Parser) &Token {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const current: &Token = parser.current_token;
    parser.current_token = lexer_next_token(parser.lexer, parser.arena);
    return current;
}

// 辅助函数：期望特定类型的 Token
// 参数：parser - Parser 指针，type - Token 类型
// 返回：匹配的 Token 指针，不匹配返回 null
fn parser_expect(parser: &Parser, type: TokenType) &Token {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    if parser.current_token.type != type {
        // 错误：期望的类型不匹配
        return null;
    }
    
    return parser_consume(parser);
}

// 辅助函数：检查当前 token（'{'）后面是否是结构体字段初始化列表的开始
// 结构体字段初始化列表格式：identifier: expr 或 }
// 注意：调用此函数时，parser.current_token 应该是 '{'
// 参数：parser - Parser 指针
// 返回：是结构体初始化返回 1，否则返回 0
fn parser_peek_is_struct_init(parser: &Parser) i32 {
    if parser == null || parser.lexer == null || parser.current_token == null {
        return 0;
    }
    
    if parser.current_token.type != TokenType.TOKEN_LEFT_BRACE {
        return 0;
    }
    
    // 保存 lexer 状态（当前 lexer 的 position 已经在 '{' 之后）
    const lexer: &Lexer = parser.lexer;
    const saved_position: i32 = lexer.position;
    const saved_line: i32 = lexer.line;
    const saved_column: i32 = lexer.column;
    
    // 获取 '{' 后面的 token（lexer_next_token 会跳过空白字符和注释）
    const after_brace: &Token = lexer_next_token(lexer, parser.arena);
    
    if after_brace == null {
        // 恢复状态
        lexer.position = saved_position;
        lexer.line = saved_line;
        lexer.column = saved_column;
        return 0;
    }
    
    const token_type: TokenType = after_brace.type;
    var is_struct_init: i32 = 0;
    
    // 只检查 identifier: 模式，不检查空的 {}（因为空代码块 {} 和空结构体字面量 {} 无法区分）
    if token_type == TokenType.TOKEN_IDENTIFIER {
        // 检查标识符后面是否有 ':'
        const saved_position2: i32 = lexer.position;
        const saved_line2: i32 = lexer.line;
        const saved_column2: i32 = lexer.column;
        
        const after_identifier: &Token = lexer_next_token(lexer, parser.arena);
        if after_identifier != null && after_identifier.type == TokenType.TOKEN_COLON {
            is_struct_init = 1;
        }
        
        // 恢复状态到标识符之前
        lexer.position = saved_position2;
        lexer.line = saved_line2;
        lexer.column = saved_column2;
    }
    
    // 恢复 lexer 状态到 '{' 之后
    lexer.position = saved_position;
    lexer.line = saved_line;
    lexer.column = saved_column;
    
    return is_struct_init;
}

// 从 Arena 复制字符串
// 参数：arena - Arena 分配器，src - 源字符串（&byte 类型，存储在 Arena 中）
// 返回：复制后的字符串指针（存储在 Arena 中），失败返回 null
// 注意：此函数用于复制 token.value，使用 strlen 计算长度，然后使用 arena_strdup
fn arena_strdup_for_parser(arena: &Arena, src: &byte) &byte {
    if arena == null || src == null {
        return null;
    }
    
    // 计算字符串长度
    const str_len: i32 = strlen(src as *byte);
    
    // 使用 arena_strdup 复制字符串
    return arena_strdup(arena, src, str_len);
}

// ===== 类型解析函数 =====

// 解析类型（支持命名类型、指针类型和数组类型）
// type = named_type | pointer_type | array_type
// named_type = ID
// pointer_type = '&' type | '*' type
// array_type = '[' type ':' expr ']'
// 参数：parser - Parser 指针
// 返回：类型节点，失败返回 null
// 注意：此函数递归调用 parser_parse_type 和 parser_parse_expression
fn parser_parse_type(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 检查是否是指针类型（&Type 或 *Type）
    if parser.current_token.type == TokenType.TOKEN_AMPERSAND {
        // 普通指针类型 &Type
        parser_consume(parser);  // 消费 '&'
        
        // 递归解析指向的类型
        const pointed_type: &ASTNode = parser_parse_type(parser);
        if pointed_type == null {
            return null;
        }
        
        // 创建指针类型节点
        const pointer_type: &ASTNode = ast_new_node(AST_TYPE_POINTER, line, column, parser.arena, parser.lexer.filename);
        if pointer_type == null {
            return null;
        }
        
        pointer_type.type_pointer_pointed_type = pointed_type;
        pointer_type.type_pointer_is_ffi_pointer = 0;  // 普通指针
        
        return pointer_type;
    } else if parser.current_token.type == TokenType.TOKEN_ASTERISK {
        // FFI 指针类型 *Type（仅用于 extern 函数）
        parser_consume(parser);  // 消费 '*'
        
        // 递归解析指向的类型
        const pointed_type: &ASTNode = parser_parse_type(parser);
        if pointed_type == null {
            return null;
        }
        
        // 创建 FFI 指针类型节点
        const pointer_type: &ASTNode = ast_new_node(AST_TYPE_POINTER, line, column, parser.arena, parser.lexer.filename);
        if pointer_type == null {
            return null;
        }
        
        pointer_type.type_pointer_pointed_type = pointed_type;
        pointer_type.type_pointer_is_ffi_pointer = 1;  // FFI 指针
        
        return pointer_type;
    } else if parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
        // 数组类型 [Type: Size]
        parser_consume(parser);  // 消费 '['
        
        // 解析元素类型
        const element_type: &ASTNode = parser_parse_type(parser);
        if element_type == null {
            return null;
        }
        
        // 期望 ':'
        if parser_expect(parser, TokenType.TOKEN_COLON) == null {
            return null;
        }
        
        // 解析数组大小表达式（必须是编译期常量，但解析阶段先解析为表达式）
        // 注意：这里解析为表达式节点，类型检查阶段会验证是否为编译期常量
        const size_expr: &ASTNode = parser_parse_expression(parser);
        if size_expr == null {
            return null;
        }
        
        // 期望 ']'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
            return null;
        }
        
        // 创建数组类型节点
        const array_type: &ASTNode = ast_new_node(AST_TYPE_ARRAY, line, column, parser.arena, parser.lexer.filename);
        if array_type == null {
            return null;
        }
        
        array_type.type_array_element_type = element_type;
        array_type.type_array_size_expr = size_expr;
        
        return array_type;
    } else if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
        // 命名类型（i32, bool, void, 或结构体名称）
        const type_node: &ASTNode = ast_new_node(AST_TYPE_NAMED, line, column, parser.arena, parser.lexer.filename);
        if type_node == null {
            return null;
        }
        
        // 复制类型名称到 Arena
        const type_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if type_name == null {
            return null;
        }
        
        type_node.type_named_name = type_name;
        
        // 消费类型标识符
        parser_consume(parser);
        
        return type_node;
    }
    
    // 无法识别的类型语法
    return null;
}

// ===== 代码块解析函数 =====

// 解析代码块（完善版本，解析语句列表）
// 参数：parser - Parser 指针
// 返回：代码块节点（AST_BLOCK），失败返回 null
// 注意：此函数调用 parser_parse_statement（在后面定义）
fn parser_parse_block(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 '{'
    if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 创建代码块节点
    const block: &ASTNode = ast_new_node(AST_BLOCK, line, column, parser.arena, parser.lexer.filename);
    if block == null {
        return null;
    }
    
    // 初始化语句列表（使用固定大小数组）
    var stmts: [&ASTNode: PARSER_MAX_STMTS] = [];
    var stmt_count: i32 = 0;
    var i: i32 = 0;
    
    // 初始化数组为全 null
    i = 0;
    while i < PARSER_MAX_STMTS {
        stmts[i] = null;
        i = i + 1;
    }
    
    // 消费 '{'
    parser_consume(parser);
    
    // 解析语句列表
    while parser.current_token != null && 
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        
        // 检查容量
        if stmt_count >= PARSER_MAX_STMTS {
            // 超出容量，报错
            fprintf(2 as *void, "错误: 代码块语句数量超出限制 (%d)\n", PARSER_MAX_STMTS);
            return null;
        }
        
        // 解析语句
        const stmt: &ASTNode = parser_parse_statement(parser);
        if stmt == null {
            // 解析失败
            return null;
        }
        
        stmts[stmt_count] = stmt;
        stmt_count = stmt_count + 1;
    }
    
    // 期望 '}'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    
    // 将语句列表复制到代码块节点的固定大小数组
    i = 0;
    while i < stmt_count {
        block.block_stmts[i] = stmts[i];
        i = i + 1;
    }
    // 剩余位置初始化为 null
    while i < MAX_BLOCK_STMTS {
        block.block_stmts[i] = null;
        i = i + 1;
    }
    block.block_stmt_count = stmt_count;
    
    return block;
}

// ===== 声明解析函数 =====

// 解析结构体声明：struct ID { field_list }
// field_list = field { ',' field }
// field = ID ':' type
// 参数：parser - Parser 指针
// 返回：AST_STRUCT_DECL 节点，失败返回 null
fn parser_parse_struct(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'struct'
    if parser_match(parser, TokenType.TOKEN_STRUCT) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'struct'
    parser_consume(parser);
    
    // 期望结构体名称
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const struct_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
    if struct_name == null {
        return null;
    }
    
    // 消费结构体名称
    parser_consume(parser);
    
    // 创建结构体声明节点
    const struct_decl: &ASTNode = ast_new_node(AST_STRUCT_DECL, line, column, parser.arena, parser.lexer.filename);
    if struct_decl == null {
        return null;
    }
    
    struct_decl.struct_decl_name = struct_name;
    struct_decl.struct_decl_fields = null;
    struct_decl.struct_decl_field_count = 0;
    
    // 期望 '{'
    if parser_expect(parser, TokenType.TOKEN_LEFT_BRACE) == null {
        return null;
    }
    
    // 解析字段列表
    // 字段列表：field { ',' field }
    // field = ID ':' type
    var fields: [&ASTNode: PARSER_MAX_FIELDS] = [];
    var field_count: i32 = 0;
    var i: i32 = 0;
    
    // 初始化数组为全 null
    i = 0;
    while i < PARSER_MAX_FIELDS {
        fields[i] = null;
        i = i + 1;
    }
    
    while parser.current_token != null && 
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        
        // 检查容量
        if field_count >= PARSER_MAX_FIELDS {
            fprintf(2 as *void, "错误: 结构体字段数量超出限制 (%d)\n", PARSER_MAX_FIELDS);
            return null;
        }
        
        // 解析字段名称
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const field_line: i32 = parser.current_token.line;
        const field_column: i32 = parser.current_token.column;
        const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if field_name == null {
            return null;
        }
        
        parser_consume(parser);
        
        // 期望 ':'
        if parser_expect(parser, TokenType.TOKEN_COLON) == null {
            return null;
        }
        
        // 解析字段类型
        const field_type: &ASTNode = parser_parse_type(parser);
        if field_type == null {
            return null;
        }
        
        // 创建字段节点（使用 AST_VAR_DECL，is_const = 0）
        const field: &ASTNode = ast_new_node(AST_VAR_DECL, field_line, field_column, parser.arena, parser.lexer.filename);
        if field == null {
            return null;
        }
        
        field.var_decl_name = field_name;
        field.var_decl_type = field_type;
        field.var_decl_init = null;
        field.var_decl_is_const = 0;
        
        fields[field_count] = field;
        field_count = field_count + 1;
        
        // 检查是否有逗号（可选，最后一个字段后不需要逗号）
        if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
            parser_consume(parser);
        }
    }
    
    // 期望 '}'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    
    // 将字段列表复制到结构体节点的固定大小数组
    i = 0;
    while i < field_count {
        struct_decl.struct_decl_fields[i] = fields[i];
        i = i + 1;
    }
    // 剩余位置初始化为 null
    while i < MAX_STRUCT_FIELDS {
        struct_decl.struct_decl_fields[i] = null;
        i = i + 1;
    }
    struct_decl.struct_decl_field_count = field_count;
    
    return struct_decl;
}

// 解析枚举声明：enum ID '{' variant_list '}'
// variant_list = variant { ',' variant }
// variant = ID [ '=' NUM ]
// 参数：parser - Parser 指针
// 返回：AST_ENUM_DECL 节点，失败返回 null
fn parser_parse_enum(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'enum'
    if parser_match(parser, TokenType.TOKEN_ENUM) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'enum'
    parser_consume(parser);
    
    // 期望枚举名称
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const enum_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
    if enum_name == null {
        return null;
    }
    
    // 消费枚举名称
    parser_consume(parser);
    
    // 创建枚举声明节点
    const enum_decl: &ASTNode = ast_new_node(AST_ENUM_DECL, line, column, parser.arena, parser.lexer.filename);
    if enum_decl == null {
        return null;
    }
    
    enum_decl.enum_decl_name = enum_name;
    enum_decl.enum_decl_variants = null;
    enum_decl.enum_decl_variant_count = 0;
    
    // 期望 '{'
    if parser_expect(parser, TokenType.TOKEN_LEFT_BRACE) == null {
        return null;
    }
    
    // 解析变体列表
    // 变体列表：variant { ',' variant }
    // variant = ID
    var variants: &EnumVariant = null;
    var variant_count: i32 = 0;
    var variant_capacity: i32 = 0;
    
    while parser.current_token != null && 
          parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
          parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        
        // 解析变体名称
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const variant_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if variant_name == null {
            return null;
        }
        
        parser_consume(parser);
        
        // 扩展变体数组（使用 Arena 分配）
        // EnumVariant 包含两个指针（name 和 value），每个8字节，总共16字节
        if variant_count >= variant_capacity {
            var new_capacity: i32 = 0;
            if variant_capacity == 0 {
                new_capacity = 4;
            } else {
                new_capacity = variant_capacity * 2;
            }
            const new_variants: &EnumVariant = arena_alloc(parser.arena, 16 * new_capacity) as &EnumVariant;
            if new_variants == null {
                return null;
            }
            
            // 复制旧变体
            if variants != null {
                var i: i32 = 0;
                while i < variant_count {
                    new_variants[i].name = variants[i].name;
                    new_variants[i].value = variants[i].value;
                    i = i + 1;
                }
            }
            
            variants = new_variants;
            variant_capacity = new_capacity;
        }
        
        // 解析可选的显式值 (= NUM)
        var variant_value: &byte = null;
        if parser_match(parser, TokenType.TOKEN_ASSIGN) != 0 {
            parser_consume(parser);  // 消费 '='
            
            // 期望数字字面量
            if parser_match(parser, TokenType.TOKEN_NUMBER) == 0 {
                return null;
            }
            
            // 复制数字值字符串到 Arena
            variant_value = arena_strdup_for_parser(parser.arena, parser.current_token.value);
            if variant_value == null {
                return null;
            }
            
            parser_consume(parser);  // 消费数字值
        }
        
        // 添加变体
        variants[variant_count].name = variant_name;
        variants[variant_count].value = variant_value;  // null 表示没有显式赋值
        variant_count = variant_count + 1;
        
        // 检查是否有逗号（可选，最后一个变体后不需要逗号）
        if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
            parser_consume(parser);
        }
    }
    
    // 期望 '}'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
        return null;
    }
    
    enum_decl.enum_decl_variants = variants;
    enum_decl.enum_decl_variant_count = variant_count;
    
    return enum_decl;
}

// 解析函数声明：fn ID '(' [ param_list ] ')' type '{' statements '}'
// param_list = param { ',' param }
// param = ID ':' type
// 参数：parser - Parser 指针
// 返回：AST_FN_DECL 节点，失败返回 null
fn parser_parse_function(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'fn'
    if parser_match(parser, TokenType.TOKEN_FN) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'fn'
    parser_consume(parser);
    
    // 期望函数名称
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const fn_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
    if fn_name == null {
        return null;
    }
    
    // 消费函数名称
    parser_consume(parser);
    
    // 创建函数声明节点
    const fn_decl: &ASTNode = ast_new_node(AST_FN_DECL, line, column, parser.arena, parser.lexer.filename);
    if fn_decl == null {
        return null;
    }
    
    fn_decl.fn_decl_name = fn_name;
    fn_decl.fn_decl_params = null;
    fn_decl.fn_decl_param_count = 0;
    fn_decl.fn_decl_return_type = null;
    fn_decl.fn_decl_body = null;
    
    // 期望 '('
    if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
        return null;
    }
    
    // 解析参数列表（可选）
    var params: [&ASTNode: PARSER_MAX_PARAMS] = [];
    var param_count: i32 = 0;
    var i: i32 = 0;
    
    // 初始化数组为全 null
    i = 0;
    while i < PARSER_MAX_PARAMS {
        params[i] = null;
        i = i + 1;
    }
    
    if parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
        // 有参数
        while parser.current_token != null && 
              parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 && 
              parser_match(parser, TokenType.TOKEN_EOF) == 0 {
            
            // 检查容量
            if param_count >= PARSER_MAX_PARAMS {
                fprintf(2 as *void, "错误: 函数参数数量超出限制 (%d)\n", PARSER_MAX_PARAMS);
                return null;
            }
            
            // 解析参数名称
            if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                return null;
            }
            
            const param_line: i32 = parser.current_token.line;
            const param_column: i32 = parser.current_token.column;
            const param_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
            if param_name == null {
                return null;
            }
            
            parser_consume(parser);
            
            // 期望 ':'
            if parser_expect(parser, TokenType.TOKEN_COLON) == null {
                return null;
            }
            
            // 解析参数类型
            const param_type: &ASTNode = parser_parse_type(parser);
            if param_type == null {
                return null;
            }
            
            // 创建参数节点（使用 AST_VAR_DECL，is_const = 0）
            const param: &ASTNode = ast_new_node(AST_VAR_DECL, param_line, param_column, parser.arena, parser.lexer.filename);
            if param == null {
                return null;
            }
            
            param.var_decl_name = param_name;
            param.var_decl_type = param_type;
            param.var_decl_init = null;
            param.var_decl_is_const = 0;
            
            params[param_count] = param;
            param_count = param_count + 1;
            
            // 检查是否有逗号
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            }
        }
    }
    
    // 期望 ')'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
        return null;
    }
    
    // 解析返回类型
    const return_type: &ASTNode = parser_parse_type(parser);
    if return_type == null {
        return null;
    }
    
    // 解析函数体（代码块）
    const body: &ASTNode = parser_parse_block(parser);
    if body == null {
        return null;
    }
    
    // 将参数列表复制到函数节点的固定大小数组
    i = 0;
    while i < param_count {
        fn_decl.fn_decl_params[i] = params[i];
        i = i + 1;
    }
    // 剩余位置初始化为 null
    while i < MAX_FN_PARAMS {
        fn_decl.fn_decl_params[i] = null;
        i = i + 1;
    }
    fn_decl.fn_decl_param_count = param_count;
    fn_decl.fn_decl_return_type = return_type;
    fn_decl.fn_decl_body = body;
    
    return fn_decl;
}

// 解析 extern 函数声明
// extern_decl = 'extern' 'fn' ID '(' [ param_list ] ')' type ';'
// 参数：parser - Parser 指针
// 返回：AST_FN_DECL 节点（body 为 null），失败返回 null
fn parser_parse_extern_function(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 期望 'extern'
    if parser_match(parser, TokenType.TOKEN_EXTERN) == 0 {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 消费 'extern'
    parser_consume(parser);
    
    // 期望 'fn'
    if parser_expect(parser, TokenType.TOKEN_FN) == null {
        return null;
    }
    
    // 期望函数名称
    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
        return null;
    }
    
    const fn_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
    if fn_name == null {
        return null;
    }
    
    // 消费函数名称
    parser_consume(parser);
    
    // 创建函数声明节点
    const fn_decl: &ASTNode = ast_new_node(AST_FN_DECL, line, column, parser.arena, parser.lexer.filename);
    if fn_decl == null {
        return null;
    }
    
    fn_decl.fn_decl_name = fn_name;
    fn_decl.fn_decl_params = null;
    fn_decl.fn_decl_param_count = 0;
    fn_decl.fn_decl_return_type = null;
    fn_decl.fn_decl_body = null;  // extern 函数没有函数体
    fn_decl.fn_decl_is_varargs = 0;  // 默认不是可变参数函数
    
    // 期望 '('
    if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
        return null;
    }
    
    // 解析参数列表（可选，支持可变参数）
    var params: [&ASTNode: PARSER_MAX_PARAMS] = [];
    var param_count: i32 = 0;
    var is_varargs: i32 = 0;
    var i: i32 = 0;
    
    // 初始化数组为全 null
    i = 0;
    while i < PARSER_MAX_PARAMS {
        params[i] = null;
        i = i + 1;
    }
    
    if parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
        // 有参数
        while parser.current_token != null && 
              parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 && 
              parser_match(parser, TokenType.TOKEN_EOF) == 0 {
            
            // 检查是否为可变参数标记（...）
            if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                // 可变参数标记必须是参数列表的最后一个元素
                parser_consume(parser);  // 消费 '...'
                is_varargs = 1;
                break;  // 遇到 ... 后退出循环
            }
            
            // 检查容量
            if param_count >= PARSER_MAX_PARAMS {
                fprintf(2 as *void, "错误: extern 函数参数数量超出限制 (%d)\n", PARSER_MAX_PARAMS);
                return null;
            }
            
            // 解析参数名称
            if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                return null;
            }
            
            const param_line: i32 = parser.current_token.line;
            const param_column: i32 = parser.current_token.column;
            const param_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
            if param_name == null {
                return null;
            }
            
            parser_consume(parser);
            
            // 期望 ':'
            if parser_expect(parser, TokenType.TOKEN_COLON) == null {
                return null;
            }
            
            // 解析参数类型
            const param_type: &ASTNode = parser_parse_type(parser);
            if param_type == null {
                return null;
            }
            
            // 创建参数节点（使用 AST_VAR_DECL，is_const = 0）
            const param: &ASTNode = ast_new_node(AST_VAR_DECL, param_line, param_column, parser.arena, parser.lexer.filename);
            if param == null {
                return null;
            }
            
            param.var_decl_name = param_name;
            param.var_decl_type = param_type;
            param.var_decl_init = null;
            param.var_decl_is_const = 0;
            
            params[param_count] = param;
            param_count = param_count + 1;
            
            // 检查是否有逗号
            if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                parser_consume(parser);
            } else if parser_match(parser, TokenType.TOKEN_ELLIPSIS) != 0 {
                // 逗号后紧跟 ...，也是合法的
                // 不消费逗号，让下次循环处理 ...
            }
        }
    }
    
    // 期望 ')'
    if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
        return null;
    }
    
    // 解析返回类型
    const return_type: &ASTNode = parser_parse_type(parser);
    if return_type == null {
        return null;
    }
    
    // extern 函数以分号结尾，没有函数体
    if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
        return null;
    }
    
    // 将参数列表复制到函数节点的固定大小数组
    i = 0;
    while i < param_count {
        fn_decl.fn_decl_params[i] = params[i];
        i = i + 1;
    }
    // 剩余位置初始化为 null
    while i < MAX_FN_PARAMS {
        fn_decl.fn_decl_params[i] = null;
        i = i + 1;
    }
    fn_decl.fn_decl_param_count = param_count;
    fn_decl.fn_decl_return_type = return_type;
    fn_decl.fn_decl_body = null;  // extern 函数没有函数体
    fn_decl.fn_decl_is_varargs = is_varargs;
    
    return fn_decl;
}

// 解析声明（函数、结构体或变量声明）
// 参数：parser - Parser 指针
// 返回：声明节点（AST_FN_DECL, AST_STRUCT_DECL, AST_ENUM_DECL, 或 AST_VAR_DECL），失败返回 null
fn parser_parse_declaration(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 根据第一个 Token 判断声明类型
    if parser_match(parser, TokenType.TOKEN_EXTERN) != 0 {
        // extern 函数声明
        return parser_parse_extern_function(parser);
    } else if parser_match(parser, TokenType.TOKEN_FN) != 0 {
        return parser_parse_function(parser);
    } else if parser_match(parser, TokenType.TOKEN_ENUM) != 0 {
        return parser_parse_enum(parser);
    } else if parser_match(parser, TokenType.TOKEN_STRUCT) != 0 {
        return parser_parse_struct(parser);
    } else if parser_match(parser, TokenType.TOKEN_CONST) != 0 || parser_match(parser, TokenType.TOKEN_VAR) != 0 {
        // 变量声明
        return parser_parse_statement(parser);
    } else {
        // 无法识别的声明类型
        return null;
    }
}

// 解析程序（顶层声明列表）
// 参数：parser - Parser 指针
// 返回：AST_PROGRAM 节点，失败返回 null
fn parser_parse(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 创建程序节点
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    const program: &ASTNode = ast_new_node(AST_PROGRAM, line, column, parser.arena, parser.lexer.filename);
    if program == null {
        return null;
    }
    
    // 初始化声明列表
    program.program_decls = null;
    program.program_decl_count = 0;
    
    // 解析顶层声明列表
    var decls: [&ASTNode: PARSER_MAX_DECLS] = [];
    var decl_count: i32 = 0;
    var i: i32 = 0;
    
    // 初始化数组为全 null
    i = 0;
    while i < PARSER_MAX_DECLS {
        decls[i] = null;
        i = i + 1;
    }
    
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_EOF) == 0 {
        // 检查容量
        if decl_count >= PARSER_MAX_DECLS {
            fprintf(2 as *void, "错误: 程序声明数量超出限制 (%d)\n", PARSER_MAX_DECLS);
            return null;
        }
        
        const decl: &ASTNode = parser_parse_declaration(parser);
        if decl == null {
            // 解析失败：检查是否因为到达文件末尾（EOF）还是真正的错误
            // 如果当前 token 不是 EOF，说明遇到了真正的解析错误
            if parser.current_token != null && parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                // 真正的解析错误：输出错误信息并返回 null
                // 注意：stderr 在 C 中通常是文件描述符 2，这里使用数值常量
                const stderr_fd: *void = 2 as *void;
                if parser.lexer.filename != null {
                    const token_value: *byte = parser.current_token.value != null ? parser.current_token.value as *byte : "";
                    fprintf(stderr_fd, "错误: 语法分析失败 (%s:%d:%d): 意外的 token", 
                            parser.lexer.filename as *byte, parser.current_token.line, parser.current_token.column);
                    // 检查 token_value 是否非空
                    if parser.current_token.value != null && strcmp(token_value, "") != 0 {
                        fprintf(stderr_fd, " '%s'", token_value);
                    }
                } else {
                    const token_value: *byte = parser.current_token.value != null ? parser.current_token.value as *byte : "";
                    fprintf(stderr_fd, "错误: 语法分析失败 (<unknown>:%d:%d): 意外的 token", 
                            parser.current_token.line, parser.current_token.column);
                    // 检查 token_value 是否非空
                    if parser.current_token.value != null && strcmp(token_value, "") != 0 {
                        fprintf(stderr_fd, " '%s'", token_value);
                    }
                }
                fprintf(stderr_fd, "\n");
                return null;
            }
            // 到达文件末尾，正常退出循环
            break;
        }
        
        decls[decl_count] = decl;
        decl_count = decl_count + 1;
    }
    
    // 将声明列表复制到程序节点的固定大小数组
    i = 0;
    while i < decl_count {
        program.program_decls[i] = decls[i];
        i = i + 1;
    }
    // 剩余位置初始化为 null
    while i < MAX_PROGRAM_DECLS {
        program.program_decls[i] = null;
        i = i + 1;
    }
    program.program_decl_count = decl_count;
    
    return program;
}

// ===== 表达式解析函数 =====

// 解析基础表达式
// 支持：数字、标识符、布尔字面量、括号表达式、函数调用、结构体字面量、字段访问
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_primary_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 解析数字字面量
    if parser.current_token.type == TokenType.TOKEN_NUMBER {
        const node: &ASTNode = ast_new_node(AST_NUMBER, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        // 将字符串转换为整数
        const value: i32 = atoi(parser.current_token.value as *byte);
        node.number_value = value;
        
        parser_consume(parser);
        return node;
    }
    
    // 解析布尔字面量
    if parser.current_token.type == TokenType.TOKEN_TRUE {
        const node: &ASTNode = ast_new_node(AST_BOOL, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        node.bool_literal_value = 1;  // true
        
        parser_consume(parser);
        return node;
    }
    
    if parser.current_token.type == TokenType.TOKEN_FALSE {
        const node: &ASTNode = ast_new_node(AST_BOOL, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        node.bool_literal_value = 0;  // false
        
        parser_consume(parser);
        return node;
    }
    
    // 解析字符串字面量
    if parser.current_token.type == TokenType.TOKEN_STRING {
        const node: &ASTNode = ast_new_node(AST_STRING, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        // 复制字符串内容到 Arena（token 的 value 已经在 Arena 中）
        const str_value: &byte = parser.current_token.value;
        if str_value == null {
            return null;
        }
        
        // 字符串内容已经在 token 中，直接使用（token 的 value 存储在 Arena 中）
        node.string_literal_value = str_value;
        
        parser_consume(parser);
        return node;
    }
    
    // 解析 null 字面量（null 被解析为标识符节点，在代码生成阶段通过字符串比较识别）
    if parser.current_token.type == TokenType.TOKEN_NULL {
        const node: &ASTNode = ast_new_node(AST_IDENTIFIER, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        // 复制 "null" 字符串到 Arena（代码生成器会通过字符串比较识别）
        const null_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if null_name == null {
            return null;
        }
        node.identifier_name = null_name;
        
        parser_consume(parser);
        return node;
    }
    
    // 解析 sizeof 表达式：sizeof(Type) 或 sizeof(expr)
    if parser.current_token.type == TokenType.TOKEN_SIZEOF {
        parser_consume(parser);  // 消费 'sizeof'
        
        // 期望 '('
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const sizeof_node: &ASTNode = ast_new_node(AST_SIZEOF, line, column, parser.arena, parser.lexer.filename);
        if sizeof_node == null {
            return null;
        }
        
        // 尝试解析类型，如果失败则解析表达式
        // 先检查是否是类型语法（基础类型或 struct 关键字）
        var is_type: i32 = 0;
        var target: &ASTNode = null;
        
        if parser.current_token != null {
            if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
                const type_name: *byte = parser.current_token.value as *byte;
                // 检查是否是基础类型或 struct 关键字
                if strcmp(type_name, "i32" as *byte) == 0 || 
                   strcmp(type_name, "usize" as *byte) == 0 ||
                   strcmp(type_name, "bool" as *byte) == 0 || 
                   strcmp(type_name, "byte" as *byte) == 0 ||
                   strcmp(type_name, "void" as *byte) == 0 ||
                   strcmp(type_name, "struct" as *byte) == 0 {
                    // 尝试解析类型
                    target = parser_parse_type(parser);
                    if target != null {
                        is_type = 1;
                    }
                }
            } else if parser.current_token.type == TokenType.TOKEN_AMPERSAND || 
                      parser.current_token.type == TokenType.TOKEN_ASTERISK ||
                      parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
                // 指针类型或数组类型开始
                target = parser_parse_type(parser);
                if target != null {
                    is_type = 1;
                }
            }
        }
        
        // 如果不是类型，则解析表达式
        if target == null {
            target = parser_parse_expression(parser);
            if target == null {
                return null;
            }
            is_type = 0;
        }
        
        sizeof_node.sizeof_expr_target = target;
        sizeof_node.sizeof_expr_is_type = is_type;
        
        // 期望 ')'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return sizeof_node;
    }
    
    // 解析 alignof 表达式：alignof(Type) 或 alignof(expr)
    if parser.current_token.type == TokenType.TOKEN_ALIGNOF {
        parser_consume(parser);  // 消费 'alignof'
        
        // 期望 '('
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const alignof_node: &ASTNode = ast_new_node(AST_ALIGNOF, line, column, parser.arena, parser.lexer.filename);
        if alignof_node == null {
            return null;
        }
        
        // 尝试解析类型，如果失败则解析表达式
        // 先检查是否是类型语法（基础类型或 struct 关键字）
        var is_type: i32 = 0;
        var target: &ASTNode = null;
        
        if parser.current_token != null {
            if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
                const type_name: *byte = parser.current_token.value as *byte;
                // 检查是否是基础类型或 struct 关键字
                if strcmp(type_name, "i32" as *byte) == 0 || 
                   strcmp(type_name, "usize" as *byte) == 0 ||
                   strcmp(type_name, "bool" as *byte) == 0 || 
                   strcmp(type_name, "byte" as *byte) == 0 ||
                   strcmp(type_name, "void" as *byte) == 0 ||
                   strcmp(type_name, "struct" as *byte) == 0 {
                    // 尝试解析类型
                    target = parser_parse_type(parser);
                    if target != null {
                        is_type = 1;
                    }
                }
            } else if parser.current_token.type == TokenType.TOKEN_AMPERSAND || 
                      parser.current_token.type == TokenType.TOKEN_ASTERISK ||
                      parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
                // 指针类型或数组类型开始
                target = parser_parse_type(parser);
                if target != null {
                    is_type = 1;
                }
            }
        }
        
        // 如果不是类型，则解析表达式
        if target == null {
            target = parser_parse_expression(parser);
            if target == null {
                return null;
            }
            is_type = 0;
        }
        
        alignof_node.alignof_expr_target = target;
        alignof_node.alignof_expr_is_type = is_type;
        
        // 期望 ')'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return alignof_node;
    }
    
    // 解析 len 表达式：len(array)
    if parser.current_token.type == TokenType.TOKEN_LEN {
        parser_consume(parser);  // 消费 'len'
        
        // 期望 '('
        if parser_expect(parser, TokenType.TOKEN_LEFT_PAREN) == null {
            return null;
        }
        
        const len_node: &ASTNode = ast_new_node(AST_LEN, line, column, parser.arena, parser.lexer.filename);
        if len_node == null {
            return null;
        }
        
        // 解析数组表达式
        const array_expr: &ASTNode = parser_parse_expression(parser);
        if array_expr == null {
            return null;
        }
        
        len_node.len_expr_array = array_expr;
        
        // 期望 ')'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        return len_node;
    }
    
    // 解析标识符（可能是普通标识符、函数调用、或结构体字面量的开始）
    if parser.current_token.type == TokenType.TOKEN_IDENTIFIER {
        const name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if name == null {
            return null;
        }
        
        parser_consume(parser);  // 消费标识符
        
        // 检查下一个 token 类型
        if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LEFT_PAREN {
            // 函数调用：ID '(' [ arg_list ] ')'
            const call: &ASTNode = ast_new_node(AST_CALL_EXPR, line, column, parser.arena, parser.lexer.filename);
            if call == null {
                return null;
            }
            
            // 创建标识符节点作为被调用的函数
            const callee: &ASTNode = ast_new_node(AST_IDENTIFIER, line, column, parser.arena, parser.lexer.filename);
            if callee == null {
                return null;
            }
            callee.identifier_name = name;
            call.call_expr_callee = callee;
            
            // 消费 '('
            parser_consume(parser);
            
            // 解析参数列表（可选）
            var args: [&ASTNode: PARSER_MAX_CALL_ARGS] = [];
            var arg_count: i32 = 0;
            var i: i32 = 0;
            
            // 初始化数组为全 null
            i = 0;
            while i < PARSER_MAX_CALL_ARGS {
                args[i] = null;
                i = i + 1;
            }
            
            if parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 {
                // 有参数
                while parser.current_token != null && 
                      parser_match(parser, TokenType.TOKEN_RIGHT_PAREN) == 0 && 
                      parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                    
                    // 检查容量
                    if arg_count >= PARSER_MAX_CALL_ARGS {
                        fprintf(2 as *void, "错误: 函数调用参数数量超出限制 (%d)\n", PARSER_MAX_CALL_ARGS);
                        return null;
                    }
                    
                    // 解析参数表达式
                    const arg: &ASTNode = parser_parse_expression(parser);
                    if arg == null {
                        return null;
                    }
                    
                    args[arg_count] = arg;
                    arg_count = arg_count + 1;
                    
                    // 检查是否有逗号
                    if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    }
                }
            }
            
            // 期望 ')'
            if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
                return null;
            }
            
            // 将参数列表复制到调用节点的固定大小数组
            i = 0;
            while i < arg_count {
                call.call_expr_args[i] = args[i];
                i = i + 1;
            }
            // 剩余位置初始化为 null
            while i < MAX_CALL_ARGS {
                call.call_expr_args[i] = null;
                i = i + 1;
            }
            call.call_expr_arg_count = arg_count;
            
            // 字段访问和数组访问可能跟在函数调用后面（例如：f().field 或 f()[0]）
            var result: &ASTNode = call;
            
            // 处理字段访问和数组访问链
            while parser.current_token != null {
                if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                    // 字段访问：.field
                    parser_consume(parser);  // 消费 '.'
                    
                    // 期望字段名称
                    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                        return null;
                    }
                    
                    const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费字段名称
                    
                    // 创建字段访问节点
                    const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser.lexer.filename);
                    if member_access == null {
                        return null;
                    }
                    
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    
                    result = member_access;
                } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                    // 数组访问：[index]
                    const bracket_line: i32 = parser.current_token.line;
                    const bracket_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费 '['
                    
                    // 解析索引表达式
                    const index_expr: &ASTNode = parser_parse_expression(parser);
                    if index_expr == null {
                        return null;
                    }
                    
                    // 期望 ']'
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    
                    // 创建数组访问节点
                    const array_access: &ASTNode = ast_new_node(AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser.lexer.filename);
                    if array_access == null {
                        return null;
                    }
                    
                    array_access.array_access_array = result;
                    array_access.array_access_index = index_expr;
                    
                    result = array_access;
                } else {
                    // 既不是字段访问也不是数组访问，退出循环
                    break;
                }
            }
            
            return result;
        } else if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_LEFT_BRACE {
            // 使用 peek 机制检测是否是结构体字面量
            const is_struct_init: i32 = parser_peek_is_struct_init(parser);
            
            if is_struct_init == 0 {
                // 不是结构体字面量，创建普通标识符（后面的'{'是代码块的开始，不是表达式的一部分）
                const node: &ASTNode = ast_new_node(AST_IDENTIFIER, line, column, parser.arena, parser.lexer.filename);
                if node == null {
                    return null;
                }
                
                node.identifier_name = name;
                
                // 字段访问可能跟在标识符后面（例如：obj.field）
                var result: &ASTNode = node;
                
                // 处理字段访问链（左结合：a.b.c 解析为 (a.b).c）
                while parser.current_token != null && parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                    parser_consume(parser);  // 消费 '.'
                    
                    // 期望字段名称
                    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                        return null;
                    }
                    
                    const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费字段名称
                    
                    // 创建字段访问节点
                    const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser.lexer.filename);
                    if member_access == null {
                        return null;
                    }
                    
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    
                    result = member_access;
                }
                
                return result;
            }
            
            // 结构体字面量：ID '{' field_init_list '}'
            const struct_init: &ASTNode = ast_new_node(AST_STRUCT_INIT, line, column, parser.arena, parser.lexer.filename);
            if struct_init == null {
                return null;
            }
            
            struct_init.struct_init_struct_name = name;
            
            // 消费 '{'
            parser_consume(parser);
            
            // 解析字段初始化列表
            var field_names: [&byte: PARSER_MAX_STRUCT_INIT_FIELDS] = [];
            var field_values: [&ASTNode: PARSER_MAX_STRUCT_INIT_FIELDS] = [];
            var field_count: i32 = 0;
            var i: i32 = 0;
            
            // 初始化数组为全 null
            i = 0;
            while i < PARSER_MAX_STRUCT_INIT_FIELDS {
                field_names[i] = null;
                field_values[i] = null;
                i = i + 1;
            }
            
            if parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 {
                // 有字段初始化
                while parser.current_token != null && 
                      parser_match(parser, TokenType.TOKEN_RIGHT_BRACE) == 0 && 
                      parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                    
                    // 检查容量
                    if field_count >= PARSER_MAX_STRUCT_INIT_FIELDS {
                        fprintf(2 as *void, "错误: 结构体初始化字段数量超出限制 (%d)\n", PARSER_MAX_STRUCT_INIT_FIELDS);
                        return null;
                    }
                    
                    // 解析字段名称
                    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                        return null;
                    }
                    
                    const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    
                    parser_consume(parser);  // 消费字段名称
                    
                    // 期望 ':'
                    if parser_expect(parser, TokenType.TOKEN_COLON) == null {
                        return null;
                    }
                    
                    // 解析字段值表达式
                    const field_value: &ASTNode = parser_parse_expression(parser);
                    if field_value == null {
                        return null;
                    }
                    
                    field_names[field_count] = field_name;
                    field_values[field_count] = field_value;
                    field_count = field_count + 1;
                    
                    // 检查是否有逗号
                    if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                        parser_consume(parser);
                    }
                }
            }
            
            // 期望 '}'
            if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACE) == null {
                return null;
            }
            
            // 将字段列表复制到结构体初始化节点的固定大小数组
            i = 0;
            while i < field_count {
                struct_init.struct_init_field_names[i] = field_names[i];
                struct_init.struct_init_field_values[i] = field_values[i];
                i = i + 1;
            }
            // 剩余位置初始化为 null
            while i < MAX_STRUCT_INIT_FIELD_NAMES {
                struct_init.struct_init_field_names[i] = null;
                i = i + 1;
            }
            i = field_count;
            while i < MAX_STRUCT_INIT_FIELDS {
                struct_init.struct_init_field_values[i] = null;
                i = i + 1;
            }
            struct_init.struct_init_field_count = field_count;
            
            // 字段访问可能跟在结构体字面量后面（例如：Point{x:1,y:2}.x）
            var result: &ASTNode = struct_init;
            
            // 处理字段访问链
            while parser.current_token != null && parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                parser_consume(parser);  // 消费 '.'
                
                // 期望字段名称
                if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                    return null;
                }
                
                const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                if field_name == null {
                    return null;
                }
                
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费字段名称
                
                // 创建字段访问节点
                const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser.lexer.filename);
                if member_access == null {
                    return null;
                }
                
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                
                result = member_access;
            }
            
            return result;
        } else {
            // 普通标识符
            const node: &ASTNode = ast_new_node(AST_IDENTIFIER, line, column, parser.arena, parser.lexer.filename);
            if node == null {
                return null;
            }
            
            node.identifier_name = name;
            
            // 字段访问和数组访问可能跟在标识符后面（例如：obj.field 或 arr[0]）
            var result: &ASTNode = node;
            
            // 处理字段访问和数组访问链（左结合：a.b.c 解析为 (a.b).c，arr[0][1] 解析为 (arr[0])[1]）
            while parser.current_token != null {
                if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                    // 字段访问：.field
                    parser_consume(parser);  // 消费 '.'
                    
                    // 期望字段名称
                    if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                        return null;
                    }
                    
                    const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                    if field_name == null {
                        return null;
                    }
                    
                    const field_line: i32 = parser.current_token.line;
                    const field_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费字段名称
                    
                    // 创建字段访问节点
                    const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser.lexer.filename);
                    if member_access == null {
                        return null;
                    }
                    
                    member_access.member_access_object = result;
                    member_access.member_access_field_name = field_name;
                    
                    result = member_access;
                } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                    // 数组访问：[index]
                    const bracket_line: i32 = parser.current_token.line;
                    const bracket_column: i32 = parser.current_token.column;
                    parser_consume(parser);  // 消费 '['
                    
                    // 解析索引表达式
                    const index_expr: &ASTNode = parser_parse_expression(parser);
                    if index_expr == null {
                        return null;
                    }
                    
                    // 期望 ']'
                    if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                        return null;
                    }
                    
                    // 创建数组访问节点
                    const array_access: &ASTNode = ast_new_node(AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser.lexer.filename);
                    if array_access == null {
                        return null;
                    }
                    
                    array_access.array_access_array = result;
                    array_access.array_access_index = index_expr;
                    
                    result = array_access;
                } else {
                    // 既不是字段访问也不是数组访问，退出循环
                    break;
                }
            }
            
            return result;
        }
    }
    
    // 解析数组字面量：[expr1, expr2, ..., exprN] 或 []
    if parser.current_token.type == TokenType.TOKEN_LEFT_BRACKET {
        const array_line: i32 = parser.current_token.line;
        const array_column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 '['
        
        // 创建数组字面量节点
        const array_literal: &ASTNode = ast_new_node(AST_ARRAY_LITERAL, array_line, array_column, parser.arena, parser.lexer.filename);
        if array_literal == null {
            return null;
        }
        
        // 初始化元素数组
        var elements: [&ASTNode: PARSER_MAX_ARRAY_ELEMENTS] = [];
        var element_count: i32 = 0;
        var i: i32 = 0;
        
        // 初始化数组为全 null
        i = 0;
        while i < PARSER_MAX_ARRAY_ELEMENTS {
            elements[i] = null;
            i = i + 1;
        }
        
        // 检查是否为空数组
        if parser_match(parser, TokenType.TOKEN_RIGHT_BRACKET) == 0 {
            // 有元素，解析元素列表
            while parser.current_token != null && 
                  parser_match(parser, TokenType.TOKEN_RIGHT_BRACKET) == 0 && 
                  parser_match(parser, TokenType.TOKEN_EOF) == 0 {
                
                // 检查容量
                if element_count >= PARSER_MAX_ARRAY_ELEMENTS {
                    fprintf(2 as *void, "错误: 数组字面量元素数量超出限制 (%d)\n", PARSER_MAX_ARRAY_ELEMENTS);
                    return null;
                }
                
                // 解析元素表达式
                const element: &ASTNode = parser_parse_expression(parser);
                if element == null {
                    return null;
                }
                
                elements[element_count] = element;
                element_count = element_count + 1;
                
                // 检查是否有逗号
                if parser_match(parser, TokenType.TOKEN_COMMA) != 0 {
                    parser_consume(parser);
                } else {
                    // 没有逗号，应该是最后一个元素
                    break;
                }
            }
        }
        
        // 期望 ']'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
            return null;
        }
        
        // 将元素列表复制到数组字面量节点的固定大小数组
        i = 0;
        while i < element_count {
            array_literal.array_literal_elements[i] = elements[i];
            i = i + 1;
        }
        // 剩余位置初始化为 null
        while i < MAX_ARRAY_LITERAL_ELEMENTS {
            array_literal.array_literal_elements[i] = null;
            i = i + 1;
        }
        array_literal.array_literal_element_count = element_count;
        
        // 字段访问和数组访问可能跟在数组字面量后面（例如：[1,2,3][0]）
        var result: &ASTNode = array_literal;
        
        // 处理字段访问和数组访问链
        while parser.current_token != null {
            if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                // 字段访问：.field
                parser_consume(parser);  // 消费 '.'
                
                // 期望字段名称
                if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                    return null;
                }
                
                const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                if field_name == null {
                    return null;
                }
                
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费字段名称
                
                // 创建字段访问节点
                const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser.lexer.filename);
                if member_access == null {
                    return null;
                }
                
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                
                result = member_access;
            } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                // 数组访问：[index]
                const bracket_line: i32 = parser.current_token.line;
                const bracket_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费 '['
                
                // 解析索引表达式
                const index_expr: &ASTNode = parser_parse_expression(parser);
                if index_expr == null {
                    return null;
                }
                
                // 期望 ']'
                if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                    return null;
                }
                
                // 创建数组访问节点
                const array_access: &ASTNode = ast_new_node(AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser.lexer.filename);
                if array_access == null {
                    return null;
                }
                
                array_access.array_access_array = result;
                array_access.array_access_index = index_expr;
                
                result = array_access;
            } else {
                // 既不是字段访问也不是数组访问，退出循环
                break;
            }
        }
        
        return result;
    }
    
    // 解析括号表达式
    if parser.current_token.type == TokenType.TOKEN_LEFT_PAREN {
        parser_consume(parser);  // 消费 '('
        
        // 解析内部表达式（递归调用）
        const expr: &ASTNode = parser_parse_expression(parser);
        if expr == null {
            return null;
        }
        
        // 期望 ')'
        if parser_expect(parser, TokenType.TOKEN_RIGHT_PAREN) == null {
            return null;
        }
        
        // 字段访问和数组访问可能跟在括号表达式后面（例如：(expr).field 或 (expr)[0]）
        var result: &ASTNode = expr;
        
        // 处理字段访问和数组访问链
        while parser.current_token != null {
            if parser_match(parser, TokenType.TOKEN_DOT) != 0 {
                // 字段访问：.field
                parser_consume(parser);  // 消费 '.'
                
                // 期望字段名称
                if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
                    return null;
                }
                
                const field_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
                if field_name == null {
                    return null;
                }
                
                const field_line: i32 = parser.current_token.line;
                const field_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费字段名称
                
                // 创建字段访问节点
                const member_access: &ASTNode = ast_new_node(AST_MEMBER_ACCESS, field_line, field_column, parser.arena, parser.lexer.filename);
                if member_access == null {
                    return null;
                }
                
                member_access.member_access_object = result;
                member_access.member_access_field_name = field_name;
                
                result = member_access;
            } else if parser_match(parser, TokenType.TOKEN_LEFT_BRACKET) != 0 {
                // 数组访问：[index]
                const bracket_line: i32 = parser.current_token.line;
                const bracket_column: i32 = parser.current_token.column;
                parser_consume(parser);  // 消费 '['
                
                // 解析索引表达式
                const index_expr: &ASTNode = parser_parse_expression(parser);
                if index_expr == null {
                    return null;
                }
                
                // 期望 ']'
                if parser_expect(parser, TokenType.TOKEN_RIGHT_BRACKET) == null {
                    return null;
                }
                
                // 创建数组访问节点
                const array_access: &ASTNode = ast_new_node(AST_ARRAY_ACCESS, bracket_line, bracket_column, parser.arena, parser.lexer.filename);
                if array_access == null {
                    return null;
                }
                
                array_access.array_access_array = result;
                array_access.array_access_index = index_expr;
                
                result = array_access;
            } else {
                // 既不是字段访问也不是数组访问，退出循环
                break;
            }
        }
        
        return result;
    }
    
    // 无法识别的基础表达式
    return null;
}

// 解析一元表达式（!, -, &, *，右结合）
// unary_expr = ('!' | '-' | '&' | '*') unary_expr | primary_expr
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_unary_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 检查一元运算符（!, -, &, *）
    if parser_match(parser, TokenType.TOKEN_EXCLAMATION) != 0 || 
       parser_match(parser, TokenType.TOKEN_MINUS) != 0 ||
       parser_match(parser, TokenType.TOKEN_AMPERSAND) != 0 ||
       parser_match(parser, TokenType.TOKEN_ASTERISK) != 0 {
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 递归解析一元表达式（右结合）
        const operand: &ASTNode = parser_parse_unary_expr(parser);
        if operand == null {
            return null;
        }
        
        // 创建一元表达式节点
        const node: &ASTNode = ast_new_node(AST_UNARY_EXPR, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        node.unary_expr_op = op as i32;
        node.unary_expr_operand = operand;
        
        return node;
    }
    
    // 不是一元运算符，解析基础表达式
    return parser_parse_primary_expr(parser);
}

// 解析类型转换表达式（右结合）
// cast_expr = unary_expr [ 'as' type ]
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_cast_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数（一元表达式）
    const expr: &ASTNode = parser_parse_unary_expr(parser);
    if expr == null {
        return null;
    }
    
    // 检查是否有 'as' 关键字（类型转换）
    if parser.current_token != null && parser.current_token.type == TokenType.TOKEN_AS {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 'as'
        
        // 解析目标类型
        const target_type: &ASTNode = parser_parse_type(parser);
        if target_type == null {
            return null;
        }
        
        // 创建类型转换节点
        const node: &ASTNode = ast_new_node(AST_CAST_EXPR, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        node.cast_expr_expr = expr;
        node.cast_expr_target_type = target_type;
        
        return node;
    }
    
    // 没有类型转换，返回原表达式
    return expr;
}

// 解析乘除模表达式（左结合）
// mul_expr = cast_expr { ('*' | '/' | '%') cast_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_mul_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数（类型转换表达式）
    var left: &ASTNode = parser_parse_cast_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的乘除模运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_ASTERISK) != 0 ||
        parser_match(parser, TokenType.TOKEN_SLASH) != 0 ||
        parser_match(parser, TokenType.TOKEN_PERCENT) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数（类型转换表达式）
        const right: &ASTNode = parser_parse_cast_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析加减表达式（左结合）
// add_expr = mul_expr { ('+' | '-') mul_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_add_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_mul_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的加减运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_PLUS) != 0 ||
        parser_match(parser, TokenType.TOKEN_MINUS) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_mul_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析比较表达式（左结合）
// rel_expr = add_expr { ('<' | '>' | '<=' | '>=') add_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_rel_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_add_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的比较运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_LESS) != 0 ||
        parser_match(parser, TokenType.TOKEN_GREATER) != 0 ||
        parser_match(parser, TokenType.TOKEN_LESS_EQUAL) != 0 ||
        parser_match(parser, TokenType.TOKEN_GREATER_EQUAL) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_add_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析相等性表达式（左结合）
// eq_expr = rel_expr { ('==' | '!=') rel_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_eq_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_rel_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的相等性运算符（左结合）
    while parser.current_token != null && (
        parser_match(parser, TokenType.TOKEN_EQUAL) != 0 ||
        parser_match(parser, TokenType.TOKEN_NOT_EQUAL) != 0
    ) {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_rel_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析逻辑与表达式（左结合）
// and_expr = eq_expr { '&&' eq_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_and_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_eq_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的逻辑与运算符（左结合）
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_LOGICAL_AND) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_eq_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析逻辑或表达式（左结合）
// or_expr = and_expr { '||' and_expr }
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_or_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    var left: &ASTNode = parser_parse_and_expr(parser);
    if left == null {
        return null;
    }
    
    // 解析连续的逻辑或运算符（左结合）
    while parser.current_token != null && parser_match(parser, TokenType.TOKEN_LOGICAL_OR) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        const op: TokenType = parser.current_token.type;
        parser_consume(parser);  // 消费运算符
        
        // 解析右操作数
        const right: &ASTNode = parser_parse_and_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建二元表达式节点
        const node: &ASTNode = ast_new_node(AST_BINARY_EXPR, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        node.binary_expr_left = left;
        node.binary_expr_op = op as i32;
        node.binary_expr_right = right;
        
        left = node;  // 左结合：继续以当前节点作为左操作数
    }
    
    return left;
}

// 解析赋值表达式（右结合）
// assign_expr = or_expr [ '=' assign_expr ]
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_assign_expr(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 解析左操作数
    const left: &ASTNode = parser_parse_or_expr(parser);
    if left == null {
        return null;
    }
    
    // 检查是否有赋值运算符
    if parser.current_token != null && parser_match(parser, TokenType.TOKEN_ASSIGN) != 0 {
        const line: i32 = parser.current_token.line;
        const column: i32 = parser.current_token.column;
        parser_consume(parser);  // 消费 '='
        
        // 递归解析赋值表达式（右结合）
        const right: &ASTNode = parser_parse_assign_expr(parser);
        if right == null {
            return null;
        }
        
        // 创建赋值节点
        const node: &ASTNode = ast_new_node(AST_ASSIGN, line, column, parser.arena, parser.lexer.filename);
        if node == null {
            return null;
        }
        
        node.assign_dest = left;
        node.assign_src = right;
        
        return node;
    }
    
    // 没有赋值运算符，返回左操作数
    return left;
}

// 解析表达式（完整版本）
// expr = assign_expr
// 参数：parser - Parser 指针
// 返回：表达式节点，失败返回 null
fn parser_parse_expression(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    // 从赋值表达式开始解析（最低优先级）
    return parser_parse_assign_expr(parser);
}

// ===== 语句解析函数 =====

// 解析语句
// 参数：parser - Parser 指针
// 返回：语句节点，失败返回 null
fn parser_parse_statement(parser: &Parser) &ASTNode {
    if parser == null || parser.current_token == null {
        return null;
    }
    
    const line: i32 = parser.current_token.line;
    const column: i32 = parser.current_token.column;
    
    // 根据第一个 Token 判断语句类型
    if parser.current_token.type == TokenType.TOKEN_RETURN {
        // 解析 return 语句
        parser_consume(parser);  // 消费 'return'
        
        const stmt: &ASTNode = ast_new_node(AST_RETURN_STMT, line, column, parser.arena, parser.lexer.filename);
        if stmt == null {
            return null;
        }
        
        // 解析返回值表达式（可选，void 函数可以没有返回值）
        if parser_match(parser, TokenType.TOKEN_SEMICOLON) != 0 {
            // 没有返回值（void 函数）
            stmt.return_stmt_expr = null;
            parser_consume(parser);  // 消费 ';'
        } else {
            // 有返回值表达式
            const expr: &ASTNode = parser_parse_expression(parser);
            if expr == null {
                return null;
            }
            stmt.return_stmt_expr = expr;
            
            // 期望 ';'
            if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
                return null;
            }
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_BREAK) != 0 {
        // 解析 break 语句
        parser_consume(parser);  // 消费 'break'
        
        const stmt: &ASTNode = ast_new_node(AST_BREAK_STMT, line, column, parser.arena, parser.lexer.filename);
        if stmt == null {
            return null;
        }
        
        // 期望 ';'
        if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_CONTINUE) != 0 {
        // 解析 continue 语句
        parser_consume(parser);  // 消费 'continue'
        
        const stmt: &ASTNode = ast_new_node(AST_CONTINUE_STMT, line, column, parser.arena, parser.lexer.filename);
        if stmt == null {
            return null;
        }
        
        // 期望 ';'
        if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_IF) != 0 {
        // 解析 if 语句
        parser_consume(parser);  // 消费 'if'
        
        const stmt: &ASTNode = ast_new_node(AST_IF_STMT, line, column, parser.arena, parser.lexer.filename);
        if stmt == null {
            return null;
        }
        
        // 解析条件表达式
        const condition: &ASTNode = parser_parse_expression(parser);
        if condition == null {
            return null;
        }
        stmt.if_stmt_condition = condition;
        
        // 解析 then 分支（代码块）
        const then_branch: &ASTNode = parser_parse_block(parser);
        if then_branch == null {
            return null;
        }
        stmt.if_stmt_then_branch = then_branch;
        
        // 解析 else 分支（可选）
        if parser_match(parser, TokenType.TOKEN_ELSE) != 0 {
            parser_consume(parser);  // 消费 'else'
            
            const else_branch: &ASTNode = parser_parse_block(parser);
            if else_branch == null {
                return null;
            }
            stmt.if_stmt_else_branch = else_branch;
        } else {
            stmt.if_stmt_else_branch = null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_WHILE) != 0 {
        // 解析 while 语句
        parser_consume(parser);  // 消费 'while'
        
        const stmt: &ASTNode = ast_new_node(AST_WHILE_STMT, line, column, parser.arena, parser.lexer.filename);
        if stmt == null {
            return null;
        }
        
        // 解析条件表达式
        const condition: &ASTNode = parser_parse_expression(parser);
        if condition == null {
            return null;
        }
        stmt.while_stmt_condition = condition;
        
        // 解析循环体（代码块）
        const body: &ASTNode = parser_parse_block(parser);
        if body == null {
            return null;
        }
        stmt.while_stmt_body = body;
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_FOR) != 0 {
        // 解析 for 语句（数组遍历）
        // 语法：for expr | ID | { statements } 或 for expr | &ID | { statements }
        parser_consume(parser);  // 消费 'for'
        
        const stmt: &ASTNode = ast_new_node(AST_FOR_STMT, line, column, parser.arena, parser.lexer.filename);
        if stmt == null {
            return null;
        }
        
        // 解析数组表达式
        const array_expr: &ASTNode = parser_parse_expression(parser);
        if array_expr == null {
            return null;
        }
        stmt.for_stmt_array = array_expr;
        
        // 期望 '|'
        if parser_expect(parser, TokenType.TOKEN_PIPE) == null {
            return null;
        }
        
        // 检查是否为引用迭代（&ID）还是值迭代（ID）
        var is_ref: i32 = 0;
        if parser_match(parser, TokenType.TOKEN_AMPERSAND) != 0 {
            // 引用迭代：for expr | &ID | { ... }
            parser_consume(parser);  // 消费 '&'
            is_ref = 1;
        }
        
        // 期望循环变量名称
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const var_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if var_name == null {
            return null;
        }
        stmt.for_stmt_var_name = var_name;
        parser_consume(parser);  // 消费变量名称
        
        // 期望 '|'
        if parser_expect(parser, TokenType.TOKEN_PIPE) == null {
            return null;
        }
        
        stmt.for_stmt_is_ref = is_ref;
        
        // 解析循环体（代码块）
        const body: &ASTNode = parser_parse_block(parser);
        if body == null {
            return null;
        }
        stmt.for_stmt_body = body;
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_CONST) != 0 || parser_match(parser, TokenType.TOKEN_VAR) != 0 {
        // 解析变量声明
        var is_const: i32 = 0;
        if parser_match(parser, TokenType.TOKEN_CONST) != 0 {
            is_const = 1;
        }
        parser_consume(parser);  // 消费 'const' 或 'var'
        
        // 期望变量名称
        if parser_match(parser, TokenType.TOKEN_IDENTIFIER) == 0 {
            return null;
        }
        
        const var_name: &byte = arena_strdup_for_parser(parser.arena, parser.current_token.value);
        if var_name == null {
            return null;
        }
        
        parser_consume(parser);  // 消费变量名称
        
        const stmt: &ASTNode = ast_new_node(AST_VAR_DECL, line, column, parser.arena, parser.lexer.filename);
        if stmt == null {
            return null;
        }
        
        stmt.var_decl_name = var_name;
        stmt.var_decl_is_const = is_const;
        
        // 期望 ':'
        if parser_expect(parser, TokenType.TOKEN_COLON) == null {
            return null;
        }
        
        // 解析类型
        const type: &ASTNode = parser_parse_type(parser);
        if type == null {
            return null;
        }
        stmt.var_decl_type = type;
        
        // 期望 '='
        if parser_expect(parser, TokenType.TOKEN_ASSIGN) == null {
            return null;
        }
        
        // 解析初始值表达式
        const init: &ASTNode = parser_parse_expression(parser);
        if init == null {
            return null;
        }
        stmt.var_decl_init = init;
        
        // 期望 ';'
        if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
            return null;
        }
        
        return stmt;
    }
    
    if parser_match(parser, TokenType.TOKEN_LEFT_BRACE) != 0 {
        // 解析代码块语句
        return parser_parse_block(parser);
    }
    
    // 解析表达式语句（表达式后加分号）
    // 注意：AST_EXPR_STMT 节点在 union 中没有对应的数据结构
    // 根据 ast.c 的注释，表达式语句的数据存储在表达式的节点中
    // 所以这里直接返回表达式节点（表达式节点本身可以作为语句）
    const expr: &ASTNode = parser_parse_expression(parser);
    if expr == null {
        return null;
    }
    
    // 期望 ';'
    if parser_expect(parser, TokenType.TOKEN_SEMICOLON) == null {
        return null;
    }
    
    // 直接返回表达式节点（表达式节点可以作为语句）
    return expr;
}
