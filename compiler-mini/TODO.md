# Uya Mini 编译器实现待办事项

本文档跟踪 Uya Mini 编译器的详细实现任务列表。

## 代码质量约束（严格执行）

- ✅ 所有代码必须使用**中文注释**
- ✅ **每个函数不超过 200 行**（严格限制）
- ✅ **每个源文件不超过 1500 行**（严格限制）
- ✅ 禁止使用堆分配（不能使用 `malloc`、`calloc`、`realloc`、`free`）
- ✅ 使用 Arena 分配器管理内存
- ✅ 使用 C99 标准
- ✅ 使用 LLVM C API 生成二进制代码
- ✅ **必须遵循 TDD（测试驱动开发）流程**
- ✅ **功能必须完整实现，不能简化，不能偷懒**

## TDD 开发流程（强制要求）

每个功能实现必须遵循以下流程：

1. **Red（红）**：先编写测试用例，运行测试确保失败
2. **Green（绿）**：实现最小代码使测试通过
3. **Refactor（重构）**：重构优化代码，保持测试通过

**重要原则**：
- 不能跳过测试步骤
- 不能简化功能实现
- 可以分部实现（多次会话完成一个模块）

## 重要参考文档

- `spec/UYA_MINI_SPEC.md` - **Uya Mini 语言规范（必须参考）**
- `../uya.md` - Uya 语言完整规范
- `../uya_ai_prompt.md` - Uya 语言 AI 提示词
- `../compiler/architecture.md` - Uya 编译器架构设计

---

## 阶段1：项目初始化 ✅

### 1.1 创建项目结构

- [x] 创建 `compiler-mini/` 目录
- [x] 创建 `spec/` 目录
- [x] 创建语言规范文档 `spec/UYA_MINI_SPEC.md`
- [ ] 创建 `src/` 目录
- [ ] 创建 `tests/` 目录

### 1.2 创建开发文档

- [x] 创建 `.cursorrules` 规则文件
- [x] 创建 `CONTEXT_SWITCH.md` 上下文切换指南
- [x] 创建 `TODO.md` 待办事项文档
- [ ] 创建 `PROGRESS.md` 进度跟踪文档
- [ ] 创建 `README.md` 项目说明文档

### 1.3 配置构建系统

- [ ] 创建 `Makefile`
  - [ ] 配置 C99 编译选项（`-Wall -Wextra -pedantic -std=c99`）
  - [ ] 配置 LLVM 库链接（`-llvm` 或具体库路径）
  - [ ] `make build` - 构建编译器
  - [ ] `make test` - 运行测试
  - [ ] `make clean` - 清理编译产物

---

## 阶段2：实现 Arena 分配器

### 2.1 Arena 分配器接口

- [ ] 创建 `src/arena.h`
  - [ ] 定义 Arena 结构体（包含静态缓冲区、当前指针、大小等字段）
  - [ ] 声明 `arena_alloc(size)` - 分配内存
  - [ ] 声明 `arena_reset()` - 重置分配器
  - [ ] 声明 `arena_init()` - 初始化 Arena（可选）
  - [ ] 添加中文注释说明

### 2.2 Arena 分配器实现

- [ ] 创建 `src/arena.c`
  - [ ] 定义静态缓冲区（例如 1MB）
  - [ ] 实现 `arena_alloc(size)` - 从缓冲区分配内存（bump pointer）
  - [ ] 实现 `arena_reset()` - 重置指针到开始位置
  - [ ] 实现内存对齐（如果需要）
  - [ ] 添加中文注释说明
  - [ ] 验证代码可以编译

### 2.3 Arena 分配器测试

- [ ] 创建简单测试用例验证 Arena 分配器功能
- [ ] 测试基本分配功能
- [ ] 测试重置功能
- [ ] 测试内存对齐（如果有）

---

## 阶段3：实现 AST 数据结构

### 3.1 AST 节点类型定义

- [ ] 创建 `src/ast.h`
  - [ ] 定义 ASTNodeType 枚举（仅包含最小子集需要的节点类型）
    - [ ] 程序节点、函数声明、结构体声明、变量声明
    - [ ] 表达式节点：二元运算、一元运算、标识符、数字、布尔、函数调用
    - [ ] 结构体相关：结构体字面量、字段访问
    - [ ] 语句节点：return、if、while、赋值、表达式语句、代码块
  - [ ] 定义基础 ASTNode 结构体
  - [ ] 定义各种 AST 节点数据结构的 union
  - [ ] 添加中文注释说明

### 3.2 AST 节点创建函数（TDD）

#### TDD Red: 编写测试

- [ ] 创建测试文件
  - [ ] 测试各种节点类型的创建
  - [ ] 运行测试确保失败

#### TDD Green: 实现功能

- [ ] 创建 `src/ast.c`
  - [ ] 实现 `ast_new_node()` - 创建 AST 节点（使用 Arena 分配）
  - [ ] 实现 `ast_free()` - 释放 AST 节点（可选，因为使用 Arena）
  - [ ] 实现各种节点类型的创建辅助函数
  - [ ] 添加中文注释说明
  - [ ] 运行测试确保通过
  - [ ] **验证函数 < 200 行，文件 < 1500 行**

#### TDD Refactor: 优化

- [ ] 代码审查和重构
- [ ] 运行测试确保通过

---

## 阶段4：实现词法分析器（Lexer）

### 4.1 Token 类型定义

- [ ] 创建 `src/lexer.h`
  - [ ] 定义 TokenType 枚举（仅包含最小子集需要的 Token）
    - [ ] 基础：EOF、IDENTIFIER、NUMBER、布尔字面量
    - [ ] 关键字：struct、const、var、fn、return、if、else、while、true、false
    - [ ] 运算符：+、-、*、/、%、==、!=、<、>、<=、>=、&&、||、!
    - [ ] 标点符号：(、)、{、}、;、,、=、.
  - [ ] 定义 Token 结构体（值、行号、列号等）
  - [ ] 添加中文注释说明

### 4.2 Lexer 结构定义

- [ ] 在 `src/lexer.h` 中定义 Lexer 结构体
  - [ ] 源代码缓冲区（固定大小数组）
  - [ ] 当前位置、行号、列号
  - [ ] 文件名（如果需要）
  - [ ] 添加中文注释说明

### 4.3 Lexer 核心实现（TDD，可以分部实现）

#### TDD Red: 编写测试

- [ ] 创建测试文件
  - [ ] 测试 `lexer_new()` 创建功能
  - [ ] 测试标识符识别
  - [ ] 测试关键字识别
  - [ ] 测试数字识别
  - [ ] 测试运算符识别
  - [ ] 运行测试确保失败

#### TDD Green: 实现功能（可以分多次会话完成）

- [ ] 创建 `src/lexer.c`
  - [ ] 实现 `lexer_new()` - 创建 Lexer（读取文件到固定大小缓冲区）
  - [ ] 实现 `lexer_next_token()` - 获取下一个 Token
  - [ ] 实现标识符和关键字识别
  - [ ] 实现数字字面量识别
  - [ ] 实现运算符和标点符号识别
  - [ ] 实现注释处理（`//` 单行注释）
  - [ ] 实现空白字符跳过
  - [ ] 所有字符串存储在 Arena 中
  - [ ] 添加中文注释说明
  - [ ] 运行测试确保通过
  - [ ] **验证函数 < 200 行，文件 < 1500 行**
  - [ ] **如果文件超过 1500 行，必须拆分为多个文件**

#### TDD Refactor: 优化

- [ ] 代码审查和重构
- [ ] 运行测试确保通过

### 4.4 Lexer 测试

- [ ] 创建测试用例验证 Lexer 功能
- [ ] 测试基本 Token 识别
- [ ] 测试关键字识别
- [ ] 测试数字识别
- [ ] 测试运算符识别

---

## 阶段5：实现语法分析器（Parser）

### 5.1 Parser 结构定义

- [ ] 创建 `src/parser.h`
  - [ ] 定义 Parser 结构体（Lexer 指针、当前 Token 等）
  - [ ] 声明解析函数
  - [ ] 添加中文注释说明

### 5.2 Parser 核心实现（TDD，必须分部实现）

**注意**：Parser 功能复杂，必须分多次会话完成，不能简化。

#### TDD Red: 编写测试

- [ ] 创建测试文件
  - [ ] 测试函数声明解析
  - [ ] 测试结构体声明解析
  - [ ] 测试表达式解析
  - [ ] 测试结构体字面量和字段访问解析
  - [ ] 运行测试确保失败

#### TDD Green: 实现功能（分多次会话）

**会话1：基础解析功能**
- [ ] 创建 `src/parser.c`
- [ ] 实现 `parser_new()` - 创建 Parser
- [ ] 实现 `parser_parse()` - 解析程序（顶层声明列表）
- [ ] 实现 `parser_parse_declaration()` - 解析声明基础框架
- [ ] 运行测试，更新 PROGRESS.md

**会话2：函数和结构体解析**
- [ ] 实现 `parser_parse_function()` - 解析函数声明（完整实现，不能简化）
- [ ] 实现 `parser_parse_struct()` - 解析结构体声明（完整实现，不能简化）
- [ ] 运行测试，更新 PROGRESS.md

**会话3：语句解析**
- [ ] 实现 `parser_parse_statement()` - 解析语句（完整实现）
- [ ] 运行测试，更新 PROGRESS.md

**会话4：表达式解析**
- [ ] 实现 `parser_parse_expression()` - 解析表达式（完整实现，不能简化）
- [ ] 实现结构体字面量解析（完整实现）
- [ ] 实现字段访问解析（完整实现）
- [ ] 运行测试，更新 PROGRESS.md

**所有会话完成后：**
- [ ] 所有 AST 节点从 Arena 分配
- [ ] 添加中文注释说明
- [ ] **验证每个函数 < 200 行，文件 < 1500 行**
- [ ] **如果文件超过 1500 行，拆分为 parser_*.c 多个文件**

#### TDD Refactor: 优化

- [ ] 代码审查和重构
- [ ] 运行所有测试确保通过

### 5.3 Parser 测试

- [ ] 创建测试用例验证 Parser 功能
- [ ] 测试函数解析
- [ ] 测试结构体解析
- [ ] 测试表达式解析
- [ ] 测试结构体字面量和字段访问解析

---

## 阶段6：实现类型检查器（Checker）

### 6.1 Checker 结构定义

- [ ] 创建 `src/checker.h`
  - [ ] 定义 TypeChecker 结构体
  - [ ] 定义符号表结构（使用固定大小哈希表）
  - [ ] 定义类型结构（基础类型、结构体类型）
  - [ ] 添加中文注释说明

### 6.2 Checker 核心实现（TDD，可以分部实现）

#### TDD Red: 编写测试

- [ ] 创建测试文件
  - [ ] 测试变量类型检查
  - [ ] 测试函数调用类型检查
  - [ ] 测试结构体类型检查
  - [ ] 运行测试确保失败

#### TDD Green: 实现功能（可以分多次会话）

- [ ] 创建 `src/checker.c`
  - [ ] 实现 `checker_new()` - 创建 TypeChecker
  - [ ] 实现 `checker_check()` - 类型检查主函数
  - [ ] 实现变量类型检查（完整实现，不能简化）
  - [ ] 实现函数调用类型检查（参数匹配、返回值类型，完整实现）
  - [ ] 实现结构体类型检查（完整实现，不能简化）
    - [ ] 结构体定义检查
    - [ ] 字段访问检查
    - [ ] 结构体字面量检查
    - [ ] 结构体比较检查
  - [ ] 实现运算符类型检查（完整实现）
  - [ ] 实现符号表（固定大小哈希表，开放寻址，完整实现）
  - [ ] 添加中文注释说明
  - [ ] 运行测试确保通过
  - [ ] **验证函数 < 200 行，文件 < 1500 行**

#### TDD Refactor: 优化

- [ ] 代码审查和重构
- [ ] 运行测试确保通过

### 6.3 Checker 测试

- [ ] 创建测试用例验证 Checker 功能
- [ ] 测试类型匹配检查
- [ ] 测试函数调用检查
- [ ] 测试结构体类型检查

---

## 阶段7：实现代码生成器（CodeGen，LLVM C API）

### 7.1 CodeGen 结构定义

- [ ] 创建 `src/codegen.h`
  - [ ] 定义 CodeGenerator 结构体
  - [ ] 声明代码生成函数
  - [ ] 包含 LLVM C API 头文件
  - [ ] 添加中文注释说明

### 7.2 CodeGen 核心实现（TDD，必须分部实现）

**注意**：CodeGen 功能复杂，必须分多次会话完成，不能简化。

#### TDD Red: 编写测试

- [ ] 创建测试文件
  - [ ] 测试基础类型代码生成
  - [ ] 测试函数代码生成
  - [ ] 测试结构体代码生成
  - [ ] 运行测试确保失败

#### TDD Green: 实现功能（分多次会话）

**会话1：基础框架和类型映射**
- [ ] 创建 `src/codegen.c`
- [ ] 实现 `codegen_new()` - 创建 CodeGenerator
- [ ] 实现 `codegen_generate()` - 代码生成主函数框架
- [ ] 实现 LLVM 模块和上下文创建
- [ ] 实现基础类型到 LLVM 类型映射（完整实现）
  - [ ] i32 → LLVMInt32Type()
  - [ ] bool → LLVMInt1Type()
  - [ ] void → LLVMVoidType()
- [ ] 运行测试，更新 PROGRESS.md

**会话2：结构体类型映射**
- [ ] 实现结构体类型到 LLVM 类型映射（完整实现，不能简化）
  - [ ] 使用 LLVMStructType() 创建结构体类型
- [ ] 运行测试，更新 PROGRESS.md

**会话3：表达式代码生成**
- [ ] 实现表达式代码生成（完整实现，不能简化）
- [ ] 运行测试，更新 PROGRESS.md

**会话4：语句代码生成**
- [ ] 实现语句代码生成（完整实现，不能简化）
- [ ] 运行测试，更新 PROGRESS.md

**会话5：函数代码生成**
- [ ] 实现函数代码生成（完整实现，不能简化）
- [ ] 运行测试，更新 PROGRESS.md

**会话6：结构体处理**
- [ ] 实现结构体处理（完整实现，不能简化）
  - [ ] 结构体字面量生成（LLVMConstStruct()）
  - [ ] 字段访问生成（LLVMBuildExtractValue()）
  - [ ] 字段赋值生成（LLVMBuildInsertValue()）
  - [ ] 结构体比较生成（逐字段比较）
- [ ] 运行测试，更新 PROGRESS.md

**会话7：目标代码生成和清理**
- [ ] 实现目标代码生成（LLVMTargetMachineEmitToFile()）
- [ ] 实现资源清理
- [ ] 运行测试，更新 PROGRESS.md

**所有会话完成后：**
- [ ] 添加中文注释说明
- [ ] **验证函数 < 200 行，文件 < 1500 行**
- [ ] **如果文件超过 1500 行，拆分为 codegen_*.c 多个文件**
- [ ] 验证代码可以编译并链接 LLVM 库

#### TDD Refactor: 优化

- [ ] 代码审查和重构
- [ ] 运行所有测试确保通过

### 7.3 CodeGen 测试

- [ ] 创建测试用例验证 CodeGen 功能
- [ ] 测试基础类型代码生成
- [ ] 测试函数代码生成
- [ ] 测试结构体代码生成
- [ ] 测试生成的二进制文件可以执行

---

## 阶段8：实现主程序（Main）

### 8.1 Main 程序实现

- [ ] 创建 `src/main.c`
  - [ ] 实现 main() 函数
  - [ ] 实现命令行参数解析
  - [ ] 实现编译流程协调
    - [ ] 创建 Arena 分配器
    - [ ] 创建 Lexer
    - [ ] 创建 Parser 并解析
    - [ ] 创建 Checker 并类型检查
    - [ ] 创建 CodeGen 并生成代码
  - [ ] 实现错误处理
  - [ ] 实现资源清理
  - [ ] 添加中文注释说明
  - [ ] 验证程序可以编译并运行

### 8.2 主程序测试

- [ ] 测试命令行参数解析
- [ ] 测试完整编译流程
- [ ] 测试错误处理

---

## 阶段9：测试和验证

### 9.1 功能测试

- [ ] 创建基础类型测试用例
- [ ] 创建函数测试用例
- [ ] 创建结构体测试用例
- [ ] 创建控制流测试用例（if、while）
- [ ] 创建表达式测试用例

### 9.2 集成测试

- [ ] 测试完整程序编译
- [ ] 测试生成的二进制文件执行
- [ ] 验证输出结果正确性

---

## 阶段10：将 C99 编译器翻译成 Uya（未来）

### 10.1 分析 C99 代码

- [ ] 识别需要转换的 C 特性
- [ ] 规划 Uya 语法表达方式

### 10.2 逐步翻译

- [ ] Arena 分配器 → Uya
- [ ] Lexer → Uya
- [ ] Parser → Uya
- [ ] Checker → Uya
- [ ] CodeGen → Uya（调用 LLVM C API）
- [ ] Main → Uya

### 10.3 自举测试

- [ ] 使用 Uya 编译器编译自身
- [ ] 验证自举成功

---

## 技术要点总结

1. **TDD 驱动**：所有功能必须遵循 TDD 流程（Red-Green-Refactor）
2. **完整实现**：不能简化功能，不能偷懒，必须完整实现
3. **分部实现**：可以分多次会话完成一个模块，但必须完整实现
4. **代码质量**：函数 < 200 行，文件 < 1500 行（严格限制）
5. **无堆分配**：所有数据结构使用固定大小数组，通过 Arena 分配器管理
6. **中文注释**：所有代码必须使用中文注释
7. **结构体支持**：Uya Mini 包含结构体支持，编译器内部可以使用结构体
8. **LLVM C API**：使用 LLVM C API 直接从 AST 生成二进制
9. **参考规范**：实现前必须参考 `spec/UYA_MINI_SPEC.md`

