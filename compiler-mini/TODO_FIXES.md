# Uya Mini 编译器修复待办事项

本文档列出了当前编译器实现与规范文档（`spec/UYA_MINI_SPEC.md`）不一致的地方，需要修复的问题。

**生成日期**：2026-01-13  
**规范版本**：UYA_MINI_SPEC.md（基于 Uya 0.29）

---

## 概述

对照规范文档检查当前实现后，发现以下需要修复的问题：

1. **usize 类型缺失**：规范要求支持 `usize` 类型，但代码中完全没有实现
2. **枚举类型支持不一致**：规范明确说明不支持枚举，但代码中实现了完整的枚举支持
3. **算术运算符类型规则不符合规范**：规范允许 `i32` 和 `usize` 混合运算，但代码只支持 `i32`
4. **指针大小硬编码**：代码中硬编码指针大小为 8 字节（64位平台），应支持平台相关
5. **结构体内存布局验证**：需要验证是否符合规范中的详细内存布局规则

---

## 问题详细说明

### 1. ❌ usize 类型缺失（P0 - 高优先级）

**问题描述**：
- 规范要求支持 `usize` 类型（平台相关的无符号大小类型）
- 32位平台：`usize` = `u32`（4 字节）
- 64位平台：`usize` = `u64`（8 字节）
- 用途：表示指针大小、数组索引、内存大小等平台相关的值
- **当前代码中完全没有 `TYPE_USIZE` 或 `usize` 的实现**

**影响范围**：
- 类型系统（`checker.h`）：需要添加 `TYPE_USIZE`
- 词法分析器（`lexer.c`）：需要识别 `usize` 关键字（已支持？需验证）
- 语法分析器（`parser.c`）：需要支持 `usize` 类型解析
- 类型检查器（`checker.c`）：
  - 需要支持 `usize` 类型检查
  - 需要支持 `i32` 和 `usize` 混合算术运算
  - 需要支持 `i32 ↔ usize` 类型转换
- 代码生成器（`codegen.c`）：
  - 需要根据目标平台映射 `usize` 到 `LLVMInt32Type()` 或 `LLVMInt64Type()`
  - 需要支持 `usize` 类型的代码生成

**修复任务**：
- [ ] 在 `checker.h` 的 `TypeKind` 枚举中添加 `TYPE_USIZE`
- [ ] 在 `checker.c` 的 `type_from_ast()` 函数中添加 `usize` 类型识别
- [ ] 在 `codegen.c` 的 `codegen_get_base_type()` 函数中添加 `TYPE_USIZE` 支持
- [ ] 在 `codegen.c` 的 `get_llvm_type_from_ast()` 函数中添加 `usize` 类型映射（根据目标平台）
- [ ] 修改算术运算符类型检查规则（`checker_check_binary_expr()`），支持 `i32` 和 `usize` 混合运算
- [ ] 修改算术运算符代码生成（`codegen_gen_expr()`），支持混合类型运算
- [ ] 添加 `i32 ↔ usize` 类型转换支持（`as` 关键字）
- [ ] 添加 `usize` 类型相关测试用例

**参考规范章节**：
- 2.1 支持的类型（第 101-107 行）
- 4.7 表达式 - 运算符说明（第 595-598 行）
- 4.8 类型转换（第 632-636 行）

---

### 2. ⚠️ 枚举类型支持不一致（P1 - 中优先级）

**问题描述**：
- 规范明确说明"不支持的特性：枚举"（第 33 行）
- 但当前代码中实现了完整的枚举支持：
  - `TYPE_ENUM` 在 `checker.h` 中定义
  - `AST_ENUM_DECL` 在 `ast.h` 中定义
  - `checker.c` 中有完整的枚举类型检查逻辑
  - `codegen.c` 中有完整的枚举代码生成逻辑
  - 测试文件中有多个枚举测试用例（5个测试文件：`test_enum_basic.uya`、`test_enum_auto_increment.uya`、`test_enum_explicit_value.uya`、`test_enum_mixed_value.uya`、`test_enum_sizeof.uya`）
- README.md 中也提到"枚举支持"

**实际情况**：
- 代码已经完整实现了枚举支持，包括：
  - 枚举声明（`enum Name { ... }`）
  - 枚举值访问（`EnumName.VariantName`）
  - 显式赋值（`Variant = 42`）
  - 自动递增（默认从 0 开始递增）
  - 混合赋值（部分显式，部分自动）
  - 枚举比较（`==`、`!=`、`<`、`>` 等）
  - 枚举 sizeof（返回 i32 类型，大小为 4 字节，因为枚举在 LLVM 中映射为 i32）

**决策**：**保留枚举支持，更新规范文档**
- 原因：
  - 代码已经完整实现枚举支持，且有完整的测试用例
  - README.md 中明确说明支持枚举
  - 移除枚举支持需要大量工作，且会影响现有测试
  - 枚举是常见语言特性，有助于代码可读性

**修复任务**：
- [ ] 更新 `UYA_MINI_SPEC.md` 规范文档：
  - 从"不支持的特性"列表中移除"枚举"
  - 在"核心特性"部分添加枚举支持说明
  - 添加枚举类型的语法和语义规则（2.1 支持的类型、4.2 语法规范等）
  - 添加枚举类型相关章节（语法、语义、示例等）
- [ ] 验证规范文档与实现的一致性

**参考规范章节**：
- 核心特性 - 不支持的特性（第 32-39 行）
- 需要更新为支持的特性

**状态**：待更新规范文档

---

### 3. ❌ 算术运算符类型规则不符合规范（P0 - 高优先级）

**问题描述**：
- 规范要求：`i32` 和 `usize` 可以混合运算
  - 如果两个操作数都是 `i32`，结果为 `i32`
  - 如果至少有一个是 `usize`，结果为 `usize`
- **当前实现**：`checker_check_binary_expr()` 函数中只允许 `i32` 类型（第 1178 行）
  ```c
  if (left_type.kind != TYPE_I32 || right_type.kind != TYPE_I32) {
      checker_report_error(checker);
      return result;
  }
  ```

**修复任务**：
- [ ] 修改 `checker_check_binary_expr()` 函数，支持 `i32` 和 `usize` 混合运算
- [ ] 实现结果类型推断规则：如果至少有一个是 `usize`，结果为 `usize`
- [ ] 修改代码生成器，支持混合类型算术运算（需要类型提升）
- [ ] 添加混合类型运算测试用例

**参考规范章节**：
- 4.7 表达式 - 运算符说明（第 595-598 行）

**注意**：此问题与问题 1（usize 类型缺失）相关，需要先实现 `usize` 类型。

---

### 4. ⚠️ 指针大小硬编码（P1 - 中优先级）

**问题描述**：
- 规范要求：指针大小应平台相关（32位平台=4字节，64位平台=8字节）
- **当前实现**：在 `codegen.c` 的 `sizeof` 实现中硬编码为 8 字节（第 1888-1890 行）
  ```c
  case LLVMPointerTypeKind:
      // 指针类型：64位平台为 8 字节，32位平台为 4 字节
      // 这里假设 64 位平台（简化实现）
      size = 8;
      break;
  ```
- 同样的问题也出现在数组元素大小计算中（第 1902-1903 行）

**修复任务**：
- [ ] 使用 LLVM TargetData API 获取指针大小（而不是硬编码）
- [ ] 修改 `codegen.c` 中的 `sizeof` 实现，使用 `LLVMPointerSize()` 或类似 API
- [ ] 修改数组元素大小计算中的指针大小处理
- [ ] 验证 32 位和 64 位平台的指针大小正确性

**参考规范章节**：
- 2.1 支持的类型 - 指针类型（第 108-112 行）

---

### 5. ⚠️ 结构体内存布局验证（P1 - 中优先级）

**问题描述**：
- 规范中详细定义了结构体内存布局规则（2.3 节）：
  - 字段对齐规则
  - 字段偏移计算（`align_up` 函数）
  - 填充字节（明确为 0 填充）
  - 嵌套结构体布局
  - 数组字段布局
  - 结构体大小和对齐
  - 平台差异
- **当前实现**：使用 LLVM 的 `LLVMStructType()` 和 TargetData API 来处理结构体布局
- 需要验证 LLVM 的布局是否符合规范要求（特别是填充字节内容）

**验证任务**：
- [ ] 验证字段对齐规则是否符合规范
- [ ] 验证字段偏移计算是否正确
- [ ] 验证填充字节是否为 0（规范明确要求）
- [ ] 验证嵌套结构体布局
- [ ] 验证数组字段布局
- [ ] 验证结构体大小和对齐计算
- [ ] 创建测试用例验证各种结构体布局场景

**参考规范章节**：
- 2.3 结构体内存布局详细规则（第 120-277 行）

---

## 修复优先级

| 优先级 | 问题 | 原因 |
|--------|------|------|
| P0 | usize 类型缺失 | 规范核心特性，影响其他功能 |
| P0 | 算术运算符类型规则 | 与 usize 相关，规范明确要求 |
| P1 | 枚举类型支持不一致 | 需要决策，影响代码一致性 |
| P1 | 指针大小硬编码 | 影响跨平台支持 |
| P1 | 结构体内存布局验证 | 需要验证，可能已正确但需确认 |

---

## 修复顺序建议

1. **更新规范文档以反映枚举支持**（已决策：保留枚举）
   - 更新 `UYA_MINI_SPEC.md`，添加枚举支持说明
   - 从"不支持的特性"列表中移除"枚举"

2. **实现 usize 类型支持**（问题 1）
   - 这是基础类型，其他功能依赖它

3. **修复算术运算符类型规则**（问题 3）
   - 依赖于 usize 类型的实现

4. **修复指针大小硬编码**（问题 4）
   - 独立问题，不影响其他功能

5. **验证结构体内存布局**（问题 5）
   - 需要详细的测试和验证

---

## 注意事项

1. **测试覆盖**：修复每个问题后，需要添加相应的测试用例
2. **向后兼容**：更新规范文档时需要保持与现有实现的兼容性
3. **平台支持**：修复指针大小和 usize 类型时，需要考虑 32 位和 64 位平台
4. **文档更新**：修复后需要更新 README.md 和相关文档

---

## 相关文件

- **规范文档**：`compiler-mini/spec/UYA_MINI_SPEC.md`
- **类型定义**：`compiler-mini/src/checker.h`
- **AST 定义**：`compiler-mini/src/ast.h`
- **类型检查**：`compiler-mini/src/checker.c`
- **代码生成**：`compiler-mini/src/codegen.c`
- **项目 README**：`compiler-mini/README.md`

---

## 更新日志

- 2026-01-13：初始版本，基于规范文档检查生成
- 2026-01-13：更新枚举类型支持不一致问题的处理方式，决定保留枚举支持并更新规范文档

