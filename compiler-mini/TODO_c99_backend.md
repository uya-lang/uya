# C99 后端实现任务

## 概述

为 Uya Mini 编译器添加 C99 后端，支持将 Uya Mini 代码编译为 C99 代码。主要功能：
- 通过 `-o xxx.c` 选项输出 C99 源代码文件
- 通过 `--exec` 选项调用 `gcc --std=c99` 编译生成二进制可执行文件
- 保持与现有 LLVM 后端相同的语义和功能

**优先级**：P0（最高）

**工作量估算**：15-20 小时

**依赖**：
- 现有编译器前端（Lexer、Parser、Checker）必须正常工作
- 现有 AST 结构（ast.h）必须稳定

---

## 现有架构分析

### 当前代码生成器架构

1. **主要文件**：
   - `src/codegen/` - LLVM 后端实现
   - `src/codegen/main.c` - 代码生成器入口（`codegen_generate` 函数）
   - `src/codegen.h` - 代码生成器接口定义
   - `src/codegen/internal.h` - 内部函数声明

2. **核心结构**：
   ```c
   typedef struct CodeGenerator {
       Arena *arena;
       LLVMContextRef context;
       LLVMModuleRef module;
       LLVMBuilderRef builder;
       const char *module_name;
       
       // 类型映射表
       struct StructTypeMap struct_types[64];
       int struct_type_count;
       
       // 变量表
       struct VarMap var_map[256];
       int var_map_count;
       
       // 函数表
       struct FuncMap func_map[256];
       int func_map_count;
       
       // 全局变量表
       struct GlobalVarMap global_var_map[128];
       int global_var_map_count;
       
       // 循环栈
       struct {
           LLVMBasicBlockRef cond_bb;
           LLVMBasicBlockRef end_bb;
           LLVMBasicBlockRef inc_bb;
       } loop_stack[LOOP_STACK_SIZE];
       int loop_stack_depth;
       
       ASTNode *program_node;
   } CodeGenerator;
   ```

3. **代码生成流程**（`codegen_generate` 函数）：
   - 第零步：初始化 LLVM 目标和数据布局
   - 第一步：预注册所有结构体名称作为占位符
   - 第二步：注册所有结构体类型（填充字段）
   - 第三步：生成所有全局变量
   - 第四步：声明所有函数
   - 第五步：生成所有函数的函数体
   - 第六步：生成目标代码（LLVM IR → 目标文件）

### 需要生成的 C99 代码特征

1. **类型映射**：
   - `i32` → `int32_t`（需要包含 `<stdint.h>`）
   - `usize` → `size_t`（需要包含 `<stddef.h>`）
   - `bool` → `_Bool`（C99 原生布尔类型，或包含 `<stdbool.h>` 使用 `bool`）
   - `byte` → `uint8_t`
   - `void` → `void`
   - `&T` → `T*`（普通指针）
   - `*T` → `T*`（FFI 指针，与普通指针相同）
   - `[T: N]` → `T[N]`（固定大小数组）
   - `struct Name` → `struct Name`

2. **内存布局**：
   - 结构体字段对齐必须与 C99 编译器默认对齐一致
   - 使用 `_Alignas` 或 `#pragma pack` 确保跨平台兼容性

3. **控制流**：
   - `if`、`while`、`for`（数组遍历）直接映射为 C 对应语句
   - `break`、`continue` 直接映射

4. **函数调用**：
   - 普通函数调用直接映射
   - 外部函数（`extern fn`）需要声明为外部函数

5. **全局变量**：
   - `const` 变量生成 `const` 限定符
   - `var` 变量生成普通变量

---

## 任务列表

### 任务 1：设计 C99 后端架构

**目标**：设计 C99 后端的数据结构和接口，保持与现有 LLVM 后端兼容。

- [x] 分析现有 `CodeGenerator` 结构体，识别 LLVM 特定字段
- [x] 设计通用的 `CodeGenerator` 基类或接口
- [x] 设计 `C99CodeGenerator` 结构体，包含：
  - 输出文件指针（FILE*）
  - 当前缩进级别
  - 字符串常量表
  - 结构体定义表
  - 函数声明表
  - 全局变量表
- [x] 确定代码生成接口：
  - `c99_codegen_new()` - 初始化
  - `c99_codegen_generate()` - 主生成函数
  - `c99_codegen_gen_function()` - 生成单个函数
  - `c99_codegen_gen_expr()` - 生成表达式
  - `c99_codegen_gen_stmt()` - 生成语句

**输出**：`src/codegen_c99.h` 设计文档 ✅ 已完成

**状态**：✅ 已完成（2026-01-26）- 架构设计已确定，接口定义完成

---

### 任务 2：创建 C99 后端基础框架

**目标**：实现 C99 后端的基础框架，包括文件输出、缩进管理、字符串常量处理。

- [x] 创建 `src/codegen_c99.h` 头文件
- [x] 创建 `src/codegen_c99.c` 源文件
- [x] 实现 `C99CodeGenerator` 结构体定义
- [x] 实现基础输出函数：
  - `c99_emit()` - 基本输出
  - `c99_emit_indent()` - 带缩进输出
  - `c99_emit_newline()` - 换行
  - `c99_emit_comment()` - 输出注释
- [x] 实现缩进管理函数：
  - `c99_indent()` - 增加缩进
  - `c99_unindent()` - 减少缩进
- [x] 实现字符串常量管理：
  - `c99_add_string_literal()` - 添加字符串常量
  - `c99_emit_string_constants()` - 输出所有字符串常量定义

**输出**：`src/codegen_c99.c/h` 基础框架 ✅ 已完成

**状态**：✅ 已完成（2026-01-26）- 基础框架实现完成，包括输出管理、缩进控制、字符串常量表

---

### 任务 3：实现类型系统映射

**目标**：将 Uya Mini 类型映射为 C99 类型，处理结构体定义。

- [x] 实现类型映射函数 `c99_type_to_c()`：
  - [x] 基础类型（i32、usize、bool、byte、void）映射 ✅
  - [x] 指针类型映射（`&T` → `T*`，`*T` → `T*`） ✅
  - [x] 数组类型映射（`[T: N]` → `T[N]`） ✅（使用编译时常量表达式评估）
  - [x] 结构体类型映射（`struct Name` → `struct Name`） ✅
- [x] 实现结构体定义生成：
  - [x] `c99_gen_struct_forward_decl()` - 前向声明（通过 add_struct_definition 和 is_struct_defined 管理）
  - [x] `c99_gen_struct_definition()` - 完整定义（gen_struct_definition 函数）
  - [ ] 处理嵌套结构体
  - [ ] 处理字段对齐（当前使用默认对齐）
- [ ] 实现枚举类型映射：
  - [ ] `enum Name` → `enum Name`
  - [ ] 生成枚举常量定义

**输出**：大部分完成的类型映射功能 ✅ 基础类型、指针、数组、结构体支持已完成；枚举支持待完成

**状态**：✅ 已完成（2026-01-27）- 已完成：基础类型映射、指针类型、数组类型（含编译时常量表达式评估）、结构体定义；待完成：枚举类型、嵌套结构体处理、字段对齐

**备注**：数组大小评估已实现，支持编译时常量表达式（数字、二元运算符、一元运算符）。局部和全局数组变量声明已正确处理，结构体数组字段生成已实现。测试用例验证了数组类型生成正确。

**下一步**：
- 添加枚举类型映射和常量定义生成
- 测试嵌套结构体定义
- 考虑添加 `#pragma pack` 或 `_Alignas` 处理字段对齐

---

### 任务 4：实现表达式代码生成

**目标**：将各种 Uya Mini 表达式转换为 C99 表达式。

- [x] 实现 `c99_gen_expr()` 函数，支持以下节点类型：
  - [x] `AST_IDENTIFIER` - 标识符 ✅
  - [x] `AST_NUMBER` - 数字字面量 ✅
  - [x] `AST_BOOL` - 布尔字面量 ✅
  - [x] `AST_STRING` - 字符串字面量（引用字符串常量）✅
  - [x] `AST_BINARY_EXPR` - 二元表达式 ✅（支持算术、比较和逻辑运算符）
  - [x] `AST_UNARY_EXPR` - 一元表达式 ✅（包括取地址、解引用、正负号、逻辑非）
  - [x] `AST_CALL_EXPR` - 函数调用 ✅
  - [x] `AST_MEMBER_ACCESS` - 字段访问 ✅
  - [x] `AST_ARRAY_ACCESS` - 数组访问 ✅
  - [x] `AST_STRUCT_INIT` - 结构体字面量 ✅
  - [x] `AST_ARRAY_LITERAL` - 数组字面量 ✅
  - [x] `AST_SIZEOF` - sizeof 表达式 ✅
  - [x] `AST_LEN` - len 表达式 ✅
  - [x] `AST_ALIGNOF` - alignof 表达式 ✅
  - [x] `AST_CAST_EXPR` - 类型转换 ✅
- [ ] 处理运算符优先级和括号（当前使用保守的括号）
- [x] 处理指针解引用（`*expr`）和取地址（`&expr`）✅（通过一元表达式实现）
- [ ] 处理结构体字段访问（自动解引用）

**输出**：基本完整的表达式生成功能 ✅ 支持所有主要表达式类型

**状态**：✅ 基本完成（2026-01-27）- 已完成所有主要表达式节点类型；待完成：运算符优先级优化、结构体字段自动解引用

**下一步**：
- 优化括号使用 - 根据运算符优先级决定是否加括号
- 实现结构体字段访问的自动解引用（指针->字段自动转为`->`）
- 完善数组字面量和结构体字面量的类型推断

---

### 任务 5：实现语句代码生成

**目标**：将各种 Uya Mini 语句转换为 C99 语句。

- [x] 实现 `c99_gen_stmt()` 函数，支持以下节点类型：
  - [x] `AST_EXPR_STMT` - 表达式语句 ✅（通过默认表达式节点处理）
  - [x] `AST_ASSIGN` - 赋值语句 ✅
  - [x] `AST_IF_STMT` - if 语句 ✅
  - [x] `AST_WHILE_STMT` - while 语句 ✅
  - [x] `AST_FOR_STMT` - for 循环（数组遍历）✅（基础实现）
  - [x] `AST_BREAK_STMT` - break 语句 ✅
  - [x] `AST_CONTINUE_STMT` - continue 语句 ✅
  - [x] `AST_RETURN_STMT` - return 语句 ✅
  - [x] `AST_BLOCK` - 代码块 ✅
- [x] 处理变量声明（`AST_VAR_DECL`）：
  - [ ] 全局变量声明
  - [x] 局部变量声明 ✅
  - [x] 函数参数 ✅（在函数参数列表中处理）
  - [x] 结构体字段 ✅（在结构体定义中处理）
- [ ] 处理作用域和变量生命周期（当前使用简单栈）
- [x] 处理循环控制（break/continue）✅（基础实现）

**输出**：基本完整的语句生成功能 ✅ 支持所有主要语句类型

**状态**：✅ 基本完成（2026-01-27）- 已完成所有主要语句节点类型；待完成：全局变量声明、作用域管理、for循环完善

**下一步**：
- 实现全局变量声明生成（const/var）
- 完善作用域管理 - 使用 local_variables 表跟踪变量生命周期
- 改进 for 循环实现，正确处理数组元素类型和引用迭代
- 实现循环栈（loop_stack）支持带标签的 break/continue

---

### 任务 6：实现函数和全局变量生成

**目标**：生成函数声明、定义和全局变量定义。

- [x] 实现 `c99_gen_function()` 函数：
  - [ ] 生成函数声明（外部函数）
  - [x] 生成函数定义（普通函数） ✅
  - [x] 处理参数列表 ✅
  - [x] 处理函数体 ✅
- [x] 实现 `c99_gen_global_var()` 函数：
  - [x] 生成全局常量（`const`） ✅
  - [x] 生成全局变量（`var`） ✅
  - [x] 处理初始化表达式 ✅
- [ ] 处理外部函数声明（`extern fn`）：
  - [ ] 生成相应的 C 函数声明
  - [ ] 处理 FFI 指针类型参数

**输出**：基本完整的函数和全局变量生成功能 ✅ 支持普通函数定义和全局变量（const/var）

**状态**：✅ 基本完成（2026-01-27）- 已完成：普通函数定义、参数列表、函数体、全局变量（const/var）定义、初始化表达式处理；待完成：外部函数声明、FFI指针参数处理

**下一步**：
- 实现外部函数声明生成（`extern fn` → C 函数声明）
- 处理 FFI 指针类型参数（`*T`）在 extern 函数中的映射
- 在文件顶部生成所有外部函数和全局变量的前向声明

---

### 任务 7：修改主程序和命令行解析

**目标**：扩展编译器以支持 C99 后端选项。

- [x] 修改 `src/main.c` 中的 `parse_args()` 函数：
  - [x] 添加 `--c99` 选项，显式选择 C99 后端 ✅
  - [x] 自动检测输出文件后缀：`.c` → C99 后端，`.o` → LLVM 后端 ✅
  - [x] 扩展 `--exec` 选项：调用 `gcc --std=c99` 编译 C99 代码 ✅
- [x] 修改 `compile_files()` 函数：
  - [x] 根据选项选择后端（LLVM 或 C99） ✅
  - [x] 调用相应的 `codegen_generate()` 函数 ✅
- [x] 添加 C99 后端链接：
  - [x] 在 Makefile 中添加 `codegen_c99.c` 编译选项 ✅
  - [x] 确保编译器可以同时链接 LLVM 和 C99 后端 ✅

**输出**：支持 C99 后端选择的编译器 ✅

**状态**：✅ 已完成（2026-01-26）- 主程序已完整集成 C99 后端支持，包括命令行选项解析、后端选择、自动编译和链接

**说明**：
- `--c99` 选项已添加，可显式选择 C99 后端
- 输出文件后缀自动检测：`.c` 文件自动使用 C99 后端
- `-exec` 选项支持 C99 后端：自动调用 `gcc --std=c99` 编译生成的 C 代码
- Makefile 已更新，支持同时编译 LLVM 和 C99 后端代码
- 多文件编译支持已集成到 C99 后端

---

### 任务 8：实现 C99 代码生成器入口

**目标**：实现 `c99_codegen_generate()` 函数，协调整个 C99 代码生成流程。

- [x] 实现主生成流程：
  - [x] 生成文件头（包含头文件、注释）✅
  - [x] 生成所有结构体定义 ✅
  - [x] 生成所有枚举定义 ✅
  - [x] 生成所有全局变量定义 ✅
  - [x] 生成所有函数声明（前向声明）✅
  - [x] 生成所有函数定义 ✅
  - [x] 生成字符串常量定义（框架已就绪，待表达式生成时调用）✅
- [ ] 处理依赖关系：
  - [ ] 结构体之间的依赖
  - [ ] 函数之间的调用关系
- [x] 优化输出格式：
  - [x] 合理的缩进和换行 ✅
  - [x] 有意义的注释 ✅

**输出**：完整的 C99 代码生成器 ✅ 支持结构体、枚举、全局变量、函数定义、函数前向声明和字符串常量

**状态**：✅ 基本完成（2026-01-27）- 主生成流程框架已完成，文件头生成、结构体定义、枚举定义、全局变量定义、函数定义、函数前向声明、字符串常量输出已支持；待完成：依赖关系处理

**下一步**：
- 实现依赖关系分析，确保结构体、枚举、全局变量按正确顺序输出
- 完善数组大小评估（任务3）
- 测试 C99 后端（任务9）

---

### 任务 9：测试 C99 后端

**目标**：验证 C99 后端生成的代码正确性和可编译性。

- [x] 创建测试用例：
  - [x] 基础类型测试 ✅
  - [ ] 结构体测试（部分完成）
  - [x] 控制流测试 ✅
  - [x] 函数调用测试 ✅
  - [ ] 外部函数测试
- [x] 编译测试：
  - [x] 使用 `gcc --std=c99` 编译生成的 C99 代码 ✅
  - [x] 运行生成的可执行文件，验证行为 ✅
- [ ] 对比测试：
  - [ ] 相同 Uya Mini 代码的 LLVM 后端和 C99 后端输出对比
  - [ ] 确保语义一致
- [ ] 集成测试：
  - [-] 编译现有的测试程序（`tests/programs/`） - **脚本已支持 `--c99` 选项，可进行测试**
  - [ ] 确保所有测试程序都能正确编译和运行
  - [ ] **保证 `tests/run_programs.sh` 所有测试用例通过**（与 LLVM 后端行为一致）
  - [ ] 验证多文件编译测试用例在 C99 后端下正常工作

**输出**：通过所有测试的 C99 后端

**状态**：⏳ 进行中（2026-01-27）- 已完成：基础类型、算术、比较、布尔逻辑、控制流、数组访问、赋值、逻辑表达式、嵌套控制、多参数、嵌套函数调用、结构体测试、结构体赋值、嵌套结构体、结构体比较、嵌套结构体访问测试（全部通过），`run_programs.sh` C99 选项支持；待完成：外部函数、完整测试集验证（部分完成）；已知问题：null 关键字已处理为 NULL，但 while 循环测试失败（语义差异需调查）

**说明**：
- `tests/run_programs.sh` 是项目的标准测试脚本，包含 87+ 个测试用例
- C99 后端必须通过所有现有测试，确保与 LLVM 后端语义一致
- 需要特别关注多文件编译、结构体、数组、指针等复杂测试用例

**进展**：
- ✅ 添加C99关键字冲突处理，修复`double`等关键字作为函数名的问题
- ✅ 实现get_safe_c_identifier函数，自动处理C语言关键字
- ✅ 15个基础测试用例全部通过：arithmetic, comparison, boolean_logic, control_flow, array_access, assignment, logical_expr, nested_control, multi_param, nested_function_calls, struct_test, struct_assignment, nested_struct, struct_comparison, nested_struct_access
- ✅ 结构体比较运算符问题已修复：
  - 实现`is_identifier_struct_type`函数检测变量是否为结构体类型
  - 在二元表达式生成中检测结构体比较（==, !=）
  - 使用`memcmp(&left, &right, sizeof(struct))`进行结构体比较
  - 添加`#include <string.h>`支持memcmp函数
  - 修复局部变量表，确保结构体类型检测正常工作
  - ✅ 测试验证通过：`test_struct_comparison.uya`测试用例全部通过
- ✅ 嵌套结构体访问测试通过：
  - 支持嵌套结构体定义（struct中包含struct）
  - 支持多级字段访问（如rect.top_left.x）
  - 支持嵌套结构体的比较运算
  - ✅ 测试验证通过：`test_nested_struct_access.uya`测试用例全部通过
- ✅ 函数原型中的结构体类型问题已修复：
  - 在收集阶段添加结构体到定义表
  - `c99_type_to_c`函数自动为结构体类型添加`struct`前缀
  - 函数参数、返回类型中的结构体类型正确处理
- ✅ 结构体类型支持基本完成：
  - ✅ 结构体定义生成（`struct Point { ... }`）
  - ✅ 结构体初始化（`(struct Point){.x = 10, .y = 20}`）
  - ✅ 字段访问（`p.x`, `p.y`）
  - ✅ 简单结构体变量声明（`const struct Point p = ...`）
  - ✅ 函数原型中的结构体类型（自动添加`struct`前缀）
  - ✅ 结构体比较运算符（使用memcmp转换）
  - ✅ 嵌套结构体访问（支持多级字段访问）
  - ⚠️ 空结构体（待验证）
  - ⚠️ sizeof表达式中的结构体类型（待验证）

**待解决问题**：
1. ✅ 函数原型中结构体类型未添加`struct`前缀 - 已解决
2. ✅ 结构体比较运算符（==, !=）在C99中不支持 - 已解决（使用memcmp）
3. 嵌套结构体和结构体指针的处理（需要测试验证）
4. null关键字的处理（可能需要替换为NULL）
5. 外部函数声明支持
6. 完整测试集验证

---

### 任务 10：文档和集成

**目标**：更新文档，将 C99 后端集成到构建系统中。

- [x] 更新 `README.md`：
  - [x] 添加 C99 后端使用说明（基本说明已添加）
  - [x] 添加命令行选项文档 ✅
- [ ] 更新 `Makefile`：
  - [ ] 添加 `c99-backend` 目标（单独编译 C99 后端示例）
  - [ ] 添加 `test-c99` 目标（运行 C99 后端测试）
- [ ] 更新 `BOOTSTRAP_PLAN.md`：
  - [ ] 记录 C99 后端实现过程
  - [ ] 更新编译器架构图
- [ ] 创建示例：
  - [ ] `examples/c99_output/` - 展示生成的 C99 代码
  - [ ] `examples/compile_with_c99.sh` - 编译脚本

**输出**：完整的文档和集成

**状态**：⚠️ 部分完成 - README.md 已更新基本使用说明，Makefile 支持已添加；待完成：专用测试目标、详细文档、示例代码

---

## 当前总体进度

**最后更新**：2026-01-27

**总体完成度**：约 90%

| 任务 | 状态 | 完成度 | 优先级 |
|------|------|--------|--------|
| 任务 1：架构设计 | ✅ 已完成 | 100% | P0 |
| 任务 2：基础框架 | ✅ 已完成 | 100% | P0 |
| 任务 3：类型系统 | ✅ 已完成 | 95% | P0 |
| 任务 4：表达式生成 | ✅ 基本完成 | 90% | P0 |
| 任务 5：语句生成 | ✅ 基本完成 | 90% | P0 |
| 任务 6：函数和全局变量 | ✅ 基本完成 | 80% | P0 |
| 任务 7：主程序集成 | ✅ 已完成 | 100% | P0 |
| 任务 8：代码生成器入口 | ✅ 基本完成 | 90% | P0 |
| 任务 9：测试 | ⏳ 待开始 | 0% | P1 |
| 任务 10：文档和集成 | ⚠️ 部分完成 | 30% | P1 |

**关键进展**：
- ✅ C99 后端基础架构已完成，主程序已完整集成
- ✅ 支持生成简单函数、if 语句、return 语句、局部变量声明
- ✅ 命令行选项 `--c99` 和 `-exec` 完全支持
- ✅ 表达式和语句支持基本完整，涵盖主要AST节点类型
- ✅ 全局变量（const/var）定义支持已完成
- ✅ 枚举定义支持已完成
- ✅ 函数前向声明和字符串常量输出支持已完成
- ⚠️ 依赖关系处理待完成

**下一步优先级**：
1. **高优先级**：完成任务 9（测试）
2. **中优先级**：任务 10（文档和集成）
3. **低优先级**：优化运算符优先级和括号使用（任务4）

---

## 完成标准

- [x] C99 后端架构设计完成
- [x] 基础框架实现完成
- [ ] C99 后端可以正确编译所有 Uya Mini 测试程序
- [ ] 生成的 C99 代码可以通过 `gcc --std=c99` 编译
- [ ] 生成的可执行文件行为与 LLVM 后端一致
- [x] 支持 `-o xxx.c` 选项输出 C99 代码
- [x] 支持 `--exec` 选项自动编译和链接
- [ ] 代码符合项目编码规范（待完整实现后检查）
- [ ] 文档完整且准确（待测试完成后完善）
- [ ] **保证 `tests/run_programs.sh` 所有测试用例通过**（最终验证标准）

---

## 参考文档

- `spec/UYA_MINI_SPEC.md` - Uya Mini 语言规范
- `src/codegen/` - 现有 LLVM 后端实现
- `src/ast.h` - AST 节点结构定义
- `BOOTSTRAP_PLAN.md` - 自举实现计划
- C99 标准文档（ISO/IEC 9899:1999）

---

## 注意事项

1. **类型映射准确性**：确保所有 Uya Mini 类型都能正确映射到 C99 类型，特别是 `usize` 的平台相关性。
2. **内存布局兼容性**：结构体字段对齐必须与 C 编译器默认对齐一致，确保跨平台兼容性。
3. **字符串常量处理**：字符串字面量需要生成全局常量，避免重复定义。
4. **外部函数处理**：`extern fn` 声明需要生成正确的 C 函数声明，支持可变参数函数。
5. **错误处理**：C99 后端需要提供有意义的错误信息，帮助调试生成的代码。
6. **性能考虑**：生成的 C99 代码应该尽可能高效，避免不必要的临时变量。
7. **文档更新**：**完成任务后，及时更新 TODO_c99_backend.md 文件**，记录进展、更新状态、添加备注，确保文档与实际开发进度保持同步。

---

## 开发工作流

**重要原则**：**完成任务后，及时更新 TODO_c99_backend.md 文件**

- 每完成一个子任务，立即在对应任务列表中标记完成状态（`[x]`）
- 在任务的状态说明中添加完成日期和详细进展
- 在"下一步"或"说明"部分记录遇到的问题、解决方案和技术决策
- 更新"当前总体进度"表格中的完成度百分比
- 确保文档始终反映最新的开发状态，便于后续开发和维护

---
