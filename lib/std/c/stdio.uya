// c.stdio - 标准 I/O 操作
// 版本：v0.3.0
// 说明：基于系统调用的标准 I/O 函数（零外部依赖）
// 注意：函数名使用下划线分隔风格，避免与 C 标准库冲突

use std.c.syscall.SYS_read;
use std.c.syscall.SYS_write;

// ============================================================
// 标准文件描述符
// ============================================================

export const STDIN: i64 = 0;
export const STDOUT: i64 = 1;
export const STDERR: i64 = 2;

// ============================================================
// 基础输出函数
// ============================================================

// put_char - 向标准输出写入一个字符
// 返回：写入的字符（成功）或 -1（失败）
export fn put_char(c: i32) i32 {
    var ch: byte = c as byte;
    const result: !i64 = @syscall(SYS_write, STDOUT, &ch as i64, 1);
    const written: i64 = result catch {
        return 0 - 1;
    };
    if written == 1 {
        return c;
    }
    return 0 - 1;
}

// put_char_fd - 向指定文件描述符写入一个字符
// 返回：写入的字符（成功）或 -1（失败）
export fn put_char_fd(c: i32, fd: i64) i32 {
    var ch: byte = c as byte;
    const result: !i64 = @syscall(SYS_write, fd, &ch as i64, 1);
    const written: i64 = result catch {
        return 0 - 1;
    };
    if written == 1 {
        return c;
    }
    return 0 - 1;
}

// write_bytes - 向标准输出写入 n 个字节
// 返回：写入的字节数，失败返回 -1
export fn write_bytes(buf: &byte, n: usize) i64 {
    const result: !i64 = @syscall(SYS_write, STDOUT, buf as i64, n as i64);
    const written: i64 = result catch {
        return 0 - 1;
    };
    return written;
}

// write_bytes_fd - 向指定文件描述符写入 n 个字节
// 返回：写入的字节数，失败返回 -1
export fn write_bytes_fd(buf: &byte, n: usize, fd: i64) i64 {
    const result: !i64 = @syscall(SYS_write, fd, buf as i64, n as i64);
    const written: i64 = result catch {
        return 0 - 1;
    };
    return written;
}

// put_str_len - 向标准输出写入指定长度的字符串并换行
// 返回：0 成功，-1 失败
export fn put_str_len(s: &byte, len: usize) i32 {
    // 写入字符串内容
    const result: !i64 = @syscall(SYS_write, STDOUT, s as i64, len as i64);
    _ = result catch {
        return 0 - 1;
    };
    // 写入换行符
    var newline: byte = 10 as byte;
    const nl_result: !i64 = @syscall(SYS_write, STDOUT, &newline as i64, 1);
    _ = nl_result catch {
        return 0 - 1;
    };
    return 0;
}

// ============================================================
// 基础输入函数
// ============================================================

// get_char - 从标准输入读取一个字符
// 返回：读取的字符，EOF 或错误返回 -1
export fn get_char() i32 {
    var ch: byte = 0 as byte;
    const result: !i64 = @syscall(SYS_read, STDIN, &ch as i64, 1);
    const bytes_read: i64 = result catch {
        return 0 - 1;
    };
    if bytes_read == 1 {
        return ch as i32;
    }
    return 0 - 1;
}

// read_bytes - 从标准输入读取最多 n 个字节
// 返回：读取的字节数，EOF 或错误返回 -1
export fn read_bytes(buf: &byte, n: usize) i64 {
    const result: !i64 = @syscall(SYS_read, STDIN, buf as i64, n as i64);
    const bytes_read: i64 = result catch {
        return 0 - 1;
    };
    return bytes_read;
}

// read_bytes_fd - 从指定文件描述符读取最多 n 个字节
// 返回：读取的字节数，EOF 或错误返回 -1
export fn read_bytes_fd(buf: &byte, n: usize, fd: i64) i64 {
    const result: !i64 = @syscall(SYS_read, fd, buf as i64, n as i64);
    const bytes_read: i64 = result catch {
        return 0 - 1;
    };
    return bytes_read;
}

// ============================================================
// 整数转字符串辅助函数
// ============================================================

// i32_to_str - 将 i32 转换为十进制字符串
// 返回：写入的字符数
export fn i32_to_str(value: i32, buf: &byte) usize {
    var v: i32 = value;
    var len: usize = 0;
    var is_neg: bool = false;

    if v < 0 {
        is_neg = true;
        v = 0 - v;
    }

    // 特殊情况：值为 0
    if v == 0 {
        buf[0] = 48 as byte;  // '0'
        return 1;
    }

    // 逆序写入数字
    while v > 0 {
        buf[len] = (v % 10 + 48) as byte;  // '0' = 48
        v = v / 10;
        len = len + 1;
    }

    if is_neg {
        buf[len] = 45 as byte;  // '-'
        len = len + 1;
    }

    // 反转字符串
    var left: usize = 0;
    var right: usize = len - 1;
    while left < right {
        const tmp: byte = buf[left];
        buf[left] = buf[right];
        buf[right] = tmp;
        left = left + 1;
        right = right - 1;
    }

    return len;
}

// i64_to_str - 将 i64 转换为十进制字符串
// 返回：写入的字符数
export fn i64_to_str(value: i64, buf: &byte) usize {
    var v: i64 = value;
    var len: usize = 0;
    var is_neg: bool = false;

    if v < 0 {
        is_neg = true;
        v = 0 - v;
    }

    // 特殊情况：值为 0
    if v == 0 {
        buf[0] = 48 as byte;  // '0'
        return 1;
    }

    // 逆序写入数字
    while v > 0 {
        buf[len] = (v % 10 + 48) as byte;  // '0' = 48
        v = v / 10;
        len = len + 1;
    }

    if is_neg {
        buf[len] = 45 as byte;  // '-'
        len = len + 1;
    }

    // 反转字符串
    var left: usize = 0;
    var right: usize = len - 1;
    while left < right {
        const tmp: byte = buf[left];
        buf[left] = buf[right];
        buf[right] = tmp;
        left = left + 1;
        right = right - 1;
    }

    return len;
}

// print_i32 - 将 i32 值打印到标准输出
// 返回：写入的字符数
export fn print_i32(value: i32) usize {
    var buf: [byte: 12] = [];
    const len: usize = i32_to_str(value, &buf[0] as &byte);
    _ = write_bytes(&buf[0] as &byte, len);
    return len;
}

// print_i64 - 将 i64 值打印到标准输出
// 返回：写入的字符数
export fn print_i64(value: i64) usize {
    var buf: [byte: 21] = [];
    const len: usize = i64_to_str(value, &buf[0] as &byte);
    _ = write_bytes(&buf[0] as &byte, len);
    return len;
}

// ============================================================
// C 标准库兼容函数（用于 --nostdlib 模式）
// ============================================================

use std.c.syscall.sys_open;
use std.c.syscall.sys_close;
use std.c.syscall.sys_read;
use std.c.syscall.sys_write;
use std.c.syscall.O_RDONLY;
use std.c.syscall.O_WRONLY;
use std.c.syscall.O_RDWR;
use std.c.syscall.O_CREAT;
use std.c.syscall.O_TRUNC;
use std.c.syscall.O_APPEND;
use std.c.syscall.S_IRWXU;
use std.c.syscall.STDOUT_FILENO;
use std.c.syscall.STDERR_FILENO;
use std.c.string.strlen;
use std.c.string.strcmp;

// 全局文件描述符存储（用于 fopen/fclose，最多 64 个文件）
var fopen_fd_storage: [i64: 64] = [];

// fopen - 打开文件（C 标准库兼容）
// 注意：在 --nostdlib 模式下，FILE* 实际上就是文件描述符（转换为指针）
// 返回：FILE*（实际上是文件描述符的指针），失败返回 null
export fn fopen(filename: *byte, mode: *byte) *void {
    if filename == null || mode == null {
        return null;
    }
    
    // 解析模式字符串
    var flags: i64 = 0;
    var create_mode: i64 = 0;
    var i: usize = 0;
    const mode_len: usize = strlen(mode);
    
    while i < mode_len {
        const c: byte = mode[i];
        if c == 114 {  // 'r'
            flags = O_RDONLY;
        } else if c == 119 {  // 'w'
            flags = O_WRONLY | O_CREAT | O_TRUNC;
            create_mode = S_IRWXU;
        } else if c == 97 {  // 'a'
            flags = O_WRONLY | O_CREAT | O_APPEND;
            create_mode = S_IRWXU;
        } else if c == 43 {  // '+'
            // 读写模式
            if flags == O_RDONLY {
                flags = O_RDWR;
            } else {
                flags = flags | O_RDWR;
            }
        } else if c == 98 {  // 'b' (binary mode, ignored on Linux)
            // 忽略
        }
        i = i + 1;
    }
    
    // 打开文件
    const result: !i64 = sys_open(filename as i64, flags, create_mode);
    const fd: i64 = result catch {
        return null;
    };
    
    // 使用全局数组存储文件描述符（简化实现，最多支持 64 个打开的文件）
    var j: usize = 0;
    while j < 64 {
        // 查找空闲槽位（fd <= 0 表示未使用）
        if fopen_fd_storage[j] <= 0 {
            fopen_fd_storage[j] = fd;
            return &fopen_fd_storage[j] as *void;
        }
        j = j + 1;
    }
    
    // 如果数组满了，关闭文件描述符并返回 null
    _ = sys_close(fd);
    return null;
}

// fclose - 关闭文件（C 标准库兼容）
// 返回：0 成功，EOF (-1) 失败
export fn fclose(stream: *void) i32 {
    if stream == null {
        return 0 - 1;  // EOF
    }
    
    // 从指针中获取文件描述符
    const fd_ptr: &i64 = stream as &i64;
    const fd: i64 = fd_ptr[0];
    
    if fd < 0 {
        return 0 - 1;  // EOF
    }
    
    const result: !i64 = sys_close(fd);
    _ = result catch {
        return 0 - 1;  // EOF
    };
    
    // 标记为已关闭
    fd_ptr[0] = 0 - 1;
    return 0;
}

// fread - 从文件读取（C 标准库兼容）
// 返回：读取的元素数
export fn fread(ptr: *byte, size: usize, nmemb: usize, stream: *void) usize {
    if ptr == null || stream == null || size == 0 || nmemb == 0 {
        return 0;
    }
    
    // 从指针中获取文件描述符
    const fd_ptr: &i64 = stream as &i64;
    const fd: i64 = fd_ptr[0];
    
    if fd < 0 {
        return 0;
    }
    
    const total_size: usize = size * nmemb;
    const result: !i64 = sys_read(fd, ptr as i64, total_size as i64);
    const bytes_read: i64 = result catch {
        return 0;
    };
    
    if bytes_read < 0 {
        return 0;
    }
    
    // 返回读取的元素数（向下取整）
    return (bytes_read as usize) / size;
}

// fgetc - 从文件读取一个字符（C 标准库兼容）
// 返回：读取的字符，EOF (-1) 表示错误或文件结束
export fn fgetc(stream: *void) i32 {
    if stream == null {
        return 0 - 1;  // EOF
    }
    
    // 从指针中获取文件描述符
    const fd_ptr: &i64 = stream as &i64;
    const fd: i64 = fd_ptr[0];
    
    if fd < 0 {
        return 0 - 1;  // EOF
    }
    
    var ch: byte = 0 as byte;
    const result: !i64 = sys_read(fd, &ch as i64, 1);
    const bytes_read: i64 = result catch {
        return 0 - 1;  // EOF
    };
    
    if bytes_read == 1 {
        return ch as i32;
    }
    
    return 0 - 1;  // EOF
}

// fprintf - 格式化输出到文件流（简化版本，只支持 %s 和 %d）
// 返回：写入的字符数，失败返回负数
export fn fprintf(stream: *void, format: *byte, ...) i32 {
    if stream == null || format == null {
        return 0 - 1;
    }
    
    // 从指针中获取文件描述符
    const fd_ptr: &i64 = stream as &i64;
    const fd: i64 = fd_ptr[0];
    
    if fd < 0 {
        return 0 - 1;
    }
    
    // 简化实现：只支持 %s 和 %d
    // 注意：可变参数在 Uya 中需要特殊处理，这里使用简化实现
    var buf: [byte: 4096] = [];
    var buf_pos: usize = 0;
    var format_pos: usize = 0;
    const format_len: usize = strlen(format);
    
    // 获取可变参数（简化：假设最多 10 个参数）
    // 注意：Uya 的可变参数处理较复杂，这里使用简化实现
    // 实际使用时，需要根据格式字符串解析参数
    
    while format_pos < format_len && buf_pos < 4095 {
        const c: byte = format[format_pos];
        if c == 37 {  // '%'
            format_pos = format_pos + 1;
            if format_pos < format_len {
                const spec: byte = format[format_pos];
                if spec == 115 {  // 's' - 字符串
                    // 简化：跳过字符串参数（需要 va_list 支持）
                    buf[buf_pos] = 63 as byte;  // '?'
                    buf_pos = buf_pos + 1;
                } else if spec == 100 {  // 'd' - 整数
                    // 简化：跳过整数参数（需要 va_list 支持）
                    buf[buf_pos] = 48 as byte;  // '0'
                    buf_pos = buf_pos + 1;
                } else if spec == 37 {  // '%%' - 转义的 %
                    buf[buf_pos] = 37 as byte;  // '%'
                    buf_pos = buf_pos + 1;
                } else {
                    // 未知格式说明符，原样输出
                    buf[buf_pos] = 37 as byte;  // '%'
                    buf_pos = buf_pos + 1;
                    if buf_pos < 4095 {
                        buf[buf_pos] = spec;
                        buf_pos = buf_pos + 1;
                    }
                }
            }
        } else {
            buf[buf_pos] = c;
            buf_pos = buf_pos + 1;
        }
        format_pos = format_pos + 1;
    }
    
    buf[buf_pos] = 0 as byte;
    
    // 写入到文件流
    const result: !i64 = sys_write(fd, &buf[0] as i64, buf_pos as i64);
    const written: i64 = result catch {
        return 0 - 1;
    };
    
    return written as i32;
}

// fwrite - 向文件流写入数据（C 标准库兼容）
// 返回：写入的元素数
export fn fwrite(ptr: &byte, size: usize, nmemb: usize, stream: *void) usize {
    if ptr == null || stream == null || size == 0 || nmemb == 0 {
        return 0;
    }
    
    // 从指针中获取文件描述符
    const fd_ptr: &i64 = stream as &i64;
    const fd: i64 = fd_ptr[0];
    
    if fd < 0 {
        return 0;
    }
    
    const total_size: usize = size * nmemb;
    const result: !i64 = sys_write(fd, ptr as i64, total_size as i64);
    const bytes_written: i64 = result catch {
        return 0;
    };
    
    if bytes_written < 0 {
        return 0;
    }
    
    // 返回写入的元素数（向下取整）
    return (bytes_written as usize) / size;
}

// fputc - 向文件流写入一个字符（C 标准库兼容）
// 返回：写入的字符，EOF (-1) 表示错误
export fn fputc(c: i32, stream: *void) i32 {
    if stream == null {
        return 0 - 1;  // EOF
    }
    
    // 从指针中获取文件描述符
    const fd_ptr: &i64 = stream as &i64;
    const fd: i64 = fd_ptr[0];
    
    if fd < 0 {
        return 0 - 1;  // EOF
    }
    
    var ch: byte = c as byte;
    const result: !i64 = sys_write(fd, &ch as i64, 1);
    const bytes_written: i64 = result catch {
        return 0 - 1;  // EOF
    };
    
    if bytes_written == 1 {
        return c;
    }
    
    return 0 - 1;  // EOF
}

// fputs - 向文件流写入字符串（C 标准库兼容）
// 返回：非负值成功，EOF (-1) 失败
export fn fputs(s: &byte, stream: *void) i32 {
    if s == null || stream == null {
        return 0 - 1;  // EOF
    }
    
    const len: usize = strlen(s);
    if len == 0 {
        return 0;
    }
    
    const written: usize = fwrite(s, 1, len, stream);
    
    if written == len {
        return 0;
    }
    
    return 0 - 1;  // EOF
}

// sprintf - 格式化字符串（简化版本，只支持 %s 和 %d）
// 返回：写入的字符数（不包括 null 终止符），失败返回负数
export fn sprintf(buf: &byte, format: *byte, ...) i32 {
    if buf == null || format == null {
        return 0 - 1;
    }
    
    // 简化实现：只支持 %s 和 %d
    // 注意：可变参数在 Uya 中需要特殊处理，这里使用简化实现
    var buf_pos: usize = 0;
    var format_pos: usize = 0;
    const format_len: usize = strlen(format);
    const max_buf: usize = 4096;  // 最大缓冲区大小
    
    while format_pos < format_len && buf_pos < max_buf - 1 {
        const c: byte = format[format_pos];
        if c == 37 {  // '%'
            format_pos = format_pos + 1;
            if format_pos < format_len {
                const spec: byte = format[format_pos];
                if spec == 115 {  // 's' - 字符串
                    // 简化：跳过字符串参数（需要 va_list 支持）
                    buf[buf_pos] = 63 as byte;  // '?'
                    buf_pos = buf_pos + 1;
                } else if spec == 100 {  // 'd' - 整数
                    // 简化：跳过整数参数（需要 va_list 支持）
                    buf[buf_pos] = 48 as byte;  // '0'
                    buf_pos = buf_pos + 1;
                } else if spec == 37 {  // '%%' - 转义的 %
                    buf[buf_pos] = 37 as byte;  // '%'
                    buf_pos = buf_pos + 1;
                } else {
                    // 未知格式说明符，原样输出
                    buf[buf_pos] = 37 as byte;  // '%'
                    buf_pos = buf_pos + 1;
                    if buf_pos < max_buf - 1 {
                        buf[buf_pos] = spec;
                        buf_pos = buf_pos + 1;
                    }
                }
            }
        } else {
            buf[buf_pos] = c;
            buf_pos = buf_pos + 1;
        }
        format_pos = format_pos + 1;
    }
    
    buf[buf_pos] = 0 as byte;
    return buf_pos as i32;
}

// snprintf - 格式化字符串（带长度限制，简化版本，只支持 %s 和 %d）
// 返回：写入的字符数（不包括 null 终止符），失败返回负数
export fn snprintf(buf: &byte, n: usize, format: *byte, ...) i32 {
    if buf == null || format == null || n == 0 {
        return 0 - 1;
    }
    
    // 简化实现：只支持 %s 和 %d
    // 注意：可变参数在 Uya 中需要特殊处理，这里使用简化实现
    var buf_pos: usize = 0;
    var format_pos: usize = 0;
    const format_len: usize = strlen(format);
    var max_buf: usize = n - 1;
    if max_buf > 4096 {
        max_buf = 4096;
    }
    
    while format_pos < format_len && buf_pos < max_buf {
        const c: byte = format[format_pos];
        if c == 37 {  // '%'
            format_pos = format_pos + 1;
            if format_pos < format_len {
                const spec: byte = format[format_pos];
                if spec == 115 {  // 's' - 字符串
                    // 简化：跳过字符串参数（需要 va_list 支持）
                    if buf_pos < max_buf {
                        buf[buf_pos] = 63 as byte;  // '?'
                        buf_pos = buf_pos + 1;
                    }
                } else if spec == 100 {  // 'd' - 整数
                    // 简化：跳过整数参数（需要 va_list 支持）
                    if buf_pos < max_buf {
                        buf[buf_pos] = 48 as byte;  // '0'
                        buf_pos = buf_pos + 1;
                    }
                } else if spec == 37 {  // '%%' - 转义的 %
                    if buf_pos < max_buf {
                        buf[buf_pos] = 37 as byte;  // '%'
                        buf_pos = buf_pos + 1;
                    }
                } else {
                    // 未知格式说明符，原样输出
                    if buf_pos < max_buf {
                        buf[buf_pos] = 37 as byte;  // '%'
                        buf_pos = buf_pos + 1;
                    }
                    if buf_pos < max_buf {
                        buf[buf_pos] = spec;
                        buf_pos = buf_pos + 1;
                    }
                }
            }
        } else {
            if buf_pos < max_buf {
                buf[buf_pos] = c;
                buf_pos = buf_pos + 1;
            }
        }
        format_pos = format_pos + 1;
    }
    
    if buf_pos < n {
        buf[buf_pos] = 0 as byte;
    } else if n > 0 {
        buf[n - 1] = 0 as byte;
    }
    
    return buf_pos as i32;
}
