// c.string - 字符串和内存操作
// 版本：v0.3.1
// 说明：纯 Uya 实现的字符串和内存操作函数（零外部依赖）
// 注意：函数名与 C 标准库一致（memcpy, strlen, strcmp 等）

// ============================================================
// 内存操作函数
// ============================================================

// memcpy - 复制 n 字节从 src 到 dest
// 注意：src 和 dest 不能重叠（重叠请用 memmove）
// 返回：dest 指针（与 musl 一致：void *memcpy(void *dest, const void *src, size_t n)）
export fn memcpy(dest: *void, src: *void, n: usize) *void {
    var dest_bytes: &byte = dest as &byte;
    var src_bytes: &byte = src as &byte;
    var i: usize = 0;
    while i < n {
        dest_bytes[i] = src_bytes[i];
        i = i + 1;
    }
    return dest;
}

// memmove - 复制 n 字节从 src 到 dest（支持重叠）
// 返回：dest 指针（与 musl 一致：void *memmove(void *dest, const void *src, size_t n)）
export fn memmove(dest: *void, src: *void, n: usize) *void {
    var dest_bytes: &byte = dest as &byte;
    var src_bytes: &byte = src as &byte;
    if dest_bytes as i64 <= src_bytes as i64 {
        // 正向复制
        var i: usize = 0;
        while i < n {
            dest_bytes[i] = src_bytes[i];
            i = i + 1;
        }
    } else {
        // 反向复制（避免覆盖未复制的数据）
        var i: usize = n;
        while i > 0 {
            i = i - 1;
            dest_bytes[i] = src_bytes[i];
        }
    }
    return dest;
}

// memset - 将 s 的前 n 字节设置为 c
// 返回：s 指针（与 musl 一致：void *memset(void *s, int c, size_t n)）
export fn memset(s: *void, c: i32, n: usize) *void {
    var s_bytes: &byte = s as &byte;
    var c_byte: byte = c as byte;
    var i: usize = 0;
    while i < n {
        s_bytes[i] = c_byte;
        i = i + 1;
    }
    return s;
}

// memcmp - 比较两块内存的前 n 字节
// 返回：0 相等，<0 s1<s2，>0 s1>s2（与 musl 一致：int memcmp(const void *s1, const void *s2, size_t n)）
export fn memcmp(s1: *void, s2: *void, n: usize) i32 {
    var s1_bytes: &byte = s1 as &byte;
    var s2_bytes: &byte = s2 as &byte;
    var i: usize = 0;
    while i < n {
        if s1_bytes[i] != s2_bytes[i] {
            return s1_bytes[i] as i32 - s2_bytes[i] as i32;
        }
        i = i + 1;
    }
    return 0;
}

// memchr - 在 s 的前 n 字节中查找字节 c
// 返回：找到的指针，未找到返回 null（与 musl 一致：void *memchr(const void *s, int c, size_t n)）
export fn memchr(s: *void, c: i32, n: usize) *void {
    var s_bytes: &byte = s as &byte;
    var c_byte: byte = c as byte;
    var i: usize = 0;
    while i < n {
        if s_bytes[i] == c_byte {
            return s_bytes as *void + i;
        }
        i = i + 1;
    }
    return null;
}

// ============================================================
// 字符串操作函数
// ============================================================

// strlen - 计算以 null 结尾的字符串长度
// 返回：字符串长度（不含 null 终止符）
export fn strlen(s: &byte) usize {
    var len: usize = 0;
    while s[len] != 0 as byte {
        len = len + 1;
    }
    return len;
}

// strcmp - 比较两个以 null 结尾的字符串
// 返回：0 相等，<0 s1<s2，>0 s1>s2
export fn strcmp(s1: &byte, s2: &byte) i32 {
    var i: usize = 0;
    while s1[i] != 0 as byte && s2[i] != 0 as byte {
        if s1[i] != s2[i] {
            return s1[i] as i32 - s2[i] as i32;
        }
        i = i + 1;
    }
    return s1[i] as i32 - s2[i] as i32;
}

// strncmp - 比较两个字符串的前 n 字节
// 返回：0 相等，<0 s1<s2，>0 s1>s2
export fn strncmp(s1: &byte, s2: &byte, n: usize) i32 {
    var i: usize = 0;
    while i < n && s1[i] != 0 as byte && s2[i] != 0 as byte {
        if s1[i] != s2[i] {
            return s1[i] as i32 - s2[i] as i32;
        }
        i = i + 1;
    }
    if i >= n {
        return 0;
    }
    return s1[i] as i32 - s2[i] as i32;
}

// strcpy - 复制字符串（含 null 终止符）
// 返回：dest 指针
export fn strcpy(dest: &byte, src: &byte) &byte {
    var i: usize = 0;
    while src[i] != 0 as byte {
        dest[i] = src[i];
        i = i + 1;
    }
    dest[i] = 0 as byte;
    return dest;
}

// strncpy - 复制至多 n 个字节的字符串
// 如果 src 不足 n 字节，剩余部分填充 0
// 返回：dest 指针
export fn strncpy(dest: &byte, src: &byte, n: usize) &byte {
    var i: usize = 0;
    while i < n && src[i] != 0 as byte {
        dest[i] = src[i];
        i = i + 1;
    }
    while i < n {
        dest[i] = 0 as byte;
        i = i + 1;
    }
    return dest;
}

// strcat - 连接两个字符串
// 返回：dest 指针
export fn strcat(dest: &byte, src: &byte) &byte {
    var dest_len: usize = strlen(dest);
    var i: usize = 0;
    while src[i] != 0 as byte {
        dest[dest_len + i] = src[i];
        i = i + 1;
    }
    dest[dest_len + i] = 0 as byte;
    return dest;
}

// strchr - 在字符串中查找字符 c 首次出现的位置
// 返回：找到的指针，未找到返回 null（与 musl 一致：char *strchr(const char *s, int c)）
export fn strchr(s: *byte, c: i32) *byte {
    var s_bytes: &byte = s as &byte;
    var c_byte: byte = c as byte;
    var i: usize = 0;
    while s_bytes[i] != 0 as byte {
        if s_bytes[i] == c_byte {
            return s_bytes as *byte + i;
        }
        i = i + 1;
    }
    // 也检查 null 终止符
    if c_byte == 0 as byte {
        return s_bytes as *byte + i;
    }
    return null;
}

// strrchr - 在字符串中查找字符 c 最后一次出现的位置
// 返回：找到的指针，未找到返回 null（与 musl 一致：char *strrchr(const char *s, int c)）
export fn strrchr(s: *byte, c: i32) *byte {
    var s_bytes: &byte = s as &byte;
    var c_byte: byte = c as byte;
    var last: *byte = null;
    var i: usize = 0;
    while s_bytes[i] != 0 as byte {
        if s_bytes[i] == c_byte {
            last = s_bytes as *byte + i;
        }
        i = i + 1;
    }
    if c_byte == 0 as byte {
        return s_bytes as *byte + i;
    }
    return last;
}
