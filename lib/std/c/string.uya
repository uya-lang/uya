// c.string - 字符串和内存操作
// 版本：v0.3.1
// 说明：纯 Uya 实现的字符串和内存操作函数（零外部依赖）
// 注意：函数名与 C 标准库一致（memcpy, strlen, strcmp 等）

// ============================================================
// 内存操作函数
// ============================================================

// memcpy - 复制 n 字节从 src 到 dest
// 注意：src 和 dest 不能重叠（重叠请用 memmove）
// 返回：dest 指针
export fn memcpy(dest: &byte, src: &byte, n: usize) &byte {
    var i: usize = 0;
    while i < n {
        dest[i] = src[i];
        i = i + 1;
    }
    return dest;
}

// memmove - 复制 n 字节从 src 到 dest（支持重叠）
// 返回：dest 指针
export fn memmove(dest: &byte, src: &byte, n: usize) &byte {
    if dest as i64 <= src as i64 {
        // 正向复制
        var i: usize = 0;
        while i < n {
            dest[i] = src[i];
            i = i + 1;
        }
    } else {
        // 反向复制（避免覆盖未复制的数据）
        var i: usize = n;
        while i > 0 {
            i = i - 1;
            dest[i] = src[i];
        }
    }
    return dest;
}

// memset - 将 s 的前 n 字节设置为 c
// 返回：s 指针
export fn memset(s: &byte, c: byte, n: usize) &byte {
    var i: usize = 0;
    while i < n {
        s[i] = c;
        i = i + 1;
    }
    return s;
}

// memcmp - 比较两块内存的前 n 字节
// 返回：0 相等，<0 s1<s2，>0 s1>s2
export fn memcmp(s1: &byte, s2: &byte, n: usize) i32 {
    var i: usize = 0;
    while i < n {
        if s1[i] != s2[i] {
            return s1[i] as i32 - s2[i] as i32;
        }
        i = i + 1;
    }
    return 0;
}

// memchr - 在 s 的前 n 字节中查找字节 c
// 返回：找到的位置索引，未找到返回 -1
export fn memchr(s: &byte, c: byte, n: usize) i64 {
    var i: usize = 0;
    while i < n {
        if s[i] == c {
            return i as i64;
        }
        i = i + 1;
    }
    return 0 - 1;
}

// ============================================================
// 字符串操作函数
// ============================================================

// strlen - 计算以 null 结尾的字符串长度
// 返回：字符串长度（不含 null 终止符）
export fn strlen(s: &byte) usize {
    var len: usize = 0;
    while s[len] != 0 as byte {
        len = len + 1;
    }
    return len;
}

// strcmp - 比较两个以 null 结尾的字符串
// 返回：0 相等，<0 s1<s2，>0 s1>s2
export fn strcmp(s1: &byte, s2: &byte) i32 {
    var i: usize = 0;
    while s1[i] != 0 as byte && s2[i] != 0 as byte {
        if s1[i] != s2[i] {
            return s1[i] as i32 - s2[i] as i32;
        }
        i = i + 1;
    }
    return s1[i] as i32 - s2[i] as i32;
}

// strncmp - 比较两个字符串的前 n 字节
// 返回：0 相等，<0 s1<s2，>0 s1>s2
export fn strncmp(s1: &byte, s2: &byte, n: usize) i32 {
    var i: usize = 0;
    while i < n && s1[i] != 0 as byte && s2[i] != 0 as byte {
        if s1[i] != s2[i] {
            return s1[i] as i32 - s2[i] as i32;
        }
        i = i + 1;
    }
    if i >= n {
        return 0;
    }
    return s1[i] as i32 - s2[i] as i32;
}

// strcpy - 复制字符串（含 null 终止符）
// 返回：dest 指针
export fn strcpy(dest: &byte, src: &byte) &byte {
    var i: usize = 0;
    while src[i] != 0 as byte {
        dest[i] = src[i];
        i = i + 1;
    }
    dest[i] = 0 as byte;
    return dest;
}

// strncpy - 复制至多 n 个字节的字符串
// 如果 src 不足 n 字节，剩余部分填充 0
// 返回：dest 指针
export fn strncpy(dest: &byte, src: &byte, n: usize) &byte {
    var i: usize = 0;
    while i < n && src[i] != 0 as byte {
        dest[i] = src[i];
        i = i + 1;
    }
    while i < n {
        dest[i] = 0 as byte;
        i = i + 1;
    }
    return dest;
}

// strcat - 连接两个字符串
// 返回：dest 指针
export fn strcat(dest: &byte, src: &byte) &byte {
    var dest_len: usize = strlen(dest);
    var i: usize = 0;
    while src[i] != 0 as byte {
        dest[dest_len + i] = src[i];
        i = i + 1;
    }
    dest[dest_len + i] = 0 as byte;
    return dest;
}

// strchr - 在字符串中查找字符 c 首次出现的位置
// 返回：位置索引，未找到返回 -1
export fn strchr(s: &byte, c: byte) i64 {
    var i: usize = 0;
    while s[i] != 0 as byte {
        if s[i] == c {
            return i as i64;
        }
        i = i + 1;
    }
    // 也检查 null 终止符
    if c == 0 as byte {
        return i as i64;
    }
    return 0 - 1;
}

// strrchr - 在字符串中查找字符 c 最后一次出现的位置
// 返回：位置索引，未找到返回 -1
export fn strrchr(s: &byte, c: byte) i64 {
    var last: i64 = 0 - 1;
    var i: usize = 0;
    while s[i] != 0 as byte {
        if s[i] == c {
            last = i as i64;
        }
        i = i + 1;
    }
    if c == 0 as byte {
        return i as i64;
    }
    return last;
}
