// c.stdlib - 标准库函数（内存分配、进程控制、字符串转换）
// 版本：v0.3.0
// 说明：基于系统调用的标准库函数（零外部依赖）
// 注意：函数名与 C 标准库一致（malloc, free, exit, atoi 等）

use std.c.syscall.sys_exit;
use std.c.syscall.sys_getpid;
use std.c.syscall.SYS_brk;
use std.c.string.memset;
use std.c.string.strlen;

// ============================================================
// mmap 标志常量（Linux）
// ============================================================

const MAP_PRIVATE: i64 = 2;
const MAP_ANONYMOUS: i64 = 32;
const PROT_READ: i64 = 1;
const PROT_WRITE: i64 = 2;

// ============================================================
// 内存分配函数（基于 mmap）
// ============================================================

// malloc - 分配 size 字节的内存
// 返回：分配的内存指针，失败返回 null
// 注意：使用 mmap 实现，每次分配独立的内存页
export fn malloc(size: usize) &void {
    if size == 0 {
        return null;
    }
    
    // 使用 mmap 分配内存
    // mmap(addr=0, length=size, prot=PROT_READ|PROT_WRITE, flags=MAP_PRIVATE|MAP_ANONYMOUS, fd=-1, offset=0)
    // 注意：SYS_mmap = 9 (Linux x86-64)
    const result: !i64 = @syscall(9, 0, size as i64, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0 - 1, 0);
    const ptr: i64 = result catch {
        return null;
    };
    
    // mmap 失败时返回 -1（转换为 null）
    if ptr < 0 {
        return null;
    }
    
    return ptr as &void;
}

// free - 释放 malloc 分配的内存
// 注意：使用 munmap 释放内存
export fn free(ptr: &void) void {
    if ptr == null {
        return;
    }
    
    // 注意：munmap 需要知道内存大小，但标准 free 接口没有大小参数
    // 简化实现：使用一个固定大小的内存块（实际应用中需要维护分配表）
    // 这里使用一个简单的实现：假设每次分配至少 4096 字节（一页）
    // 实际应用中应该维护一个分配表来记录每个指针的大小
    
    // 简化：munmap(ptr, 4096) - 假设最小分配为一页
    // 注意：这是一个简化实现，实际应该维护分配表
    // 注意：SYS_munmap = 11 (Linux x86-64)
    _ = @syscall(11, ptr as i64, 4096);
}

// calloc - 分配并清零 nmemb * size 字节的内存
// 返回：分配的内存指针，失败返回 null
export fn calloc(nmemb: usize, size: usize) &void {
    const total_size: usize = nmemb * size;
    const ptr: &void = malloc(total_size);
    if ptr == null {
        return null;
    }
    
    // 清零内存
    _ = memset(ptr as *void, 0, total_size);
    return ptr;
}

// realloc - 重新分配内存（扩展或缩小）
// 返回：新的内存指针，失败返回 null
// 注意：简化实现，实际应该复制旧数据
export fn realloc(ptr: &void, size: usize) &void {
    if ptr == null {
        return malloc(size);
    }
    
    if size == 0 {
        free(ptr);
        return null;
    }
    
    // 简化实现：分配新内存（实际应该复制旧数据并释放旧内存）
    // 注意：这是一个简化实现，实际应该维护分配表并复制数据
    const new_ptr: &void = malloc(size);
    if new_ptr == null {
        return null;
    }
    
    // 注意：无法知道旧内存的大小，这里假设至少复制 size 字节
    // 实际应用中应该维护分配表
    // 这里简化：只分配新内存，不复制旧数据（调用者需要自己处理）
    
    return new_ptr;
}

// ============================================================
// 进程控制函数
// ============================================================

// exit - 正常退出进程
// 注意：noreturn 函数
export fn exit(status: i32) void {
    sys_exit(status as i64);
}

// abort - 异常终止进程（发送 SIGABRT）
// 注意：noreturn 函数
export fn abort() void {
    // 注意：SYS_getpid = 39, SYS_kill = 62 (Linux x86-64)
    // 使用 sys_getpid 函数（已封装错误处理）
    const pid: i64 = sys_getpid();
    // 发送 SIGABRT (6) 给自己
    _ = @syscall(62, pid, 6);
    // 如果 kill 失败，直接退出
    sys_exit(1);
}

// ============================================================
// 字符串转数字函数
// ============================================================

// atoi - 将字符串转换为 i32
// 返回：转换后的整数，失败返回 0
export fn atoi(s: &byte) i32 {
    if s == null {
        return 0;
    }
    
    var result: i32 = 0;
    var i: usize = 0;
    var is_neg: bool = false;
    
    // 跳过前导空白字符
    while s[i] == 32 as byte || s[i] == 9 as byte || s[i] == 10 as byte || s[i] == 13 as byte {
        i = i + 1;
    }
    
    // 检查符号
    if s[i] == 45 as byte {  // '-'
        is_neg = true;
        i = i + 1;
    } else if s[i] == 43 as byte {  // '+'
        i = i + 1;
    }
    
    // 转换数字
    while s[i] >= 48 as byte && s[i] <= 57 as byte {  // '0' - '9'
        const digit: i32 = s[i] as i32 - 48;
        result = result * 10 + digit;
        i = i + 1;
    }
    
    if is_neg {
        result = 0 - result;
    }
    
    return result;
}

// atol - 将字符串转换为 i64
// 返回：转换后的长整数，失败返回 0
export fn atol(s: &byte) i64 {
    if s == null {
        return 0;
    }
    
    var result: i64 = 0;
    var i: usize = 0;
    var is_neg: bool = false;
    
    // 跳过前导空白字符
    while s[i] == 32 as byte || s[i] == 9 as byte || s[i] == 10 as byte || s[i] == 13 as byte {
        i = i + 1;
    }
    
    // 检查符号
    if s[i] == 45 as byte {  // '-'
        is_neg = true;
        i = i + 1;
    } else if s[i] == 43 as byte {  // '+'
        i = i + 1;
    }
    
    // 转换数字
    while s[i] >= 48 as byte && s[i] <= 57 as byte {  // '0' - '9'
        const digit: i64 = s[i] as i64 - 48;
        result = result * 10 + digit;
        i = i + 1;
    }
    
    if is_neg {
        result = 0 - result;
    }
    
    return result;
}

// atof - 将字符串转换为 f64（简化实现）
// 返回：转换后的浮点数，失败返回 0.0
// 注意：这是一个简化实现，只支持基本格式
export fn atof(s: &byte) f64 {
    if s == null {
        return 0.0;
    }
    
    var i: usize = 0;
    var is_neg: bool = false;
    var result: f64 = 0.0;
    
    // 跳过前导空白字符
    while s[i] == 32 as byte || s[i] == 9 as byte || s[i] == 10 as byte || s[i] == 13 as byte {
        i = i + 1;
    }
    
    // 检查符号
    if s[i] == 45 as byte {  // '-'
        is_neg = true;
        i = i + 1;
    } else if s[i] == 43 as byte {  // '+'
        i = i + 1;
    }
    
    // 转换整数部分
    while s[i] >= 48 as byte && s[i] <= 57 as byte {  // '0' - '9'
        const digit: f64 = s[i] as f64 - 48.0;
        result = result * 10.0 + digit;
        i = i + 1;
    }
    
    // 转换小数部分
    if s[i] == 46 as byte {  // '.'
        i = i + 1;
        var frac: f64 = 0.0;
        var frac_div: f64 = 10.0;
        
        while s[i] >= 48 as byte && s[i] <= 57 as byte {  // '0' - '9'
            const digit: f64 = s[i] as f64 - 48.0;
            frac = frac + digit / frac_div;
            frac_div = frac_div * 10.0;
            i = i + 1;
        }
        
        result = result + frac;
    }
    
    if is_neg {
        result = 0.0 - result;
    }
    
    return result;
}

// strtod - 将字符串转换为 f64（C 标准库兼容）
// 返回：转换后的浮点数，失败返回 0.0
// 注意：endptr 用于返回转换结束的位置
export fn strtod(nptr: *byte, endptr: * *byte) f64 {
    if nptr == null {
        if endptr != null {
            endptr[0] = null;
        }
        return 0.0;
    }
    
    var i: usize = 0;
    var is_neg: bool = false;
    var result: f64 = 0.0;
    
    // 跳过前导空白字符
    while nptr[i] == 32 as byte || nptr[i] == 9 as byte || nptr[i] == 10 as byte || nptr[i] == 13 as byte {
        i = i + 1;
    }
    
    // 检查符号
    if nptr[i] == 45 as byte {  // '-'
        is_neg = true;
        i = i + 1;
    } else if nptr[i] == 43 as byte {  // '+'
        i = i + 1;
    }
    
    // 转换整数部分
    while nptr[i] >= 48 as byte && nptr[i] <= 57 as byte {  // '0' - '9'
        const digit: f64 = nptr[i] as f64 - 48.0;
        result = result * 10.0 + digit;
        i = i + 1;
    }
    
    // 转换小数部分
    if nptr[i] == 46 as byte {  // '.'
        i = i + 1;
        var frac: f64 = 0.0;
        var frac_div: f64 = 10.0;
        
        while nptr[i] >= 48 as byte && nptr[i] <= 57 as byte {  // '0' - '9'
            const digit: f64 = nptr[i] as f64 - 48.0;
            frac = frac + digit / frac_div;
            frac_div = frac_div * 10.0;
            i = i + 1;
        }
        
        result = result + frac;
    }
    
    if is_neg {
        result = 0.0 - result;
    }
    
    // 设置 endptr
    if endptr != null {
        endptr[0] = (nptr as i64 + i as i64) as *byte;
    }
    
    return result;
}

// strtol - 将字符串转换为 i64（C 标准库兼容）
// 返回：转换后的长整数，失败返回 0
// 注意：endptr 用于返回转换结束的位置，base 用于指定进制（2-36）
export fn strtol(nptr: *byte, endptr: * *byte, base: i32) i64 {
    if nptr == null {
        if endptr != null {
            endptr[0] = null;
        }
        return 0;
    }
    
    var result: i64 = 0;
    var i: usize = 0;
    var is_neg: bool = false;
    var radix: i32 = base;
    
    // 如果 base 为 0，自动检测进制
    if radix == 0 {
        // 跳过前导空白字符
        while nptr[i] == 32 as byte || nptr[i] == 9 as byte || nptr[i] == 10 as byte || nptr[i] == 13 as byte {
            i = i + 1;
        }
        
        // 检查前缀
        if nptr[i] == 48 as byte {  // '0'
            i = i + 1;
            if nptr[i] == 120 as byte || nptr[i] == 88 as byte {  // 'x' or 'X'
                radix = 16;
                i = i + 1;
            } else {
                radix = 8;
            }
        } else {
            radix = 10;
        }
    } else {
        // 跳过前导空白字符
        while nptr[i] == 32 as byte || nptr[i] == 9 as byte || nptr[i] == 10 as byte || nptr[i] == 13 as byte {
            i = i + 1;
        }
    }
    
    // 检查符号
    if nptr[i] == 45 as byte {  // '-'
        is_neg = true;
        i = i + 1;
    } else if nptr[i] == 43 as byte {  // '+'
        i = i + 1;
    }
    
    // 转换数字
    while i < 4096 {  // 防止无限循环
        const c: byte = nptr[i];
        var digit: i64 = 0 - 1;
        
        if c >= 48 as byte && c <= 57 as byte {  // '0' - '9'
            digit = c as i64 - 48;
        } else if c >= 97 as byte && c <= 122 as byte {  // 'a' - 'z'
            digit = c as i64 - 97 + 10;
        } else if c >= 65 as byte && c <= 90 as byte {  // 'A' - 'Z'
            digit = c as i64 - 65 + 10;
        } else {
            break;
        }
        
        if digit < 0 || digit >= radix as i64 {
            break;
        }
        
        result = result * radix as i64 + digit;
        i = i + 1;
    }
    
    if is_neg {
        result = 0 - result;
    }
    
    // 设置 endptr
    if endptr != null {
        endptr[0] = (nptr as i64 + i as i64) as *byte;
    }
    
    return result;
}


// ============================================================
// 系统函数（C 标准库兼容）
// ============================================================

use std.c.syscall.SYS_stat;
use std.c.syscall.SYS_readlink;
use std.c.string.strlen;
use std.c.string.strcmp;
use std.c.string.strncpy;

// stat - 获取文件状态（C 标准库兼容）
// 返回：0 成功，-1 失败
export fn stat(path: *byte, buf: &Stat) i32 {
    if path == null || buf == null {
        return 0 - 1;
    }
    
    // 调用 stat 系统调用
    const result: !i64 = @syscall(SYS_stat, path as i64, buf as i64);
    const ret: i64 = result catch {
        return 0 - 1;
    };
    
    if ret < 0 {
        return 0 - 1;
    }
    
    return 0;
}

// readlink - 读取符号链接（C 标准库兼容）
// 返回：读取的字节数，失败返回 -1
export fn readlink(path: *byte, buf: *byte, bufsiz: usize) i32 {
    if path == null || buf == null || bufsiz == 0 {
        return 0 - 1;
    }
    
    // 调用 readlink 系统调用
    const result: !i64 = @syscall(SYS_readlink, path as i64, buf as i64, bufsiz as i64);
    const ret: i64 = result catch {
        return 0 - 1;
    };
    
    if ret < 0 {
        return 0 - 1;
    }
    
    return ret as i32;
}

// getenv - 获取环境变量（简化实现）
// 返回：环境变量值的指针，未找到返回 null
// 注意：这是一个简化实现，实际应该从 environ 变量读取
export fn getenv(name: *byte) *byte {
    if name == null {
        return null;
    }
    
    // 简化实现：返回 null（实际应该从 environ 读取）
    // 注意：在 --nostdlib 模式下，environ 变量可能不可用
    // 这里提供一个占位实现，实际使用时需要访问 environ
    return null;
}

// ============================================================
// 目录操作函数（C 标准库兼容）
// ============================================================

use std.c.syscall.sys_open;
use std.c.syscall.sys_close;
use std.c.syscall.sys_read;
use std.c.syscall.O_RDONLY;
use std.c.syscall.SYS_getdents64;

// 目录流结构（简化实现）
// 注意：DIR 结构体在 extern_decls.uya 中声明为不透明类型
// 这里我们使用文件描述符作为 DIR 的底层实现
var opendir_fd_storage: [i64: 64] = [];

// opendir - 打开目录（C 标准库兼容）
// 返回：DIR*，失败返回 null
export fn opendir(name: *byte) *DIR {
    if name == null {
        return null;
    }
    
    // 打开目录文件描述符
    const result: !i64 = sys_open(name as i64, O_RDONLY, 0);
    const fd: i64 = result catch {
        return null;
    };
    
    if fd < 0 {
        return null;
    }
    
    // 使用全局数组存储文件描述符（简化实现，最多支持 64 个打开的目录）
    var j: usize = 0;
    while j < 64 {
        // 查找空闲槽位（fd <= 0 表示未使用）
        if opendir_fd_storage[j] <= 0 {
            opendir_fd_storage[j] = fd;
            return &opendir_fd_storage[j] as *DIR;
        }
        j = j + 1;
    }
    
    // 如果数组满了，关闭文件描述符并返回 null
    _ = sys_close(fd);
    return null;
}

// readdir - 读取目录项（简化实现）
// 返回：Dirent*，失败或结束返回 null
// 注意：这是一个简化实现，实际应该使用 getdents64 系统调用
export fn readdir(dirp: *DIR) *Dirent {
    if dirp == null {
        return null;
    }
    
    // 从指针中获取文件描述符
    const fd_ptr: &i64 = dirp as &i64;
    const fd: i64 = fd_ptr[0];
    
    if fd < 0 {
        return null;
    }
    
    // 简化实现：返回 null（实际应该使用 getdents64 读取目录项）
    // 注意：getdents64 系统调用较复杂，这里提供占位实现
    return null;
}

// closedir - 关闭目录（C 标准库兼容）
// 返回：0 成功，-1 失败
export fn closedir(dirp: *DIR) i32 {
    if dirp == null {
        return 0 - 1;
    }
    
    // 从指针中获取文件描述符
    const fd_ptr: &i64 = dirp as &i64;
    const fd: i64 = fd_ptr[0];
    
    if fd < 0 {
        return 0 - 1;
    }
    
    const result: !i64 = sys_close(fd);
    _ = result catch {
        return 0 - 1;
    };
    
    // 标记为已关闭
    fd_ptr[0] = 0 - 1;
    return 0;
}
