  // ✅ 编译通过：常量运算无溢出
  const x: i32 = 100 + 200;  // 编译期证明：300 < 2147483647
  
  // ❌ 编译错误：常量溢出
  const y: i32 = 2147483647 + 1;  // 编译错误
  
  // ✅ 编译通过：显式溢出检查，返回错误
  fn add_safe(a: i32, b: i32) !i32 {
      if a > 0 && b > 0 && a > 2147483647 - b {
          return error.Overflow;  // 返回错误
      }
      return a + b;  // 编译器证明：经过检查后无溢出
  }
  
  // ✅ 编译通过：显式溢出检查，返回饱和值（有效数值）
  fn add_saturating(a: i32, b: i32) i32 {
      if a > 0 && b > 0 && a > 2147483647 - b {
          return 2147483647;  // 上溢时返回最大值
      }
      if a < 0 && b < 0 && a < -2147483648 - b {
          return -2147483648;  // 下溢时返回最小值
      }
      return a + b;  // 编译器证明：经过检查后无溢出
  }
  
  // ✅ 编译通过：显式溢出检查，返回包装值（有效数值）
  // 注意：包装算术需要显式处理，不能依赖未定义行为
  fn add_wrapping(a: i32, b: i32) i32 {
      // 显式检查溢出，如果溢出则返回包装后的值
      if a > 0 && b > 0 && a > 2147483647 - b {
          // 包装算术：溢出时返回 (a + b) % 2^32，但需要显式计算
          // 实际实现可能需要使用更大的类型进行计算
          const sum: i64 = (a as i64) + (b as i64);
          return (sum as! i32);  // 显式截断到 i32 范围
      }
      if a < 0 && b < 0 && a < -2147483648 - b {
          const sum: i64 = (a as i64) + (b as i64);
          return (sum as! i32);  // 显式截断到 i32 范围
      }
      return a + b;  // 编译器证明：经过检查后无溢出
  }
  
  // ❌ 编译错误：无法证明无溢出
  fn add_unsafe(a: i32, b: i32) i32 {
      return a + b;  // 编译错误
  }
  