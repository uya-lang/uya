  编译器无法**静态决定**走宏路径还是函数路径，**语义双态**死灰复燃。  
- 把决策推迟到"是否全常量"⇒ 又回到**隐式宏**的老路。

------------------------------------------------
8. 缓解办法（已够用）
------------------------------------------------
| 方法 | 示例 |
|---|---|
| 改名 | `mc twice_mc` / `fn twice_fn` |
| 包级命名空间 | 未来 `mod` 打开后自然隔离 |
| 重载式命名 | `mc twice_int` / `fn twice_any` |

------------------------------------------------
9. 一句话总结
------------------------------------------------
用 `mc` 就得接受**"一名一义"**：同一作用域内 `mc` 与 `fn` 不能重名——**这是消除歧义的唯一代价，也是最后一道防线**。

---

## 18 指针算术

### 18.1 设计目标
- **安全指针算术**：支持 `ptr +/- offset`，但必须通过编译期证明安全
- **零运行时开销**：所有边界检查在编译期完成
- **符合语言哲学**：所有指针操作必须被编译期证明为安全，失败即编译错误
- **程序员责任**：程序员必须提供边界检查，帮助编译器完成证明
- **编译器验证**：编译器验证这些证明，无法证明安全即编译错误

### 18.2 语法

> **BNF 语法规范**：详见 [grammar.md](./grammar.md#31-指针算术)

指针算术语法：
- `ptr + offset`：指针向后偏移
- `ptr - offset`：指针向前偏移
- `ptr += offset`：指针向后偏移并赋值
- `ptr -= offset`：指针向前偏移并赋值
- `ptr1 - ptr2`：指针间距离计算（返回 `usize`）

**类型说明**：
- `offset` 的类型为 `usize`（平台相关的无符号整数类型）
- 指针间距离计算 `ptr1 - ptr2` 返回 `usize` 类型
- `usize` 在 32 位平台为 `u32`（4 字节），在 64 位平台为 `u64`（8 字节）
- `usize` 用于表示内存地址、数组索引和大小，保证能够表示平台上任意对象的大小

### 18.3 安全保证机制

#### 18.3.1 边界检查
- 每个指针算术操作必须有边界信息
- 编译器要求程序员提供边界证明
- 无法证明安全 → 编译错误

#### 18.3.2 指针来源追踪
- 指针必须来源于安全的内存区域（栈数组、堆分配、或已验证的指针）
- 编译器追踪指针的生命周期和边界信息

#### 18.3.3 指针算术示例
