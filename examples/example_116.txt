
**字符串切片特性**：
- 字符串数组 `[i8: N]` 可以使用切片语法 `&text[start:len]` 创建切片视图
- 字符串切片类型为 `&[i8]`，可以定义类型别名 `type str = &[i8]` 简化使用
- 字符串切片支持所有切片操作：for循环迭代、索引访问等
- 字符串切片是原字符串的视图，修改原字符串会影响切片
- 字符串切片的生命周期绑定到原字符串，遵循切片生命周期规则

### 17.8 零开销保证

- **宽度编译期常数** → 不占用寄存器；  
- **无运行时解析** → 无 `vsnprintf` 扫描；  
- **无堆分配** → 仍是 `alloca [N x i8]`；  
- **单条 `sprintf` 调用** → 与手写 C 同速。

### 17.8 一句话总结

> Uya 自定义格式 `"a=${x:#06x}"` → **编译期展开成定长栈数组**，格式与 C printf 100% 对应，**零运行时解析、零堆、零 GC**，性能 = 手写 `sprintf`。

---

## 20 泛型（可选特性）

> **注意**：本章描述的是可选特性，作为增量文档提供。  
> — 单页纸，直接附在规范末尾 —

------------------------------------------------
1. 核心规则（仅 3 行）
------------------------------------------------
1. **定义用括号**：`struct S(T)` / `interface I(T)` 在括号中明确声明泛型参数，与实例化 `S(i32)` / `I(i32)` 完全对称；函数保持自动推断，更简洁。  
2. impl / 调用时把**具体类型**写进括号 `(T1, T2, …)` 即完成单态化；找不到对应参数 ⇒ 编译错误。  
3. 单态化后走原有全部流程（UB 证明、drop、atomic、接口检查等）。

------------------------------------------------
2. 语法影子（用户侧 0 新符号）
------------------------------------------------
| 场景 | 旧写法 | 泛型写法 | 备注 |
|---|---|---|---|
| 泛型接口 | `interface I { fn f(x: i32); }` | `interface I(T) { fn f(x: T); }` | 定义用括号，参数顺序明确 |
| 泛型结构体 | `struct S { x: i32; }` | `struct S(T) { x: T; }` | 定义用括号，与实例化对称 |
| 泛型函数 | 无 | `fn id(x: T) T { return x; }` | 函数保持自动推断，更简洁 |
| 实例化 | `impl S : I { … }` | `impl S(T) : I(T) { … }` | 括号内给实参，定义实例化对称 |
| 多参数 | 无 | `struct Pair(A, B) { x: A, y: B; }` | 多参数用逗号分隔 |

> 括号 `()` 已存在于函数调用/元组，**不算新符号**。

------------------------------------------------
3. 实例化规则
------------------------------------------------
- 顺序对应：按裸名首次出现顺序一一替换。  
- 可写多行：`impl Vec { T = i32; }` 或一行 `impl Vec { T = i32; }`。  
- 未用完/多给均报错，防止错位。

------------------------------------------------
4. 约束：靠"接口位置"表达上界
------------------------------------------------
