// 泛型接口示例

// 基本泛型接口：迭代器
interface Iterator<T> {
    fn next(self: &Self) union Option<T>;
    fn has_next(self: &Self) bool;
}

// 使用示例
// fn process_items<T>(iter: Iterator<T>) void {
//     while iter.has_next() {
//         const item = iter.next();
//         // 处理 item
//     }
// }

// 多约束泛型接口：可克隆和可比较的类型
interface Cloneable<T: Clone + Ord> {
    fn clone(self: &Self) T;
    fn compare(self: &Self, other: &T) i32;
}

// 泛型接口：容器
interface Container<T> {
    fn add(self: &Self, item: T) void;
    fn remove(self: &Self, item: T) bool;
    fn contains(self: &Self, item: T) bool;
    fn size(self: &Self) i32;
}

// 结构体实现泛型接口
struct VecIterator<T> : Iterator<T> {
    data: &T,
    index: i32,
    len: i32,
    
    fn next(self: &Self) union Option<T> {
        // 实现迭代逻辑
        return error.EndOfIterator;
    }
    
    fn has_next(self: &Self) bool {
        return self.index < self.len;
    }
}

// 使用泛型接口作为函数参数
fn iterate_over<T>(iter: Iterator<T>) void {
    while iter.has_next() {
        const item = iter.next();
        // 处理 item
    }
}

fn main() i32 {
    return 0;
}

