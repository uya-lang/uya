# 优雅 (Uya) 编程语言

> 零GC · 默认Rust级安全 · 单页纸可读完 · 通过路径零指令  
> 无lifetime符号 · 无隐式控制

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## 简介

优雅（Uya）是一个系统编程语言，专注于**内存安全**、**并发安全**和**零运行时开销**。设计目标是提供 Rust 级别的安全性，同时保持 C 级别的性能和简洁性。

## 核心特性

### 0.12 版本核心特性

- **原子类型**：`atomic T` 关键字，自动原子指令，零运行时锁
- **内存安全强制**：所有 UB 必须被编译期证明为安全，失败即编译错误
- **并发安全强制**：零数据竞争，通过路径零指令
- **字符串插值**：支持 `"a${x}"` 和 `"pi=${pi:.2f}"` 两种形式
- **灵活错误处理**：支持预定义错误和运行时错误（类似 Zig 语法，无需预定义）

### 设计亮点

- ✅ **零 GC**：栈式数组，无垃圾回收
- ✅ **编译期证明**：所有内存安全在编译期验证
- ✅ **零运行时开销**：通过路径零指令，失败路径不存在
- ✅ **简洁语法**：无 lifetime 符号，无隐式控制
- ✅ **RAII 支持**：自动资源管理
- ✅ **错误处理**：显式错误联合类型 `!T` 和 `try/catch`，支持预定义错误和运行时错误（类似 Zig 语法，无需预定义）
- ✅ **接口系统**：Go 风格的接口，Zig 风格的零注册
- ✅ **FFI 支持**：无缝调用 C 函数
- ✅ **泛型支持**：零新关键字，向后 100% 兼容
- ✅ **显式宏**：使用 `mc` 区分宏与函数，零歧义

## 快速开始

### 示例代码

```uya
// 结构体定义
struct Vec3 {
  x: f32,
  y: f32,
  z: f32
}

// 函数定义
fn add(a: i32, b: i32) i32 {
  return a + b;
}

// 错误处理（支持预定义和运行时错误）
error DivisionByZero;  // 预定义错误（可选）

fn safe_divide(a: i32, b: i32) !i32 {
    if b == 0 {
        return error.DivisionByZero;  // 预定义错误
    }
    if a < 0 {
        return error.NegativeInput;   // 运行时错误，无需预定义
    }
    return a / b;
}

// 原子操作
struct Counter {
  value: atomic i32
}

fn increment(counter: *Counter) void {
  counter.value += 1;  // 自动原子 fetch_add
}

// 接口
interface IWriter {
  fn write(self: *Self, buf: *byte, len: i32) i32;
}

// FFI 调用
extern i32 printf(byte* fmt, ...);

// 泛型函数（可选特性）
fn id(x: T) T {
  return x;
}

// 显式宏（可选特性）
mc twice(n: i32) expr { n + n }

fn main() i32 {
  printf("Hello, Uya!\n");
  
  // 使用泛型
  let x: i32 = id(42);
  
  // 使用宏
  let y: i32 = twice(5);  // 编译期展开为 5 + 5
  
  return 0;
}
```

## 设计哲学

### 核心思想

将运行时的"可能越界"转化为编译期的"要么证明安全，要么返回显式错误"。

**核心机制**：
- 程序员必须提供**显式边界检查**，帮助编译器完成证明
- 编译器在编译期验证这些证明，无法证明安全即编译错误
- 每个数组访问都有明确的**数学证明**，消除运行时不确定性

### 责任转移

| 语言 | 安全责任 | 编译器角色 |
|------|---------|-----------|
| **C/C++** | 程序员负责安全 | 编译器不帮忙，只生成代码 |
| **Rust** | 编译器通过借用检查器帮忙 | 编译器主动检查所有权和生命周期 |
| **优雅** | 程序员必须提供证明，编译器验证证明 | 编译器验证数学证明，失败即编译错误 |

### 结果与收益

1. **数学证明的确定性**：每个数组访问都有明确的数学证明（`i >= 0 && i < len`）
2. **消除整类安全漏洞**：彻底消除缓冲区溢出等内存安全漏洞
3. **零运行时开销**：所有检查在编译期完成，通过路径零指令
4. **失败路径不存在**：无法证明安全的代码不生成，运行时不会出现未定义行为

## 类型系统

| 优雅类型 | C 对应 | 大小/对齐 | 备注 |
|---------|--------|-----------|------|
| `i8` `i16` `i32` `i64` | 同宽 signed | 1 2 4 8 B | 对齐 = 类型大小；支持 `max/min` 关键字访问极值 |
| `u8` `u16` `u32` `u64` | 同宽 unsigned | 1 2 4 8 B | 对齐 = 类型大小；无符号整数类型，用于与 C 互操作和格式化 |
| `f32` `f64` | float/double | 4/8 B | 对齐 = 类型大小 |
| `bool` | uint8_t | 1 B | 0/1，对齐 1 B |
| `byte` | uint8_t | 1 B | 无符号字节，对齐 1 B，用于字节数组 |
| `void` | void | 0 B | 仅用于函数返回类型 |
| `byte*` | char* | 4/8 B（平台相关） | 用于 FFI，指向 C 字符串；32位平台=4B，64位平台=8B；可与 `null` 比较 |
| `&T` | 普通指针 | 8 B | 无 lifetime 符号 |
| `&atomic T` | 原子指针 | 8 B | 关键字驱动，见原子操作章节 |
| `atomic T` | 原子类型 | sizeof(T) | 语言级原子类型，见原子操作章节 |
| `[T; N]` | T[N] | N·sizeof(T) | N 为编译期正整数，对齐 = T 的对齐 |
| `struct S { }` | struct S | 字段顺序布局 | 对齐 = 最大字段对齐 |
| `interface I { }` | - | 16 B (64位) | vtable 指针(8B) + 数据指针(8B) |
| `!T` | 错误联合类型 | max(sizeof(T), sizeof(错误标记)) + 对齐填充 | `T \| Error` |

## 内存安全

### 强制规则

所有 UB 场景必须被编译期证明为安全，失败即编译错误：

1. **数组越界访问**：常量索引越界 → 编译错误；变量索引 → 必须证明 `i >= 0 && i < len`
2. **整数溢出**：必须证明无溢出，证明失败 → 编译错误
3. **除零错误**：常量除零 → 编译错误；变量 → 必须证明 `y != 0`
4. **使用未初始化内存**：必须证明「首次使用前已赋值」
5. **空指针解引用**：必须证明 `ptr != null` 或前序有检查

### 安全策略

- **编译期证明**：所有 UB 必须被编译器证明为安全
- **失败即错误**：证明失败 → 编译错误，不生成代码
- **零运行时开销**：通过路径零指令，失败路径不存在
- **无 panic、无 catch、无断言**：所有检查在编译期完成

## 并发安全

### 机制

- **原子类型 `atomic T`** → 语言层原子
- **读/写/复合赋值 = 自动原子指令** → **零运行时锁**
- **数据竞争 = 零**（所有原子操作自动序列化）
- **零新符号**：无需额外的语法标记

```uya
struct Counter {
  value: atomic i32
}

fn increment(counter: *Counter) void {
  counter.value += 1;  // 自动原子 fetch_add
  let v: i32 = counter.value;  // 自动原子 load
  counter.value = 10;  // 自动原子 store
}
```

## 文档

完整的语言规范请参阅：
- **[uya.md](./uya.md)** - Markdown 格式的完整语言规范
- **[uya.html](./uya.html)** - HTML 格式（深色主题）的完整语言规范，适合在线浏览和打印

文档包含：
- 完整的语法规范
- 类型系统详解
- 内存模型和 RAII
- 错误处理机制
- 接口系统
- 原子操作
- 泛型系统（可选特性）
- 显式宏系统（可选特性）
- 完整示例代码

## 许可证

本项目采用 [MIT 许可证](./LICENSE)。

Copyright (c) 2025 zigger

## 一句话总结

> **优雅 0.12 = 默认即 Rust 级内存安全 + 并发安全 + Zig 风格错误处理**；
> **只加 1 个关键字 `atomic T`，其余零新符号**；
> **所有 UB 必须被编译期证明为安全 → 失败即编译错误**；
> **通过路径零指令，失败路径不存在，不降级、不插运行时锁。**

## 贡献

欢迎贡献代码、报告问题或提出建议！

## 相关链接

- [语言规范文档（Markdown）](./uya.md)
- [语言规范文档（HTML，深色主题）](./uya.html)
- [许可证](./LICENSE)

---

**注意**：优雅语言目前处于开发阶段（**0.12 版本**），部分特性可能尚未完全实现。请参考 [uya.md](./uya.md) 了解当前版本的限制和未来计划。


