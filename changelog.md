# Uya 语言版本变更日志

本文档记录 Uya 语言的所有版本变更历史。

---

## 0.32 版本变更（相对于 0.31）

### 0.32 内置函数统一以 @ 开头

- **所有内置函数以 `@` 开头**（第 1 章、第 16 章）：
  - `sizeof` → `@sizeof(T)`：类型大小查询
  - `alignof` → `@alignof(T)`：类型对齐查询
  - `len` → `@len(a)`：数组长度查询
  - `max` → `@max`：整数类型最大值（类型从上下文推断，原为关键字）
  - `min` → `@min`：整数类型最小值（类型从上下文推断，原为关键字）
- **关键字变更**：`max`、`min` 从关键字中移除，改为内置函数标识（以 `@` 开头）
- **语法**：内置函数调用形式为 `@sizeof(T)`、`@alignof(T)`、`@len(expr)`；极值形式为 `@max`、`@min`（无参数，类型由上下文推断）
- **向后兼容性**：破坏性变更，现有使用 `sizeof`、`alignof`、`len`、`max`、`min` 的代码需改为 `@sizeof`、`@alignof`、`@len`、`@max`、`@min`

---

## 0.30 版本变更（相对于 0.29）

### 0.30 alignof 改为内置函数

- **alignof 改为内置函数**（第 16 章）：
  - `alignof` 从标准库函数改为编译器内置函数，无需导入即可使用
  - 不再需要 `use std.mem.alignof;`，可以直接使用 `alignof(T)`
  - 编译期折叠为常数，零运行时开销
  - 与 `sizeof` 和 `len` 函数一致，都是编译器内置的，自动可用
- **向后兼容性**：
  - 这是破坏性变更，现有使用 `use std.mem.alignof;` 的代码需要移除导入语句

### 0.30 Uya 指针到 FFI 指针的显式转换

- **指针类型转换支持**（第 5.2 章、第 11 章）：
  - ✅ **Uya 普通指针 `&T` 可以通过 `as` 显式转换为 FFI 指针类型 `*T`**
  - 使用 `as` 进行安全转换：`&T as *T`（无精度损失，编译期检查）
  - 仅在 FFI 函数调用时使用，符合 Uya "显式控制"的设计哲学
  - 示例：`extern write(fd: i32, buf: *byte, count: i32) i32;` 调用时使用 `write(1, &buffer[0] as *byte, 10);`
- **类型转换规则更新**（第 11.4 章）：
  - 在转换规则表中添加指针类型转换：
    - `&T` → `*T`：✅ 支持 `as`（安全转换）
    - `*T` → `&T`：❌ 不支持 `as`，✅ 支持 `as!`（强转）
- **设计哲学一致性**：
  - 保持"零隐式转换"原则，通过显式 `as` 转换
  - 编译期验证，无运行时开销
  - 类型安全，防止误用
- **向后兼容性**：
  - 这是新增功能，不影响现有代码
  - 现有代码可以继续使用，新代码可以使用显式转换更方便地与 C 函数互操作

---

## 0.29 版本变更（相对于 0.28）

### 0.29 文档增强和规范细化

- **结构体内存布局详细规则**（第 4.2 章）：
  - 新增详细章节，完整说明结构体字段对齐、填充、嵌套结构体布局规则
  - 明确字段偏移计算公式：`offset(field_n) = align_up(offset(field_n-1) + sizeof(field_n-1), alignof(field_n))`
  - 明确填充字节内容为 0（零填充），确保结构体布局的可预测性
  - 详细说明嵌套结构体、数组字段、特殊类型字段（切片、接口、错误联合类型）的布局规则
  - 提供结构体大小和对齐的完整计算规则
  - 说明不同平台（32位/64位）的结构体布局差异
  - 明确空结构体的特殊规则（大小 = 1 字节，对齐 = 1 字节）
- **函数调用约定详细说明**（第 5.1.2 章）：
  - 新增详细章节，完整说明函数调用约定（ABI）规则
  - 详细说明 x86-64 System V ABI（Linux、macOS、BSD）的参数传递、返回值传递、寄存器使用规则
  - 详细说明 x86-64 Microsoft x64 Calling Convention（Windows）的调用约定
  - 详细说明 ARM64 ABI（AArch64）的调用约定
  - 详细说明 32位 x86 平台的 cdecl 调用约定
  - 明确错误联合类型 `!T` 的返回值处理规则（与普通结构体相同）
  - 提供调用约定总结表，对比不同平台的规则差异
  - 强调所有调用约定都与 C ABI 完全兼容，编译器自动选择正确的调用约定
- **文档优化**：
  - 优化文档结构和章节组织
  - 增强技术细节的完整性和准确性
  - 为编译器实现提供更详细的参考规范

---

## 0.28 版本变更（相对于 0.27）

### 0.28 sizeof 改为内置函数

- **sizeof 改为内置函数**（第 16 章）：
  - `sizeof` 从标准库函数改为编译器内置函数，无需导入即可使用
  - 不再需要 `use std.mem.{sizeof, alignof};`，可以直接使用 `sizeof(T)`
  - 编译期折叠为常数，零运行时开销
  - 与 `len` 函数一致，都是编译器内置的，自动可用
- **向后兼容性**：
  - 这是破坏性变更，现有使用 `use std.mem.{sizeof, alignof};` 的代码需要移除导入语句
  - `alignof` 仍然保留为标准库函数，需要导入使用

---

## 0.25 版本变更（相对于 0.24）

### 0.25 函数指针类型和导出函数支持

- **函数指针类型**（第 5 章）：
  - 新增函数指针类型语法：`fn(param_types) return_type`
  - 支持类型别名：`type ComparFunc = fn(*void, *void) i32;`
  - `&function_name` 的类型是函数指针类型（不是 `*void`）
  - 仅在 FFI 上下文中使用，用于与 C 函数指针互操作
- **导出函数给 C**（第 5.2 章）：
  - `extern fn name(...) type { ... }` - 导出 Uya 函数为 C 函数（导出，供 C 调用）
  - 导出的函数可以使用 `&name` 获取函数指针，传递给需要函数指针的 C 函数
  - 函数参数和返回值必须使用 C 兼容的类型
- **类型系统更新**：
  - 在类型系统中添加函数指针类型：`fn(...) type`
  - 函数指针类型大小：4/8 B（平台相关，与普通指针相同）

---

## 0.24 版本变更（相对于 0.23）

### 0.24 接口实现语法简化

- **移除接口实现块语法**（第 6 章）：
  - 删除了 `StructName : InterfaceName { ... }` 这种单独的接口实现块语法
  - 结构体在定义时声明接口：`struct StructName : InterfaceName { ... }`
  - 接口方法作为结构体方法定义，可以在结构体内部（与字段一起）或外部方法块中定义
  - 语法更简洁，接口方法就是结构体方法，无需区分
- **接口实现语法简化**（第 6 章）：
  - 移除了 `impl` 关键字，接口实现语法从 `impl StructName : InterfaceName {}` 简化为 `StructName : InterfaceName {}`
  - 语法更简洁，与结构体方法定义更对称（结构体方法：`StructName {}`，接口实现：`StructName : InterfaceName {}`）
  - `:` 符号语义清晰，表示"实现"关系，与类型标注的 `:` 一致
- **接口组合语法优化**（第 6 章）：
  - 接口组合语法保持不变，在接口体中直接列出被组合的接口名
  - 推荐使用分号分隔组合接口名（如 `IReader; IWriter;`），与方法签名格式一致，更清晰
  - 接口组合和方法签名可以混合使用
- **关键字列表更新**：
  - 从关键字列表中移除 `impl`，不再是保留关键字
- **向后兼容性**：
  - 这是破坏性变更，需要迁移现有代码中的 `impl` 语法
  - 建议作为版本升级的一部分

---

## 0.23 版本变更（相对于 0.22）

### 0.23 统一结构体标准

- **统一结构体标准**（第 4 章）：
  - 所有 `struct` 统一使用 C 内存布局，无需 `extern` 关键字
  - 移除了 `extern struct` 的特殊语法，统一为标准 `struct`
  - 所有结构体都可以直接与 C 代码互操作，编译器自动生成对应的 C 兼容布局
- **支持所有类型**（第 4 章）：
  - 结构体可以包含所有类型（基础类型、数组、切片、接口、错误联合类型、原子类型等）
  - 不再限制结构体字段类型，支持完整的 Uya 类型系统
- **完整 Uya 能力**（第 4 章）：
  - 所有结构体都可以有方法（结构体内部或外部定义）
  - 所有结构体都可以有 drop 函数（实现 RAII 自动资源管理）
  - 所有结构体都可以实现接口（支持动态派发）
  - 同一个结构体，两面性：C 代码看到纯数据，Uya 代码看到完整对象
- **C 内存布局定义**（第 4.1 章）：
  - 定义了切片类型 `&[T]` 在 C 中的表示：`{ void* ptr; size_t len; }`
  - 定义了接口类型 `InterfaceName` 在 C 中的表示：`{ void* vtable; void* data; }`
  - 定义了错误联合类型 `!T` 在 C 中的表示：`{ uint32_t error_id; T value; }`（error_id == 0 表示成功）
- **文档优化**：
  - 优化了 `grammar.md` 和 `uya.md` 的一致性和清晰度
  - 添加了结构体方法的完整语法定义
  - 添加了文档间的交叉引用
  - 统一了术语表述

---

## 0.22 版本变更（相对于 0.21）

### 0.22 切片类型重构
- **切片类型系统**（第 2 章）：
  - 新增切片类型 `&[T]`（动态长度切片引用）和 `&[T; N]`（已知长度切片引用）
  - 切片是胖指针（指针+长度），大小 16 字节，零堆分配
- **切片语法更新**（第 4 章）：
  - 废弃旧语法 `arr[start:len]`（返回新数组）
  - 新语法 `&arr[start:len]`（返回切片视图）
  - 支持负数索引：`&arr[-3:3]` 等价于 `&arr[7:3]`（对于长度为 10 的数组）
- **for循环支持切片**（第 8 章）：
  - 值迭代：`for slice |value| { }`（只读）
  - 引用迭代：`for slice |&ptr| { }`（可修改）
  - 索引迭代：`for slice |i| { }`（只获取索引）
  - 索引和值：`for slice |i, value| { }` 或 `for slice |i, &ptr| { }`
- **切片生命周期规则**（第 6.5 章）：
  - 切片生命周期 ≤ 原数据生命周期
  - 编译器自动验证切片不会超过原数据的生命周期
  - 切片是原数据的视图，修改原数组会影响切片
- **字符串切片**（第 17 章）：
  - 字符串数组 `[i8; N]` 支持切片操作：`&text[start:len]`
  - 字符串切片类型为 `&[i8]`，可定义类型别名 `type str = &[i8]`
- **性能保证**：
  - 零分配：切片是胖指针，无堆分配
  - 编译期展开：for循环编译期展开
  - 编译期验证：边界检查在编译期完成
  - 内存安全：生命周期自动绑定，防止悬垂引用

---

## 0.20 版本变更（相对于 0.19）

### 0.20 泛型语法优化
- **泛型定义语法优化**：定义使用括号 `struct S(T)` / `interface I(T)`，与实例化 `S(i32)` / `I(i32)` 完全对称，参数顺序明确
- **函数自动推断**：泛型函数保持自动推断，无需显式指定类型参数，更简洁
- **新增泛型容器库示例**：完整的 `ArrayList(T)`、`Collection(T)` 接口和实现示例（第 20 章 6.3 节）

---

## 0.19 版本变更（相对于 0.18）

### 0.19 文档更新
- **FFI 指针类型支持扩展**（第 2 章、第 5.2 章、第 5.3 章）：
  - 明确 FFI 指针 `*T` 支持所有 C 兼容类型，包括 `*i8`, `*i16`, `*i32`, `*i64`, `*u8`, `*u16`, `*u32`, `*u64`, `*f32`, `*f64`, `*bool`, `*byte`, `*void`, `*CStruct`
  - 统一指针语法：将所有 `byte*` 替换为 `*byte`（即 `*T` 形式，T=byte），统一使用 `*T` 语法
  - 添加统一指针语法规则说明，明确区分三种指针类型：
    - `&T`：Uya 内部安全指针，支持所有 Uya 类型
    - `*T`：FFI 专用指针，仅用于 C 语言互操作，支持所有 C 兼容类型
    - `&[T]`：参数语法糖，表示指针+长度的组合
  - FFI 指针使用规则：
    - ✅ 仅用于 FFI 函数声明/调用和 extern struct 字段
    - ✅ 支持下标访问 `ptr[i]`，但必须提供长度约束证明
    - ❌ 不能用于普通变量声明（编译错误）
    - ❌ 不能进行普通指针算术（只能用于 FFI 上下文）
  - 添加 `*u16` 等类型的完整使用示例和禁止用法示例
  - 强调设计哲学一致性：显式区分、安全强化、编译期验证、零隐式转换、C 兼容性

---

## 0.17 版本变更（相对于 0.16）

### 0.17 新增特性
- **移动语义**（第 12.5 章）：结构体赋值时转移所有权，避免不必要的拷贝
  - 自动移动场景：赋值、函数参数传递、返回值、结构体字段初始化、数组元素赋值
  - 严格检查机制：存在活跃指针时禁止移动，防止悬垂指针
  - 与 RAII 完美配合：移动后只有目标对象调用 drop，防止 double free
- **结构体方法语法糖**（第 29.3 章）：`obj.method()` 语法糖，编译期展开为静态函数调用
  - 支持 `Self` 占位符：`fn method(self: *Self) ReturnType`，与接口实现语法一致
  - 必须使用指针：`self: *Self` 或 `self: *StructName`，不允许按值传递，避免语义歧义
  - 方法调用不触发移动：调用时自动传递指针（`&obj`），确保方法调用后原对象仍然可用
  - 编译期展开：编译期展开为静态函数，所有方法都是静态绑定
- **Self 类型扩展**：`Self` 占位符现在可以在结构体方法中使用，与接口实现保持一致
- ***T 语法扩展**：`*T` 语法现在可以在结构体方法的方法签名中使用

---

## 0.16 版本变更（相对于 0.15）

### 0.16 新增特性
- **字符串插值**（第 23 章）：支持 `"a${x}"` 和 `"pi=${pi:.2f}"` 两种形式
- **安全指针算术**（第 27 章）：支持 `ptr +/- offset`，必须通过编译期证明安全
- **测试单元**（第 28 章）：`test` 块用于单元测试

---

## 0.15 版本变更（相对于 0.14）

### 0.15 新增特性
- **sizeof 和 alignof**：标准库函数，用于获取类型大小和对齐，编译期常量
  - 位置：`std/mem.uya`
  - 使用：`use std.mem.{sizeof, alignof};`
  - 支持所有基础类型、数组、结构体、原子类型等

---

## 语法简化（跨版本）

### for 循环语法简化
- 移除 `iter()` 和 `range()` 函数，直接支持 `for obj |v| {}` 和 `for 0..10 |v| {}`
- 新增可修改迭代语法：`for obj |&v| {}`（用于修改数组元素）
- 支持丢弃元素语法：`for obj {}` 和 `for 0..N {}`（只循环次数，不绑定变量）

### 运算符简化
- 移除 `checked_*` 函数，使用 `try` 关键字进行溢出检查（如 `try a + b`）
- 移除 `saturating_*` 函数，使用饱和运算符（`+|`, `-|`, `*|`）
- 移除 `wrapping_*` 函数，使用包装运算符（`+%`, `-%`, `*%`）

---

## 向后兼容性

- 所有 0.13 代码保持兼容（语法变更不影响现有代码）
- 新语法完全可选，可以继续使用原有方式

