# Uya 语言版本变更日志

本文档记录 Uya 语言的所有版本变更历史。

---

## 0.24 版本变更（相对于 0.23）

### 0.24 接口实现语法简化

- **接口实现语法简化**（第 6 章）：
  - 移除了 `impl` 关键字，接口实现语法从 `impl StructName : InterfaceName {}` 简化为 `StructName : InterfaceName {}`
  - 语法更简洁，与结构体方法定义更对称（结构体方法：`StructName {}`，接口实现：`StructName : InterfaceName {}`）
  - `:` 符号语义清晰，表示"实现"关系，与类型标注的 `:` 一致
- **接口组合语法优化**（第 6 章）：
  - 接口组合语法保持不变，在接口体中直接列出被组合的接口名
  - 推荐使用分号分隔组合接口名（如 `IReader; IWriter;`），与方法签名格式一致，更清晰
  - 接口组合和方法签名可以混合使用
- **关键字列表更新**：
  - 从关键字列表中移除 `impl`，不再是保留关键字
- **向后兼容性**：
  - 这是破坏性变更，需要迁移现有代码中的 `impl` 语法
  - 建议作为版本升级的一部分

---

## 0.23 版本变更（相对于 0.22）

### 0.23 统一结构体标准

- **统一结构体标准**（第 4 章）：
  - 所有 `struct` 统一使用 C 内存布局，无需 `extern` 关键字
  - 移除了 `extern struct` 的特殊语法，统一为标准 `struct`
  - 所有结构体都可以直接与 C 代码互操作，编译器自动生成对应的 C 兼容布局
- **支持所有类型**（第 4 章）：
  - 结构体可以包含所有类型（基础类型、数组、切片、接口、错误联合类型、原子类型等）
  - 不再限制结构体字段类型，支持完整的 Uya 类型系统
- **完整 Uya 能力**（第 4 章）：
  - 所有结构体都可以有方法（结构体内部或外部定义）
  - 所有结构体都可以有 drop 函数（实现 RAII 自动资源管理）
  - 所有结构体都可以实现接口（支持动态派发）
  - 同一个结构体，两面性：C 代码看到纯数据，Uya 代码看到完整对象
- **C 内存布局定义**（第 4.1 章）：
  - 定义了切片类型 `&[T]` 在 C 中的表示：`{ void* ptr; size_t len; }`
  - 定义了接口类型 `InterfaceName` 在 C 中的表示：`{ void* vtable; void* data; }`
  - 定义了错误联合类型 `!T` 在 C 中的表示：`{ uint32_t error_id; T value; }`（error_id == 0 表示成功）
- **文档优化**：
  - 优化了 `grammar.md` 和 `uya.md` 的一致性和清晰度
  - 添加了结构体方法的完整语法定义
  - 添加了文档间的交叉引用
  - 统一了术语表述

---

## 0.22 版本变更（相对于 0.21）

### 0.22 切片类型重构
- **切片类型系统**（第 2 章）：
  - 新增切片类型 `&[T]`（动态长度切片引用）和 `&[T; N]`（已知长度切片引用）
  - 切片是胖指针（指针+长度），大小 16 字节，零堆分配
- **切片语法更新**（第 4 章）：
  - 废弃旧语法 `arr[start:len]`（返回新数组）
  - 新语法 `&arr[start:len]`（返回切片视图）
  - 支持负数索引：`&arr[-3:3]` 等价于 `&arr[7:3]`（对于长度为 10 的数组）
- **for循环支持切片**（第 8 章）：
  - 值迭代：`for slice |value| { }`（只读）
  - 引用迭代：`for slice |&ptr| { }`（可修改）
  - 索引迭代：`for slice |i| { }`（只获取索引）
  - 索引和值：`for slice |i, value| { }` 或 `for slice |i, &ptr| { }`
- **切片生命周期规则**（第 6.5 章）：
  - 切片生命周期 ≤ 原数据生命周期
  - 编译器自动验证切片不会超过原数据的生命周期
  - 切片是原数据的视图，修改原数组会影响切片
- **字符串切片**（第 17 章）：
  - 字符串数组 `[i8; N]` 支持切片操作：`&text[start:len]`
  - 字符串切片类型为 `&[i8]`，可定义类型别名 `type str = &[i8]`
- **性能保证**：
  - 零分配：切片是胖指针，无堆分配
  - 编译期展开：for循环编译期展开
  - 编译期验证：边界检查在编译期完成
  - 内存安全：生命周期自动绑定，防止悬垂引用

---

## 0.20 版本变更（相对于 0.19）

### 0.20 泛型语法优化
- **泛型定义语法优化**：定义使用括号 `struct S(T)` / `interface I(T)`，与实例化 `S(i32)` / `I(i32)` 完全对称，参数顺序明确
- **函数自动推断**：泛型函数保持自动推断，无需显式指定类型参数，更简洁
- **新增泛型容器库示例**：完整的 `ArrayList(T)`、`Collection(T)` 接口和实现示例（第 20 章 6.3 节）

---

## 0.19 版本变更（相对于 0.18）

### 0.19 文档更新
- **FFI 指针类型支持扩展**（第 2 章、第 5.2 章、第 5.3 章）：
  - 明确 FFI 指针 `*T` 支持所有 C 兼容类型，包括 `*i8`, `*i16`, `*i32`, `*i64`, `*u8`, `*u16`, `*u32`, `*u64`, `*f32`, `*f64`, `*bool`, `*byte`, `*void`, `*CStruct`
  - 统一指针语法：将所有 `byte*` 替换为 `*byte`（即 `*T` 形式，T=byte），统一使用 `*T` 语法
  - 添加统一指针语法规则说明，明确区分三种指针类型：
    - `&T`：Uya 内部安全指针，支持所有 Uya 类型
    - `*T`：FFI 专用指针，仅用于 C 语言互操作，支持所有 C 兼容类型
    - `&[T]`：参数语法糖，表示指针+长度的组合
  - FFI 指针使用规则：
    - ✅ 仅用于 FFI 函数声明/调用和 extern struct 字段
    - ✅ 支持下标访问 `ptr[i]`，但必须提供长度约束证明
    - ❌ 不能用于普通变量声明（编译错误）
    - ❌ 不能进行普通指针算术（只能用于 FFI 上下文）
  - 添加 `*u16` 等类型的完整使用示例和禁止用法示例
  - 强调设计哲学一致性：显式区分、安全强化、编译期验证、零隐式转换、C 兼容性

---

## 0.17 版本变更（相对于 0.16）

### 0.17 新增特性
- **移动语义**（第 12.5 章）：结构体赋值时转移所有权，避免不必要的拷贝
  - 自动移动场景：赋值、函数参数传递、返回值、结构体字段初始化、数组元素赋值
  - 严格检查机制：存在活跃指针时禁止移动，防止悬垂指针
  - 与 RAII 完美配合：移动后只有目标对象调用 drop，防止 double free
- **结构体方法语法糖**（第 29.3 章）：`obj.method()` 语法糖，编译期展开为静态函数调用
  - 支持 `Self` 占位符：`fn method(self: *Self) ReturnType`，与接口实现语法一致
  - 必须使用指针：`self: *Self` 或 `self: *StructName`，不允许按值传递，避免语义歧义
  - 方法调用不触发移动：调用时自动传递指针（`&obj`），确保方法调用后原对象仍然可用
  - 编译期展开：编译期展开为静态函数，所有方法都是静态绑定
- **Self 类型扩展**：`Self` 占位符现在可以在结构体方法中使用，与接口实现保持一致
- ***T 语法扩展**：`*T` 语法现在可以在结构体方法的方法签名中使用

---

## 0.16 版本变更（相对于 0.15）

### 0.16 新增特性
- **字符串插值**（第 23 章）：支持 `"a${x}"` 和 `"pi=${pi:.2f}"` 两种形式
- **安全指针算术**（第 27 章）：支持 `ptr +/- offset`，必须通过编译期证明安全
- **测试单元**（第 28 章）：`test` 块用于单元测试

---

## 0.15 版本变更（相对于 0.14）

### 0.15 新增特性
- **sizeof 和 alignof**：标准库函数，用于获取类型大小和对齐，编译期常量
  - 位置：`std/mem.uya`
  - 使用：`use std.mem.{sizeof, alignof};`
  - 支持所有基础类型、数组、结构体、原子类型等

---

## 语法简化（跨版本）

### for 循环语法简化
- 移除 `iter()` 和 `range()` 函数，直接支持 `for obj |v| {}` 和 `for 0..10 |v| {}`
- 新增可修改迭代语法：`for obj |&v| {}`（用于修改数组元素）
- 支持丢弃元素语法：`for obj {}` 和 `for 0..N {}`（只循环次数，不绑定变量）

### 运算符简化
- 移除 `checked_*` 函数，使用 `try` 关键字进行溢出检查（如 `try a + b`）
- 移除 `saturating_*` 函数，使用饱和运算符（`+|`, `-|`, `*|`）
- 移除 `wrapping_*` 函数，使用包装运算符（`+%`, `-%`, `*%`）

---

## 向后兼容性

- 所有 0.13 代码保持兼容（语法变更不影响现有代码）
- 新语法完全可选，可以继续使用原有方式

